#include "TTSP_3D.h"
#include "KnotInsertion.h"
#include "BSplineBasis.h"
#include <fstream>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <map>
#include <sstream>
#include <iomanip>
#include "LeastSquare.h"
#include "PDEdata.h"

typedef unsigned int uint;
const double Knot[] = {0.5 - sqrt(3.0) / 6.0, 0.5 + sqrt(3.0) / 6.0};

int fc_cnct[4][4] = { { 0, 1, 5, 4 }, { 1, 2, 6, 5 }, { 2, 3, 7, 6 }, { 3, 0, 4, 7 } };
int ed_cnct[4][4] = { { 0, 5, 8, 4 }, { 1, 6, 9, 5 }, { 2, 7, 10, 6 }, { 3, 4, 11, 7 } };
int ed_uvw[8][3] = { { 0, 3, 4 }, { 1, 0, 5 }, { 2, 1, 6 }, { 3, 2, 7 }, { 11, 8, 4 }, { 8, 9, 5 }, { 9, 10, 6 }, { 10, 11, 7 } };
int fc_ppd_ed[6] = { 4, 3, 0, 3, 0, 4 };
int fc_opst[6] = { 5, 3, 4, 1, 2, 0 };

int solid_fc[6][4] = { { 0, 1, 2, 3 }, { 0, 1, 5, 4 }, { 1, 2, 6, 5 }, { 2, 3, 7, 6 }, { 3,0, 4, 7 }, {4,5,6,7} };
int solid_ed[12][2] = { { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 0 }, { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 4 } };

/*
1) InitialRotate() - set rotation matrix for each hex w.r.t. each of its non-boundary faces, note that this rotation is element-element rotation, that is, the transformation
   between local coordinate systems of two neighboring elements; so for each shared reference vertex, we need to fix its LCS, note this LCS is different from
   that of element, it is the LCS of vertex!
2) setReference() - for each vertex, set a LCS, note that this is generally different from what we mentioned in InitialRotate(); each vertex can always be located as
   a corner of a certain hex, then we set...
*/

TruncatedTspline_3D::TruncatedTspline_3D()
{
	//cp.clear();
	//tmesh.clear();
}

void TruncatedTspline_3D::CreateUniformCube(string fn)
{
	int nsmp(8);
	int npt = (nsmp + 1)*(nsmp + 1)*(nsmp + 1);
	int nel = nsmp*nsmp*nsmp;
	vector<array<double, 3>> spt(npt);
	vector<array<int, 8>> sele(nel);
	int i, j, k, loc(0);
	for (i = 0; i < nsmp + 1; i++)
	{
		for (j = 0; j < nsmp + 1; j++)
		{
			for (k = 0; k < nsmp + 1; k++)
			{
				spt[loc][0] = k;
				spt[loc][1] = j;
				spt[loc][2] = i;
				loc++;
			}
		}
	}
	loc = 0;
	for (i = 0; i < nsmp; i++)
	{
		for (j = 0; j < nsmp; j++)
		{
			for (k = 0; k < nsmp; k++)
			{
				sele[loc][0] = i*(nsmp + 1)*(nsmp + 1) + j*(nsmp + 1) + k;
				sele[loc][1] = i*(nsmp + 1)*(nsmp + 1) + j*(nsmp + 1) + k+1;
				sele[loc][2] = i*(nsmp + 1)*(nsmp + 1) + (j+1)*(nsmp + 1) + k + 1;
				sele[loc][3] = i*(nsmp + 1)*(nsmp + 1) + (j + 1)*(nsmp + 1) + k;
				sele[loc][4] = (i+1)*(nsmp + 1)*(nsmp + 1) + j*(nsmp + 1) + k;
				sele[loc][5] = (i + 1)*(nsmp + 1)*(nsmp + 1) + j*(nsmp + 1) + k + 1;
				sele[loc][6] = (i + 1)*(nsmp + 1)*(nsmp + 1) + (j + 1)*(nsmp + 1) + k + 1;
				sele[loc][7] = (i + 1)*(nsmp + 1)*(nsmp + 1) + (j + 1)*(nsmp + 1) + k;
				loc++;
			}
		}
	}

	string fname = fn + ".vtk";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nCube hex test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << spt.size() << " float\n";
		for (uint i = 0; i<spt.size(); i++)
		{
			fout << spt[i][0] << " " << spt[i][1] << " " << spt[i][2] << "\n";
		}
		fout << "\nCELLS " << sele.size() << " " << 9 * sele.size() << '\n';
		for (uint i = 0; i<sele.size(); i++)
		{
			fout << "8 " << sele[i][0] << " " << sele[i][1] << " " << sele[i][2] << " " << sele[i][3] << " " << sele[i][4] << " " << sele[i][5] << " " << sele[i][6] << " " << sele[i][7] << '\n';
		}
		fout << "\nCELL_TYPES " << sele.size() << '\n';
		for (uint i = 0; i<sele.size(); i++)
		{
			fout << "12\n";
		}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

double TruncatedTspline_3D::PartionOfUnity(int eid, const array<double, 3>& u)
{
	double sum(0.);
	vector<double> Nt;
	vector<array<double, 3>> dNdt;
	ElementBasis(eid,u,Nt,dNdt);
	for (uint i = 0; i < Nt.size(); i++) sum += Nt[i];
	return sum;
}

void TruncatedTspline_3D::VisualizeControlMesh(string fn)
{
	string fname(fn+".vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if(fout.is_open())
	{
		fout<<"# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout<<"POINTS "<<cp.size()<<" float\n";
		for(uint i=0;i<cp.size();i++)
		{
			fout<<cp[i].coor[0]<<" "<<cp[i].coor[1]<<" "<<cp[i].coor[2]<<"\n";
		}
		int nel_act(0);
		for(uint i=0; i<tmesh.size(); i++)
		{
			//if (tmesh[i].act == 1 /*&& tmesh[i].type == 2*/ /*&& tmesh[i].type != 2 && tmesh[i].type != 3*/) 
				nel_act++;
		}
		fout<<"\nCELLS "<<nel_act<<" "<<9*nel_act<<'\n';
		for(uint i=0; i<tmesh.size(); i++)
		{
			//if (tmesh[i].act == 1 /*&& tmesh[i].type == 2*/ /*&& tmesh[i].type != 2 && tmesh[i].type != 3*/)
			{
				fout<<"8 ";
				for(int j=0; j<8; j++)
				{
					fout<<tmesh[i].cnct[j]<<' ';
				}
				fout<<'\n';
			}
		}
		fout<<"\nCELL_TYPES "<<nel_act<<'\n';
		for(uint i=0; i<nel_act; i++)
		{
			fout<<"12\n";
		}
		//fout<<"\nCELLS "<<eleH[lev].size()<<" "<<5*eleH[lev].size()<<'\n';
		//for(uint i=0;i<eleH[lev].size();i++)
		//{
		//	fout<<"4 "<<eleH[lev][i].cnct[0]<<" "<<eleH[lev][i].cnct[1]<<" "<<eleH[lev][i].cnct[2]<<" "<<eleH[lev][i].cnct[3]<<'\n';
		//}
		//fout<<"\nCELL_TYPES "<<eleH[lev].size()<<'\n';
		//for(uint i=0;i<eleH[lev].size();i++)
		//{
		//	fout<<"9\n";
		//}
		fout << "\nCELL_DATA " << tmesh.size() << "\nSCALARS eact float 1\nLOOKUP_TABLE default\n";
		for (uint i = 0; i < tmesh.size(); i++)
		{
			fout << tmesh[i].bc << "\n";
		}
		//fout<<"POINT_DATA "<<cp.size()<<"\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
		//for(uint i=0;i<cp.size();i++)
		//{
		//	fout<<cp[i].act<<"\n";
		//}
		//fout<<"\nCELLS "<<cp.size()<<" "<<2*cp.size()<<'\n';
		//for(uint i=0;i<cp.size();i++)
		//{
		//	fout<<"1 "<<i<<'\n';
		//}
		//fout<<"\nCELL_TYPES "<<cp.size()<<'\n';
		//for(uint i=0;i<cp.size();i++)
		//{
		//	fout<<"1\n";
		//}
		//fout<<"POINT_DATA "<<cp.size()<<"\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
		//for(uint i=0;i<cp.size();i++)
		//{
		//	fout<<cp[i].trun<<"\n";
		//}

		fout.close();
	}
	else
	{
		cout<<"Cannot open "<<fname<<"!\n";
	}
}

void TruncatedTspline_3D::CollectActives()
{
	haid.clear();
	faid.clear();
	eaid.clear();
	int loc(0);
	for(uint i=0; i<tmesh.size(); i++)
	{
		tmesh[i].id_act = -1;
		if(tmesh[i].act==1 /*&& tmesh[i].type!=2 && tmesh[i].type!=3*/)
		{
			haid.push_back(i);
			tmesh[i].id_act = loc++;
		}
	}
	loc = 0;
	for (uint i = 0; i<tmface.size(); i++)
	{
		tmface[i].id_act = -1;
		if (tmface[i].act == 1)
		{
			faid.push_back(i);
			tmface[i].id_act = loc++;
		}
	}
	loc = 0;
	for (uint i = 0; i<tmedge.size(); i++)
	{
		tmedge[i].id_act = -1;
		if (tmedge[i].act == 1)
		{
			eaid.push_back(i);
			tmedge[i].id_act = loc++;
		}
	}
}

//void TruncatedTspline_3D::StrongBalanceCheck(const vector<int>& rid, vector<int>& rid2)//later
//{
//	uint i,j,k;
//	rid2.clear();
//	for(i=0; i<rid.size(); i++)
//	{
//		if(tmesh[rid[i]].act==1)
//		{
//		}
//	}
//}
//
//void TruncatedTspline_3D::FaceIntersectCheck(vector<int>& rid2)//later
//{
//	rid2.clear();
//	for(uint i=0; i<tmesh.size(); i++)
//	{
//		//tmesh[i].ref=0;
//		if(tmesh[i].act==1)
//		{
//			int ntjc(0);
//			for(int j=0; j<4; j++)
//			{
//				if(tmedge[tmesh[i].edge[j]].act==0)
//				{
//					ntjc++;
//				}
//			}
//			if(ntjc==1 && tmesh[i].type==2)//boundary element
//			{
//				//tmesh[i].ref=10;
//				rid2.push_back(i);
//			}
//			else if(ntjc==2)
//			{
//				int pos(0);
//				for(int j=0; j<4; j++)
//				{
//					if(tmedge[tmesh[i].edge[j]].act==0)
//					{
//						pos=j;
//						break;
//					}
//				}
//				if(tmedge[tmesh[i].edge[(pos+1)%4]].act==0)
//				{
//					//tmesh[i].ref=20;
//				}
//				else if(tmedge[tmesh[i].edge[(pos+2)%4]].act==0)
//				{
//					//tmesh[i].ref=21;
//				}
//				rid2.push_back(i);
//			}
//			else if(ntjc==3)
//			{
//				//tmesh[i].ref=3;
//				rid2.push_back(i);
//			}
//			else if(ntjc==4)
//			{
//				//tmesh[i].ref=4;
//				rid2.push_back(i);
//			}
//		}
//	}
//}
//
//void TruncatedTspline_3D::StrongBalanceRefine(const vector<int>& ridsb)
//{
//	for(uint i=0; i<ridsb.size(); i++)
//	{
//		if(tmesh[ridsb[i]].act==1)
//		{
//			//if(tmesh[ridsb[i]].type==0)
//			//{
//			//	ElementRefine_Square_4(ridsb[i]);
//			//}
//			//else if(tmesh[ridsb[i]].type==1)
//			//{
//			//	ElementRefine_Rectangular(ridsb[i]);
//			//}
//			//else if(tmesh[ridsb[i]].type==2)
//			//{
//			//	ElementRefine_Boundary(ridsb[i]);
//			//}
//		}
//	}
//}
//
//void TruncatedTspline_3D::TargetRefine(const vector<int>& rid)
//{
//	for(uint i=0; i<rid.size(); i++)
//	{
//		if(tmesh[rid[i]].act==1)
//		{
//			//if(tmesh[rid[i]].type==0)
//			//{
//			//	ElementRefine_Square_4(rid[i]);
//			//}
//			//else if(tmesh[rid[i]].type==1)
//			//{
//			//	ElementRefine_Rectangular(rid[i]);
//			//}
//		}
//	}
//}
//
//void TruncatedTspline_3D::OneTjunctionRefine(const vector<int>& ridtp)//later
//{
//	
//}
//
//void TruncatedTspline_3D::TjuncExtentCheck()
//{
//	for(uint i=0; i<tmesh.size(); i++)
//	{
//		if(tmesh[i].act==1 && tmesh[i].type==0)
//		{
//			int pos(-1);
//			for(int j=0; j<4; j++)
//			{
//				if(tmedge[tmesh[i].edge[j]].act==0)
//				{
//					pos=j;
//					break;
//				}
//			}
//			if(pos!=-1)
//			{
//				int ed[2]={(pos+1)%4,(pos+3)%4},ref(0);
//				for(int k=0; k<2; k++)
//				{
//					int ednb(tmedge[tmesh[i].edge[ed[k]]].face[0]);
//					if(ednb==i) ednb=tmedge[tmesh[i].edge[ed[k]]].face[1];
//					int* it=find(tmesh[ednb].edge,tmesh[ednb].edge+4,ed[k]);
//					int loc=it-tmesh[ednb].edge;
//					loc=(loc+2)%4;
//					if(tmedge[tmesh[ednb].edge[loc]].act==0)
//						ref=1;
//				}
//				if(ref==1)
//				{
//					//ElementRefine_Square_2(i);
//				}
//			}
//		}
//	}
//}
//
//void TruncatedTspline_3D::TjuncExtentCheck_1(vector<int>& ridtjx)
//{
//	ridtjx.clear();
//	for(uint i=0; i<tmesh.size(); i++)
//	{
//		if(tmesh[i].act==1)
//		{
//			int pos(-1);
//			for(int j=0; j<4; j++)
//			{
//				if(tmedge[tmesh[i].edge[j]].act==0)
//				{
//					pos=j;
//					break;
//				}
//			}
//			if(pos!=-1)
//			{
//				int ed[2]={(pos+1)%4,(pos+3)%4},ref(0);
//				for(int k=0; k<2; k++)
//				{
//					int ednb(tmedge[tmesh[i].edge[ed[k]]].face[0]);
//					if(ednb==i) ednb=tmedge[tmesh[i].edge[ed[k]]].face[1];
//					int* it=find(tmesh[ednb].edge,tmesh[ednb].edge+4,tmesh[i].edge[ed[k]]);
//					if(it==tmesh[ednb].edge+4)
//					{
//						vector<int>::iterator it1=find(ridtjx.begin(),ridtjx.end(),ednb);
//						if(it1==ridtjx.end())
//							ridtjx.push_back(ednb);
//					}
//				}
//			}
//		}
//	}
//}
//
//void TruncatedTspline_3D::TjuncExtentCheck_2(vector<int>& ridtjx)
//{
//	ridtjx.clear();
//	for(uint i=0; i<tmesh.size(); i++)
//	{
//		if(tmesh[i].act==1 && tmesh[i].type==0)
//		{
//			int pos(-1);
//			for(int j=0; j<4; j++)
//			{
//				if(tmedge[tmesh[i].edge[j]].act==0)
//				{
//					pos=j;
//					break;
//				}
//			}
//			if(pos!=-1)
//			{
//				int ed[2]={(pos+1)%4,(pos+3)%4},ref(0);
//				for(int k=0; k<2; k++)
//				{
//					int ednb(tmedge[tmesh[i].edge[ed[k]]].face[0]);
//					if(ednb==i) ednb=tmedge[tmesh[i].edge[ed[k]]].face[1];
//					int* it=find(tmesh[ednb].edge,tmesh[ednb].edge+4,tmesh[i].edge[ed[k]]);
//					int loc=it-tmesh[ednb].edge;
//					loc=(loc+2)%4;
//					if(tmedge[tmesh[ednb].edge[loc]].act==0)
//					{
//						vector<int>::iterator it=find(ridtjx.begin(),ridtjx.end(),i);
//						if(it==ridtjx.end())
//							ridtjx.push_back(i);
//					}
//				}
//			}
//		}
//	}
//}

void TruncatedTspline_3D::VisualizeBezierMesh(vector<BezierElement3D> bzmesh, string fn)
{
	int cn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };
	string fname = fn + "_bzmesh.vtk";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nBezier mesh\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << 8 * bzmesh.size() << " float\n";
		for (uint i = 0; i<bzmesh.size(); i++)
		{
			for (int j = 0; j < 8; j++)
			{
				fout << bzmesh[i].pts[cn[j]][0] << " " << bzmesh[i].pts[cn[j]][1] << " " << bzmesh[i].pts[cn[j]][2] << "\n";
			}
		}
		fout << "\nCELLS " << bzmesh.size() << " " << 9 * bzmesh.size() << '\n';
		for (uint i = 0; i<bzmesh.size(); i++)
		{
			fout << "8 " << 8 * i << " " << 8 * i + 1 << " " << 8 * i + 2 << " " << 8 * i + 3
				<< " " << 8 * i + 4 << " " << 8 * i + 5 << " " << 8 * i + 6 << " " << 8 * i + 7 << '\n';
		}
		fout << "\nCELL_TYPES " << bzmesh.size() << '\n';
		for (uint i = 0; i<bzmesh.size(); i++)
		{
			fout << "12\n";
		}
		//fout << "POINT_DATA " << sdisp.size() << "\nSCALARS err float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<sdisp.size(); i++)
		//{
		//	fout << sdisp[i] << "\n";
		//}
		fout << "\nCELL_DATA " << bzmesh.size() << "\nSCALARS Error float 1\nLOOKUP_TABLE default\n";
		for (uint i = 0; i < bzmesh.size(); i++)
		{
			fout << bzmesh[i].type << "\n";
		}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::VisualizeTMesh(string fn)
{
	string fname(fn+".vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if(fout.is_open())
	{
		fout<<"# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout<<"POINTS "<<cp.size()<<" float\n";
		for(uint i=0;i<cp.size();i++)
		{
			fout<<cp[i].coor[0]<<" "<<cp[i].coor[1]<<" "<<cp[i].coor[2]<<"\n";
		}
		int ned(0);
		for(uint i=0;i<tmedge.size();i++)
		{
			if(tmedge[i].act==1) ned++;
		}
		fout<<"\nCELLS "<<ned<<" "<<3*ned<<'\n';
		for(uint i=0;i<tmedge.size();i++)
		{
			if(tmedge[i].act==1)
				fout<<"2 "<<tmedge[i].pt[0]<<" "<<tmedge[i].pt[1]<<'\n';
		}
		fout<<"\nCELL_TYPES "<<ned<<'\n';
		for(uint i=0;i<tmedge.size();i++)
		{
			if(tmedge[i].act==1)
				fout<<"3\n";
		}
		fout<<"\nCELL_DATA "<<ned<<"\nSCALARS len float 1\nLOOKUP_TABLE default\n";
		for(uint i=0;i<tmedge.size();i++)
		{
			if(tmedge[i].act==1)
				fout<<tmedge[i].len<<"\n";
				//fout << tmedge[i].type << "\n";
		}
		//fout<<"POINT_DATA "<<cp.size()<<"\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
		//for(uint i=0;i<cp.size();i++)
		//{
		//	fout<<cp[i].trun<<"\n";
		//}


		//fout<<"\nCELLS "<<cp.size()<<" "<<2*cp.size()<<'\n';
		//for(uint i=0;i<cp.size();i++)
		//{
		//	fout<<"1 "<<i<<'\n';
		//}
		//fout<<"\nCELL_TYPES "<<cp.size()<<'\n';
		//for(uint i=0;i<cp.size();i++)
		//{
		//	fout<<"1\n";
		//}
		//fout<<"POINT_DATA "<<cp.size()<<"\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
		//for(uint i=0;i<cp.size();i++)
		//{
		//	fout<<cp[i].trun<<"\n";
		//}

		fout.close();
	}
	else
	{
		cout<<"Cannot open "<<fname<<"!\n";
	}
}

void TruncatedTspline_3D::VisualizeFaceMesh(string fn)
{
	string fname(fn + ".vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << cp.size() << " float\n";
		for (uint i = 0; i<cp.size(); i++)
		{
			fout << cp[i].coor[0] << " " << cp[i].coor[1] << " " << cp[i].coor[2] << "\n";
		}
		int nfc(0);
		for (uint i = 0; i<tmface.size(); i++)
		{
			if (tmface[i].act == 1 /*&& tmface[i].type==1*/) nfc++;
		}
		fout << "\nCELLS " << nfc << " " << 5 * nfc << '\n';
		for (uint i = 0; i<tmface.size(); i++)
		{
			if (tmface[i].act == 1 /*&& tmface[i].type == 1*/)
				fout << "4 " << tmface[i].cnct[0] << " " << tmface[i].cnct[1] << " " << tmface[i].cnct[2] << " " << tmface[i].cnct[3] << '\n';
		}
		fout << "\nCELL_TYPES " << nfc << '\n';
		for (uint i = 0; i<tmface.size(); i++)
		{
			if (tmface[i].act == 1 /*&& tmface[i].type == 1*/)
				fout << "9\n";
		}
		//fout << "\nCELL_DATA " << nfc << "\nSCALARS len float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<tmface.size(); i++)
		//{
		//	if (tmface[i].act == 1)
		//		fout << tmedge[i].len << "\n";
		//}
		//fout<<"POINT_DATA "<<cp.size()<<"\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
		//for(uint i=0;i<cp.size();i++)
		//{
		//	fout<<cp[i].trun<<"\n";
		//}


		//fout<<"\nCELLS "<<cp.size()<<" "<<2*cp.size()<<'\n';
		//for(uint i=0;i<cp.size();i++)
		//{
		//	fout<<"1 "<<i<<'\n';
		//}
		//fout<<"\nCELL_TYPES "<<cp.size()<<'\n';
		//for(uint i=0;i<cp.size();i++)
		//{
		//	fout<<"1\n";
		//}
		//fout<<"POINT_DATA "<<cp.size()<<"\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
		//for(uint i=0;i<cp.size();i++)
		//{
		//	fout<<cp[i].trun<<"\n";
		//}

		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

//void TruncatedTspline_3D::ShootRay_Edge(int edid, int pid, double kv[4])
//{
//	kv[2]=tmedge[edid].len;
//	int start(0),end(1);
//	if(tmedge[edid].pt[1]==pid)
//	{
//		start=1; end=0;
//	}
//	if(tmedge[edid].pn[end][0]==0) kv[3]=tmedge[tmedge[edid].pn[end][1]].len;
//	else if(tmedge[edid].pn[end][0]==1)
//	{
//		int fcid(tmedge[edid].pn[end][1]);
//		kv[3]=tmedge[tmesh[fcid].edge[0]].len;
//	}
//	else if(tmedge[edid].pn[end][0]==2)
//	{
//		int fcid(tmedge[edid].pn[end][1]);
//		kv[3]=tmedge[tmesh[fcid].edge[1]].len;
//	}
//	else
//		kv[3]=0.;
//
//	if(tmedge[edid].pn[start][0]==0)
//	{
//		kv[1]=tmedge[tmedge[edid].pn[start][1]].len;
//		int edpre(tmedge[edid].pn[start][1]);
//		int start1(0),end1(1);
//		if(tmedge[edpre].pt[0]==pid)
//		{
//			start1=1; end1=0;
//		}
//		if(tmedge[edpre].pn[start1][0]==0)
//			kv[0]=tmedge[tmedge[edpre].pn[start1][1]].len;
//		else if(tmedge[edpre].pn[start1][0]==1)
//		{
//			int fcid(tmedge[edpre].pn[start1][1]);
//			kv[0]=tmedge[tmesh[fcid].edge[0]].len;
//		}
//		else if(tmedge[edpre].pn[start1][0]==2)
//		{
//			int fcid(tmedge[edpre].pn[start1][1]);
//			kv[0]=tmedge[tmesh[fcid].edge[1]].len;
//		}
//		else
//			kv[0]=0.;
//	}
//	else if(tmedge[edid].pn[start][0]==1)
//	{
//		int fcid(tmedge[edid].pn[start][1]);
//		kv[1]=tmedge[tmesh[fcid].edge[0]].len;
//		int loc;
//		for(int j=0; j<4; j++)
//		{
//			if(tmesh[fcid].pn[j][0]==0 && tmesh[fcid].pn[j][1]==edid)
//			{
//				loc=j; break;
//			}
//		}
//		loc=(loc+2)%4;
//		if(tmesh[fcid].pn[loc][0]==0)
//		{
//			kv[0]=tmedge[tmesh[fcid].pn[loc][1]].len;
//		}
//		else if(tmesh[fcid].pn[loc][0]==1)
//		{
//			kv[0]=tmedge[tmesh[tmesh[fcid].pn[loc][0]].edge[0]].len;
//		}
//		else if(tmesh[fcid].pn[loc][0]==2)
//		{
//			kv[0]=tmedge[tmesh[tmesh[fcid].pn[loc][0]].edge[1]].len;
//		}
//		else
//		{
//			kv[0]=0.;
//		}
//	}
//	else if(tmedge[edid].pn[start][0]==2)
//	{
//		int fcid(tmedge[edid].pn[start][1]);
//		kv[1]=tmedge[tmesh[fcid].edge[1]].len;
//		int loc;
//		for(int j=0; j<4; j++)
//		{
//			if(tmesh[fcid].pn[j][0]==0 && tmesh[fcid].pn[j][1]==edid)
//			{
//				loc=j; break;
//			}
//		}
//		loc=(loc+2)%4;
//		if(tmesh[fcid].pn[loc][0]==0)
//		{
//			kv[0]=tmedge[tmesh[fcid].pn[loc][1]].len;
//		}
//		else if(tmesh[fcid].pn[loc][0]==1)
//		{
//			kv[0]=tmedge[tmesh[tmesh[fcid].pn[loc][0]].edge[0]].len;
//		}
//		else if(tmesh[fcid].pn[loc][0]==2)
//		{
//			kv[0]=tmedge[tmesh[tmesh[fcid].pn[loc][0]].edge[1]].len;
//		}
//		else
//		{
//			kv[0]=0.;
//		}
//	}
//	else
//	{
//		kv[1]=0.;
//		kv[0]=0.;
//	}
//}
//
//void TruncatedTspline_3D::ShootRay_Face(int fcid, int pid, double kv[4])
//{
//	int dir(0),loc;
//	for(int j=0; j<4; j++)
//	{
//		if(tmedge[tmesh[fcid].edge[j]].act==0 && tmedge[tmesh[fcid].edge[j]].midpt==pid)
//		{
//			loc=j; break;
//		}
//	}
//	if(loc==0 || loc==2) dir=1;
//	kv[2]=tmedge[tmesh[fcid].edge[dir]].len;
//	int loc1=(loc+2)%4;
//	if(tmesh[fcid].pn[loc1][0]==0)
//	{
//		kv[3]=tmedge[tmesh[fcid].pn[loc1][1]].len;
//	}
//	else if(tmesh[fcid].pn[loc1][0]==1)
//	{
//		int fcid1(tmesh[fcid].pn[loc1][1]);
//		kv[3]=tmedge[tmesh[fcid1].edge[0]].len;
//	}
//	else if(tmesh[fcid].pn[loc1][0]==2)
//	{
//		int fcid1(tmesh[fcid].pn[loc1][1]);
//		kv[3]=tmedge[tmesh[fcid1].edge[1]].len;
//	}
//	else
//	{
//		kv[3]=0.;
//	}
//
//	if(tmesh[fcid].pn[loc][0]==0)
//	{
//		int edid(tmesh[fcid].pn[loc][1]);
//		kv[1]=tmedge[edid].len;
//		int start(0),end(1);
//		if(tmedge[edid].pt[1]==pid)
//		{
//			start=1; end=0;
//		}
//		if(tmedge[edid].pn[end][0]==0)
//		{
//			kv[0]=tmedge[tmedge[edid].pn[end][1]].len;
//		}
//		else if(tmedge[edid].pn[end][0]==1)
//		{
//			int fcid1(tmedge[edid].pn[end][1]);
//			kv[0]=tmedge[tmesh[fcid1].edge[0]].len;
//		}
//		else if(tmedge[edid].pn[end][0]==2)
//		{
//			int fcid1(tmedge[edid].pn[end][1]);
//			kv[0]=tmedge[tmesh[fcid1].edge[0]].len;
//		}
//		else
//		{
//			kv[0]=0.;
//		}
//	}
//	else
//	{
//		cerr<<"Wrong edge connectivity!\n";
//	}
//}

bool TruncatedTspline_3D::CheckSubKnotVector(const double ku1[5], const double kv1[5], const double ku2[5], const double kv2[5])
{
	if(ku1[0]>=ku2[0] && ku1[4]<=ku2[4] && kv1[0]>=kv2[0] && kv1[4]<=kv2[4])
	{
		double min_u1(10.),min_v1(10.),min_u2(10.),min_v2(10.);
		for(int i=0; i<4; i++)
		{
			double tmp=ku1[i+1]-ku1[i];
			if(tmp!=0. && tmp<min_u1) min_u1=tmp;
			tmp=kv1[i+1]-kv1[i];
			if(tmp!=0. && tmp<min_v1) min_v1=tmp;
			tmp=ku2[i+1]-ku2[i];
			if(tmp!=0. && tmp<min_u2) min_u2=tmp;
			tmp=kv2[i+1]-kv2[i];
			if(tmp!=0. && tmp<min_v2) min_v2=tmp;
		}
		if(min_u1<=min_u2 && min_v1<=min_v2)
		{
			for(int i=0; i<5; i++)
			{
				const double* it1=find(ku2,ku2+5,ku1[i]);
				if(it1==ku2+5)
				{
					return true;
				}
				const double* it2=find(kv2,kv2+5,kv1[i]);
				if(it2==kv2+5)
				{
					return true;
				}
			}
			return false;
		}
		else
		{
			return false;
		}
	}
	else
	{
		return false;
	}
}

bool TruncatedTspline_3D::CheckSubKnotVector(const array<double,5>& ku1, const array<double,5>& kv1, const array<double,5>& ku2, const array<double,5>& kv2)
{
	if(ku1[0]>=ku2[0] && ku1[4]<=ku2[4] && kv1[0]>=kv2[0] && kv1[4]<=kv2[4])
	{
		double min_u1(10.),min_v1(10.),min_u2(10.),min_v2(10.);
		for(int i=0; i<4; i++)
		{
			double tmp=ku1[i+1]-ku1[i];
			if(tmp!=0. && tmp<min_u1) min_u1=tmp;
			tmp=kv1[i+1]-kv1[i];
			if(tmp!=0. && tmp<min_v1) min_v1=tmp;
			tmp=ku2[i+1]-ku2[i];
			if(tmp!=0. && tmp<min_u2) min_u2=tmp;
			tmp=kv2[i+1]-kv2[i];
			if(tmp!=0. && tmp<min_v2) min_v2=tmp;
		}
		if(min_u1<=min_u2 && min_v1<=min_v2)
		{
			for(int i=0; i<5; i++)
			{
				array<double,5>::const_iterator it1=find(ku2.begin(),ku2.end(),ku1[i]);
				if(it1==ku2.end())
				{
					return true;
				}
				array<double,5>::const_iterator it2=find(kv2.begin(),kv2.end(),kv1[i]);
				if(it2==kv2.end())
				{
					return true;
				}
			}
			return false;
		}
		else
		{
			return false;
		}
	}
	else
	{
		return false;
	}
}

void TruncatedTspline_3D::InitialConnect()
{
	uint i,j;
	tmedge.clear();
	tmface.clear();
	BuildInitialEdges();

	////construct edges
	//for(i=0; i<tmesh.size(); i++)
	//{
	//	for(j=0; j<4; j++)
	//	{
	//		Edge3D edtmp;
	//		edtmp.pt[0]=tmesh[i].cnct[j];
	//		edtmp.pt[1]=tmesh[i].cnct[(j+1)%4];
	//		vector<Edge3D>::iterator it=find(tmedge.begin(),tmedge.end(),edtmp);
	//		int edid(it-tmedge.begin());
	//		if(it==tmedge.end())
	//		{
	//			tmedge.push_back(edtmp);
	//		}
	//		tmesh[i].edge[j]=edid;
	//		//tmedge[edid].hex.push_back(i);
	//	}
	//	for(j=0; j<4; j++)
	//	{
	//		Edge3D edtmp;
	//		edtmp.pt[0]=tmesh[i].cnct[j];
	//		edtmp.pt[1]=tmesh[i].cnct[j+4];
	//		vector<Edge3D>::iterator it=find(tmedge.begin(),tmedge.end(),edtmp);
	//		int edid(it-tmedge.begin());
	//		if(it==tmedge.end())
	//		{
	//			tmedge.push_back(edtmp);
	//		}
	//		tmesh[i].edge[j+4]=edid;
	//		//tmedge[edid].hex.push_back(i);
	//	}
	//	for(j=0; j<4; j++)
	//	{
	//		Edge3D edtmp;
	//		edtmp.pt[0]=tmesh[i].cnct[j+4];
	//		edtmp.pt[1]=tmesh[i].cnct[(j+1)%4+4];
	//		vector<Edge3D>::iterator it=find(tmedge.begin(),tmedge.end(),edtmp);
	//		int edid(it-tmedge.begin());
	//		if(it==tmedge.end())
	//		{
	//			tmedge.push_back(edtmp);
	//		}
	//		tmesh[i].edge[j+8]=edid;
	//		//tmedge[edid].hex.push_back(i);
	//	}
	//}
	////construct faces
	//for(i=0; i<tmesh.size(); i++)
	//{
	//	//one bottom face
	//	Face3D fc1;
	//	for(j=0; j<4; j++)
	//	{
	//		fc1.cnct[j]=tmesh[i].cnct[j];
	//		fc1.edge[j]=tmesh[i].edge[j];
	//	}
	//	vector<Face3D>::iterator it1=find(tmface.begin(),tmface.end(),fc1);
	//	int fc1id(it1-tmface.begin());
	//	if(it1==tmface.end())
	//	{
	//		tmface.push_back(fc1);
	//	}
	//	tmesh[i].face[0]=fc1id;
	//	//tmface[fc1id].hex.push_back(i);
	//	//4 side faces
	//	for(j=0; j<4; j++)
	//	{
	//		Face3D fc;
	//		for(int k=0; k<4; k++)
	//		{
	//			fc.cnct[k]=tmesh[i].cnct[fc_cnct[j][k]];
	//			fc.edge[k]=tmesh[i].edge[ed_cnct[j][k]];
	//		}
	//		vector<Face3D>::iterator it=find(tmface.begin(),tmface.end(),fc);
	//		int fcid(it-tmface.begin());
	//		if(it==tmface.end())
	//		{
	//			tmface.push_back(fc);
	//		}
	//		tmesh[i].face[j+1]=fcid;
	//		//tmface[fcid].hex.push_back(i);
	//	}
	//	//one top face
	//	Face3D fc2;
	//	for(j=0; j<4; j++)
	//	{
	//		fc2.cnct[j]=tmesh[i].cnct[j+4];
	//		fc2.edge[j]=tmesh[i].edge[j+8];
	//	}
	//	vector<Face3D>::iterator it2=find(tmface.begin(),tmface.end(),fc2);
	//	int fc2id(it2-tmface.begin());
	//	if(it2==tmface.end())
	//	{
	//		tmface.push_back(fc2);
	//	}
	//	tmesh[i].face[5]=fc2id;
	//	//tmface[fc2id].hex.push_back(i);
	//}
	////vertex-to-hex, edge-to-hex, face-to-hex
	//for(i=0; i<tmesh.size(); i++)
	//{
	//	for(j=0; j<8; j++)
	//	{
	//		cp[tmesh[i].cnct[j]].hex.push_back(i);
	//	}
	//	for(j=0; j<12; j++)
	//	{
	//		tmedge[tmesh[i].edge[j]].hex.push_back(i);
	//	}
	//	for(j=0; j<6; j++)
	//	{
	//		tmface[tmesh[i].face[j]].hex.push_back(i);
	//	}
	//}
	////vertex-to-face, edge-to-face
	//for(i=0; i<tmface.size(); i++)
	//{
	//	for(j=0; j<4; j++)
	//	{
	//		cp[tmface[i].cnct[j]].face.push_back(i);
	//		tmedge[tmface[i].edge[j]].face.push_back(i);
	//	}
	//}
	////vertex-to-edge
	//for(i=0; i<tmedge.size(); i++)
	//{
	//	for(j=0; j<2; j++)
	//	{
	//		cp[tmedge[i].pt[j]].edge.push_back(i);
	//	}
	//}

	//find BC face, edge, vertex

	//int ed0[6][4] = { { 4, 5, 6, 7 }, { 1, 3, 9, 11 }, { 0, 2, 8, 10 }, { 1, 3, 9, 11 }, { 0, 2, 8, 10 }, { 4, 5, 6, 7 } };//order could be wrong, but doesn't matter
	for(i=0; i<tmface.size(); i++)
	{
		if(tmface[i].hex.size()==1)
		{
			tmface[i].type = 1;
			tmesh[tmface[i].hex[0]].type=1;
			for(j=0; j<4; j++)
			{
				cp[tmface[i].cnct[j]].type=1;
				tmedge[tmface[i].edge[j]].type=1;
			}
			//set zero length edges
			//int hexid(tmface[i].hex[0]);
			//int* it=find(tmesh[hexid].face,tmesh[hexid].face+6,i);
			//int fc_loc(it-tmesh[hexid].face);
			//for(j=0; j<4; j++)
			//{
			//	tmedge[tmesh[hexid].edge[ed0[fc_loc][j]]].len=0.;
			//}
		}
	}
	//additional boundary elements
	for (i = 0; i<tmesh.size(); i++)
	{
		if (tmesh[i].type != 1)
		{
			for (j = 0; j<8; j++)
			{
				if (cp[tmesh[i].cnct[j]].type == 1)
				{
					tmesh[i].type = 1;
					break;
				}
			}
		}
	}
	//find extraordinary edges and vertices
	for(i=0; i<tmedge.size(); i++)
	{
		if(tmedge[i].type!=1 && tmedge[i].hex.size()!=4)
		{
			tmedge[i].type=2;
			if(cp[tmedge[i].pt[0]].type!=1)
				cp[tmedge[i].pt[0]].type=3;
			if(cp[tmedge[i].pt[1]].type!=1)
				cp[tmedge[i].pt[1]].type=3;
		}
	}
	//boundary
	//for(i=0; i<cp.size(); i++)
	//{
	//	if(cp[i].type==1)//not consider surface extraordinary points yet
	//	{
	//		//int val(0);
	//		//for(j=0; j<cp[i].face.size(); j++)
	//		//{
	//		//	if(tmface[cp[i].face[j]].type==1) val++;
	//		//}
	//		//if(val==3 || val>4) cp[i].type=13;
	//	}
	//}
	//find irregular elements
	for(i=0; i<tmesh.size(); i++)
	{
		if(tmesh[i].type!=1)
		{
			for(j=0; j<12; j++)
			{
				if(tmedge[tmesh[i].edge[j]].type==2)
				{
					tmesh[i].type=2;
					break;
				}
			}
			//additional
			for (j = 0; j<8; j++)
			{
				if (cp[tmesh[i].cnct[j]].type == 3)
				{
					tmesh[i].type = 2;
					break;
				}
			}
		}
	}
	
	//boundry extraordinary points
	for (i = 0; i<cp.size(); i++)
	{
		if (cp[i].type == 1)
		{
			int count(0);
			for (j = 0; j < cp[i].edge.size(); j++)
			{
				if (tmedge[cp[i].edge[j]].type == 2) count++;
			}
			if (count==1) cp[i].bcxp = 1;
			else if (count>1) cp[i].bcxp = 2;
		}
	}

	//check 3D EP
	int n3d(0);
	for (i = 0; i < cp.size(); i++)
	{
		if (cp[i].type == 3)
		{
			int ned(0);
			for (j = 0; j < cp[i].edge.size(); j++)
			{
				if (tmedge[cp[i].edge[j]].type == 2)
				{
					ned++;
				}
			}
			if (ned>2)
			{
				n3d++;
			}
		}
	}
	cout << "# 3D EP: " << n3d << "\n";
	//getchar();
}

void TruncatedTspline_3D::UpdateConnect()
{
	uint i, j, k;
	//initialization
	for (i = 0; i < cp.size(); i++)
	{
		cp[i].hex.clear();
		cp[i].face.clear();
		cp[i].edge.clear();
	}
	for (i = 0; i < tmedge.size(); i++)
	{
		tmedge[i].face.clear();
		tmedge[i].hex.clear();
	}
	for (i = 0; i < tmface.size(); i++)
	{
		tmface[i].hex.clear();
	}
	//update
	for (i = 0; i < tmesh.size(); i++)
	{
		if (tmesh[i].act == 1)
		{
			for (j = 0; j < 8; j++)
			{
				cp[tmesh[i].cnct[j]].hex.push_back(i);
			}
			for (j = 0; j < 12; j++)
			{
				if (tmedge[tmesh[i].edge[j]].act == 1)
				{
					tmedge[tmesh[i].edge[j]].hex.push_back(i);
				}
				else
				{
					cp[tmedge[tmesh[i].edge[j]].midpt].hex.push_back(i);
					int edchd[2] = { tmedge[tmesh[i].edge[j]].chd[0], tmedge[tmesh[i].edge[j]].chd[1] };
					tmedge[edchd[0]].hex.push_back(i);
					tmedge[edchd[1]].hex.push_back(i);
				}
			}
			for (j = 0; j < 6; j++)
			{
				if (tmface[tmesh[i].face[j]].act == 1)
				{
					tmface[tmesh[i].face[j]].hex.push_back(i);
				}
				else
				{
					if (tmface[tmesh[i].face[j]].ctpt != -1)
					{
						cp[tmface[tmesh[i].face[j]].ctpt].hex.push_back(i);
					}
					for (k = 0; k < tmface[tmesh[i].face[j]].Tedge.size(); k++)
					{
						if (tmedge[tmface[tmesh[i].face[j]].Tedge[k]].act==1)
							tmedge[tmface[tmesh[i].face[j]].Tedge[k]].hex.push_back(i);
						else
						{
							tmedge[tmedge[tmface[tmesh[i].face[j]].Tedge[k]].chd[0]].hex.push_back(i);
							tmedge[tmedge[tmface[tmesh[i].face[j]].Tedge[k]].chd[1]].hex.push_back(i);
						}
					}
					for (k = 0; k < tmface[tmesh[i].face[j]].chd.size(); k++)
					{
						tmface[tmface[tmesh[i].face[j]].chd[k]].hex.push_back(i);
					}
				}
			}
		}
	}
	for (i = 0; i < tmface.size(); i++)
	{
		if (tmface[i].act == 1)
		{
			for (j = 0; j < 4; j++)
			{
				cp[tmface[i].cnct[j]].face.push_back(i);
				if (tmedge[tmface[i].edge[j]].act == 1)
				{
					tmedge[tmface[i].edge[j]].face.push_back(i);
				}
				else
				{
					cp[tmedge[tmface[i].edge[j]].midpt].face.push_back(i);
					int edchd[2] = { tmedge[tmface[i].edge[j]].chd[0], tmedge[tmface[i].edge[j]].chd[1] };
					tmedge[edchd[0]].face.push_back(i);
					tmedge[edchd[1]].face.push_back(i);
				}
			}
		}
	}
	for (i = 0; i < tmedge.size(); i++)
	{
		if (tmedge[i].act == 1)
		{
			cp[tmedge[i].pt[0]].edge.push_back(i);
			cp[tmedge[i].pt[1]].edge.push_back(i);
		}
	}
}

void TruncatedTspline_3D::InitialRotate()
{
	int pref_loc[6] = {0,0,1,3,0,4};
	//int ed_uvw[8][3] = { { 0, 3, 4 }, { 1, 0, 5 }, { 2, 1, 6 }, { 3, 2, 7 }, { 11, 8, 4 }, { 8, 9, 5 }, { 9, 10, 6 }, { 10, 11, 7 } };
	int edref_loc[6][3] = { { 0, 3, -2 }, { 0, -2, 4 }, { -1, 1, 5 }, { 2, -1, 7 }, {-2,3,4}, { 8, 11, -1 }};
	vector<Matrix3d> mat_all;
	getElementRotate(mat_all);
	for (uint i = 0; i < mat_all.size(); i++)
	{
		Matrix3d tmp = mat_all[i].transpose();
		mat_all[i] = tmp;
	}
	//set 6 rotation matrix correpsonding to each face
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		for (int i = 0; i < 6; i++)
		{
			if (tmface[tmesh[eid].face[i]].type != 1)//not boundary
			{
				int fcid(tmesh[eid].face[i]);
				int hxid(tmface[tmesh[eid].face[i]].hex[0]);
				if (hxid == eid) hxid = tmface[tmesh[eid].face[i]].hex[1];
				int ptref(tmesh[eid].cnct[pref_loc[i]]);
				int* it = find(tmesh[hxid].cnct, tmesh[hxid].cnct+8, ptref);
				int loc(it - tmesh[hxid].cnct);
				int ed_ref[3];
				for (int j = 0; j < 3; j++)
				{
					if (edref_loc[i][j] < 0) ed_ref[j] = edref_loc[i][j];
					else ed_ref[j] = tmesh[eid].edge[edref_loc[i][j]];
				}
				Matrix3d mat_loc;
				getCornerRotate(hxid,ed_uvw[loc],ed_ref,mat_loc);
				tmesh[eid].nbrot[i] = mat_loc*mat_all[loc];
				//cout << "face nb: " << hxid << "\n";
				//cout << tmesh[eid].nbrot[i] << "\n";
				//if (i == 4)
				//{
				//	cout << "local: "<<loc<<"\n";
				//	cout << mat_loc << "\n";
				//	cout << mat_all[loc]<<"\n";
				//}
				//getchar();
			}
		}
	}
}

void TruncatedTspline_3D::getElementRotate(vector<Matrix3d>& mat)//rotatoin matrix for each corner vertex
{
	mat.clear();
	mat.resize(8);
	mat[0] << 1, 0, 0,
			  0, 1, 0, 
			  0, 0, 1;
	mat[1] << 0, -1, 0, 
		      1, 0, 0, 
			  0, 0, 1;
	mat[2] << -1, 0, 0, 
		      0, -1, 0, 
			  0, 0, 1;
	mat[3] << 0, 1, 0, 
		      -1, 0, 0, 
			  0, 0, 1;
	mat[4] << 0, 1, 0, 
		      1, 0, 0, 
			  0, 0, -1;
	mat[5] << -1, 0, 0, 
		      0, 1, 0, 
			  0, 0, -1;
	mat[6] << 0, -1, 0, 
		      -1, 0, 0, 
			  0, 0, -1;
	mat[7] << 1, 0, 0, 
		      0, -1, 0, 
			  0, 0, -1;
}

void TruncatedTspline_3D::getCornerRotate(int hxid, int uvw_loc[3], int uvw_ref[3], Matrix3d& mat)
{
	int pos(0), loc(0);
	Matrix3d tmp1 = Matrix3d::Identity();
	Matrix3d tmp2 = Matrix3d::Zero();
	tmp2(0, 0) = -1; tmp2(1, 1) = -1; tmp2(2, 2) = -1;
	for (int i = 0; i < 3; i++)
	{
		if (tmesh[hxid].edge[uvw_loc[i]] == uvw_ref[0])
		{
			//mat(i, 0) = 1.; mat(i, 1) = 0.; mat(i, 2) = 0.;
			mat(0, i) = 1.; mat(1, i) = 0.; mat(2, i) = 0.;
		}
		else if (tmesh[hxid].edge[uvw_loc[i]] == uvw_ref[1])
		{
			//mat(i, 0) = 0.; mat(i, 1) = 1.; mat(i, 2) = 0.;
			mat(0, i) = 0.; mat(1, i) = 1.; mat(2, i) = 0.;
		}
		else if (tmesh[hxid].edge[uvw_loc[i]] == uvw_ref[2])
		{
			//mat(i, 0) = 0.; mat(i, 1) = 0.; mat(i, 2) = 1.;
			mat(0, i) = 0.; mat(1, i) = 0.; mat(2, i) = 1.;
		}
		else
		{
			pos = i;
		}
		if (uvw_ref[i] < 0) loc = i;
	}
	if (uvw_ref[loc] == -1)//postive
	{
		//mat(pos, 0) = tmp1(loc, 0); mat(pos, 1) = tmp1(loc, 1); mat(pos, 2) = tmp1(loc, 2);
		mat(0, pos) = tmp1(0, loc); mat(1, pos) = tmp1(1, loc); mat(2, pos) = tmp1(2, loc);
	}
	else if (uvw_ref[loc] == -2)//negative
	{
		//mat(pos, 0) = tmp2(loc, 0); mat(pos, 1) = tmp2(loc, 1); mat(pos, 2) = tmp2(loc, 2);
		mat(0, pos) = tmp2(0, loc); mat(1, pos) = tmp2(1, loc); mat(2, pos) = tmp2(2, loc);
	}
}

//void TruncatedTspline_3D::UpdateConnect()
//{
//	uint i,j,k;
//	for(i=0; i<cp.size(); i++)
//	{
//		cp[i].face.clear();
//		cp[i].edge.clear();
//	}
//	for(i=0; i<tmedge.size(); i++)
//	{
//		tmedge[i].face.clear();
//	}
//	//loop all faces
//	for(i=0; i<tmesh.size(); i++)
//	{
//		if(tmesh[i].act==1)
//		{
//			for(j=0; j<4; j++)
//			{
//				cp[tmesh[i].cnct[j]].face.push_back(i);
//				if(tmedge[tmesh[i].edge[j]].act==1)
//				{
//					tmedge[tmesh[i].edge[j]].face.push_back(i);
//				}
//				else
//				{
//					cp[tmedge[tmesh[i].edge[j]].midpt].face.push_back(i);
//					int chdid[2]={tmedge[tmesh[i].edge[j]].chd[0],tmedge[tmesh[i].edge[j]].chd[1]};
//					if(tmedge[chdid[0]].act==1 && tmedge[chdid[1]].act==1)
//					{
//						tmedge[chdid[0]].face.push_back(i);
//						tmedge[chdid[1]].face.push_back(i);
//					}
//					else
//					{
//						cerr<<"Configuration not recognized!\n";
//					}
//				}
//			}
//		}
//	}
//	//loop all edges
//	for(i=0; i<tmedge.size(); i++)
//	{
//		if(tmedge[i].act==1)
//		{
//			cp[tmedge[i].pt[0]].edge.push_back(i);
//			cp[tmedge[i].pt[1]].edge.push_back(i);
//		}
//	}
//
//	for(i=0; i<cp.size(); i++)
//	{
//		if(cp[i].face.size()==3 && cp[i].type!=2)
//		{
//			cp[i].type=1;
//		}
//	}
//
//	//FindEdgeTopoDirec_1();
//	//FindKnotInterval_1();//find kitvtmp
//	//UpdateKnotInterval_1();
//	//SetLocalCoorSystem();
//	//FindIEN_1();
//}

void TruncatedTspline_3D::FindEdgeTopoDirec()
{
	for(uint i=0; i<tmedge.size(); i++)
	{
		tmedge[i].pn[0][0]=4; tmedge[i].pn[0][1]=-1;
		tmedge[i].pn[1][0]=4; tmedge[i].pn[1][1]=-1;//initialize as end
		if(tmedge[i].act==1)
		{
			for(int j=0; j<2; j++)
			{
				int type, next;
				EdgeConnect(i,tmedge[i].pt[j],type,next);//T-junction connectivity comes from refinement later
				tmedge[i].pn[j][0]=type;
				tmedge[i].pn[j][1]=next;

				//if (i == 347 && tmedge[i].pt[j] == 142)
				//{
				//	cout << tmedge[i].pn[j][0] << " " << tmedge[i].pn[j][1]<<"\n";
				//	getchar();
				//}

				//else if(cp[tmedge[i].pt[j]].type==1)//T-junctions
				//{
				//	int fid(-1);
				//	int loc(0);
				//	for(uint k=0; k<cp[tmedge[i].pt[j]].face.size(); k++)
				//	{
				//		int ftmp(cp[tmedge[i].pt[j]].face[k]);
				//		for(int k1=0; k1<4; k1++)
				//		{
				//			if(tmedge[tmesh[ftmp].edge[k1]].act==0 && tmedge[tmesh[ftmp].edge[k1]].midpt==tmedge[i].pt[j])
				//			{
				//				loc=k1; fid=ftmp; break;
				//			}
				//		}
				//		if(fid!=-1)
				//		{
				//			break;
				//		}
				//	}
				//	if(fid==-1)
				//	{
				//		cout<<"edge id: "<<i<<"\n";
				//		cout<<tmedge[i].pt[0]<<" "<<tmedge[i].pt[1]<<"\n";
				//		cout<<tmedge[i].prt<<"\n";
				//		//cout<<cp[tmedge[i].pt[0]].face.size()<<" "<<cp[tmedge[i].pt[1]].face.size()<<"\n";
				//		cout<<cp[tmedge[i].pt[0]].face[0]<<" "<<cp[tmedge[i].pt[0]].face[1]<<" "<<cp[tmedge[i].pt[0]].face[2]<<"\n";
				//		cerr<<"T-junction cannot be found in any neighboring elements!\n";
				//		getchar();
				//	}
				//	if(tmedge[tmesh[fid].edge[loc]].chd[0]==i)
				//	{
				//		tmedge[i].pn[j][0]=0;
				//		tmedge[i].pn[j][1]=tmedge[tmesh[fid].edge[loc]].chd[1];
				//	}
				//	else if(tmedge[tmesh[fid].edge[loc]].chd[1]==i)
				//	{
				//		tmedge[i].pn[j][0]=0;
				//		tmedge[i].pn[j][1]=tmedge[tmesh[fid].edge[loc]].chd[0];
				//	}
				//	else
				//	{
				//		tmedge[i].pn[j][0]=1;
				//		tmedge[i].pn[j][1]=fid;
				//	}
				//}
			}
		}
	}
}

//void TruncatedTspline_3D::EdgeConnect(int ed0, int pid0, int& type1, int& ed1)//ed0 and pid0 is the current edge and point, type1 and ed1 for next information
//{
//	type1=4;//end
//	ed1=-1;
//	if(tmedge[ed0].type!=1 && (cp[pid0].type==1 || cp[pid0].type==12 || cp[pid0].type==13)) return;
//	if(tmedge[ed0].type==1 && cp[pid0].type==13) {type1=3; return;}
//	vector<int> edtmp;
//	for(uint i=0; i<cp[pid0].edge.size(); i++)//find the edge that not belong to hexes
//	{
//		int edid(cp[pid0].edge[i]);//edge connect to the end point pid0
//		if(edid != ed0)
//		{
//			int flag(0);
//			for(uint j=0; j<tmedge[ed0].hex.size(); j++)
//			{
//				int hexid(tmedge[ed0].hex[j]);//hex sharing this edge
//				for(uint k=0; k<12; k++)
//				{
//					int ed(tmesh[hexid].edge[k]);
//					if(tmedge[ed].act==1 && ed==edid)
//					{
//						flag=1; break;
//					}
//					else if(tmedge[ed].act==0 && (tmedge[ed].chd[0]==edid || tmedge[ed].chd[1]==edid))
//					{
//						flag=1; break;
//					}
//				}
//				for(uint k=0; k<6; k++)
//				{
//					int fc(tmesh[hexid].face[k]);
//					vector<int>::iterator it=find(tmface[fc].Tedge.begin(),tmface[fc].Tedge.end(),edid);
//					if(it!=tmface[fc].Tedge.end())
//					{
//						flag=1; break;
//					}
//				}
//			}
//			if(flag==0)
//			{
//				edtmp.push_back(edid);
//			}
//		}
//	}
//	if(edtmp.size()==1)
//	{
//		type1=0;
//		ed1=edtmp[0];
//	}
//	else if(edtmp.size()==0)//4 possible cases
//	{
//		type1=3;//case 1 - XP
//		for(uint i=0; i<cp[pid0].hex.size(); i++)
//		{
//			for(int j=0; j<6; j++)
//			{
//				int fcid(tmesh[cp[pid0].hex[i]].face[j]);
//				if(tmface[fcid].act==0 && tmface[fcid].ctpt==pid0)
//				{
//					type1=2;
//					ed1=cp[pid0].hex[i];
//					break;
//				}
//			}
//			if(type1==2) break;//case 2 - hex
//		}
//		if(type1==3)
//		{
//			vector<int> fctmp;
//			for(uint i=0; i<cp[pid0].face.size(); i++)
//			{
//				int fcid(cp[pid0].face[i]), flag(0);
//				for(uint j=0; j<tmedge[ed0].hex.size(); j++)
//				{
//					int hxid(tmedge[ed0].hex[j]);
//					for(int k=0; k<6; k++)
//					{
//						if(tmface[tmesh[hxid].face[k]].act==1 && tmesh[hxid].face[k]==i) flag=1;
//						if(tmface[tmesh[hxid].face[k]].act==0)
//						{
//							int fcid1(tmesh[hxid].face[k]);
//							vector<int>::iterator it=find(tmface[fcid1].chd.begin(),tmface[fcid1].chd.end(),i);
//							if(it!=tmface[fcid1].chd.end()) flag=1;
//						}
//						if(flag==1) break;
//					}
//					if(flag==1) break;
//				}
//				if(flag==0)
//				{
//					fctmp.push_back(fcid);
//					//type1=1; ed1=fcid; break;//case 3 - face
//				}
//			}
//			if(fctmp.size()==1)
//			{
//				type1=1; ed1=fctmp[0];
//			}
//			else if(fctmp.size()==0)
//			{
//				if(tmedge[ed0].prt!=-1)
//				{
//					for(uint i=0; i<cp[pid0].edge.size(); i++)
//					{
//						if(tmedge[cp[pid0].edge[i]].prt==tmedge[ed0].prt)
//						{
//							type1=0; ed1=cp[pid0].edge[i]; break;
//						}
//					}
//				}
//			}
//		}
//	}
//	else
//	{
//		type1=3;
//	}
//}

void TruncatedTspline_3D::EdgeConnect(int ed0, int pid0, int& type1, int& ed1)//ed0 and pid0 is the current edge and point, type1 and ed1 for next information
{
	type1 = 4;//end
	ed1 = -1;
	if (tmedge[ed0].type != 1 && (cp[pid0].type == 1 || cp[pid0].type == 12 || cp[pid0].type == 13)) return;
	if (tmedge[ed0].type == 1 && cp[pid0].type == 13) { type1 = 3; return; }
	if (tmedge[ed0].prt != -1)
	{
		if (tmedge[tmedge[ed0].prt].midpt == pid0)
		{
			type1 = 0; ed1 = tmedge[tmedge[ed0].prt].chd[0];
			if (ed1 == ed0) ed1 = tmedge[tmedge[ed0].prt].chd[1];
			return;
		}
	}
	vector<int> edtmp;
	for (uint i = 0; i<cp[pid0].edge.size(); i++)//find the edge that not belong to faces
	{
		int edid(cp[pid0].edge[i]);//edge connect to the end point pid0
		if (edid != ed0)
		{
			int flag(0);
			for (uint j = 0; j<tmedge[ed0].face.size(); j++)
			{
				int fcid(tmedge[ed0].face[j]);//active face sharing input edge
				for (uint k = 0; k<4; k++)
				{
					int ed(tmface[fcid].edge[k]);
					if (tmedge[ed].act == 1 && ed == edid)
					{
						flag = 1; break;
					}
					else if (tmedge[ed].act == 0 && (tmedge[ed].chd[0] == edid || tmedge[ed].chd[1] == edid))
					{
						flag = 1; break;
					}
				}
			}
			if (flag == 0)
			{
				edtmp.push_back(edid);
			}
		}
	}
	if (edtmp.size() == 1)
	{
		type1 = 0;
		ed1 = edtmp[0];
	}
	else if (edtmp.size() == 0)//4 possible cases
	{
		type1 = 3;//initialized as XP
		for (uint i = 0; i<cp[pid0].hex.size(); i++)//pid0 is a face T-junction
		{
			for (int j = 0; j<6; j++)
			{
				int fcid(tmesh[cp[pid0].hex[i]].face[j]);
				if (tmface[fcid].act == 0 && tmface[fcid].ctpt == pid0)
				{
					type1 = 2;
					ed1 = cp[pid0].hex[i];//next is a solid
					return;
				}
			}
		}
		vector<int> fctmp;
		for (uint i = 0; i<cp[pid0].face.size(); i++)
		{
			int fcid(cp[pid0].face[i]), flag(0);
			for (uint j = 0; j<tmedge[ed0].hex.size(); j++)
			{
				int hxid(tmedge[ed0].hex[j]);
				for (int k = 0; k<6; k++)
				{
					if (tmface[tmesh[hxid].face[k]].act == 1 && tmesh[hxid].face[k] == fcid) flag = 1;
					if (tmface[tmesh[hxid].face[k]].act == 0)
					{
						int fcid1(tmesh[hxid].face[k]);
						vector<int>::iterator it = find(tmface[fcid1].chd.begin(), tmface[fcid1].chd.end(), fcid);
						if (it != tmface[fcid1].chd.end()) flag = 1;
					}
					if (flag == 1) break;
				}
				if (flag == 1) break;
			}
			if (flag == 0)
			{
				fctmp.push_back(fcid);
				//if (pid0 == 159 && ed0 == 403)
				//{
				//	cout << fcid <<" "<< tmface[fcid].id_act << "\n";
				//	getchar();
				//}
			}
			//if (pid0 == 142 && ed0 == 347)
			//{
			//	//cout << "here " << fctmp.size() << "\n";
			//	cout << fcid <<" "<<tmface[fcid].act << "\n";
			//	getchar();
			//}
		}
		if (fctmp.size() == 1)
		{
			type1 = 1; ed1 = fctmp[0];
			//if (pid0 == 142 && ed0 == 347)
			//{
			//	cout << "here " << fctmp.size() << "\n";
			//	getchar();
			//}
			return;
		}
		//else if (fctmp.size() == 0)
		//{
		//	if (tmedge[ed0].prt != -1)
		//	{
		//		for (uint i = 0; i<cp[pid0].edge.size(); i++)
		//		{
		//			if (tmedge[cp[pid0].edge[i]].prt == tmedge[ed0].prt)
		//			{
		//				type1 = 0; ed1 = cp[pid0].edge[i]; break;
		//			}
		//		}
		//	}
		//}
	}
	else
	{
		type1 = 3;
	}
}

//void TruncatedTspline_3D::FindFaceTopoDirec()
//{
//	for(uint i=0; i<tmface.size(); i++)
//	{
//		for(int j=0; j<4; j++)
//		{
//			tmface[i].pn[j][0]=4; tmface[i].pn[j][1]=-1; 
//		}
//		if(tmface[i].act==1)
//		{
//			for(int j=0; j<4; j++)
//			{
//				int type, next;
//				FaceConnect(i,tmface[i].edge[j],type,next);
//				tmface[i].pn[j][0]=type;
//				tmface[i].pn[j][1]=next;
//			}
//		}
//	}
//}

void TruncatedTspline_3D::FaceConnect(int fc0, int ed0, int& type1, int& fc1)
{
	type1=4; fc1=-1;
	if(tmface[fc0].type!=1 && tmedge[ed0].type==1) return;
	vector<int> fctmp;
	for(uint i=0; i<tmedge[ed0].face.size(); i++)//find the edge that not belong to hexes
	{
		int fcid(tmedge[ed0].face[i]);
		if(fcid != fc0)
		{
			int flag(0);
			for(uint j=0; j<tmface[fc0].hex.size(); j++)
			{
				int hexid(tmface[fc0].hex[j]);
				for(uint k=0; k<6; k++)
				{
					int fc(tmesh[hexid].face[k]);
					if(tmface[fc].act==1 && fc==fcid)
					{
						flag=1; break;
					}
					//else if(tmedge[ed].act==0 && (tmedge[ed].chd[0]==edid || tmedge[ed].chd[1]==edid))
					//{
					//	flag=1; break;
					//}
				}
			}
			if(flag==0)
			{
				fctmp.push_back(fcid);
			}
		}
	}
	if(fctmp.size()==1)
	{
		type1=1;//next is face
		fc1=fctmp[0];
	}
	else
	{
		type1=3;//next is extraordinary edge
	}
}

void TruncatedTspline_3D::setReference()//reference element and reference edges
{
	for(uint i=0; i<cp.size(); i++)
	{
		for(int j=0; j<4; j++)
		{
			cp[i].kitvU[j]=1.; cp[i].kitvV[j]=1.; cp[i].kitvW[j]=1.;
		}
		//if(cp[i].type!=3 && cp[i].type!=13)// not extraordinaty
		{
			int pos(0);
			cp[i].rhx=-1;
			for(uint j=0; j<cp[i].hex.size(); j++)
			{
				int* it=find(tmesh[cp[i].hex[j]].cnct,tmesh[cp[i].hex[j]].cnct+8,i);
				if(it!=tmesh[cp[i].hex[j]].cnct+8)
				{
					cp[i].rhx=cp[i].hex[j];
					pos=it-tmesh[cp[i].hex[j]].cnct;
					break;
				}
			}
			if(cp[i].rhx==-1)
			{
				cerr<<"Cannot find correct reference hex!\n";
				getchar();
			}
			getElementRotate_Unit(pos,cp[i].rot_ref);
			for(int j=0; j<3; j++)
			{
				cp[i].uved[j]=tmesh[cp[i].rhx].edge[ed_uvw[pos][j]];
				if(tmedge[cp[i].uved[j]].act==0)
				{
					int edtmp(tmedge[cp[i].uved[j]].chd[0]);
					if(tmedge[edtmp].pt[0]!=i && tmedge[edtmp].pt[1]!=i)
					{
						edtmp = tmedge[cp[i].uved[j]].chd[1];
					}
					cp[i].uved[j] = edtmp;
				}
				vector<int>::iterator it=find(cp[i].edge.begin(),cp[i].edge.end(),cp[i].uved[j]);
				if(it==cp[i].edge.end())
				{
					cerr<<"Cannot find correct uv edges!\n";
					//cout << "pid: " << i << "\n";
					//cout << "edge act: " << tmedge[tmesh[cp[i].rhx].edge[ed_uvw[pos][j]]].act << "\n";
					cout << "edge act: " << tmedge[tmesh[cp[i].rhx].edge[ed_uvw[pos][j]]].pt[0] << " " << tmedge[tmesh[cp[i].rhx].edge[ed_uvw[pos][j]]].pt[1] << "\n";
					//cout << "edge chd: " << tmedge[tmedge[tmesh[cp[i].rhx].edge[ed_uvw[pos][j]]].chd[0]].id_act << " " << tmedge[tmedge[tmesh[cp[i].rhx].edge[ed_uvw[pos][j]]].chd[1]].id_act << "\n";
					//cout << "edge: " << tmedge[cp[i].uved[j]].id_act << "\n";
					getchar();
				}
			}
		}
	}
}

void TruncatedTspline_3D::FindKnotInterval()
{
	setReference();
	//int fc_ppd_ed[6]={4,3,0,3,0,4};
	int trun_flag;
	for(uint i=0; i<cp.size(); i++)
	{
		//if(cp[i].type!=1 /*&& cp[i].type!=13*/)
		{
			ShootRay(i,cp[i].uved[0],cp[i].kitvU,trun_flag);
			ShootRay(i,cp[i].uved[1],cp[i].kitvV,trun_flag);
			ShootRay(i,cp[i].uved[2],cp[i].kitvW,trun_flag);
			//cp[i].trun=trun_flag;
		}
		//else if(cp[i].type==3)
		//{
		//	for(int j=0; j<4; j++)
		//	{
		//		cp[i].kitvU[j]=tmedge[cp[i].edge[0]].len;
		//		cp[i].kitvV[j]=tmedge[cp[i].edge[0]].len;
		//		cp[i].kitvW[j]=tmedge[cp[i].edge[0]].len;
		//	}
		//}
		//else if(cp[i].type==13)
		//{
		//}
	}
}

void TruncatedTspline_3D::ShootRay(int pid, int edid, double kv[4], int& trun_flag)
{
	int loc0(0),loc1(1);
	//int edge_lev[2]={-1,-1};
	//trun_flag=0;
	//int flag[2]={-1,-1};
	//positive direction
	if(pid!=tmedge[edid].pt[0])
	{
		loc0=1; loc1=0;
	}
	kv[2]=tmedge[edid].len;
	//edge_lev[0]=tmedge[edid].lev;//first edge level
	if(tmedge[edid].pn[loc1][0]==0)//next is edge
	{
		kv[3]=tmedge[tmedge[edid].pn[loc1][1]].len;
		////find skip
		//int edtmp(tmedge[edid].pn[loc1][1]);
		//edge_lev[1]=tmedge[edtmp].lev;//second edge level
		//if(edge_lev[1]>edge_lev[0] && tmedge[edtmp].face.size()==2)
		//{
		//	int eid[2]={tmedge[edtmp].face[0],tmedge[edtmp].face[1]};
		//	if(tmesh[eid[0]].lev!=tmesh[eid[1]].lev)
		//	{
		//		int e_fe(eid[0]);
		//		if(tmesh[eid[0]].lev > tmesh[eid[1]].lev) e_fe=eid[1];
		//		int pos(0);
		//		for(int k=0; k<4; k++)
		//		{
		//			if(tmedge[tmesh[e_fe].edge[k]].act==0)
		//			{
		//				pos=k;
		//				break;
		//			}
		//		}
		//		if(cp[tmesh[e_fe].cnct[(pos+3)%4]].type==1)
		//		{
		//			flag[0]=1;
		//		}
		//	}
		//}
	}
	else if(tmedge[edid].pn[loc1][0]==1)//next is face
	{
		int fid(tmedge[edid].pn[loc1][1]), pos(0);
		for(int i=0; i<4; i++)
		{
			if(tmedge[tmface[fid].edge[i]].act==0 && tmedge[tmface[fid].edge[i]].midpt==tmedge[edid].pt[loc1])
			{
				pos=i; break;
			}
		}
		kv[3]=tmedge[tmface[fid].edge[(pos+1)%4]].len;
	}
	else if(tmedge[edid].pn[loc1][0]==2)//next is hex
	{
		int hxid(tmedge[edid].pn[loc1][1]), pos(0);
		for(int i=0; i<6; i++)
		{
			if(tmface[tmesh[hxid].face[i]].act==0 && tmface[tmesh[hxid].face[i]].ctpt==tmedge[edid].pt[loc1])
			{
				pos=i; break;
			}
		}
		kv[3]=tmedge[tmesh[hxid].edge[fc_ppd_ed[pos]]].len;
	}
	else if(tmedge[edid].pn[loc1][0]==3)//next is XP
	{
		kv[3]=kv[2];
	}
	else if(tmedge[edid].pn[loc1][0]==4)//end
	{
		kv[3]=0.;
		//kv[3] = 1.;
	}
	//if(flag[0]==1)//skip
	//{
	//	kv[3]=2.*kv[3];
	//	trun_flag=1;
	//	//cout<<"trun!\n";
	//	//getchar();
	//}
	//negative direction
	//edge_lev[0]=-1; edge_lev[1]=-1; 
	if(tmedge[edid].pn[loc0][0]==0)//previous is edge
	{
		int ed0=tmedge[edid].pn[loc0][1];
		kv[1]=tmedge[ed0].len;
		//edge_lev[0]=tmedge[ed0].lev;//first edge level
		int a0=0, a1=1;
		if(tmedge[ed0].pt[0]!=pid)
		{
			a0=1; a1=0;
		}
		if(tmedge[ed0].pn[a1][0]==0)//previous previous is edge
		{
			kv[0]=tmedge[tmedge[ed0].pn[a1][1]].len;
			////find skip
			//int edtmp(tmedge[ed0].pn[a1][1]);
			//edge_lev[1]=tmedge[edtmp].lev;//second edge level
			//if(edge_lev[1]>edge_lev[0] && tmedge[edtmp].face.size()==2)
			//{
			//	int eid[2]={tmedge[edtmp].face[0],tmedge[edtmp].face[1]};
			//	if(tmesh[eid[0]].lev!=tmesh[eid[1]].lev)
			//	{
			//		int e_fe(eid[0]);
			//		if(tmesh[eid[0]].lev > tmesh[eid[1]].lev) e_fe=eid[1];
			//		int pos(0);
			//		for(int k=0; k<4; k++)
			//		{
			//			if(tmedge[tmesh[e_fe].edge[k]].act==0)
			//			{
			//				pos=k;
			//				break;
			//			}
			//		}
			//		if(cp[tmesh[e_fe].cnct[(pos+3)%4]].type==1)
			//		{
			//			flag[1]=1;
			//		}
			//	}
			//}
		}
		else if(tmedge[ed0].pn[a1][0]==1)//previous previous is face
		{
			int pt0(tmedge[ed0].pt[a1]), fid(tmedge[ed0].pn[a1][1]), pos(0);
			for(int i=0; i<4; i++)
			{
				if(tmedge[tmface[fid].edge[i]].act==0 && tmedge[tmface[fid].edge[i]].midpt==tmedge[ed0].pt[a1])
				{
					pos=i; break;
				}
			}
			kv[0]=tmedge[tmface[fid].edge[(pos+1)%4]].len;
		}
		else if(tmedge[ed0].pn[a1][0]==2)//previous previous is hex
		{
			int hxid(tmedge[ed0].pn[a1][1]), pos(0);
			for(int i=0; i<6; i++)
			{
				if(tmface[tmesh[hxid].face[i]].act==0 && tmface[tmesh[hxid].face[i]].ctpt==tmedge[ed0].pt[a1])
				{
					pos=i; break;
				}
			}
			kv[0]=tmedge[tmesh[hxid].edge[fc_ppd_ed[pos]]].len;
		}
		else if(tmedge[ed0].pn[a1][0]==3)
		{
			kv[0]=kv[1];
		}
		else if(tmedge[ed0].pn[a1][0]==4)
		{
			kv[0]=0.;
			//kv[0] = 1.;
		}
		
	}
	else if(tmedge[edid].pn[loc0][0]==1)//previous is face
	{
		int fid0(tmedge[edid].pn[loc0][1]), pos(0);
		for(int i=0; i<4; i++)
		{
			if(tmedge[tmface[fid0].edge[i]].act==0 && tmedge[tmface[fid0].edge[i]].midpt==pid)
			{
				pos=i; break;
			}
		}
		kv[1]=tmedge[tmface[fid0].edge[(pos+1)%4]].len;

		//if (pid == 142)
		//{
		//	cout << "here "<< kv[1] << "\n";
		//	getchar();
		//}

		int ed0(tmface[fid0].edge[(pos+2)%4]);//find opposite edge, next connetivity, can be either face or hex if ed0 is regular
		if(tmface[fid0].type!=1 && tmedge[ed0].type==1)//boundary
		{
			kv[0]=0.;
			//kv[0] = 1.;
		}
		else if(tmedge[ed0].type==2)//extraordinary
		{
			kv[0]=kv[1];
		}
		else if (tmface[fid0].prt != -1)//only consider two children first
		{
			int fid1(tmface[tmface[fid0].prt].chd[0]);
			if (fid1 == fid0) fid1 = tmface[tmface[fid0].prt].chd[1];
			int* it1 = find(tmface[fid1].edge, tmface[fid1].edge+4, ed0);
			if (it1 != tmface[fid1].edge + 4)
			{
				int pos1(it1 - tmface[fid1].edge);
				kv[0] = tmedge[tmface[fid1].edge[(pos+1)%4]].len;
			}
			else
			{
				cerr << "Can't find shared edge!\n";
				getchar();
			}
		}
		else// if(tmedge[ed0].type==0 || tmedge[ed0].type==3)//T-edge, not consider T-face
		{
			vector<int> fctmp;
			for(uint i=0; i<tmedge[ed0].face.size(); i++)
			{
				int fcid(tmedge[ed0].face[i]), flag(0);
				for(uint j=0; j<tmface[fcid].hex.size(); j++)
				{
					int hxid(tmface[fcid].hex[j]);
					for(int k=0; k<6; k++)
					{
						if(tmface[tmesh[hxid].face[k]].act==1 && tmesh[hxid].face[k]==fcid)
						{
							flag=1; break;
						}
						else if(tmface[tmesh[hxid].face[k]].act==0)
						{
							vector<int>::iterator it=find(tmface[tmesh[hxid].face[k]].chd.begin(),tmface[tmesh[hxid].face[k]].chd.end(),fcid);
							if(it!=tmface[tmesh[hxid].face[k]].chd.end())
							{
								flag=1; break;
							}
						}
					}
					if(flag==1) break;
				}
				if(flag==0) fctmp.push_back(fcid);
			}
			if(fctmp.size()==1)
			{
				int* it=find(tmface[fctmp[0]].edge,tmface[fctmp[0]].edge+4,ed0);
				if(it!=tmface[fctmp[0]].edge+4)
				{
					int pos=it-tmface[fctmp[0]].edge;
					kv[0]=tmedge[tmface[fctmp[0]].edge[(pos+1)%4]].len;
				}
				else
				{
					cerr<<"Cannot find next face that contains this edge!\n";
					getchar();
				}
			}
			else if(fctmp.size()==0)
			{
				kv[0]=kv[1];
				int hxid(-1), pos(-1);
				for(uint i=0; i<tmedge[ed0].hex.size(); i++)
				{
					for(int j=0; j<6; j++)
					{
						if(tmface[tmesh[tmedge[ed0].hex[i]].face[j]].act==0)
						{
							int fcid(tmesh[tmedge[ed0].hex[i]].face[j]);
							vector<int>::iterator it=find(tmface[fcid].Tedge.begin(),tmface[fcid].Tedge.end(),ed0);
							if(it!=tmface[fcid].Tedge.end())
							{
								hxid=tmedge[ed0].hex[i]; pos=j; break;
							}
						}
					}
					if(hxid!=-1) break;
				}
				if(hxid!=-1)
				{
					kv[0]=tmedge[tmesh[hxid].edge[fc_ppd_ed[pos]]].len;
				}
			}
		}

		//if(tmface[fid0].pn[ed0][0]==0)//previous previous is edge
		//{
		//	//do not allow currently
		//	kv[0]=tmedge[tmface[fid0].pn[ed0][1]].len;
		//}
		//else if(tmface[fid0].pn[ed0][0]==1)//previous previous is face
		//{
		//	//int fid1(tmface[fid0].pn[ed0][1]);
		//	//int* it=find(tmface[fid1].edge,tmface[fid1].edge+4,ed0);
		//	//pos=it-tmface[fid1].edge;
		//	//kv[0]=tmedge[tmface[fid1].edge[(pos+1)%4]].len;
		//}
		//else if(tmface[fid0].pn[ed0][0]==2)//previous previous is hex
		//{
		//	if(tmedge[tmface[fid0].edge[ed0]].act==1)
		//	{
		//	}
		//	else
		//	{
		//	}
		//}
		//else if(tmface[fid0].pn[ed0][0]==3)//previous previous is XP
		//{
		//	kv[0]=kv[1];
		//}
		//else if(tmface[fid0].pn[ed0][0]==4)//previous previous is end
		//{
		//	kv[0]=0.;
		//}
	}
	else if(tmedge[edid].pn[loc0][0]==2)//previous is hex
	{
		int hxid(tmedge[edid].pn[loc0][1]), pos(0);
		for(int i=0; i<6; i++)
		{
			if(tmface[tmesh[hxid].face[i]].act==0 && tmface[tmesh[hxid].face[i]].ctpt==tmedge[edid].pt[loc0])
			{
				pos=i; break;
			}
		}
		kv[1]=tmedge[tmesh[hxid].edge[fc_ppd_ed[pos]]].len;
		int fc0(tmesh[hxid].face[fc_opst[pos]]);
		if(tmface[fc0].act==1)
		{
			if(tmface[fc0].hex.size()==2)
			{
				int hxid1(tmface[fc0].hex[0]);
				if(hxid1==hxid) hxid1=tmface[fc0].hex[1];
				int* it=find(tmesh[hxid1].face,tmesh[hxid1].face+6,fc0);
				pos=it-tmesh[hxid1].face;
				kv[0]=tmedge[tmesh[hxid1].edge[fc_ppd_ed[pos]]].len;
			}
			else if(tmface[fc0].hex.size()==1)
			{
				kv[0]=0.;
				//kv[0] = 1.;
			}
		}
		else
		{
			//next could be edge, face, hex, end
		}
	}
	else if(tmedge[edid].pn[loc0][0]==3)//previous is XP
	{
		kv[1]=kv[2]; kv[0]=kv[2];
	}
	else
	{
		kv[1]=0.; kv[0]=0.;
		//kv[1] = 1.; kv[0] = 1.;
	}
	//if(flag[1]==1)//skip
	//{
	//	kv[0]=2.*kv[0];
	//	trun_flag=1;
	//	//cout<<"trun!\n";
	//	//getchar();
	//}
}

void TruncatedTspline_3D::SetLocalCoorSystem()//not robust
{
	for(uint eid=0; eid<tmesh.size(); eid++)
	{
		vector<int>().swap(tmesh[eid].node);
		vector<Matrix4d>().swap(tmesh[eid].lcs);
		if(tmesh[eid].act==1 /*&& tmesh[eid].type!=1*/)//allow boundary and try
		{
			double ul0[3] = { tmedge[tmesh[eid].edge[0]].len, tmedge[tmesh[eid].edge[1]].len, tmedge[tmesh[eid].edge[4]].len};
			double ul1[3] = { tmedge[tmesh[eid].edge[0]].len/2., tmedge[tmesh[eid].edge[1]].len/2., tmedge[tmesh[eid].edge[4]].len/2.};
			double uvcn[8][3] = { { 0., 0., 0. }, { ul0[0], 0., 0. }, { ul0[0], ul0[1], 0. }, { 0., ul0[1], 0. }, 
			{ 0., 0., ul0[2] }, { ul0[0], 0., ul0[2] }, { ul0[0], ul0[1], ul0[2] }, { 0., ul0[1], ul0[2] } };//corner point
			double uved[12][3] = { { ul1[0], 0., 0. }, { ul0[0], ul1[1], 0. }, { ul1[0], ul0[1], 0. }, {0.,ul1[1],0.},
			{ 0., 0., ul1[2] }, { ul0[0], 0., ul1[2] }, { ul0[0], ul0[1], ul1[2] }, { 0., ul0[1], ul1[2] },
			{ ul1[0], 0., ul0[2] }, { ul0[0], ul1[1], ul0[2] }, { ul1[0], ul0[1], ul0[2] }, { 0., ul1[1], ul0[2] } };//eddge point
			double uvfc[6][3] = { { ul1[0], ul1[1], 0. }, { ul1[0], 0., ul1[2] }, { ul0[0], ul1[1], ul1[2] }, 
			{ ul1[0], ul0[1], ul1[2] }, { 0., ul1[1], ul1[2] }, { ul1[0], ul1[1], ul0[2] } };//face point
			for (int i = 0; i < 8; i++)
			{
				Matrix3d tmp1;
				Matrix4d tmp2=Matrix4d::Zero();
				Find_Neighbor_Rot(eid,tmesh[eid].cnct[i],tmp1);
				for (int j = 0; j < 3; j++)
				{
					for (int k = 0; k < 3; k++)	tmp2(j, k) = tmp1(j, k);
				}
				tmp2(0, 3) = uvcn[i][0]; tmp2(1, 3) = uvcn[i][1]; tmp2(2, 3) = uvcn[i][2]; tmp2(3, 3) = 1.;
				tmesh[eid].node.push_back(tmesh[eid].cnct[i]);
				tmesh[eid].lcs.push_back(tmp2);
			}
			for (int i = 0; i < 12; i++)
			{
				if (tmedge[tmesh[eid].edge[i]].act==0)
				{
					Matrix3d tmp1;
					Matrix4d tmp2 = Matrix4d::Zero();
					Find_Neighbor_Rot(eid, tmedge[tmesh[eid].edge[i]].midpt, tmp1);
					for (int j = 0; j < 3; j++)
					{
						for (int k = 0; k < 3; k++)	tmp2(j, k) = tmp1(j, k);
					}
					tmp2(0, 3) = uved[i][0]; tmp2(1, 3) = uved[i][1]; tmp2(2, 3) = uved[i][2]; tmp2(3, 3) = 1.;
					tmesh[eid].node.push_back(tmedge[tmesh[eid].edge[i]].midpt);
					tmesh[eid].lcs.push_back(tmp2);
				}
			}
			for (int i = 0; i < 6; i++)
			{
				if (tmface[tmesh[eid].face[i]].act == 0 && tmface[tmesh[eid].face[i]].ctpt!=-1)
				{
					Matrix3d tmp1;
					Matrix4d tmp2 = Matrix4d::Zero();
					Find_Neighbor_Rot(eid, tmface[tmesh[eid].face[i]].ctpt, tmp1);
					for (int j = 0; j < 3; j++)
					{
						for (int k = 0; k < 3; k++)	tmp2(j, k) = tmp1(j, k);
					}
					tmp2(0, 3) = uvfc[i][0]; tmp2(1, 3) = uvfc[i][1]; tmp2(2, 3) = uvfc[i][2]; tmp2(3, 3) = 1.;
					tmesh[eid].node.push_back(tmface[tmesh[eid].face[i]].ctpt);
					tmesh[eid].lcs.push_back(tmp2);
				}
			}
		}
	}
}

void TruncatedTspline_3D::Find_Neighbor_Rot(int hxid, int pid, Matrix3d& rot)
{
	if (cp[pid].rhx == hxid)//pid must be a corner point
	{
		rot = cp[pid].rot_ref;
		return;
	}
	//rhx share a face with hxid
	for (int i = 0; i < 6; i++)
	{
		if (tmface[tmesh[hxid].face[i]].act == 1 && tmface[tmesh[hxid].face[i]].type == 0)
		{
			int hxnb(tmface[tmesh[hxid].face[i]].hex[0]);
			if (hxnb == hxid) hxnb = tmface[tmesh[hxid].face[i]].hex[1];//this is wrong for boundary element
			if (hxnb == cp[pid].rhx)
			{
				rot = tmesh[hxid].nbrot[i]*cp[pid].rot_ref;
				return;
			}
		}
		else if (tmface[tmesh[hxid].face[i]].act == 0)
		{
			for (uint j = 0; j < tmface[tmesh[hxid].face[i]].chd.size(); j++)
			{
				int fcid(tmface[tmesh[hxid].face[i]].chd[j]);
				int hxnb(tmface[fcid].hex[0]);
				if (hxnb == hxid) hxnb = tmface[fcid].hex[1];
				if (hxnb == cp[pid].rhx)
				{
					rot = tmesh[hxid].nbrot[i] * cp[pid].rot_ref;
					return;
				}
			}
		}
	}
	//rhx does not share face with hxid, find intermediate hex first
	vector<int> remain;
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		if (cp[pid].hex[i] != hxid) remain.push_back(cp[pid].hex[i]);
	}
	int found(0);
	int cur(hxid), next, fc_loc;
	Matrix3d tmp = Matrix3d::Identity();
	Matrix3d tmp1;
	while (remain.size()!=0 && found==0)
	{
		next = -1; fc_loc = 0;
		for (int i = 0; i < 6; i++)
		{
			if (tmface[tmesh[cur].face[i]].type==0)//non-boundary
			{
				if (tmface[tmesh[cur].face[i]].act == 1)
				{
					int nb(tmface[tmesh[cur].face[i]].hex[0]);
					if (nb == cur) nb = tmface[tmesh[cur].face[i]].hex[1];
					vector<int>::iterator it = find(remain.begin(), remain.end(), nb);
					if (it != remain.end())
					{
						next = nb; fc_loc = i;
					}
				}
				else
				{
					for (uint j = 0; j < tmface[tmesh[cur].face[i]].chd.size(); j++)
					{
						int fcid(tmface[tmesh[cur].face[i]].chd[j]);
						int nb(tmface[fcid].hex[0]);
						if (nb == cur) nb = tmface[fcid].hex[1];
						vector<int>::iterator it = find(remain.begin(), remain.end(), nb);
						if (it != remain.end())
						{
							next = nb; fc_loc = i; break;
						}
					}
				}
				if (next != -1) break;
			}
		}
		tmp1 = tmp*tmesh[cur].nbrot[fc_loc];
		tmp = tmp1;
		if (next == cp[pid].rhx)
		{
			found = 1; break;
		}
		vector<int> rtmp(remain);
		remain.clear();
		for (uint i = 0; i < rtmp.size(); i++)
		{
			if (rtmp[i] != cur) remain.push_back(rtmp[i]);
		}
		cur = next;
	}
	rot = tmp*cp[pid].rot_ref;//
	if (found == 0)
	{
		cout << "Neighbor not found!\n";
		getchar();
	}
}

void TruncatedTspline_3D::getElementRotate_Unit(int loc, Matrix3d& rot)
{
	if (loc == 0) rot << 1, 0, 0, 0, 1, 0, 0, 0, 1;
	else if (loc == 1) rot << 0, -1, 0, 1, 0, 0, 0, 0, 1;
	else if (loc == 2) rot << -1, 0, 0, 0, -1, 0, 0, 0, 1;
	else if (loc == 3) rot << 0, 1, 0, -1, 0, 0, 0, 0, 1;
	else if (loc == 4) rot << 0, 1, 0, 1, 0, 0, 0, 0, -1;
	else if (loc == 5) rot << -1, 0, 0, 0, 1, 0, 0, 0, -1;
	else if (loc == 6) rot << 0, -1, 0, -1, 0, 0, 0, 0, -1;
	else rot << 1, 0, 0, 0, -1, 0, 0, 0, -1;
}

//void TruncatedTspline_3D::FindIEN_Unstruct()//IEN, not IENtmp
//{
//	for(uint eid=0; eid<tmesh.size(); eid++)
//	{
//		tmesh[eid].IEN.clear();
//		tmesh[eid].patch_ku.clear();
//		tmesh[eid].patch_kv.clear();
//		tmesh[eid].patch_kw.clear();
//		if(tmesh[eid].act==1 && tmesh[eid].type==0)//find two ring neighorhood
//		{
//			array<double,2> urang={0.,tmedge[tmesh[eid].edge[0]].len};
//			array<double,2> vrang={0.,tmedge[tmesh[eid].edge[3]].len};
//			array<double,2> wrang={0.,tmedge[tmesh[eid].edge[4]].len};
//			int count(0);
//			//initial
//			vector<int> pr0(tmesh[eid].node),er0(1,eid),pr1,er1,pr1_pref,pr1_eref;
//			vector<int> rot_ref(tmesh[eid].node.size());
//			vector<array<double,2>> uv_ref(tmesh[eid].node.size());
//			for(uint i=0; i<tmesh[eid].node.size(); i++)
//			{
//				rot_ref[i]=tmesh[eid].lcs[i].rot;
//				uv_ref[i][0]=tmesh[eid].lcs[i].u[0];
//				uv_ref[i][1]=tmesh[eid].lcs[i].u[1];
//			}
//			for(uint i=0; i<tmesh[eid].node.size(); i++)
//			{
//				array<double,5> kui,kvi;
//				FindLocalKnotVector(tmesh[eid].node[i],rot_ref[i],uv_ref[i],kui,kvi);
//				if(CheckSupport(urang,vrang,kui,kvi))
//				{
//					tmesh[eid].IEN.push_back(tmesh[eid].node[i]);
//					tmesh[eid].patch_ku.push_back(kui);
//					tmesh[eid].patch_kv.push_back(kvi);
//				}
//			}
//			while(count<2)
//			{
//				FindNextRing(pr0,er0,pr1,er1,pr1_pref,pr1_eref);
//				vector<int> rot_tmp(pr1.size());
//				vector<array<double,2>> uv_tmp(pr1.size());
//				for(uint i=0; i<pr1.size(); i++)
//				{
//					array<double,5> kui,kvi;
//					FindRotateAndUVCoor(pr0[pr1_pref[i]],rot_ref[pr1_pref[i]],uv_ref[pr1_pref[i]],pr1_eref[i],pr1[i],rot_tmp[i],uv_tmp[i]);
//					FindLocalKnotVector(pr1[i],rot_tmp[i],uv_tmp[i],kui,kvi);
//					if(CheckSupport(urang,vrang,kui,kvi))
//					{
//						tmesh[eid].IEN.push_back(pr1[i]);
//						tmesh[eid].patch_ku.push_back(kui);
//						tmesh[eid].patch_kv.push_back(kvi);
//					}
//				}
//				pr0.clear();
//				er0.clear();
//				rot_ref.clear();
//				uv_ref.clear();
//				pr0=pr1;
//				er0=er1;
//				rot_ref=rot_tmp;
//				uv_ref=uv_tmp;
//				count++;
//			}
//		}
//		else if(tmesh[eid].act==1 && tmesh[eid].type==4)
//		{
//			tmesh[eid].IEN.push_back(tmesh[eid].cnct[0]);
//			int fc_pre(tmedge[tmesh[eid].edge[3]].face[0]);
//			if(fc_pre==eid) fc_pre=tmedge[tmesh[eid].edge[3]].face[1];
//			tmesh[eid].IEN.push_back(tmesh[fc_pre].cnct[3]);
//			tmesh[eid].IEN.push_back(tmesh[fc_pre].cnct[2]);
//			tmesh[eid].IEN.push_back(tmesh[eid].cnct[3]);
//			tmesh[eid].IEN.push_back(tmesh[eid].cnct[2]);
//			int fc_next(tmedge[tmesh[eid].edge[0]].face[0]);
//			if(fc_next==eid) fc_next=tmedge[tmesh[eid].edge[0]].face[1];
//			int fc_next0=fc_next;
//			while(fc_next!=fc_pre)
//			{
//				tmesh[eid].IEN.push_back(tmesh[fc_next].cnct[3]);
//				tmesh[eid].IEN.push_back(tmesh[fc_next].cnct[2]);
//				int fc_nn(tmedge[tmesh[fc_next].edge[0]].face[0]);
//				if(fc_nn==fc_next) fc_nn=tmedge[tmesh[fc_next].edge[0]].face[1];
//				fc_next=fc_nn;
//			}
//			for(int j=1; j<4; j++)
//			{
//				for(uint k=0; k<cp[tmesh[eid].cnct[j]].face.size(); k++)
//				{
//					int fcid(cp[tmesh[eid].cnct[j]].face[k]);
//					if(fcid!=eid && fcid!=fc_pre && fcid!=fc_next0)
//					{
//						for(uint k1=0; k1<tmesh[fcid].node.size(); k1++)
//						{
//							vector<int>::iterator it=find(tmesh[eid].IEN.begin(),tmesh[eid].IEN.end(),tmesh[fcid].node[k1]);
//							if(it==tmesh[eid].IEN.end())
//							{
//								array<double,2> uv_ref={tmesh[eid].lcs[j].u[0],tmesh[eid].lcs[j].u[1]},uv;
//								int rot;
//								array<double,5> kui, kvi;
//								FindRotateAndUVCoor(tmesh[eid].cnct[j],tmesh[eid].lcs[j].rot,uv_ref,fcid,tmesh[fcid].node[k1],rot,uv);
//								FindLocalKnotVector(tmesh[fcid].node[k1],rot,uv,kui,kvi);
//								tmesh[eid].IEN.push_back(tmesh[fcid].node[k1]);
//								tmesh[eid].patch_ku.push_back(kui);
//								tmesh[eid].patch_kv.push_back(kvi);
//							}
//						}
//					}
//				}
//			}
//		}
//	}
//}

void TruncatedTspline_3D::FindIEN_PatchKV()
{
	for(uint eid=0; eid<tmesh.size(); eid++)
	{
		vector<int>().swap(tmesh[eid].IENtmp);
		vector<array<double, 5>>().swap(tmesh[eid].patch_kutmp);
		vector<array<double, 5>>().swap(tmesh[eid].patch_kvtmp);
		vector<array<double, 5>>().swap(tmesh[eid].patch_kwtmp);
		if (tmesh[eid].act == 1 && (tmesh[eid].type == 0))//not for boundary, find two ring neighorhood
		{
			array<double,2> urang={0.,tmedge[tmesh[eid].edge[0]].len};
			array<double,2> vrang={0.,tmedge[tmesh[eid].edge[3]].len};
			array<double, 2> wrang = { 0., tmedge[tmesh[eid].edge[4]].len };
			int count(0);
			//initial
			vector<int> pr0(tmesh[eid].node),er0(1,eid),pr1,er1,pr1_pref,pr1_eref;
			vector<Matrix4d> lcs0(tmesh[eid].lcs);
			for(uint i=0; i<pr0.size(); i++)
			{
				array<double,5> kui,kvi,kwi;
				FindLocalKnotVector(pr0[i], lcs0[i], kui, kvi, kwi);
				//cout <<"element id: "<< eid << "\n";
				////cout << lcs0[i] << "\n";
				//cout << pr0[i] << "\n";
				//cout << "referent element: " << cp[pr0[i]].rhx << "\n";
				//cout << "after\n";
				//cout << kui[0] << " " << kui[1] << " " << kui[2] << " " << kui[3] << " " << kui[4] << "\n";
				//cout << kvi[0] << " " << kvi[1] << " " << kvi[2] << " " << kvi[3] << " " << kvi[4] << "\n";
				//cout << kwi[0] << " " << kwi[1] << " " << kwi[2] << " " << kwi[3] << " " << kwi[4] << "\n";
				//getchar();
				if(CheckSupport(urang,vrang,wrang,kui,kvi,kwi))
				{
					//if(tmesh[eid].node[i]>=npt_old) tmesh[eid].aff=1;
					tmesh[eid].IENtmp.push_back(tmesh[eid].node[i]);
					tmesh[eid].patch_kutmp.push_back(kui);
					tmesh[eid].patch_kvtmp.push_back(kvi);
					tmesh[eid].patch_kwtmp.push_back(kwi);
				}
			}
			while(count<1)
			{
				FindNextRing(pr0,er0,pr1,er1,pr1_pref,pr1_eref);
				vector<Matrix4d> lcs1(pr1.size());
				//cout <<"pr1 size: "<< pr1.size()<<"\n";
				//cout << "er1 size: " << er1.size() << "\n";
				//getchar();
				for(uint i=0; i<pr1.size(); i++)
				{
					array<double,5> kui,kvi,kwi;
					TranslateLCS(pr0[pr1_pref[i]], lcs0[pr1_pref[i]], pr1_eref[i], pr1[i], lcs1[i]);
					FindLocalKnotVector(pr1[i],lcs1[i],kui,kvi,kwi);
					//cout << pr1[i] << "\n";
					//cout << "ref eid: "<<cp[pr1[i]].rhx<<"\n";
					//cout << "lcs1:\n";
					//cout << lcs1[i] << "\n\n";
					//cout << kui[0] << " " << kui[1] << " " << kui[2] << " " << kui[3] << " " << kui[4] << "\n";
					//cout << kvi[0] << " " << kvi[1] << " " << kvi[2] << " " << kvi[3] << " " << kvi[4] << "\n";
					//cout << kwi[0] << " " << kwi[1] << " " << kwi[2] << " " << kwi[3] << " " << kwi[4] << "\n";
					//getchar();
					if (CheckSupport(urang, vrang, wrang,kui, kvi,kwi))
					{
						//if(pr1[i]>=npt_old) tmesh[eid].aff=1;
						tmesh[eid].IENtmp.push_back(pr1[i]);
						tmesh[eid].patch_kutmp.push_back(kui);
						tmesh[eid].patch_kvtmp.push_back(kvi);
						tmesh[eid].patch_kwtmp.push_back(kwi);
					}
				}
				pr0.clear();
				er0.clear();
				vector<Matrix4d>().swap(lcs0);
				pr0=pr1;
				er0=er1;
				lcs0 = lcs1;
				vector<Matrix4d>().swap(lcs1);
				count++;
			}
		}
		else if (tmesh[eid].act == 1 && tmesh[eid].type == 2)//irregular element with extraordinary points
		{
			SetBezierMatIrrPatch(eid);
		}
		//else if (tmesh[eid].act == 1 && tmesh[eid].type == 1)//boundart element
		//{
		//	//will later be updated by ConstructBezier_Boundary
		//}
	}
}

void TruncatedTspline_3D::FindNextRing(const vector<int>& pr0, const vector<int>& er0, vector<int>& pr1, vector<int>& er1, vector<int>& pr1_pref, vector<int>& pr1_eref)
{
	pr1.clear();//next ring point
	er1.clear();//next ring hex
	pr1_pref.clear();//store certain local index of pr0
	pr1_eref.clear();//store the first neighbor hex containing pr1_pref
	for(uint i=0; i<pr0.size(); i++)
	{
		if (cp[pr0[i]].type != 3 && cp[pr0[i]].type != 13)
		{
			for(uint j=0; j<cp[pr0[i]].hex.size(); j++)
			{
				int hxid(cp[pr0[i]].hex[j]);
				vector<int>::const_iterator it1=find(er0.begin(),er0.end(),hxid);
				vector<int>::iterator it4 = find(er1.begin(), er1.end(), hxid);
				if (it1 == er0.end() && it4 == er1.end())
				{
					er1.push_back(hxid);
					//cout << tmesh[hxid].node.size() << "\n"; getchar();
					for(uint k=0; k<tmesh[hxid].node.size(); k++)
					{
						vector<int>::const_iterator it2=find(pr0.begin(),pr0.end(),tmesh[hxid].node[k]);
						vector<int>::iterator it3=find(pr1.begin(),pr1.end(),tmesh[hxid].node[k]);
						if(it2==pr0.end() && it3==pr1.end())
						{
							//cout << "here\n"; getchar();
							pr1.push_back(tmesh[hxid].node[k]);
							pr1_pref.push_back(i);
							pr1_eref.push_back(hxid);
						}
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::TranslateLCS(int pref, Matrix4d& lcs_ref, int eid, int pid, Matrix4d& lcs)
{
	vector<int>::iterator it0=find(tmesh[eid].node.begin(),tmesh[eid].node.end(),pref);
	vector<int>::iterator it1=find(tmesh[eid].node.begin(),tmesh[eid].node.end(),pid);
	int loc0=it0-tmesh[eid].node.begin();
	int loc1=it1-tmesh[eid].node.begin();
	//find inverse of pref local eid
	Matrix4d ref_inv,mat1;
	getLCS_inverse(tmesh[eid].lcs[loc0],ref_inv);
	mat1 = ref_inv*tmesh[eid].lcs[loc1];
	lcs = lcs_ref*mat1;
}

void TruncatedTspline_3D::getLCS_inverse(const Matrix4d& mat_in, Matrix4d& mat_out)
{
	mat_out = mat_in.transpose();
	mat_out(0, 3) = -mat_in(0, 0)*mat_in(0, 3) - mat_in(1, 0)*mat_in(1, 3) - mat_in(2, 0)*mat_in(2, 3);
	mat_out(1, 3) = -mat_in(0, 1)*mat_in(0, 3) - mat_in(1, 1)*mat_in(1, 3) - mat_in(2, 1)*mat_in(2, 3);
	mat_out(2, 3) = -mat_in(0, 2)*mat_in(0, 3) - mat_in(1, 2)*mat_in(1, 3) - mat_in(2, 2)*mat_in(2, 3);
	mat_out(3, 0) = 0.; mat_out(3, 1) = 0.; mat_out(3, 2) = 0.;
}

void TruncatedTspline_3D::FindLocalKnotVector(int pid, const Matrix4d& lcs, array<double, 5>& ku, array<double, 5>& kv, array<double, 5>& kw)
{
	//array<double, 5> kutmp = { -cp[pid].kitvU[0] - cp[pid].kitvU[1], -cp[pid].kitvU[1], 0., cp[pid].kitvU[2], cp[pid].kitvU[2] + cp[pid].kitvU[3] };
	//array<double, 5> kvtmp = { -cp[pid].kitvV[0] - cp[pid].kitvV[1], -cp[pid].kitvV[1], 0., cp[pid].kitvV[2], cp[pid].kitvV[2] + cp[pid].kitvV[3] };
	//array<double, 5> kwtmp = { -cp[pid].kitvW[0] - cp[pid].kitvW[1], -cp[pid].kitvW[1], 0., cp[pid].kitvW[2], cp[pid].kitvW[2] + cp[pid].kitvW[3] };
	//cout << "before\n";
	//cout << kutmp[0] << " " << kutmp[1] << " " << kutmp[2] << " " << kutmp[3] << " " << kutmp[4] << "\n";
	//cout << kvtmp[0] << " " << kvtmp[1] << " " << kvtmp[2] << " " << kvtmp[3] << " " << kvtmp[4] << "\n";
	//cout << kwtmp[0] << " " << kwtmp[1] << " " << kwtmp[2] << " " << kwtmp[3] << " " << kwtmp[4] << "\n";
	//for (int i = 0; i < 5; i++)
	//{
	//	Vector4d tmp1(kutmp[i], kvtmp[i], kwtmp[i], 1.);
	//	Vector4d tmp2 = lcs*tmp1;
	//	ku[i] = tmp2(0); kv[i] = tmp2(1); kw[i] = tmp2(2);
	//}
	double kvit_pos[3][2] = { { cp[pid].kitvU[2], cp[pid].kitvU[2] + cp[pid].kitvU[3] }, { cp[pid].kitvV[2], cp[pid].kitvV[2] + cp[pid].kitvV[3] }, 
	{ cp[pid].kitvW[2], cp[pid].kitvW[2] + cp[pid].kitvW[3] } };
	double kvit_neg[3][2] = { { cp[pid].kitvU[1], cp[pid].kitvU[0] + cp[pid].kitvU[1] }, { cp[pid].kitvV[1], cp[pid].kitvV[0] + cp[pid].kitvV[1] },
	{ cp[pid].kitvW[1], cp[pid].kitvW[0] + cp[pid].kitvW[1] } };
	vector<Vector3d> v0(3);//local
	vector<Vector3d> v1(3);//global, correspond to ku, kv, kw
	v0[0] << lcs(0, 0), lcs(1, 0), lcs(2, 0);
	v0[1] << lcs(0, 1), lcs(1, 1), lcs(2, 1);
	v0[2] << lcs(0, 2), lcs(1, 2), lcs(2, 2);
	v1[0] << 1, 0, 0;
	v1[1] << 0, 1, 0;
	v1[2] << 0, 0, 1;
	int j;
	for (j = 0; j < 3; j++)
	{
		if (v1[0].dot(v0[j]) == 1.)
		{
			ku[0] = lcs(0, 3) - kvit_neg[j][1];
			ku[1] = lcs(0, 3) - kvit_neg[j][0];
			ku[2] = lcs(0, 3);
			ku[3] = lcs(0, 3) + kvit_pos[j][0];
			ku[4] = lcs(0, 3) + kvit_pos[j][1];
		}
		else if (v1[0].dot(v0[j]) == -1.)
		{
			ku[0] = lcs(0, 3) - kvit_pos[j][1];
			ku[1] = lcs(0, 3) - kvit_pos[j][0];
			ku[2] = lcs(0, 3);
			ku[3] = lcs(0, 3) + kvit_neg[j][0];
			ku[4] = lcs(0, 3) + kvit_neg[j][1];
		}
	}
	for (j = 0; j < 3; j++)
	{
		if (v1[1].dot(v0[j]) == 1.)
		{
			kv[0] = lcs(1, 3) - kvit_neg[j][1];
			kv[1] = lcs(1, 3) - kvit_neg[j][0];
			kv[2] = lcs(1, 3);
			kv[3] = lcs(1, 3) + kvit_pos[j][0];
			kv[4] = lcs(1, 3) + kvit_pos[j][1];
		}
		else if (v1[1].dot(v0[j]) == -1.)
		{
			kv[0] = lcs(1, 3) - kvit_pos[j][1];
			kv[1] = lcs(1, 3) - kvit_pos[j][0];
			kv[2] = lcs(1, 3);
			kv[3] = lcs(1, 3) + kvit_neg[j][0];
			kv[4] = lcs(1, 3) + kvit_neg[j][1];
		}
	}
	for (j = 0; j < 3; j++)
	{
		if (v1[2].dot(v0[j]) == 1.)
		{
			kw[0] = lcs(2, 3) - kvit_neg[j][1];
			kw[1] = lcs(2, 3) - kvit_neg[j][0];
			kw[2] = lcs(2, 3);
			kw[3] = lcs(2, 3) + kvit_pos[j][0];
			kw[4] = lcs(2, 3) + kvit_pos[j][1];
		}
		else if (v1[2].dot(v0[j]) == -1.)
		{
			kw[0] = lcs(2, 3) - kvit_pos[j][1];
			kw[1] = lcs(2, 3) - kvit_pos[j][0];
			kw[2] = lcs(2, 3);
			kw[3] = lcs(2, 3) + kvit_neg[j][0];
			kw[4] = lcs(2, 3) + kvit_neg[j][1];
		}
	}


	//for (int i = 0; i < 5; i++)
	//{
	//	Vector4d tmp1(kutmp[i],0.,0.,1.);
	//	Vector4d tmp2 = lcs*tmp1;
	//	ku[i] = tmp2(0);
	//}
	//for (int i = 0; i < 5; i++)
	//{
	//	Vector4d tmp1(0., kvtmp[i], 0., 1.);
	//	Vector4d tmp2 = lcs*tmp1;
	//	kv[i] = tmp2(1);
	//}
	//for (int i = 0; i < 5; i++)
	//{
	//	Vector4d tmp1(0., 0., kwtmp[i], 1.);
	//	Vector4d tmp2 = lcs*tmp1;
	//	kw[i] = tmp2(2);
	//}
}

bool TruncatedTspline_3D::CheckSupport(const array<double, 2>& u, const array<double, 2>& v, const array<double, 2>& w, const array<double, 5>& ku, const array<double, 5>& kv, const array<double, 5>& kw)
{
	if (ku[0]<u[1] && ku[4]>u[0] && kv[0]<v[1] && kv[4]>v[0] && kw[0]<w[1] && kw[4]>w[0])
	{
		return true;
	}
	else
	{
		return false;
	}
}

void TruncatedTspline_3D::Update_IEN()
{
	for (uint eid = 0; eid<tmesh.size(); eid++)
	{
		vector<int>().swap(tmesh[eid].IEN);
		vector<array<double, 5>>().swap(tmesh[eid].patch_ku);
		vector<array<double, 5>>().swap(tmesh[eid].patch_kv);
		vector<array<double, 5>>().swap(tmesh[eid].patch_kw);
		tmesh[eid].IEN = tmesh[eid].IENtmp;
		tmesh[eid].patch_ku = tmesh[eid].patch_kutmp;
		tmesh[eid].patch_kv = tmesh[eid].patch_kvtmp;
		tmesh[eid].patch_kw = tmesh[eid].patch_kwtmp;
		vector<int>().swap(tmesh[eid].IENtmp);
		vector<array<double, 5>>().swap(tmesh[eid].patch_kutmp);
		vector<array<double, 5>>().swap(tmesh[eid].patch_kvtmp);
		vector<array<double, 5>>().swap(tmesh[eid].patch_kwtmp);
		//if (tmesh[eid].type == 0)
		//{
		//	cout << "element id: " << eid << "\n";
		//	cout << "#IEN: " << tmesh[eid].IEN.size() << "\n";
		//	cout << "#patch_ku: " << tmesh[eid].patch_ku.size() << "\n";
		//	cout << "#patch_kv: " << tmesh[eid].patch_kv.size() << "\n";
		//	cout << "#patch_kw: " << tmesh[eid].patch_kw.size() << "\n";
		//	//for (uint i = 0; i < tmesh[eid].IEN.size(); i++)
		//	//{
		//	//	cout << "point id: " << tmesh[eid].IEN[i] << "\n";
		//	//	for (uint j = 0; j < tmesh[eid].patch_ku[i].size(); j++)
		//	//	{
		//	//		cout << tmesh[eid].patch_ku[i][j] << " ";
		//	//	}
		//	//	cout << "\n\n";
		//	//}
		//	getchar();
		//}
	}
}

//void TruncatedTspline_3D::UpdatePatchCP_Unstruct(int eid)
//{
//	vector<int> IEN_new_all;
//	vector<array<double,5>> KU_new_all;
//	vector<array<double,5>> KV_new_all;
//	for(uint i=0; i<tmesh[eid].chd.size(); i++)
//	{
//		int cid(tmesh[eid].chd[i]);
//		for(uint j=0; j<tmesh[cid].IENtmp.size(); j++)
//		{
//			vector<int>::iterator it=find(IEN_new_all.begin(),IEN_new_all.end(),tmesh[cid].IENtmp[j]);
//			if(it==IEN_new_all.end())
//			{
//				IEN_new_all.push_back(tmesh[cid].IENtmp[j]);
//				array<double,5> kutmp,kvtmp;
//				for(int k=0; k<5; k++)
//				{
//					kutmp[k]=tmesh[cid].patch_kutmp[j][k]+tmesh[eid].chd_o[i][0];
//					kvtmp[k]=tmesh[cid].patch_kvtmp[j][k]+tmesh[eid].chd_o[i][1];
//				}
//				KU_new_all.push_back(kutmp);
//				KV_new_all.push_back(kvtmp);
//			}
//		}
//	}
//
//	vector<int> IEN_old(tmesh[eid].IEN);
//	vector<vector<double>> cmat(IEN_new_all.size(),vector<double>(IEN_old.size(),0.));
//	//vector<vector<double>> tmat(IEN_new_all.size(),vector<double>(IEN_old.size(),0.));
//	for(uint i=0; i<IEN_old.size(); i++)
//	{
//		vector<int>::iterator it=find(IEN_new_all.begin(),IEN_new_all.end(),IEN_old[i]);
//		if(it!=IEN_new_all.end())
//		{
//			int loc(it-IEN_new_all.begin());
//			if(tmesh[eid].patch_ku[i]!=KU_new_all[loc] || tmesh[eid].patch_kv[i]!=KV_new_all[loc])
//			{
//				cp[IEN_old[i]].aff=1;
//			}
//			else
//			{
//				cmat[loc][i]=1.;
//			}
//		}
//	}
//
//	for(uint i=0; i<IEN_new_all.size(); i++)
//	{
//		for(uint j=0; j<IEN_old.size(); j++)
//		{
//			if(CheckSubKnotVector(KU_new_all[i],KV_new_all[i],tmesh[eid].patch_ku[j],tmesh[eid].patch_kv[j]))
//			{
//				vector<double> ku1(10),kv1(10);
//				vector<vector<double>> Tu,Tv;
//				vector<double> ku(tmesh[eid].patch_ku[j].begin(),tmesh[eid].patch_ku[j].end());
//				vector<double> kv(tmesh[eid].patch_kv[j].begin(),tmesh[eid].patch_kv[j].end());
//				vector<double>::iterator it1,it2;
//				it1=set_union(tmesh[eid].patch_ku[j].begin(),tmesh[eid].patch_ku[j].end(),KU_new_all[i].begin(),KU_new_all[i].end(),ku1.begin());
//				it2=set_union(tmesh[eid].patch_kv[j].begin(),tmesh[eid].patch_kv[j].end(),KV_new_all[i].begin(),KV_new_all[i].end(),kv1.begin());
//				ku1.resize(it1-ku1.begin());
//				kv1.resize(it2-kv1.begin());
//				TMatrix(ku,ku1,3,Tu);
//				TMatrix(kv,kv1,3,Tv);
//				it1=search(ku1.begin(),ku1.end(),KU_new_all[i].begin(),KU_new_all[i].end());
//				it2=search(kv1.begin(),kv1.end(),KV_new_all[i].begin(),KV_new_all[i].end());
//				if(it1!=ku1.end() && it2!=kv1.end())
//				{
//					int loc1=it1-ku1.begin();
//					int loc2=it2-kv1.begin();
//					cmat[i][j]=Tu[loc1][0]*Tv[loc2][0];
//				}
//			}
//		}
//	}
//	for(uint i=0; i<IEN_new_all.size(); i++)
//	{
//		//cp[IEN_new_all[i]].coortmp[0]=0.; cp[IEN_new_all[i]].coortmp[1]=0.; cp[IEN_new_all[i]].coortmp[2]=0.;
//		if(cp[IEN_new_all[i]].update==0)
//		{
//			for(uint j=0; j<IEN_old.size(); j++)
//			{
//				if(cmat[i][j]!=0.)
//				{
//					cp[IEN_new_all[i]].coortmp[0]+=cmat[i][j]*cp[IEN_old[j]].coor[0];
//					cp[IEN_new_all[i]].coortmp[1]+=cmat[i][j]*cp[IEN_old[j]].coor[1];
//					cp[IEN_new_all[i]].coortmp[2]+=cmat[i][j]*cp[IEN_old[j]].coor[2];
//				}
//			}
//			cp[IEN_new_all[i]].update=1;
//		}
//	}
//	//check truncation
//	/*double sp0[4][2]={{0.,0.},{tmedge[tmesh[eid].edge[0]].len,0.},{tmedge[tmesh[eid].edge[0]].len,tmedge[tmesh[eid].edge[1]].len},{0.,tmedge[tmesh[eid].edge[1]].len}};
//	vector<array<double,2>> spt(9);
//	for(int i=0; i<4; i++)
//	{
//		spt[i][0]=sp0[i][0]; spt[i][1]=sp0[i][1];
//		spt[i+4][0]=(sp0[i][0]+sp0[(i+1)%4][0])/2.; spt[i+4][1]=(sp0[i][1]+sp0[(i+1)%4][1])/2.; 
//	}
//	spt[8][0]=spt[4][0]; spt[8][1]=spt[5][1];
//	for(uint i=0; i<IEN_old.size(); i++)
//	{
//		vector<double> coef;
//		for(uint j=0; j<IEN_new_all.size(); j++)
//		{
//			coef.push_back(cmat[j][i]);
//		}
//		if(!CheckFullChildren_1(spt,tmesh[eid].patch_ku[i],tmesh[eid].patch_kv[i],KU_new_all,KV_new_all,coef))
//		{
//			cp[IEN_old[i]].truntmp=1;
//			for(uint j=0; j<IEN_new_all.size(); j++)
//			{
//				if(cmat[j][i]!=0. && IEN_old[i]!=IEN_new_all[j])
//				{
//					vector<int>::iterator it=find(cp[IEN_old[i]].tbftmp.begin(),cp[IEN_old[i]].tbftmp.end(),IEN_new_all[j]);
//					if(it==cp[IEN_old[i]].tbftmp.end())
//					{
//						cp[IEN_old[i]].tbftmp.push_back(IEN_new_all[j]);
//						cp[IEN_old[i]].tctmp.push_back(cmat[j][i]);
//					}
//				}
//			}
//		}
//	}*/
//}

//void TruncatedTspline_3D::Truncation()
//{
//	for(uint eid=0; eid<tmesh.size(); eid++)
//	{
//		if(tmesh[eid].act==1 && (tmesh[eid].type==0 || tmesh[eid].type==1))
//		{
//			for(uint i=0; i<tmesh[eid].IEN.size(); i++)
//			{
//				for(uint j=i+1; j<tmesh[eid].IEN.size(); j++)
//				{
//					if(CheckSubKnotVector(tmesh[eid].patch_ku[j],tmesh[eid].patch_kv[j],tmesh[eid].patch_ku[i],tmesh[eid].patch_kv[i]))//i to be truncated, j to be discarded children
//					{
//						int Bt(tmesh[eid].IEN[i]), Bc(tmesh[eid].IEN[j]);
//						vector<int>::iterator it=find(cp[Bt].tbf.begin(),cp[Bt].tbf.end(),Bc);
//						if(it==cp[Bt].tbf.end())
//						{
//							vector<double> ku1(10),kv1(10);
//							vector<vector<double>> Tu,Tv;
//							vector<double> ku(tmesh[eid].patch_ku[i].begin(),tmesh[eid].patch_ku[i].end());
//							vector<double> kv(tmesh[eid].patch_kv[i].begin(),tmesh[eid].patch_kv[i].end());
//							vector<double>::iterator it1,it2;
//							it1=set_union(tmesh[eid].patch_ku[i].begin(),tmesh[eid].patch_ku[i].end(),tmesh[eid].patch_ku[j].begin(),tmesh[eid].patch_ku[j].end(),ku1.begin());
//							it2=set_union(tmesh[eid].patch_kv[i].begin(),tmesh[eid].patch_kv[i].end(),tmesh[eid].patch_kv[j].begin(),tmesh[eid].patch_kv[j].end(),kv1.begin());
//							ku1.resize(it1-ku1.begin());
//							kv1.resize(it2-kv1.begin());
//							TMatrix(ku,ku1,3,Tu);
//							TMatrix(kv,kv1,3,Tv);
//							it1=search(ku1.begin(),ku1.end(),tmesh[eid].patch_ku[j].begin(),tmesh[eid].patch_ku[j].end());
//							it2=search(kv1.begin(),kv1.end(),tmesh[eid].patch_kv[j].begin(),tmesh[eid].patch_kv[j].end());
//							if(it1!=ku1.end() && it2!=kv1.end())
//							{
//								int loc1=it1-ku1.begin();
//								int loc2=it2-kv1.begin();
//								cp[Bt].trun=1;
//								cp[Bt].tbf.push_back(Bc);
//								cp[Bt].tc.push_back(Tu[loc1][0]*Tv[loc2][0]);
//							}
//						}
//					}
//					else if(CheckSubKnotVector(tmesh[eid].patch_ku[i],tmesh[eid].patch_kv[i],tmesh[eid].patch_ku[j],tmesh[eid].patch_kv[j]))//j to be truncated, i to be discarded children
//					{
//						int Bt(tmesh[eid].IEN[j]), Bc(tmesh[eid].IEN[i]);
//						vector<int>::iterator it=find(cp[Bt].tbf.begin(),cp[Bt].tbf.end(),Bc);
//						if(it==cp[Bt].tbf.end())
//						{
//							vector<double> ku1(10),kv1(10);
//							vector<vector<double>> Tu,Tv;
//							vector<double> ku(tmesh[eid].patch_ku[j].begin(),tmesh[eid].patch_ku[j].end());
//							vector<double> kv(tmesh[eid].patch_kv[j].begin(),tmesh[eid].patch_kv[j].end());
//							vector<double>::iterator it1,it2;
//							it1=set_union(tmesh[eid].patch_ku[j].begin(),tmesh[eid].patch_ku[j].end(),tmesh[eid].patch_ku[i].begin(),tmesh[eid].patch_ku[i].end(),ku1.begin());
//							it2=set_union(tmesh[eid].patch_kv[j].begin(),tmesh[eid].patch_kv[j].end(),tmesh[eid].patch_kv[i].begin(),tmesh[eid].patch_kv[i].end(),kv1.begin());
//							ku1.resize(it1-ku1.begin());
//							kv1.resize(it2-kv1.begin());
//							TMatrix(ku,ku1,3,Tu);
//							TMatrix(kv,kv1,3,Tv);
//							it1=search(ku1.begin(),ku1.end(),tmesh[eid].patch_ku[i].begin(),tmesh[eid].patch_ku[i].end());
//							it2=search(kv1.begin(),kv1.end(),tmesh[eid].patch_kv[i].begin(),tmesh[eid].patch_kv[i].end());
//							if(it1!=ku1.end() && it2!=kv1.end())
//							{
//								int loc1=it1-ku1.begin();
//								int loc2=it2-kv1.begin();
//								cp[Bt].trun=1;
//								cp[Bt].tbf.push_back(Bc);
//								cp[Bt].tc.push_back(Tu[loc1][0]*Tv[loc2][0]);
//							}
//						}
//					}
//				}
//			}
//		}
//	}
//}
//
//void TruncatedTspline_3D::ElementBasis(int eid, double u, double v, vector<double>& Nt, vector<array<double,2>>& dNdt)
//{
//	if(tmesh[eid].act==1)
//	{
//		if(tmesh[eid].type==0 || tmesh[eid].type==1)
//		{
//			ElementBasis_Regular(eid,u,v,Nt,dNdt);
//		}
//		else if(tmesh[eid].type==4)
//		{
//			ElementBasis_Irregular(eid,u,v,Nt,dNdt);
//		}
//	}
//}
//
//void TruncatedTspline_3D::ElementBasis_Regular(int eid, double u, double v, vector<double>& Nt, vector<array<double,2>>& dNdt)
//{
//	Nt.clear();
//	dNdt.clear();
//	Nt.resize(tmesh[eid].IEN.size());
//	dNdt.resize(tmesh[eid].IEN.size());
//	vector<double> Nt0(tmesh[eid].IEN.size());
//	vector<array<double,2>> dNdt0(tmesh[eid].IEN.size());
//	vector<double> ku(5,0.),kv(5,0.),uval,vval;
//	BSplineBasis bu,bv;
//	for(uint i=0;i<tmesh[eid].IEN.size();i++)
//	{
//		ku.assign(tmesh[eid].patch_ku[i].begin(),tmesh[eid].patch_ku[i].end());
//		kv.assign(tmesh[eid].patch_kv[i].begin(),tmesh[eid].patch_kv[i].end());
//		bu.Set(3,ku);
//		bv.Set(3,kv);
//		bu.BasisFunction(0,u,1,uval);
//		bv.BasisFunction(0,v,1,vval);
//		Nt0[i]=uval[0]*vval[0];
//		dNdt0[i][0]=uval[1]*vval[0];
//		dNdt0[i][1]=uval[0]*vval[1];
//	}
//	for(uint i=0;i<tmesh[eid].IEN.size();i++)
//	{
//		Nt[i]=Nt0[i];
//		dNdt[i][0]=dNdt0[i][0];
//		dNdt[i][1]=dNdt0[i][1];
//		if(cp[tmesh[eid].IEN[i]].trun==1)
//		{
//			int pid(tmesh[eid].IEN[i]);
//			for(uint j=0; j<cp[pid].tbf.size(); j++)
//			{
//				vector<int>::iterator it=find(tmesh[eid].IEN.begin(),tmesh[eid].IEN.end(),cp[pid].tbf[j]);
//				if(it!=tmesh[eid].IEN.end())
//				{
//					int loc(it-tmesh[eid].IEN.begin());
//					Nt[i]-=cp[pid].tc[j]*Nt0[loc];
//					dNdt[i][0]-=cp[pid].tc[j]*dNdt0[loc][0];
//					dNdt[i][1]-=cp[pid].tc[j]*dNdt0[loc][1];
//				}
//			}
//		}
//	}
//}
//
//void TruncatedTspline_3D::ElementBasis_Irregular(int eid, double u, double v, vector<double>& Nt, vector<array<double,2>>& dNdt)
//{
//	//need to change variabe for Bezier, (u,v) -> (u_b,v_b)
//	Nt.clear();
//	dNdt.clear();
//	Nt.resize(tmesh[eid].IEN.size(),0.);
//	dNdt.resize(tmesh[eid].IEN.size());
//	vector<double> Nt1(tmesh[eid].IEN.size(),0.);
//	vector<array<double,2>> dNdt1(tmesh[eid].IEN.size());
//	uint nv(cp[tmesh[eid].cnct[0]].face.size());
//	vector<vector<double>> bmat(tmesh[eid].bemat.size(),vector<double>(tmesh[eid].bemat[0].size()));
//	for(uint i=0; i<tmesh[eid].bemat.size(); i++)
//	{
//		for(uint j=0; j<tmesh[eid].bemat[i].size(); j++)
//		{
//			bmat[i][j]=tmesh[eid].bemat[i][j];
//		}
//	}
//	//SetBezier4TranMatOP(nv,bmat);
//	BezierElement2D be(4);
//	vector<double> Nt0;
//	vector<array<double,2>> dNdt0;
//	double u_b(u/tmedge[tmesh[eid].edge[0]].len), v_b(v/tmedge[tmesh[eid].edge[3]].len);
//	be.Basis(u_b,v_b,Nt0,dNdt0);
//	for(uint i=0; i<2*nv+1; i++)
//	{
//		dNdt1[i][0]=0.; dNdt1[i][1]=0.;
//		for(int j=0; j<25; j++)
//		{
//			Nt1[i]+=bmat[i][j]*Nt0[j];
//			dNdt1[i][0]+=bmat[i][j]*dNdt0[j][0];
//			dNdt1[i][1]+=bmat[i][j]*dNdt0[j][1];
//		}
//		dNdt1[i][0]/=tmedge[tmesh[eid].edge[0]].len;
//		dNdt1[i][1]/=tmedge[tmesh[eid].edge[3]].len;
//	}
//	vector<double> ku(5,0.),kv(5,0.),uval,vval;
//	BSplineBasis bu,bv;
//	for(uint i=2*nv+1; i<tmesh[eid].IEN.size(); i++)
//	{
//		ku.assign(tmesh[eid].patch_ku[i-(2*nv+1)].begin(),tmesh[eid].patch_ku[i-(2*nv+1)].end());
//		kv.assign(tmesh[eid].patch_kv[i-(2*nv+1)].begin(),tmesh[eid].patch_kv[i-(2*nv+1)].end());
//		bu.Set(3,ku);
//		bv.Set(3,kv);
//		bu.BasisFunction(0,u,1,uval);
//		bv.BasisFunction(0,v,1,vval);
//		Nt1[i]=uval[0]*vval[0];
//		dNdt1[i][0]=uval[1]*vval[0];
//		dNdt1[i][1]=uval[0]*vval[1];
//	}
//	for(uint i=0;i<tmesh[eid].IEN.size();i++)
//	{
//		Nt[i]=Nt1[i];
//		dNdt[i][0]=dNdt1[i][0];
//		dNdt[i][1]=dNdt1[i][1];
//		if(cp[tmesh[eid].IEN[i]].trun==1)
//		{
//			int pid(tmesh[eid].IEN[i]);
//			for(uint j=0; j<cp[pid].tbf.size(); j++)
//			{
//				vector<int>::iterator it=find(tmesh[eid].IEN.begin(),tmesh[eid].IEN.end(),cp[pid].tbf[j]);
//				if(it!=tmesh[eid].IEN.end())
//				{
//					int loc(it-tmesh[eid].IEN.begin());
//					Nt[i]-=cp[pid].tc[j]*Nt1[loc];
//					dNdt[i][0]-=cp[pid].tc[j]*dNdt1[loc][0];
//					dNdt[i][1]-=cp[pid].tc[j]*dNdt1[loc][1];
//				}
//			}
//		}
//	}
//}

void TruncatedTspline_3D::SetBezierMatIrrPatch(int eid)
{
	//find IENtmp first
	tmesh[eid].IENtmp.clear();
	uint i, j, k, hxid;
	vector<int> loc(cp.size(),-1);
	vector<int> hx1r(1, eid);
	for (i = 0; i < 8; i++)
	{
		loc[tmesh[eid].cnct[i]] = tmesh[eid].IENtmp.size();
		tmesh[eid].IENtmp.push_back(tmesh[eid].cnct[i]);
	}
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
		{
			hxid = cp[tmesh[eid].cnct[i]].hex[j];
			vector<int>::iterator it1 = find(hx1r.begin(),hx1r.end(),hxid);
			if (it1 == hx1r.end())
			{
				hx1r.push_back(hxid);
				for (k = 0; k < 8; k++)
				{
					vector<int>::iterator it = find(tmesh[eid].IENtmp.begin(), tmesh[eid].IENtmp.end(), tmesh[hxid].cnct[k]);
					if (it == tmesh[eid].IENtmp.end())
					{
						loc[tmesh[hxid].cnct[k]] = tmesh[eid].IENtmp.size();
						tmesh[eid].IENtmp.push_back(tmesh[hxid].cnct[k]);
					}
				}
			}
		}
	}
	for (i = 0; i < tmesh[eid].bemat.size(); i++)
	{
		tmesh[eid].bemat[i].clear();
	}
	tmesh[eid].bemat.clear();
	tmesh[eid].bemat.resize(tmesh[eid].IENtmp.size(),vector<double>(64,0.));
	//8 body points, not consider boundary yet
	double w[2] = {2./3.,1./3.};
	double a[8] = { w[0] * w[0] * w[0], w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[0] * w[0],
		w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[1] * w[1], w[1] * w[1] * w[0] };
	int bpi[8][8] = { { 0, 1, 2, 3, 4, 5, 6, 7 }, { 1, 2, 3, 0, 5, 6, 7, 4 }, { 2, 3, 0, 1, 6, 7, 4, 5 }, { 3, 0, 1, 2, 7, 4, 5,6 },
	{ 4, 5, 6, 7, 0, 1, 2, 3 }, { 5, 6, 7, 4, 1, 2, 3, 0 }, { 6, 7, 4, 5, 2, 3, 0, 1 }, { 7, 4, 5, 6, 3, 0, 1, 2 } };
	vector<array<array<double, 8>, 8>> bpm(hx1r.size());
	vector<array<array<int, 8>, 8>> bpmap(hx1r.size());
	for (i = 0; i < hx1r.size(); i++)//which element
	{
		for (j = 0; j < 8; j++)//which body point, bezier
		{
			for (k = 0; k < 8; k++)//which local corner point, b-splines
			{
				bpm[i][j][k] = a[k];
				bpmap[i][j][k] = loc[tmesh[hx1r[i]].cnct[bpi[j][k]]];
			}
		}
	}
	int layer[4] = {0,16,32,48};
	int bpbz[8] = { 5 + layer[1], 6 + layer[1], 10 + layer[1], 9 + layer[1], 5 + layer[2], 6 + layer[2], 10 + layer[2], 9 + layer[2] };
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			tmesh[eid].bemat[bpmap[0][i][j]][bpbz[i]] = bpm[0][i][j];
		}
	}
	//2*12 edge points
	int edi[12][2] = { { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 0 }, { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 5 }, { 5, 6 }, { 6, 7 }, {7,4} };
	int edbz[12][2] = { { 1, 2 }, { 7, 11 }, { 14, 13 }, { 8, 4 }, { 0 + layer[1], 0 + layer[2] }, { 3 + layer[1], 3 + layer[2] }, 
	{ 15 + layer[1], 15 + layer[2] }, { 12 + layer[1], 12 + layer[2] }, { 1 + layer[3], 2 + layer[3] }, { 7 + layer[3], 11 + layer[3] }, { 14 + layer[3], 13 + layer[3] }, { 8 + layer[3], 4 + layer[3] } };
	int pos1,pos2;
	for (i = 0; i < 12; i++)
	{
		uint nhex = tmedge[tmesh[eid].edge[i]].hex.size();
		for (j = 0; j<tmedge[tmesh[eid].edge[i]].hex.size(); j++)
		{
			hxid = tmedge[tmesh[eid].edge[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(),hx1r.end(),hxid);
			pos1 = it - hx1r.begin();
			int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct+8, tmesh[eid].cnct[edi[i][0]]);
			pos2 = it1 - tmesh[hxid].cnct;
			for (k = 0; k < 8; k++)
			{
				tmesh[eid].bemat[bpmap[pos1][pos2][k]][edbz[i][0]] += bpm[pos1][pos2][k]/nhex;
			}
			int* it2 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[edi[i][1]]);
			pos2 = it2 - tmesh[hxid].cnct;
			for (k = 0; k < 8; k++)
			{
				tmesh[eid].bemat[bpmap[pos1][pos2][k]][edbz[i][1]] += bpm[pos1][pos2][k] / nhex;
			}
		}
	}
	//8 corner points
	int cnbz[8] = { 0, 3, 15, 12, 0 + layer[3], 3 + layer[3], 15 + layer[3], 12 + layer[3]};
	for (i = 0; i < 8; i++)
	{
		uint nhex = cp[tmesh[eid].cnct[i]].hex.size();
		for (j = 0; j<nhex; j++)
		{
			hxid = cp[tmesh[eid].cnct[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			pos1 = it - hx1r.begin();
			int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[i]);
			pos2 = it1 - tmesh[hxid].cnct;
			for (k = 0; k < 8; k++)
			{
				tmesh[eid].bemat[bpmap[pos1][pos2][k]][cnbz[i]] += bpm[pos1][pos2][k] / nhex;
			}
		}
	}
	//4*6 face points
	int fci[6][4] = { { 0, 1, 3, 2 }, { 0, 1, 4, 5 }, { 1, 2, 5, 6 }, { 3, 2, 7, 6 }, { 0, 3, 4, 7 }, {4,5,7,6} };
	int fcbz[6][4] = { { 5, 6, 9, 10 }, { 1 + layer[1], 2 + layer[1], 1 + layer[2], 2 + layer[2] }, { 7 + layer[1], 11 + layer[1], 7 + layer[2], 11 + layer[2] },
	{ 13 + layer[1], 14 + layer[1], 13 + layer[2], 14 + layer[2] }, { 4 + layer[1], 8 + layer[1], 4 + layer[2], 8 + layer[2] }, { 5 + layer[3], 6 + layer[3], 9 + layer[3], 10 + layer[3] } };
	for (i = 0; i < 6; i++)
	{
		uint nhex = tmface[tmesh[eid].face[i]].hex.size();
		for (j = 0; j < nhex; j++)
		{
			hxid = tmface[tmesh[eid].face[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			pos1 = it - hx1r.begin();
			for (int j1 = 0; j1 < 4; j1++)
			{
				int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[fci[i][j1]]);
				pos2 = it1 - tmesh[hxid].cnct;
				for (k = 0; k < 8; k++)
				{
					tmesh[eid].bemat[bpmap[pos1][pos2][k]][fcbz[i][j1]] += bpm[pos1][pos2][k] / nhex;
				}
			}
		}
	}

	//cout << "bemat of eid: " << eid << "\n";
	//vector<double> col_sum(tmesh[eid].bemat[0].size(), 0.);
	//for (i = 0; i < tmesh[eid].bemat.size(); i++)
	//{
	//	for (j = 0; j < tmesh[eid].bemat[i].size(); j++)
	//	{
	//		col_sum[j] += tmesh[eid].bemat[i][j];
	//		//cout << tmesh[eid].bemat[i][j] << " ";
	//		//if (j % 16 == 0) cout << "\n";
	//	}
	//	//cout << "\n";
	//}
	//for (i = 0; i < col_sum.size(); i++)
	//{
	//	cout << col_sum[i] << "\n";
	//}
	//getchar();
}

void TruncatedTspline_3D::AllBezierPatch()//test purpose
{
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].type != 1)
		{
			SetBezierMatIrrPatch(eid);
		}
	}
}

void TruncatedTspline_3D::ElementBasis(int eid, const array<double, 3>& u, vector<double>& Nt, vector<array<double, 3>>& dNdt)
{
	if (tmesh[eid].act == 1)
	{
		if (tmesh[eid].type == 0)
		{
			ElementBasis_Regular(eid, u, Nt, dNdt);
		}
		else if (tmesh[eid].type == 2)
		{
			ElementBasis_Irregular(eid, u, Nt, dNdt);
		}
	}
}

void TruncatedTspline_3D::ElementBasis_Regular(int eid, const array<double, 3>& u, vector<double>& Nt, vector<array<double, 3>>& dNdt)
{
	Nt.clear();
	dNdt.clear();
	Nt.resize(tmesh[eid].IEN.size());
	dNdt.resize(tmesh[eid].IEN.size());
	vector<double> Nt0(tmesh[eid].IEN.size());
	vector<array<double, 3>> dNdt0(tmesh[eid].IEN.size());
	vector<double> ku(5, 0.), kv(5, 0.), kw(5,0.), uval, vval, wval;
	BSplineBasis bu, bv, bw;
	for (uint i = 0; i<tmesh[eid].IEN.size(); i++)
	{
		ku.assign(tmesh[eid].patch_ku[i].begin(), tmesh[eid].patch_ku[i].end());
		kv.assign(tmesh[eid].patch_kv[i].begin(), tmesh[eid].patch_kv[i].end());
		kw.assign(tmesh[eid].patch_kw[i].begin(), tmesh[eid].patch_kw[i].end());
		bu.Set(3, ku);
		bv.Set(3, kv);
		bw.Set(3, kw);
		bu.BasisFunction(0, u[0], 1, uval);
		bv.BasisFunction(0, u[1], 1, vval);
		bw.BasisFunction(0, u[2], 1, wval);
		Nt0[i] = uval[0] * vval[0] * wval[0];
		dNdt0[i][0] = uval[1] * vval[0] * wval[0];
		dNdt0[i][1] = uval[0] * vval[1] * wval[0];
		dNdt0[i][2] = uval[0] * vval[0] * wval[1];
	}
	for (uint i = 0; i<tmesh[eid].IEN.size(); i++)
	{
		Nt[i] = Nt0[i];
		dNdt[i][0] = dNdt0[i][0];
		dNdt[i][1] = dNdt0[i][1];
		dNdt[i][2] = dNdt0[i][2];
		if (cp[tmesh[eid].IEN[i]].trun == 1)//later improve by setPatchTruncation()
		{
			int pid(tmesh[eid].IEN[i]);
			for (uint j = 0; j<cp[pid].tbf.size(); j++)
			{
				vector<int>::iterator it = find(tmesh[eid].IEN.begin(), tmesh[eid].IEN.end(), cp[pid].tbf[j]);
				if (it != tmesh[eid].IEN.end())
				{
					int loc(it - tmesh[eid].IEN.begin());
					Nt[i] -= cp[pid].tc[j] * Nt0[loc];
					dNdt[i][0] -= cp[pid].tc[j] * dNdt0[loc][0];
					dNdt[i][1] -= cp[pid].tc[j] * dNdt0[loc][1];
					dNdt[i][2] -= cp[pid].tc[j] * dNdt0[loc][2];
				}
			}
		}
	}
}

void TruncatedTspline_3D::ElementBasis_Irregular(int eid, const array<double, 3>& u, vector<double>& Nt, vector<array<double, 3>>& dNdt)
{
	Nt.clear();
	dNdt.clear();
	Nt.resize(tmesh[eid].IEN.size());
	dNdt.resize(tmesh[eid].IEN.size());
	vector<double> Nt0(tmesh[eid].IEN.size());
	vector<array<double, 3>> dNdt0(tmesh[eid].IEN.size());
	BezierElement3D bzel;
	vector<double> Bt;
	vector<array<double, 3>> dBdt;
	bzel.Basis(u[0],u[1],u[2],Bt,dBdt);
	for (uint i = 0; i < tmesh[eid].IEN.size(); i++)
	{
		Nt0[i] = 0.;
		dNdt0[i][0] = 0.; dNdt0[i][1] = 0.; dNdt0[i][2] = 0.;
		for (uint j = 0; j < 64; j++)
		{
			Nt0[i] += tmesh[eid].bemat[i][j] * Bt[j];
			dNdt0[i][0] += tmesh[eid].bemat[i][j] * dBdt[j][0];
			dNdt0[i][1] += tmesh[eid].bemat[i][j] * dBdt[j][1];
			dNdt0[i][2] += tmesh[eid].bemat[i][j] * dBdt[j][2];
		}
	}
	for (uint i = 0; i<tmesh[eid].IEN.size(); i++)
	{
		Nt[i] = Nt0[i];
		dNdt[i][0] = dNdt0[i][0];
		dNdt[i][1] = dNdt0[i][1];
		dNdt[i][2] = dNdt0[i][2];
		if (cp[tmesh[eid].IEN[i]].trun == 1)//later improve by setPatchTruncation()
		{
			int pid(tmesh[eid].IEN[i]);
			for (uint j = 0; j<cp[pid].tbf.size(); j++)
			{
				vector<int>::iterator it = find(tmesh[eid].IEN.begin(), tmesh[eid].IEN.end(), cp[pid].tbf[j]);
				if (it != tmesh[eid].IEN.end())
				{
					int loc(it - tmesh[eid].IEN.begin());
					Nt[i] -= cp[pid].tc[j] * Nt0[loc];
					dNdt[i][0] -= cp[pid].tc[j] * dNdt0[loc][0];
					dNdt[i][1] -= cp[pid].tc[j] * dNdt0[loc][1];
					dNdt[i][2] -= cp[pid].tc[j] * dNdt0[loc][2];
				}
			}
		}
	}
}

void TruncatedTspline_3D::Para2Physical(int eid, const array<double, 3>& u, array<double, 3>& pt)
{
	vector<double> Nt;
	vector<array<double, 3>> dNdt;
	ElementBasis(eid,u,Nt,dNdt);
	pt[0] = 0.; pt[1] = 0.; pt[2] = 0.;
	for (uint i = 0; i < tmesh[eid].IEN.size(); i++)
	{
		pt[0] += Nt[i] * cp[tmesh[eid].IEN[i]].coor[0];
		pt[1] += Nt[i] * cp[tmesh[eid].IEN[i]].coor[1];
		pt[2] += Nt[i] * cp[tmesh[eid].IEN[i]].coor[2];
		//cout << tmesh[eid].IEN[i] << " ";
	}
	//getchar();
}

void TruncatedTspline_3D::VisualizeSolidVTK(string fn)
{
	vector<array<double,3>> spt;
	vector<array<double,3>> sval;
	vector<double> ssum;
	vector<array<int,8>> sele;
	vector<array<double,3>> lpt;//visulize parameter lines
	vector<array<int,2>> led;//line connectivity
	int ns(2),ne_ref(0),loc0,loc1,loc2;
	//vector<double> su(ns),sv(ns);
	//for(int i=0; i<ns; i++)
	//{
	//	su[i]=i*1./(ns-1);
	//	sv[i]=i*1./(ns-1);
	//}

	for(uint e=0;e<tmesh.size();e++)
	{
		if(tmesh[e].act==1 && (tmesh[e].type==0 || tmesh[e].type==2))
		{
			int loc(0);
			vector<double> su(ns),sv(ns),sw(ns);
			for(int i=0; i<ns; i++)
			{
				su[i]=i*tmedge[tmesh[e].edge[0]].len/(ns-1);
				sv[i]=i*tmedge[tmesh[e].edge[3]].len/(ns-1);
				sw[i] = i*tmedge[tmesh[e].edge[4]].len / (ns - 1);
			}

			for(int a=0;a<ns;a++)
			{
				for(int b=0;b<ns;b++)
				{
					for (int c = 0; c < ns; c++)
					{
						array<double, 3> pt;
						array<double, 3> uval = { su[c], sv[b], sw[a] };
						Para2Physical(e, uval, pt);
						double sumtmp = PartionOfUnity(e, uval);
						spt.push_back(pt);
						ssum.push_back(sumtmp);
						//if(a==0||a==ns-1||b==0||b==ns-1)
						//{
						//	lpt.push_back(pt);
						//}
					}
				}
			}

			for(int a=0;a<ns-1;a++)
			{
				for(int b=0;b<ns-1;b++)
				{
					for (int c = 0; c < ns-1; c++)
					{
						array<int, 8> el;
						el[0] = ne_ref + a*ns*ns + b*ns+c;
						el[1] = ne_ref + a*ns*ns + b*ns + c+1;
						el[2] = ne_ref + a*ns*ns + (b+1)*ns + c+1;
						el[3] = ne_ref + a*ns*ns + (b+1)*ns + c;
						el[4] = ne_ref + (a+1)*ns*ns + b*ns + c;
						el[5] = ne_ref + (a + 1)*ns*ns + b*ns + c + 1;
						el[6] = ne_ref + (a + 1)*ns*ns + (b + 1)*ns + c + 1;
						el[7] = ne_ref + (a + 1)*ns*ns + (b + 1)*ns + c;
						sele.push_back(el);
					}
				}
			}
			//for(int a=0;a<ns-1;a++)
			//{
			//	array<int,2> lc;
			//	lc[0]=ecount*4*(ns-1)+a;
			//	lc[1]=ecount*4*(ns-1)+a+1;
			//	led.push_back(lc);
			//	lc[0]=ecount*4*(ns-1)+3*ns-4+a;
			//	lc[1]=ecount*4*(ns-1)+3*ns-4+a+1;
			//	led.push_back(lc);
			//}
			//for(int a=0;a<ns-2;a++)
			//{
			//	array<int,2> lc;
			//	lc[0]=ecount*4*(ns-1)+ns+2*a;
			//	lc[1]=ecount*4*(ns-1)+ns+2*a+2;
			//	led.push_back(lc);
			//	lc[0]=ecount*4*(ns-1)+ns+2*a-1;
			//	lc[1]=ecount*4*(ns-1)+ns+2*a+1;
			//	led.push_back(lc);
			//}
			//array<int,2> lc1;
			//lc1[0]=ecount*4*(ns-1);
			//lc1[1]=ecount*4*(ns-1)+ns;
			//led.push_back(lc1);
			//lc1[0]=ecount*4*(ns-1)+3*ns-5;
			//lc1[1]=ecount*4*(ns-1)+4*ns-5;
			//led.push_back(lc1);
			
			ne_ref += ns*ns*ns;
		}
	}

	string fname=fn+".vtk";
	ofstream fout;
	fout.open(fname.c_str());
	if(fout.is_open())
	{
		fout<<"# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout<<"POINTS "<<spt.size()<<" float\n";
		for(uint i=0;i<spt.size();i++)
		{
			fout<<spt[i][0]<<" "<<spt[i][1]<<" "<<spt[i][2]<<"\n";
		}
		fout<<"\nCELLS "<<sele.size()<<" "<<9*sele.size()<<'\n';
		for(uint i=0;i<sele.size();i++)
		{
			fout << "8 " << sele[i][0] << " " << sele[i][1] << " " << sele[i][2] << " " << sele[i][3] << " " << sele[i][4] << " " << sele[i][5] << " " << sele[i][6] << " " << sele[i][7] << '\n';
		}
		fout<<"\nCELL_TYPES "<<sele.size()<<'\n';
		for(uint i=0;i<sele.size();i++)
		{
			fout<<"12\n";
		}
		fout<<"\nPOINT_DATA "<<ssum.size()<<"\nSCALARS sum FLOAT\nLOOKUP_TABLE default\n";
		for(uint i=0;i<ssum.size();i++)
		{
			fout<<ssum[i]<<"\n";
		}
		//fout<<"\nPOINT_DATA "<<sval.size()<<"\nNORMALS Normal FLOAT\n";
		//for(uint i=0;i<sval.size();i++)
		//{
		//	fout<<sval[i][0]<<" "<<sval[i][1]<<" "<<sval[i][2]<<"\n";
		//}
		fout.close();
	}
	else
	{
		cout<<"Cannot open "<<fname<<"!\n";
	}

	/*string fname1(fn+"-lines.vtk");
	ofstream fout1;
	fout1.open(fname1.c_str());
	if(fout1.is_open())
	{
		fout1<<"# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout1<<"POINTS "<<lpt.size()<<" float\n";
		for(uint i=0;i<lpt.size();i++)
		{
			fout1<<lpt[i][0]<<" "<<lpt[i][1]<<" "<<lpt[i][2]<<"\n";
		}
		fout1<<"\nCELLS "<<led.size()<<" "<<3*led.size()<<'\n';
		for(uint i=0;i<led.size();i++)
		{
			fout1<<"2 "<<led[i][0]<<" "<<led[i][1]<<'\n';
		}
		fout1<<"\nCELL_TYPES "<<led.size()<<'\n';
		for(uint i=0;i<led.size();i++)
		{
			fout1<<"3\n";
		}
		fout1.close();
	}
	else
	{
		cout<<"Cannot open "<<fname1<<"!\n";
	}*/
}

//void TruncatedTspline_3D::FindPatchKnotVector_Irr(int eid, vector<array<double,5>>& patch_ku, vector<array<double,5>>& patch_kv)
//{
//	patch_ku.clear();
//	patch_kv.clear();
//	patch_ku.resize(5);
//	patch_kv.resize(5);
//	//find knot vectors for node 2 to 6
//	if(tmesh[eid].act==1 && tmesh[eid].type==4)
//	{
//		//first for node 2
//		array<double,2> uv_ref0={tmesh[eid].lcs[3].u[0],tmesh[eid].lcs[3].u[1]},uv0;
//		int fcid0(tmedge[tmesh[eid].edge[3]].face[0]), rot0;
//		if(fcid0==eid) fcid0=tmedge[tmesh[eid].edge[3]].face[1];
//		FindRotateAndUVCoor(tmesh[eid].cnct[3],tmesh[eid].lcs[3].rot,uv_ref0,fcid0,tmesh[fcid0].cnct[2],rot0,uv0);
//		FindLocalKnotVector(tmesh[fcid0].cnct[2],rot0,uv0,patch_ku[0],patch_kv[0]);
//		//node 3, 4, 5
//		for(int i=3; i>0; i--)
//		{
//			array<double,2> uv1={tmesh[eid].lcs[i].u[0],tmesh[eid].lcs[i].u[1]};
//			FindLocalKnotVector(tmesh[eid].cnct[i],tmesh[eid].lcs[i].rot,uv1,patch_ku[4-i],patch_kv[4-i]);
//		}
//		//node 6
//		array<double,2> uv_ref2={tmesh[eid].lcs[1].u[0],tmesh[eid].lcs[1].u[1]},uv2;
//		int fcid2(tmedge[tmesh[eid].edge[0]].face[0]), rot2;
//		if(fcid2==eid) fcid2=tmedge[tmesh[eid].edge[0]].face[1];
//		FindRotateAndUVCoor(tmesh[eid].cnct[1],tmesh[eid].lcs[1].rot,uv_ref2,fcid2,tmesh[fcid2].cnct[2],rot2,uv2);
//		FindLocalKnotVector(tmesh[fcid2].cnct[2],rot2,uv2,patch_ku[4],patch_kv[4]);
//	}
//}

//void TruncatedTspline_3D::SurfacePointMap(int eid, double u, double v, array<double,3>& pt, array<double,3>& norm)
//{
//	vector<double> Nt;
//	vector<array<double,2>> dNdt;
//	ElementBasis(eid,u,v,Nt,dNdt);
//	pt[0]=0.; pt[1]=0.; pt[2]=0.;
//	double nmtmp[2][3]={{0.,0.,0.},{0.,0.,0.}};
//	for(uint i=0; i<tmesh[eid].IEN.size(); i++)
//	{
//		pt[0]+=cp[tmesh[eid].IEN[i]].coor[0]*Nt[i];
//		pt[1]+=cp[tmesh[eid].IEN[i]].coor[1]*Nt[i];
//		pt[2]+=cp[tmesh[eid].IEN[i]].coor[2]*Nt[i];
//		nmtmp[0][0]+=cp[tmesh[eid].IEN[i]].coor[0]*dNdt[i][0];
//		nmtmp[0][1]+=cp[tmesh[eid].IEN[i]].coor[1]*dNdt[i][0];
//		nmtmp[0][2]+=cp[tmesh[eid].IEN[i]].coor[2]*dNdt[i][0];
//		nmtmp[1][0]+=cp[tmesh[eid].IEN[i]].coor[0]*dNdt[i][1];
//		nmtmp[1][1]+=cp[tmesh[eid].IEN[i]].coor[1]*dNdt[i][1];
//		nmtmp[1][2]+=cp[tmesh[eid].IEN[i]].coor[2]*dNdt[i][1];
//	}
//	norm[0]=nmtmp[0][1]*nmtmp[1][2]-nmtmp[0][2]*nmtmp[1][1];
//	norm[1]=nmtmp[0][2]*nmtmp[1][0]-nmtmp[0][0]*nmtmp[1][2];
//	norm[2]=nmtmp[0][0]*nmtmp[1][1]-nmtmp[0][1]*nmtmp[1][0];
//	double len=sqrt(norm[0]*norm[0]+norm[1]*norm[1]+norm[2]*norm[2]);
//	norm[0]/=len; norm[1]/=len; norm[2]/=len;
//}

void TruncatedTspline_3D::ElementSubdivide_8(int eid)
{
	int pid[19];
	int edid[54];
	int fcid[36];
	int i, j, loc(0), edloc(0), fcloc(0);
	Vertex3D ptmp1;//body point
	for (i = 0; i < 8; i++)
	{
		ptmp1.coor[0] += .125*cp[tmesh[eid].cnct[i]].coor[0];
		ptmp1.coor[1] += .125*cp[tmesh[eid].cnct[i]].coor[1];
		ptmp1.coor[2] += .125*cp[tmesh[eid].cnct[i]].coor[2];
	}
	cp.push_back(ptmp1);
	pid[loc] = cp.size() - 1; loc++;
	//6 faces
	for (i = 0; i < 6; i++)
	{
		int itmp(tmesh[eid].face[i]);
		int dir(0), pos(0);
		SolidFaceDirection(eid,i,dir,pos);
		if (tmface[itmp].act == 1)
		{
			FaceSubdivision_4(itmp);
		}
		else if (tmface[itmp].act == 0 && tmface[itmp].Tedge.size() == 1)//if the original face is split into two, we need to further split
		{
			int spl_dir(0);
			if (tmedge[tmface[itmp].Tedge[0]].pt[0] == tmedge[tmface[itmp].edge[0]].midpt || tmedge[tmface[itmp].Tedge[0]].pt[1] == tmedge[tmface[itmp].edge[0]].midpt)
				spl_dir = 1;
			FaceSubdivision_24(itmp,spl_dir);
		}
		pid[loc] = tmface[itmp].ctpt; loc++;
		if (dir == 0)//same direction
		{
			for (j = 0; j < 4; j++)
			{
				edid[edloc] = tmface[itmp].Tedge[(pos+j)%4]; edloc++;
				fcid[fcloc] = tmface[itmp].chd[(pos+j)%4]; fcloc++;
			}
		}
		else//opposite direction
		{
			for (j = 0; j < 4; j++)
			{
				edid[edloc] = tmface[itmp].Tedge[(pos+4-j)%4]; edloc++;
				fcid[fcloc] = tmface[itmp].chd[(pos+4-j)%4]; fcloc++;
			}
		}
	}
	//12 edges
	for (i = 0; i < 12; i++)
	{
		int itmp(tmesh[eid].edge[i]);
		int dir(0);
		if (tmedge[itmp].pt[0] == tmesh[eid].cnct[solid_ed[i][1]]) dir = 1;

		pid[loc] = tmedge[itmp].midpt; loc++;
		if (dir == 0)
		{
			edid[edloc] = tmedge[itmp].chd[0]; edloc++;
			edid[edloc] = tmedge[itmp].chd[1]; edloc++;
		}
		else
		{
			edid[edloc] = tmedge[itmp].chd[1]; edloc++;
			edid[edloc] = tmedge[itmp].chd[0]; edloc++;
		}
	}
	//construct 6 new edges
	for (i = 0; i < 6; i++)
	{
		Edge3D edtmp;
		edtmp.pt[0] = pid[0]; edtmp.pt[1] = tmface[tmesh[eid].face[i]].ctpt;
		edtmp.len = tmedge[tmesh[eid].edge[fc_ppd_ed[i]]].len/2.;
		edtmp.lev = tmedge[tmesh[eid].edge[fc_ppd_ed[i]]].lev+1;
		tmedge.push_back(edtmp);
		edid[edloc] = tmedge.size() - 1; edloc++;
	}
	//set new edge ids
	vector<int> ednew_id(edid,edid+54);
	//construct 12 new faces
	int fcnew_cnct[12][4] = { { 11, 2, 0, 5 }, { 2, 12, 3, 0 }, { 0, 3, 13, 4 }, { 5, 0, 4, 14 }, //xy-plane
	{ 7, 1, 0, 2 }, { 1, 9, 4, 0 }, { 0, 4, 17, 6 }, { 2, 0, 6, 15 },//yz
	{ 10, 1, 0, 5 }, { 1, 8, 3, 0 }, { 0, 3, 16, 6 }, { 5, 0, 6, 18 } };//xz
	//int fcnew_edge[12][4] = { { 7, 49, 52, 17 }, { 5, 11, 50, 49 }, { 50, 9, 15, 51 }, { 52, 51, 13, 19 }, //xy-plane
	//{ 3, 48, 49, 4 }, { 1, 12, 51, 48 }, { 51, 14, 22, 53 }, { 49, 53, 20, 6 },//yz
	//{ 0, 48, 52, 16 }, { 2, 8, 50, 48 }, { 50, 10, 21, 53 }, { 52, 53, 23, 18 } };//xz
	int fc_lev_ref[12] = {0,0,0,0,2,2,2,2,1,1,1,1};
	for (i = 0; i < 12; i++)
	{
		Face3D fctmp;
		for (j = 0; j < 4; j++)
		{
			fctmp.cnct[j] = pid[fcnew_cnct[i][j]];
		}
		EdgeIndex_in_Face(fctmp,ednew_id);
		fctmp.lev = tmface[tmesh[eid].face[fc_lev_ref[i]]].lev + 2;
		tmface.push_back(fctmp);
		fcid[fcloc] = tmface.size() - 1; fcloc++;
	}
	vector<int> fcnew_id(fcid, fcid + 36);
	//construct 8 new solids
	int cnid[8];
	for (i = 0; i < 8; i++) cnid[i] = tmesh[eid].cnct[i];
	int slnew_cnct[8][8] = { { cnid[0], pid[7], pid[1], pid[10], pid[11], pid[2], pid[0], pid[5] }, { pid[7], cnid[1], pid[8], pid[1], pid[2], pid[12], pid[3], pid[0] },
	{ pid[1], pid[8], cnid[2], pid[9], pid[0], pid[3], pid[13], pid[4] }, { pid[10], pid[1], pid[9], cnid[3], pid[5], pid[0], pid[4], pid[14] },
	{ pid[11], pid[2], pid[0], pid[5], cnid[4], pid[15], pid[6], pid[18] }, { pid[2], pid[12], pid[3], pid[0], pid[15], cnid[5], pid[16], pid[6] },
	{ pid[0], pid[3], pid[13], pid[4], pid[6], pid[16], cnid[6], pid[17] }, { pid[5], pid[0], pid[4], pid[14], pid[18], pid[6], pid[17], cnid[7] },
	};
	int fc_rot[8][3] = { { 0, 1, 4 }, { 0, 1, 2 }, { 0, 2, 3 }, { 0, 3, 4 }, { 1, 4, 5 }, { 1, 2, 5 }, { 2, 3, 5 }, { 3, 4, 5 } };
	double uvw[3][2] = { { 0., tmedge[tmesh[eid].edge[0]].len / 2.}, { 0., tmedge[tmesh[eid].edge[3]].len / 2.}, { 0., tmedge[tmesh[eid].edge[4]].len / 2.}};
	double chd_o[8][3] = { { uvw[0][0], uvw[1][0], uvw[2][0] }, { uvw[0][1], uvw[1][0], uvw[2][0] }, { uvw[0][1], uvw[1][1], uvw[2][0] }, { uvw[0][0], uvw[1][1], uvw[2][0] },
	{ uvw[0][0], uvw[1][0], uvw[2][1] }, { uvw[0][1], uvw[1][0], uvw[2][1] }, { uvw[0][1], uvw[1][1], uvw[2][1] }, { uvw[0][0], uvw[1][1], uvw[2][1] } };
	tmesh[eid].chd.clear();
	tmesh[eid].chd_o.clear();
	for (i = 0; i < 8; i++)
	{
		Element3D hxtmp;
		for (j = 0; j < 8; j++)
		{
			hxtmp.cnct[j] = slnew_cnct[i][j];
		}
		hxtmp.lev = tmesh[eid].lev + 3;
		hxtmp.prt = eid;
		EdgeFaceIndex_in_Solid(hxtmp,ednew_id,fcnew_id);
		for (j = 0; j < 3; j++)
		{
			hxtmp.nbrot[fc_rot[i][j]] = tmesh[eid].nbrot[fc_rot[i][j]];
		}
		tmesh.push_back(hxtmp);
		tmesh[eid].chd.push_back(tmesh.size()-1);
		array<double, 3> otmp;
		for (j = 0; j < 3; j++)
		{
			otmp[j] = chd_o[i][j];
		}
		tmesh[eid].chd_o.push_back(otmp);
	}

	tmesh[eid].act = 0;
}

void TruncatedTspline_3D::ElementSubdivide_5(int eid, int sl_rfdir)//dir=x,y,z
{
	int pid[10];
	vector<int> edid(33);
	vector<int> fcid(20);
	int i, j, loc(0), edloc(0), fcloc(0);

	int fc_bsc[3][4] = { { 0, 1, 5, 3 }, { 0, 2, 5, 4 }, { 1, 2, 3, 4 } };
	int fc_dir[3][4] = { { 1, 1, 1, 1 }, { 0, 1, 0, 1 }, { 0, 0, 0, 0 } };
	int fc_sbd[3][2] = { { 2, 4 }, { 1, 3 }, { 0, 5 } };
	int ed_tgt[3][8] = { { 1, 3, 4, 5, 6, 7, 9, 11 }, { 0, 2, 4, 5, 6, 7, 8, 10 }, { 0, 1, 2, 3, 8, 9, 10, 11 } };

	int ed_0[3][4] = { { 0, 2, 8, 10 }, { 1, 3, 9, 11 }, { 4, 5, 6, 7 } };//original (base) edges from eid

	//4 faces to be bisected
	for (i = 0; i < 4; i++)
	{
		int itmp(tmesh[eid].face[fc_bsc[sl_rfdir][i]]);
		int dir(0), pos(0);
		SolidFaceDirection(eid, fc_bsc[sl_rfdir][i], dir, pos);
		int fc_rfdir = (fc_dir[sl_rfdir][i] + pos) % 4;
		if (dir == 1) fc_rfdir = (fc_dir[sl_rfdir][i] + pos + 1) % 4;
		if (fc_rfdir == 2) fc_rfdir = 0;
		if (fc_rfdir == 3) fc_rfdir = 1;
		if (tmface[itmp].act == 1)
		{
			FaceSubdivision_2(itmp, fc_rfdir);
			edid[edloc] = tmface[itmp].Tedge[0]; edloc++;
			fcid[fcloc] = tmface[itmp].chd[0]; fcloc++;
			fcid[fcloc] = tmface[itmp].chd[1]; fcloc++;
		}
		else
		{
			//if the original face is split into two, we need to further split
			if (tmface[itmp].ctpt != -1)//subdivided
			{
				int edbs, fcbs[2];
				Construct_BaseFace_Subdv(itmp, fc_rfdir, edbs, fcbs);
				edid[edloc] = edbs; edloc++;
				fcid[fcloc] = fcbs[0]; fcloc++;
				fcid[fcloc] = fcbs[1]; fcloc++;
			}
			else if (tmface[itmp].Tedge.size() == 1)//bisected
			{
				if (tmedge[tmface[itmp].Tedge[0]].pt[0] == tmedge[tmface[itmp].edge[fc_rfdir]].midpt
					|| tmedge[tmface[itmp].Tedge[0]].pt[1] == tmedge[tmface[itmp].edge[fc_rfdir]].midpt)//aligned
				{
					edid[edloc] = tmface[itmp].Tedge[0]; edloc++;
					fcid[fcloc] = tmface[itmp].chd[0]; fcloc++;
					fcid[fcloc] = tmface[itmp].chd[1]; fcloc++;
				}
				else//crossed
				{
					int edbs, fcbs[2];
					FaceSubdivision_24(itmp, fc_rfdir);
					Construct_BaseFace_Subdv(itmp, fc_rfdir, edbs, fcbs);
					edid[edloc] = edbs; edloc++;
					fcid[fcloc] = fcbs[0]; fcloc++;
					fcid[fcloc] = fcbs[1]; fcloc++;
				}

			}
		}
	}
	//2 faces to be subdivided
	for (i = 0; i < 2; i++)
	{
		int itmp(tmesh[eid].face[fc_sbd[sl_rfdir][i]]);
		int dir(0), pos(0);
		SolidFaceDirection(eid, fc_sbd[sl_rfdir][i], dir, pos);
		if (tmface[itmp].act == 1)
		{
			FaceSubdivision_4(itmp);
		}
		else
		{
			//if the original face is split into two, we need to further split
			if (tmface[itmp].act == 0 && tmface[itmp].Tedge.size() == 1)
			{
				int spl_dir(1);
				if (tmedge[tmface[itmp].Tedge[0]].pt[0] == tmedge[tmface[itmp].edge[0]].midpt || tmedge[tmface[itmp].Tedge[0]].pt[1] == tmedge[tmface[itmp].edge[0]].midpt)
					spl_dir = 0;
				FaceSubdivision_24(itmp, spl_dir);
			}
		}
		pid[loc] = tmface[itmp].ctpt; loc++;
		for (j = 0; j < 4; j++)
		{
			edid[edloc] = tmface[itmp].Tedge[j]; edloc++;
			fcid[fcloc] = tmface[itmp].chd[j]; fcloc++;
		}
	}
	//8 edges
	for (i = 0; i < 8; i++)
	{
		int itmp(tmesh[eid].edge[ed_tgt[sl_rfdir][i]]);
		pid[loc] = tmedge[itmp].midpt; loc++;
		edid[edloc] = tmedge[itmp].chd[0]; edloc++;
		edid[edloc] = tmedge[itmp].chd[1]; edloc++;
	}
	//4 untouched base edegs
	for (i = 0; i < 4; i++)
	{
		edid[edloc] = tmesh[eid].edge[ed_0[sl_rfdir][i]]; edloc++;
	}
	Edge3D edtmp;
	edtmp.pt[0] = tmface[tmesh[eid].face[fc_sbd[sl_rfdir][0]]].ctpt; edtmp.pt[1] = tmface[tmesh[eid].face[fc_sbd[sl_rfdir][1]]].ctpt;
	edtmp.len = tmedge[tmesh[eid].edge[ed_0[sl_rfdir][0]]].len;
	edtmp.lev = tmedge[tmesh[eid].edge[ed_0[sl_rfdir][0]]].lev;
	tmedge.push_back(edtmp);
	edid[edloc] = tmedge.size() - 1; edloc++;
	//construct 4 new faces
	int fcnew_cnct[4][4] = { { 4, 5, 0, 1 }, { 1, 0, 6, 7 }, { 3, 2, 0, 1 }, { 1, 0, 8, 9 } };
	int fc_lev_ref[4] = { 0, 0, 1, 1 };
	if (sl_rfdir == 1)
	{
		int fc_tmp[4][4] = { { 4, 0, 1, 7 }, { 0, 5, 6, 1 }, { 2, 3, 1, 0 }, { 0, 1, 9, 8 } };
		int ref_tmp[4] = { 0, 0, 2, 2 };
		for (i = 0; i < 4; i++)
		{
			fc_lev_ref[i] = ref_tmp[i];
			for (j = 0; j < 4; j++)
			{
				fcnew_cnct[i][j] = fc_tmp[i][j];
			}
		}
	}
	if (sl_rfdir == 2)
	{
		int fc_tmp[4][4] = { { 2, 0, 1, 6 }, { 0, 4, 8, 1 }, { 5, 0, 1, 9 }, { 0, 3, 7, 1 } };
		int ref_tmp[4] = { 2, 2, 1, 1 };
		for (i = 0; i < 4; i++)
		{
			fc_lev_ref[i] = ref_tmp[i];
			for (j = 0; j < 4; j++)
			{
				fcnew_cnct[i][j] = fc_tmp[i][j];
			}
		}
	}
	for (i = 0; i < 4; i++)
	{
		Face3D fctmp;
		for (j = 0; j < 4; j++)
		{
			fctmp.cnct[j] = pid[fcnew_cnct[i][j]];
		}
		EdgeIndex_in_Face(fctmp, edid);
		fctmp.lev = tmface[tmesh[eid].face[fc_lev_ref[i]]].lev + 1;
		tmface.push_back(fctmp);
		fcid[fcloc] = tmface.size() - 1; fcloc++;
	}
	//construct 4 new solids
	int cnid[8];
	for (i = 0; i < 8; i++) cnid[i] = tmesh[eid].cnct[i];
	int slnew_cnct[4][8] = { { cnid[0], cnid[1], pid[2], pid[3], pid[4], pid[5], pid[0], pid[1] }, { pid[3], pid[2], cnid[2], cnid[3], pid[1], pid[0], pid[6], pid[7] },
	{ pid[4], pid[5], pid[0], pid[1], cnid[4], cnid[5], pid[8], pid[9] }, { pid[1], pid[0], pid[6], pid[7], pid[9], pid[8], cnid[6], cnid[7] } };
	int fc_rot[4][4] = { { 0, 1, 2, 4 }, { 0, 2, 3, 4 }, { 1, 2, 4, 5 }, { 2, 3, 4, 5 } };
	double uvw[3][2] = { { 0., tmedge[tmesh[eid].edge[0]].len / 2. }, { 0., tmedge[tmesh[eid].edge[3]].len / 2. }, { 0., tmedge[tmesh[eid].edge[4]].len / 2. } };
	double chd_o[4][3] = { { uvw[0][0], uvw[1][0], uvw[2][0] }, { uvw[0][0], uvw[1][1], uvw[2][0] }, { uvw[0][0], uvw[1][0], uvw[2][1] }, { uvw[0][0], uvw[1][1], uvw[2][1] } };
	if (sl_rfdir == 1)
	{
		int cnct_tmp[4][8] = { { cnid[0], pid[2], pid[3], cnid[3], pid[4], pid[0], pid[1], pid[7] }, { pid[2], cnid[1], cnid[2], pid[3], pid[0], pid[5], pid[6], pid[1] },
		{ pid[4], pid[0], pid[1], pid[7], cnid[4], pid[8], pid[9], cnid[7] }, { pid[0], pid[5], pid[6], pid[1], pid[8], cnid[5], cnid[6], pid[9] } };
		int fcrot_tmp[4][4] = { { 0, 1, 3, 4 }, { 0, 1, 2, 3 }, { 1, 3, 4, 5 }, { 1, 2, 3, 5 } };
		double otmp[4][3] = { { uvw[0][0], uvw[1][0], uvw[2][0] }, { uvw[0][1], uvw[1][0], uvw[2][0] }, { uvw[0][0], uvw[1][0], uvw[2][1] }, { uvw[0][0], uvw[1][1], uvw[2][1] } };
		for (i = 0; i < 4; i++)
		{
			for (j = 0; j < 8; j++) slnew_cnct[i][j] = cnct_tmp[i][j];
			for (j = 0; j < 4; j++) fc_rot[i][j] = fcrot_tmp[i][j];
			for (j = 0; j < 3; j++) chd_o[i][j] = otmp[i][j];
		}
	}
	else if (sl_rfdir == 2)
	{
		int cnct_tmp[4][8] = { { cnid[0], pid[2], pid[0], pid[5], cnid[4], pid[6], pid[1], pid[9] }, { pid[2], cnid[1], pid[3], pid[0], pid[6], cnid[5], pid[7], pid[1] },
		{ pid[5], pid[0], pid[4], cnid[3], pid[9], pid[1], pid[8], cnid[7] }, { pid[0], pid[3], cnid[2], pid[4], pid[1], pid[7], cnid[6], pid[8] } };
		int fcrot_tmp[4][4] = { { 0, 1, 4, 5 }, { 0, 1, 2, 5 }, { 0, 3, 4, 5 }, { 0, 2, 3, 5 } };
		double otmp[4][3] = { { uvw[0][0], uvw[1][0], uvw[2][0] }, { uvw[0][1], uvw[1][0], uvw[2][0] }, { uvw[0][0], uvw[1][1], uvw[2][0] }, { uvw[0][1], uvw[1][1], uvw[2][0] } };
		for (i = 0; i < 4; i++)
		{
			for (j = 0; j < 8; j++) slnew_cnct[i][j] = cnct_tmp[i][j];
			for (j = 0; j < 4; j++) fc_rot[i][j] = fcrot_tmp[i][j];
			for (j = 0; j < 3; j++) chd_o[i][j] = otmp[i][j];
		}
	}
	tmesh[eid].chd.clear();
	tmesh[eid].chd_o.clear();
	for (i = 0; i < 4; i++)
	{
		Element3D hxtmp;
		for (j = 0; j < 8; j++)
		{
			hxtmp.cnct[j] = slnew_cnct[i][j];
		}
		hxtmp.lev = tmesh[eid].lev + 1;
		hxtmp.prt = eid;
		EdgeFaceIndex_in_Solid(hxtmp, edid, fcid);
		for (j = 0; j < 4; j++)
		{
			hxtmp.nbrot[fc_rot[i][j]] = tmesh[eid].nbrot[fc_rot[i][j]];
		}
		tmesh.push_back(hxtmp);
		tmesh[eid].chd.push_back(tmesh.size() - 1);
		array<double, 3> otmp;
		for (j = 0; j < 3; j++)
		{
			otmp[j] = chd_o[i][j];
		}
		tmesh[eid].chd_o.push_back(otmp);
	}

	tmesh[eid].act = 0;
}

void TruncatedTspline_3D::ElementSubdivide_4(int eid, int sl_rfdir)//dir=x,y,z
{
	int pid[10];
	vector<int> edid(33);
	vector<int> fcid(20);
	int i, j, loc(0), edloc(0), fcloc(0);

	int fc_bsc[3][4] = { { 0, 1, 5, 3 }, { 0, 2, 5, 4 }, { 1, 2, 3, 4 } };
	int fc_dir[3][4] = { { 1, 1, 1, 1 }, { 0, 1, 0, 1 }, { 0, 0, 0, 0 } };
	int fc_sbd[3][2] = { { 2, 4 }, { 1, 3 }, {0, 5} };
	int ed_tgt[3][8] = { { 1, 3, 4, 5, 6, 7, 9, 11 }, { 0, 2, 4, 5, 6, 7, 8, 10 }, { 0,1,2,3,8,9,10,11 } };

	int ed_0[3][4] = { { 0, 2, 8, 10}, { 1, 3, 9, 11}, { 4, 5, 6, 7} };//original (base) edges from eid

	//4 faces to be bisected
	for (i = 0; i < 4; i++)
	{
		int itmp(tmesh[eid].face[fc_bsc[sl_rfdir][i]]);
		int dir(0), pos(0);
		SolidFaceDirection(eid, fc_bsc[sl_rfdir][i], dir, pos);
		int fc_rfdir = (fc_dir[sl_rfdir][i] + pos) % 4;
		if (dir == 1) fc_rfdir = (fc_dir[sl_rfdir][i] + pos + 1) % 4;
		if (fc_rfdir == 2) fc_rfdir = 0;
		if (fc_rfdir == 3) fc_rfdir = 1;
		if (tmface[itmp].act == 1)
		{
			FaceSubdivision_2(itmp, fc_rfdir);
			edid[edloc] = tmface[itmp].Tedge[0]; edloc++;
			fcid[fcloc] = tmface[itmp].chd[0]; fcloc++;
			fcid[fcloc] = tmface[itmp].chd[1]; fcloc++;
		}
		else
		{
			//if the original face is split into two, we need to further split
			if (tmface[itmp].ctpt != -1)//subdivided
			{
				int edbs, fcbs[2];
				Construct_BaseFace_Subdv(itmp, fc_rfdir, edbs, fcbs);
				edid[edloc] = edbs; edloc++;
				fcid[fcloc] = fcbs[0]; fcloc++;
				fcid[fcloc] = fcbs[1]; fcloc++;
			}
			else if (tmface[itmp].Tedge.size() == 1)//bisected
			{
				if (tmedge[tmface[itmp].Tedge[0]].pt[0] == tmedge[tmface[itmp].edge[fc_rfdir]].midpt
					|| tmedge[tmface[itmp].Tedge[0]].pt[1] == tmedge[tmface[itmp].edge[fc_rfdir]].midpt)//aligned
				{
					edid[edloc] = tmface[itmp].Tedge[0]; edloc++;
					fcid[fcloc] = tmface[itmp].chd[0]; fcloc++;
					fcid[fcloc] = tmface[itmp].chd[1]; fcloc++;
				}
				else//crossed
				{
					int edbs, fcbs[2];
					FaceSubdivision_24(itmp, fc_rfdir);
					Construct_BaseFace_Subdv(itmp, fc_rfdir, edbs, fcbs);
					edid[edloc] = edbs; edloc++;
					fcid[fcloc] = fcbs[0]; fcloc++;
					fcid[fcloc] = fcbs[1]; fcloc++;
				}

			}
		}
	}
	//2 faces to be subdivided
	for (i = 0; i < 2; i++)
	{
		int itmp(tmesh[eid].face[fc_sbd[sl_rfdir][i]]);
		int dir(0), pos(0);
		SolidFaceDirection(eid, fc_sbd[sl_rfdir][i], dir, pos);
		if (tmface[itmp].act == 1)
		{
			FaceSubdivision_4(itmp);
		}
		else
		{
			//if the original face is split into two, we need to further split
			if (tmface[itmp].act == 0 && tmface[itmp].Tedge.size() == 1)
			{
				int spl_dir(1);
				if (tmedge[tmface[itmp].Tedge[0]].pt[0] == tmedge[tmface[itmp].edge[0]].midpt || tmedge[tmface[itmp].Tedge[0]].pt[1] == tmedge[tmface[itmp].edge[0]].midpt)
					spl_dir = 0;
				FaceSubdivision_24(itmp, spl_dir);
			}
		}
		pid[loc] = tmface[itmp].ctpt; loc++;
		for (j = 0; j < 4; j++)
		{
			edid[edloc] = tmface[itmp].Tedge[j]; edloc++;
			fcid[fcloc] = tmface[itmp].chd[j]; fcloc++;
		}
	}
	//8 edges
	for (i = 0; i < 8; i++)
	{
		int itmp(tmesh[eid].edge[ed_tgt[sl_rfdir][i]]);
		pid[loc] = tmedge[itmp].midpt; loc++;
		edid[edloc] = tmedge[itmp].chd[0]; edloc++;
		edid[edloc] = tmedge[itmp].chd[1]; edloc++;
	}
	//4 untouched base edegs
	for (i = 0; i < 4; i++)
	{
		edid[edloc] = tmesh[eid].edge[ed_0[sl_rfdir][i]]; edloc++;
	}
	Edge3D edtmp;
	edtmp.pt[0] = tmface[tmesh[eid].face[fc_sbd[sl_rfdir][0]]].ctpt; edtmp.pt[1] = tmface[tmesh[eid].face[fc_sbd[sl_rfdir][1]]].ctpt;
	edtmp.len = tmedge[tmesh[eid].edge[ed_0[sl_rfdir][0]]].len;
	edtmp.lev = tmedge[tmesh[eid].edge[ed_0[sl_rfdir][0]]].lev;
	tmedge.push_back(edtmp);
	edid[edloc] = tmedge.size() - 1; edloc++;
	//construct 4 new faces
	int fcnew_cnct[4][4] = { { 4, 5, 0, 1 }, { 1, 0, 6, 7 }, { 3, 2, 0, 1 }, {1,0,8,9} };
	int fc_lev_ref[4] = {0,0,1,1};
	if (sl_rfdir == 1)
	{
		int fc_tmp[4][4] = { { 4, 0, 1, 7 }, { 0, 5, 6, 1 }, { 2, 3, 1, 0 }, {0,1,9,8} };
		int ref_tmp[4] = {0,0,2,2};
		for (i = 0; i < 4; i++)
		{
			fc_lev_ref[i] = ref_tmp[i];
			for (j = 0; j < 4; j++)
			{
				fcnew_cnct[i][j] = fc_tmp[i][j];
			}
		}
	}
	if (sl_rfdir == 2)
	{
		int fc_tmp[4][4] = { { 2, 0, 1, 6 }, { 0, 4, 8, 1 }, { 5, 0, 1, 9 }, { 0, 3, 7, 1 } };
		int ref_tmp[4] = { 2, 2, 1, 1 };
		for (i = 0; i < 4; i++)
		{
			fc_lev_ref[i] = ref_tmp[i];
			for (j = 0; j < 4; j++)
			{
				fcnew_cnct[i][j] = fc_tmp[i][j];
			}
		}
	}
	for (i = 0; i < 4; i++)
	{
		Face3D fctmp;
		for (j = 0; j < 4; j++)
		{
			fctmp.cnct[j] = pid[fcnew_cnct[i][j]];
		}
		EdgeIndex_in_Face(fctmp, edid);
		fctmp.lev = tmface[tmesh[eid].face[fc_lev_ref[i]]].lev+1;
		tmface.push_back(fctmp);
		fcid[fcloc] = tmface.size() - 1; fcloc++;
	}
	//construct 4 new solids
	int cnid[8];
	for (i = 0; i < 8; i++) cnid[i] = tmesh[eid].cnct[i];
	int slnew_cnct[4][8] = { { cnid[0], cnid[1], pid[2], pid[3], pid[4], pid[5], pid[0], pid[1] }, { pid[3], pid[2], cnid[2], cnid[3], pid[1], pid[0], pid[6], pid[7] },
	{ pid[4], pid[5], pid[0], pid[1], cnid[4], cnid[5], pid[8], pid[9] }, { pid[1], pid[0], pid[6], pid[7], pid[9], pid[8], cnid[6], cnid[7] } };
	int fc_rot[4][4] = { { 0, 1, 2, 4 }, { 0, 2, 3, 4 }, { 1, 2, 4, 5 }, {2,3,4,5} };
	double uvw[3][2] = { { 0., tmedge[tmesh[eid].edge[0]].len / 2. }, { 0., tmedge[tmesh[eid].edge[3]].len / 2. }, { 0., tmedge[tmesh[eid].edge[4]].len / 2. } };
	double chd_o[4][3] = { { uvw[0][0], uvw[1][0], uvw[2][0] }, { uvw[0][0], uvw[1][1], uvw[2][0] }, { uvw[0][0], uvw[1][0], uvw[2][1] }, { uvw[0][0], uvw[1][1], uvw[2][1] } };
	if (sl_rfdir == 1)
	{
		int cnct_tmp[4][8] = { { cnid[0], pid[2], pid[3], cnid[3], pid[4], pid[0], pid[1], pid[7] }, { pid[2], cnid[1], cnid[2], pid[3], pid[0], pid[5], pid[6], pid[1] },
		{ pid[4], pid[0], pid[1], pid[7], cnid[4], pid[8], pid[9], cnid[7] }, { pid[0], pid[5], pid[6], pid[1], pid[8], cnid[5], cnid[6], pid[9] } };
		int fcrot_tmp[4][4] = { { 0, 1, 3, 4 }, { 0, 1, 2, 3 }, { 1, 3, 4, 5 }, { 1, 2, 3, 5 } };
		double otmp[4][3] = { { uvw[0][0], uvw[1][0], uvw[2][0] }, { uvw[0][1], uvw[1][0], uvw[2][0] }, { uvw[0][0], uvw[1][0], uvw[2][1] }, { uvw[0][0], uvw[1][1], uvw[2][1] } };
		for (i = 0; i < 4; i++)
		{
			for (j = 0; j < 8; j++) slnew_cnct[i][j] = cnct_tmp[i][j];
			for (j = 0; j < 4; j++) fc_rot[i][j] = fcrot_tmp[i][j];
			for (j = 0; j < 3; j++) chd_o[i][j] = otmp[i][j];
		}
	}
	else if (sl_rfdir == 2)
	{
		int cnct_tmp[4][8] = { { cnid[0], pid[2], pid[0], pid[5], cnid[4], pid[6], pid[1], pid[9] }, { pid[2], cnid[1], pid[3], pid[0], pid[6], cnid[5], pid[7], pid[1] },
		{ pid[5], pid[0], pid[4], cnid[3], pid[9], pid[1], pid[8], cnid[7] }, { pid[0], pid[3], cnid[2], pid[4], pid[1], pid[7], cnid[6], pid[8] } };
		int fcrot_tmp[4][4] = { { 0, 1, 4, 5 }, { 0, 1, 2, 5 }, { 0, 3, 4, 5 }, { 0, 2, 3, 5 } };
		double otmp[4][3] = { { uvw[0][0], uvw[1][0], uvw[2][0] }, { uvw[0][1], uvw[1][0], uvw[2][0] }, { uvw[0][0], uvw[1][1], uvw[2][0] }, { uvw[0][1], uvw[1][1], uvw[2][0] } };
		for (i = 0; i < 4; i++)
		{
			for (j = 0; j < 8; j++) slnew_cnct[i][j] = cnct_tmp[i][j];
			for (j = 0; j < 4; j++) fc_rot[i][j] = fcrot_tmp[i][j];
			for (j = 0; j < 3; j++) chd_o[i][j] = otmp[i][j];
		}
	}
	tmesh[eid].chd.clear();
	tmesh[eid].chd_o.clear();
	for (i = 0; i < 4; i++)
	{
		Element3D hxtmp;
		for (j = 0; j < 8; j++)
		{
			hxtmp.cnct[j] = slnew_cnct[i][j];
		}
		hxtmp.lev = tmesh[eid].lev + 1;
		hxtmp.prt = eid;
		EdgeFaceIndex_in_Solid(hxtmp, edid, fcid);
		for (j = 0; j < 4; j++)
		{
			hxtmp.nbrot[fc_rot[i][j]] = tmesh[eid].nbrot[fc_rot[i][j]];
		}
		tmesh.push_back(hxtmp);
		tmesh[eid].chd.push_back(tmesh.size() - 1);
		array<double, 3> otmp;
		for (j = 0; j < 3; j++)
		{
			otmp[j] = chd_o[i][j];
		}
		tmesh[eid].chd_o.push_back(otmp);
	}

	tmesh[eid].act = 0;
}

void TruncatedTspline_3D::ElementSubdivide_2(int eid, int sl_rfdir)//dir=x,y,z
{
	int pid[4];
	vector<int> edid(20);
	vector<int> fcid(11);
	int i, j, loc(0), edloc(0), fcloc(0);

	int fc_tgt[3][4] = { { 0, 1, 5, 3 }, { 0, 2, 5, 4 }, {1,2,3,4} };
	int fc_dir[3][4] = { { 0, 0, 0, 0 }, { 1, 0, 1, 0 }, {1,1,1,1} };
	int ed_tgt[3][4] = { { 0, 2, 10, 8 }, { 3, 1, 9, 11 }, {4,5,6,7} };

	int fc_0[3][2] = { { 2, 4 }, { 1, 3 }, { 0, 5 } };//original (base) faces from eid
	int ed_0[3][8] = { { 1,3,4,5,6,7,9,11 }, { 0,2,4,5,6,7,8,10 }, { 0,1,2,3,8,9,10,11 } };//original (base) edges from eid

	//4 faces
	for (i = 0; i < 4; i++)
	{
		int itmp(tmesh[eid].face[fc_tgt[sl_rfdir][i]]);
		int dir(0), pos(0);
		SolidFaceDirection(eid, fc_tgt[sl_rfdir][i], dir, pos);
		int fc_rfdir = (fc_dir[sl_rfdir][i] + pos) % 4;
		if (dir == 1) fc_rfdir = (fc_dir[sl_rfdir][i] + pos+1) % 4;
		if (fc_rfdir == 2) fc_rfdir = 0;
		if (fc_rfdir == 3) fc_rfdir = 1;
		if (tmface[itmp].act == 1)
		{
			FaceSubdivision_2(itmp, fc_rfdir);
			edid[edloc] = tmface[itmp].Tedge[0]; edloc++;
			fcid[fcloc] = tmface[itmp].chd[0]; fcloc++;
			fcid[fcloc] = tmface[itmp].chd[1]; fcloc++;
		}
		else
		{
			//if the original face is split into two, we need to further split
			if (tmface[itmp].ctpt!=-1)//subdivided
			{
				int edbs, fcbs[2];
				Construct_BaseFace_Subdv(itmp, fc_rfdir, edbs, fcbs);
				edid[edloc] = edbs; edloc++;
				fcid[fcloc] = fcbs[0]; fcloc++;
				fcid[fcloc] = fcbs[1]; fcloc++;
			}
			else if (tmface[itmp].Tedge.size() == 1)//bisected
			{
				if (tmedge[tmface[itmp].Tedge[0]].pt[0] == tmedge[tmface[itmp].edge[fc_rfdir]].midpt 
					|| tmedge[tmface[itmp].Tedge[0]].pt[1] == tmedge[tmface[itmp].edge[fc_rfdir]].midpt)//aligned
				{
					edid[edloc] = tmface[itmp].Tedge[0]; edloc++;
					fcid[fcloc] = tmface[itmp].chd[0]; fcloc++;
					fcid[fcloc] = tmface[itmp].chd[1]; fcloc++;
				}
				else//crossed
				{
					int edbs, fcbs[2];
					FaceSubdivision_24(itmp, fc_rfdir);
					Construct_BaseFace_Subdv(itmp, fc_rfdir, edbs, fcbs);
					edid[edloc] = edbs; edloc++;
					fcid[fcloc] = fcbs[0]; fcloc++;
					fcid[fcloc] = fcbs[1]; fcloc++;
				}

			}
		}
	}
	//2 untouched base faces
	for (i = 0; i < 2; i++)
	{
		fcid[fcloc] = tmesh[eid].face[fc_0[sl_rfdir][i]]; fcloc++;
	}
	//4 edges
	for (i = 0; i < 4; i++)
	{
		int itmp(tmesh[eid].edge[ed_tgt[sl_rfdir][i]]);
		int dir(0);
		if (tmedge[itmp].pt[0] == tmesh[eid].cnct[solid_ed[ed_tgt[sl_rfdir][i]][1]]) dir = 1;

		pid[loc] = tmedge[itmp].midpt; loc++;
		//if (dir == 0)
		//{
			edid[edloc] = tmedge[itmp].chd[0]; edloc++;
			edid[edloc] = tmedge[itmp].chd[1]; edloc++;
		//}
		//else
		//{
		//	edid[edloc] = tmedge[itmp].chd[1]; edloc++;
		//	edid[edloc] = tmedge[itmp].chd[0]; edloc++;
		//}
	}
	//8 untouched base edegs
	for (i = 0; i < 8; i++)
	{
		edid[edloc] = tmesh[eid].edge[ed_0[sl_rfdir][i]]; edloc++;
	}
	//construct 1 new face
	int fcnew_cnct[4] = { 0,1,2,3};
	int fc_lev_ref(2);
	if (sl_rfdir == 1) fc_lev_ref = 1;
	if (sl_rfdir == 2) fc_lev_ref = 0;
	Face3D fctmp;
	for (j = 0; j < 4; j++)
	{
		fctmp.cnct[j] = pid[fcnew_cnct[j]];
	}
	EdgeIndex_in_Face(fctmp, edid);
	fctmp.lev = tmface[tmesh[eid].face[fc_lev_ref]].lev;
	tmface.push_back(fctmp);
	fcid[fcloc] = tmface.size() - 1; fcloc++;
	//construct 2 new solids
	int cnid[8];
	for (i = 0; i < 8; i++) cnid[i] = tmesh[eid].cnct[i];
	int slnew_cnct[2][8] = { { cnid[0], pid[0], pid[1], cnid[3], cnid[4], pid[3], pid[2], cnid[7] }, { pid[0], cnid[1], cnid[2], pid[1], pid[3], cnid[5], cnid[6], pid[2] }};
	int fc_rot[2][5] = { { 0, 1, 3, 4, 5 }, { 0, 1, 2, 3, 5 } };
	double uvw[3][2] = { { 0., tmedge[tmesh[eid].edge[0]].len / 2. }, { 0., tmedge[tmesh[eid].edge[3]].len / 2. }, { 0., tmedge[tmesh[eid].edge[4]].len / 2. } };
	double chd_o[2][3] = { { uvw[0][0], uvw[1][0], uvw[2][0] }, { uvw[0][1], uvw[1][0], uvw[2][0] }};
	if (sl_rfdir == 1)
	{
		int cnct_tmp[2][8] = { { cnid[0], cnid[1], pid[1], pid[0], cnid[4], cnid[5], pid[2], pid[3] }, { pid[0], pid[1], cnid[2], cnid[3], pid[3], pid[2], cnid[6], cnid[7] } };
		int fcrot_tmp[2][5] = { { 0, 1, 2, 4, 5 }, { 0, 2, 3, 4, 5 } };
		double otmp[2][3] = { { uvw[0][0], uvw[1][0], uvw[2][0] }, { uvw[0][0], uvw[1][1], uvw[2][0] } };
		for (i = 0; i < 2; i++)
		{
			for (j = 0; j < 8; j++) slnew_cnct[i][j] = cnct_tmp[i][j];
			for (j = 0; j < 5; j++) fc_rot[i][j] = fcrot_tmp[i][j];
			for (j = 0; j < 3; j++) chd_o[i][j] = otmp[i][j];
		}
	}
	else if (sl_rfdir == 2)
	{
		int cnct_tmp[2][8] = { { cnid[0], cnid[1], cnid[2], cnid[3], pid[0], pid[1], pid[2], pid[3] }, { pid[0], pid[1], pid[2], pid[3], cnid[4], cnid[5], cnid[6], cnid[7] } };
		int fcrot_tmp[2][5] = { { 0, 1, 2, 3, 4 }, { 1, 2, 3, 4, 5 } };
		double otmp[2][3] = { { uvw[0][0], uvw[1][0], uvw[2][0] }, { uvw[0][0], uvw[1][0], uvw[2][1] } };
		for (i = 0; i < 2; i++)
		{
			for (j = 0; j < 8; j++) slnew_cnct[i][j] = cnct_tmp[i][j];
			for (j = 0; j < 5; j++) fc_rot[i][j] = fcrot_tmp[i][j];
			for (j = 0; j < 3; j++) chd_o[i][j] = otmp[i][j];
		}
	}
	tmesh[eid].chd.clear();
	for (i = 0; i < 2; i++)
	{
		Element3D hxtmp;
		for (j = 0; j < 8; j++)
		{
			hxtmp.cnct[j] = slnew_cnct[i][j];
		}
		hxtmp.lev = tmesh[eid].lev + 1;
		hxtmp.prt = eid;
		//cout << "Assigning index...\n";
		EdgeFaceIndex_in_Solid(hxtmp, edid, fcid);
		for (j = 0; j < 5; j++)
		{
			hxtmp.nbrot[fc_rot[i][j]] = tmesh[eid].nbrot[fc_rot[i][j]];
		}
		tmesh.push_back(hxtmp);
		tmesh[eid].chd.push_back(tmesh.size() - 1);
		//cout << "Finish assigning " << tmesh.size() - 1<<"\n";
		array<double, 3> otmp;
		for (j = 0; j < 3; j++)
		{
			otmp[j] = chd_o[i][j];
		}
		tmesh[eid].chd_o.push_back(otmp);
	}

	tmesh[eid].act = 0;
}

void TruncatedTspline_3D::FaceSubdivision_4(int fcid)
{
	int pid[5];
	int edid[12];
	int i, j, loc(0), edloc(0);
	Vertex3D ptmp1;
	for (i = 0; i < 4; i++)
	{
		ptmp1.coor[0] += 0.25*cp[tmface[fcid].cnct[i]].coor[0];
		ptmp1.coor[1] += 0.25*cp[tmface[fcid].cnct[i]].coor[1];
		ptmp1.coor[2] += 0.25*cp[tmface[fcid].cnct[i]].coor[2];
	}
	cp.push_back(ptmp1); 
	pid[loc] = cp.size() - 1; loc++;
	for (i = 0; i<4; i++)//4 edges
	{
		int itmp(tmface[fcid].edge[i]);
		int dir(0);
		if (tmedge[itmp].pt[1] == tmface[fcid].cnct[i]) dir = 1;

		if (tmedge[itmp].act == 1)
		{
			EdgeSubdivision_2(itmp);//add one point and two edges
			pid[loc] = cp.size()-1; loc++;
			if (dir == 0)
			{
				edid[edloc] = tmedge.size() - 2; edloc++;
				edid[edloc] = tmedge.size() - 1; edloc++;
			}
			else
			{
				edid[edloc] = tmedge.size() - 1; edloc++;
				edid[edloc] = tmedge.size() - 2; edloc++;
			}
		}
		else
		{
			pid[loc] = tmedge[itmp].midpt; loc++;
			int ied(tmedge[itmp].chd[0]);
			if (tmedge[ied].pt[0] == tmface[fcid].cnct[i] || tmedge[ied].pt[1] == tmface[fcid].cnct[i])
			{
				edid[edloc] = ied; edloc++;
				edid[edloc] = tmedge[itmp].chd[1]; edloc++;
			}
			else
			{
				edid[edloc] = tmedge[itmp].chd[1]; edloc++;
				edid[edloc] = ied; edloc++;
			}
		}
		//construct a new edge
		Edge3D edtmp;
		edtmp.pt[0] = pid[0]; edtmp.pt[1] = tmedge[itmp].midpt;
		edtmp.lev = tmedge[tmface[fcid].edge[(i + 1) % 4]].lev+1;
		edtmp.len = tmedge[tmface[fcid].edge[(i + 1) % 4]].len/2.;
		tmedge.push_back(edtmp);
		edid[edloc] = tmedge.size() - 1; edloc++;
	}

	int e_cnct[4][4] = { { tmface[fcid].cnct[0], pid[1], pid[0], pid[4] }, { pid[1], tmface[fcid].cnct[1], pid[2], pid[0] }, 
	{ pid[0], pid[2], tmface[fcid].cnct[2], pid[3] }, { pid[4], pid[0], pid[3], tmface[fcid].cnct[3] } };
	int e_edge[4][4] = { { edid[0], edid[2], edid[11], edid[10] }, { edid[1], edid[3], edid[5], edid[2] }, 
	{ edid[5], edid[4], edid[6], edid[8] }, { edid[11], edid[8], edid[7], edid[9] } };
	int enewid[4];
	double chd_org[4][2] = { { 0., 0. }, { tmedge[tmface[fcid].edge[0]].len / 2., 0. }, 
	{ tmedge[tmface[fcid].edge[0]].len / 2., tmedge[tmface[fcid].edge[1]].len / 2. }, { 0., tmedge[tmface[fcid].edge[1]].len / 2. } };
	int Tedge_id[4] = {2,5,8,11};
	vector<Face3D> etmp(4);
	for (i = 0; i<4; i++)
	{
		etmp[i].act = 1;
		etmp[i].type = 0;
		etmp[i].lev = tmface[fcid].lev + 2;
		etmp[i].prt = fcid;
		for (int j = 0; j<4; j++)
		{
			etmp[i].cnct[j] = e_cnct[i][j];
			etmp[i].edge[j] = e_edge[i][j];
		}
		tmface.push_back(etmp[i]);
		enewid[i] = tmface.size() - 1;
		tmface[fcid].chd.push_back(enewid[i]);
		//array<double, 2> chd_o_tmp = { chd_org[i][0], chd_org[i][1] };
		//tmface[fcid].chd_o.push_back(chd_o_tmp);
		tmface[fcid].Tedge.push_back(edid[Tedge_id[i]]);
	}

	tmface[fcid].ctpt = pid[0];
	tmface[fcid].act = 0;
}

void TruncatedTspline_3D::FaceSubdivision_2(int fcid, int fc_dir)//dir (0 or 1) indicates the edge that is split
{
	int pid[2];
	int edid[5];
	int i, j, loc(0), edloc(0);
	int iloc[2] = {fc_dir, fc_dir+2};

	for (i = 0; i<2; i++)//2 edges
	{
		int itmp(tmface[fcid].edge[iloc[i]]);
		int dir(0);
		if (tmedge[itmp].pt[1] == tmface[fcid].cnct[iloc[i]]) dir = 1;

		if (tmedge[itmp].act == 1)
		{
			EdgeSubdivision_2(itmp);//add one point and two edges
			pid[loc] = cp.size() - 1; loc++;
		}
		else
		{
			pid[loc] = tmedge[itmp].midpt; loc++;
		}
		if (dir==0)
		{
			edid[edloc] = tmedge[itmp].chd[0]; edloc++;
			edid[edloc] = tmedge[itmp].chd[1]; edloc++;
		}
		else
		{
			edid[edloc] = tmedge[itmp].chd[1]; edloc++;
			edid[edloc] = tmedge[itmp].chd[0]; edloc++;
		}
	}
	//construct a new edge
	Edge3D edtmp;
	edtmp.pt[0] = tmedge[tmface[fcid].edge[iloc[0]]].midpt; edtmp.pt[1] = tmedge[tmface[fcid].edge[iloc[1]]].midpt;
	edtmp.lev = tmedge[tmface[fcid].edge[fc_dir+1]].lev;
	edtmp.len = tmedge[tmface[fcid].edge[fc_dir + 1]].len;
	tmedge.push_back(edtmp);
	edid[edloc] = tmedge.size() - 1; edloc++;

	int e_cnct[2][4] = { { tmface[fcid].cnct[fc_dir], pid[0], pid[1], tmface[fcid].cnct[(fc_dir + 3) % 4] }, { pid[0], tmface[fcid].cnct[fc_dir + 1], tmface[fcid].cnct[fc_dir + 2], pid[1] } };
	int e_edge[2][4] = { { edid[0], edid[4], edid[3], tmface[fcid].edge[(fc_dir + 3) % 4] }, { edid[1], tmface[fcid].edge[fc_dir+1], edid[2], edid[4] } };
	int enewid[2];
	//double chd_org[4][2] = { { 0., 0. }, { tmedge[tmface[fcid].edge[0]].len / 2., 0. },
	//{ tmedge[tmface[fcid].edge[0]].len / 2., tmedge[tmface[fcid].edge[1]].len / 2. }, { 0., tmedge[tmface[fcid].edge[1]].len / 2. } };
	vector<Face3D> etmp(2);
	for (i = 0; i<2; i++)
	{
		etmp[i].act = 1;
		etmp[i].type = 0;
		etmp[i].lev = tmface[fcid].lev + 1;
		etmp[i].prt = fcid;
		for (int j = 0; j<4; j++)
		{
			etmp[i].cnct[j] = e_cnct[i][j];
			etmp[i].edge[j] = e_edge[i][j];
		}
		tmface.push_back(etmp[i]);
		enewid[i] = tmface.size() - 1;
		tmface[fcid].chd.push_back(enewid[i]);
		//array<double, 2> chd_o_tmp = { chd_org[i][0], chd_org[i][1] };
		//tmface[fcid].chd_o.push_back(chd_o_tmp);
	}

	tmface[fcid].Tedge.push_back(edid[4]);
	tmface[fcid].act = 0;
}

void TruncatedTspline_3D::FaceSubdivision_24(int fcid, int fc_dir)//dir (0 or 1) indicates the edge that is to be split
{
	int pid[5];
	int edid[12];
	int i, j, loc(0), edloc(0);
	Vertex3D ptmp1;
	for (i = 0; i < 4; i++)
	{
		ptmp1.coor[0] += 0.25*cp[tmface[fcid].cnct[i]].coor[0];
		ptmp1.coor[1] += 0.25*cp[tmface[fcid].cnct[i]].coor[1];
		ptmp1.coor[2] += 0.25*cp[tmface[fcid].cnct[i]].coor[2];
	}
	cp.push_back(ptmp1);
	pid[loc] = cp.size() - 1; loc++;
	for (i = 0; i<4; i++)//4 edges
	{
		int itmp(tmface[fcid].edge[i]);
		int dir(0);
		if (tmedge[itmp].pt[1] == tmface[fcid].cnct[i]) dir = 1;

		if (tmedge[itmp].act == 1)
		{
			EdgeSubdivision_2(itmp);//add one point and two edges
			pid[loc] = cp.size() - 1; loc++;
			if (dir == 0)
			{
				edid[edloc] = tmedge.size() - 2; edloc++;
				edid[edloc] = tmedge.size() - 1; edloc++;
			}
			else
			{
				edid[edloc] = tmedge.size() - 1; edloc++;
				edid[edloc] = tmedge.size() - 2; edloc++;
			}
		}
		else
		{
			pid[loc] = tmedge[itmp].midpt; loc++;
			int ied(tmedge[itmp].chd[0]);
			if (tmedge[ied].pt[0] == tmface[fcid].cnct[i] || tmedge[ied].pt[1] == tmface[fcid].cnct[i])
			{
				edid[edloc] = ied; edloc++;
				edid[edloc] = tmedge[itmp].chd[1]; edloc++;
			}
			else
			{
				edid[edloc] = tmedge[itmp].chd[1]; edloc++;
				edid[edloc] = ied; edloc++;
			}
		}
		//construct a new edge
		Edge3D edtmp;
		edtmp.pt[0] = pid[0]; edtmp.pt[1] = tmedge[itmp].midpt;
		edtmp.lev = tmedge[tmface[fcid].edge[(i + 1) % 4]].lev + 1;
		edtmp.len = tmedge[tmface[fcid].edge[(i + 1) % 4]].len / 2.;
		tmedge.push_back(edtmp);
		edid[edloc] = tmedge.size() - 1; edloc++;
	}

	int e_cnct[4][4] = { { tmface[fcid].cnct[0], pid[1], pid[0], pid[4] }, { pid[1], tmface[fcid].cnct[1], pid[2], pid[0] },
	{ pid[0], pid[2], tmface[fcid].cnct[2], pid[3] }, { pid[4], pid[0], pid[3], tmface[fcid].cnct[3] } };
	int e_edge[4][4] = { { edid[0], edid[2], edid[11], edid[10] }, { edid[1], edid[3], edid[5], edid[2] },
	{ edid[5], edid[4], edid[6], edid[8] }, { edid[11], edid[8], edid[7], edid[9] } };
	int enewid[4];
	double chd_org[4][2] = { { 0., 0. }, { tmedge[tmface[fcid].edge[0]].len / 2., 0. },
	{ tmedge[tmface[fcid].edge[0]].len / 2., tmedge[tmface[fcid].edge[1]].len / 2. }, { 0., tmedge[tmface[fcid].edge[1]].len / 2. } };
	int Tedge_id[4] = { 2, 5, 8, 11 };
	vector<Face3D> etmp(4);
	for (i = 0; i<4; i++)
	{
		etmp[i].act = 1;
		etmp[i].type = 0;
		etmp[i].lev = tmface[fcid].lev + 2;
		etmp[i].prt = fcid;
		for (int j = 0; j<4; j++)
		{
			etmp[i].cnct[j] = e_cnct[i][j];
			etmp[i].edge[j] = e_edge[i][j];
		}
		tmface.push_back(etmp[i]);
		enewid[i] = tmface.size() - 1;
		//tmface[fcid].chd.push_back(enewid[i]);
		//tmface[fcid].Tedge.push_back(edid[Tedge_id[i]]);
	}

	int edchd[2] = {5,11};
	int fcchd[2][2] = { {0,1}, {3,2} };
	if (fc_dir == 1)
	{
		edchd[0] = 2; edchd[1] = 8;
		fcchd[0][0] = 0; fcchd[0][1] = 3;
		fcchd[1][0] = 1; fcchd[1][1] = 2;
	}
	if (tmface[fcid].Tedge.size() == 1)
	{
		tmedge[tmface[fcid].Tedge[0]].act = 0;
		tmedge[tmface[fcid].Tedge[0]].midpt = pid[0];
		for (i = 0; i < 2; i++)
		{
			tmedge[tmface[fcid].Tedge[0]].chd[i] = edid[edchd[i]];
			tmedge[edid[edchd[i]]].prt = tmface[fcid].Tedge[0];
		}
	}
	else
	{
		cerr << "Configuration of face subdivisiono is wrong!\n";
	}
	tmface[fcid].Tedge.clear();

	int Tedge_id1[2] = {2,8};
	if (fc_dir == 1)
	{
		Tedge_id1[0] = 11; Tedge_id1[1] = 5;
	}
	if (tmface[fcid].chd.size() == 2)
	{
		for (i = 0; i < 2; i++)
		{
			tmface[tmface[fcid].chd[i]].act = 0;
			tmface[tmface[fcid].chd[i]].chd.push_back(enewid[fcchd[i][0]]);
			tmface[tmface[fcid].chd[i]].chd.push_back(enewid[fcchd[i][1]]);
			tmface[tmface[fcid].chd[i]].Tedge.clear();
			tmface[tmface[fcid].chd[i]].Tedge.push_back(edid[Tedge_id1[i]]);

			//if (edid[Tedge_id1[i]] == 347)
			//{
			//	cout << "here\n"; getchar();
			//}

			//tmface[enewid[fcchd[i][0]]].prt = tmface[fcid].chd[i];
			//tmface[enewid[fcchd[i][0]]].prt = tmface[fcid].chd[i];
		}
	}
	else
	{
		cerr << "Configuration of face subdivisiono is wrong!\n";
	}
	tmface[fcid].chd.clear();
	for (i = 0; i<4; i++)
	{
		tmface[fcid].chd.push_back(enewid[i]);
		tmface[fcid].Tedge.push_back(edid[Tedge_id[i]]);
	}

	tmface[fcid].ctpt = pid[0];
	tmface[fcid].act = 0;
}

void TruncatedTspline_3D::EdgeSubdivision_2(int edid)
{
	Vertex3D ptmp;
	ptmp.coor[0] = (cp[tmedge[edid].pt[0]].coor[0] + cp[tmedge[edid].pt[1]].coor[0]) / 2.;
	ptmp.coor[1] = (cp[tmedge[edid].pt[0]].coor[1] + cp[tmedge[edid].pt[1]].coor[1]) / 2.;
	ptmp.coor[2] = (cp[tmedge[edid].pt[0]].coor[2] + cp[tmedge[edid].pt[1]].coor[2]) / 2.;
	int mid(cp.size());
	cp.push_back(ptmp);
	tmedge[edid].midpt = mid;
	Edge3D edtmp1, edtmp2;
	int chdid[2];
	//1st child edge
	edtmp1.act = 1;
	edtmp1.lev = tmedge[edid].lev + 1;
	edtmp1.pt[0] = tmedge[edid].pt[0]; edtmp1.pt[1] = mid;
	edtmp1.len = tmedge[edid].len / 2.;
	edtmp1.prt = edid;
	chdid[0] = tmedge.size();
	tmedge[edid].chd[0] = chdid[0];
	tmedge.push_back(edtmp1);
	//2nd child edge
	edtmp2.act = 1;
	edtmp2.lev = tmedge[edid].lev + 1;
	edtmp2.pt[1] = tmedge[edid].pt[1]; edtmp2.pt[0] = mid;
	edtmp2.len = tmedge[edid].len / 2.;
	edtmp2.prt = edid;
	chdid[1] = tmedge.size();
	tmedge[edid].chd[1] = chdid[1];
	tmedge.push_back(edtmp2);

	tmedge[edid].act = 0;
}

void TruncatedTspline_3D::SolidFaceDirection(int eid, int fcid, int& dir, int& pos)//fcid is the local index of the face in the solid
{
	dir = 0; pos = 0;
	int itmp(tmesh[eid].face[fcid]);
	int* it = find(tmface[itmp].cnct, tmface[itmp].cnct + 4, tmesh[eid].cnct[solid_fc[fcid][0]]);
	pos=it - tmface[itmp].cnct;
	if (it == tmface[itmp].cnct + 4)
	{
		cerr << "Cannot find point in the face!\n";
		getchar();
	}
	else
	{
		if (tmesh[eid].cnct[solid_fc[fcid][1]] != tmface[itmp].cnct[(pos + 1) % 4])
		{
			dir = 1;
		}
	}
}

void TruncatedTspline_3D::EdgeIndex_in_Face(Face3D& fc, const vector<int>& edid)
{
	for (int i = 0; i < 4; i++)
	{
		int loc(-1);
		for (uint j = 0; j < edid.size(); j++)
		{
			if ((fc.cnct[i] == tmedge[edid[j]].pt[0] && fc.cnct[(i + 1) % 4] == tmedge[edid[j]].pt[1]) ||
				(fc.cnct[i] == tmedge[edid[j]].pt[1] && fc.cnct[(i + 1) % 4] == tmedge[edid[j]].pt[0]))
			{
				loc = j; break;
			}
		}
		if (loc == -1)
		{
			loc = 0;
			cout << "Cant't find edge in face\n";
			getchar();
		}
		fc.edge[i] = edid[loc];
	}
}

void TruncatedTspline_3D::EdgeFaceIndex_in_Solid(Element3D& hx, const vector<int>& edid, const vector<int>& fcid)
{
	for (int i = 0; i < 12; i++)
	{
		int loc(-1);
		for (uint j = 0; j < edid.size(); j++)
		{
			if ((hx.cnct[solid_ed[i][0]] == tmedge[edid[j]].pt[0] && hx.cnct[solid_ed[i][1]] == tmedge[edid[j]].pt[1]) ||
				(hx.cnct[solid_ed[i][0]] == tmedge[edid[j]].pt[1] && hx.cnct[solid_ed[i][1]] == tmedge[edid[j]].pt[0]))
			{
				loc = j; break;
			}
		}
		if (loc == -1)
		{
			loc = 0;
			cout << "Can't find edge in a solid\n";
			getchar();
		}
		hx.edge[i] = edid[loc];
	}
	for (int i = 0; i < 6; i++)
	{
		int loc(-1);
		array<int, 4> cnct1 = { hx.cnct[solid_fc[i][0]], hx.cnct[solid_fc[i][1]], hx.cnct[solid_fc[i][2]], hx.cnct[solid_fc[i][3]]};
		sort(cnct1.begin(),cnct1.end());
		for (uint j = 0; j < fcid.size(); j++)
		{
			array<int, 4> cnct2 = { tmface[fcid[j]].cnct[0], tmface[fcid[j]].cnct[1], tmface[fcid[j]].cnct[2], tmface[fcid[j]].cnct[3]};
			sort(cnct2.begin(), cnct2.end());
			if (cnct1==cnct2)
			{
				loc = j; break;
			}
		}
		if (loc == -1)
		{
			loc = 0;
			cout << "Can't find face in a solid\n";
			cout << hx.cnct[solid_fc[i][0]] << " " << hx.cnct[solid_fc[i][1]] << " " << hx.cnct[solid_fc[i][2]] << " " << hx.cnct[solid_fc[i][3]] << "\n";
			getchar();
		}
		hx.face[i] = fcid[loc];
	}
}

void TruncatedTspline_3D::Index_Direction(int eid, int vloc[8], int edloc[12], int fcloc[6], int dir)
{
	int i;
	if (dir == 0)//x direction
	{
		for (i = 0; i < 8; i++) vloc[i] = tmesh[eid].cnct[i];
		for (i = 0; i < 12; i++) vloc[i] = tmesh[eid].edge[i];
		for (i = 0; i < 6; i++) vloc[i] = tmesh[eid].face[i];
	}
	else if (dir == 1)//y
	{
	}
	else//z
	{
	}
}

void TruncatedTspline_3D::Construct_NewEdge(int pt[2], int lev, double len)
{
	Edge3D edtmp;
	edtmp.pt[0] = pt[0]; edtmp.pt[1] = pt[1];
	edtmp.lev = lev;
	edtmp.len = len;
	tmedge.push_back(edtmp);
}

void TruncatedTspline_3D::Construct_BaseFace_Subdv(int fcid, int dir, int& ed_base, int fc_base[2])
{
	int edid[7];
	int iloc[2] = {dir,dir+2};
	for (int i = 0; i < 2; i++)
	{
		edid[2 * i] = tmedge[tmface[fcid].edge[iloc[i]]].chd[0];
		edid[2 * i+1] = tmedge[tmface[fcid].edge[iloc[i]]].chd[1];
		if (tmedge[edid[2 * i]].pt[0] != tmface[fcid].cnct[iloc[i]] && tmedge[edid[2 * i]].pt[1] != tmface[fcid].cnct[iloc[i]])
		{
			edid[2 * i] = tmedge[tmface[fcid].edge[iloc[i]]].chd[1];
			edid[2 * i + 1] = tmedge[tmface[fcid].edge[iloc[i]]].chd[0];
		}
	}
	edid[4] = tmface[fcid].edge[dir+1];
	edid[5] = tmface[fcid].edge[(dir + 3)%4];
	//construct base edge
	Edge3D etmp;
	etmp.act = 0;
	etmp.pt[0] = tmedge[tmface[fcid].edge[dir]].midpt;
	etmp.pt[1] = tmedge[tmface[fcid].edge[dir + 2]].midpt;
	etmp.lev = tmedge[tmface[fcid].edge[dir+1]].lev;
	etmp.len = tmedge[tmface[fcid].edge[dir + 1]].len;
	etmp.midpt = tmface[fcid].ctpt;
	etmp.chd[0] = tmface[fcid].Tedge[dir];
	etmp.chd[1] = tmface[fcid].Tedge[dir + 2];
	tmedge.push_back(etmp);
	edid[6] = tmedge.size() - 1;
	tmedge[tmface[fcid].Tedge[dir]].prt = edid[6];
	tmedge[tmface[fcid].Tedge[dir + 2]].prt = edid[6];

	//construct base face
	int fcnew_cnct[2][4] = { { tmface[fcid].cnct[dir], etmp.pt[0], etmp.pt[1], tmface[fcid].cnct[(dir + 3) % 4] }, 
	{ etmp.pt[0], tmface[fcid].cnct[dir + 1], tmface[fcid].cnct[dir + 2], etmp.pt[1] } };
	int fcnew_edge[2][4] = { { edid[0], edid[6], edid[3], edid[5] }, { edid[1], edid[4], edid[2], edid[6] }};
	int fc_chd[2][2] = { { tmface[fcid].chd[dir], tmface[fcid].chd[(dir + 3) % 4] }, { tmface[fcid].chd[dir + 1], tmface[fcid].chd[dir + 2] } };
	int fc_Ted[2] = { tmface[fcid].Tedge[(dir+3)%4], tmface[fcid].Tedge[dir+1] };
	for (int i = 0; i < 2; i++)
	{
		Face3D fctmp;
		fctmp.act = 0;
		fctmp.lev = tmface[fcid].lev - 1;
		for (int j = 0; j < 4; j++)
		{
			fctmp.cnct[j] = fcnew_cnct[i][j];
			fctmp.edge[j] = fcnew_edge[i][j];
		}
		fctmp.chd.push_back(fc_chd[i][0]);
		fctmp.chd.push_back(fc_chd[i][1]);
		fctmp.Tedge.push_back(fc_Ted[i]);
		tmface.push_back(fctmp);
		tmface[fc_chd[i][0]].prt = tmface.size() - 1;
		tmface[fc_chd[i][1]].prt = tmface.size() - 1;

		//if (fc_Ted[i] == 347)
		//{
		//	cout << "here\n"; getchar();
		//}
	}

	ed_base = edid[6];
	fc_base[0] = tmface.size() - 2;
	fc_base[1] = tmface.size() - 1;
}

//void TruncatedTspline_3D::Truncation()
//{
//	int diag[8] = { 6, 7, 4, 5, 2, 3, 0, 1 };
//	for (uint i = 0; i < tmesh.size(); i++)
//	{
//		if (tmesh[i].act == 1 && tmesh[i].type == 0)
//		{
//			vector<int> fcnb;
//			for (uint j = 0; j < 6; j++)
//			{
//				if (tmface[tmesh[i].face[j]].act == 1)
//				{
//					int tmp(tmface[tmesh[i].face[j]].hex[0]);
//					if (tmp == i) tmp = tmface[tmesh[i].face[j]].hex[1];
//					fcnb.push_back(tmp);
//				}
//				else
//				{
//					for (uint k = 0; k < tmface[tmesh[i].face[j]].chd.size(); k++)
//					{
//						int tmp(tmface[tmface[tmesh[i].face[j]].chd[k]].hex[0]);
//						if (tmp == i) tmp = tmface[tmface[tmesh[i].face[j]].chd[k]].hex[1];
//						fcnb.push_back(tmp);
//					}
//				}
//			}
//			int dc(-1), crnb(-1);
//			for (int j = 0; j < 8; j++)
//			{
//				for (uint k = 0; k < cp[tmesh[i].cnct[j]].hex.size(); k++)
//				{
//					if (tmesh[cp[tmesh[i].cnct[j]].hex[k]].lev == tmesh[i].lev - 3)
//					{
//						vector<int>::iterator it = find(fcnb.begin(), fcnb.end(), cp[tmesh[i].cnct[j]].hex[k]);
//						int hxid(cp[tmesh[i].cnct[j]].hex[k]);
//						int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[i].cnct[j]);
//						if (it == fcnb.end() && it1 != tmesh[hxid].cnct + 8)
//						{
//							crnb = cp[tmesh[i].cnct[j]].hex[k];
//							dc = tmesh[i].cnct[j];
//							break;
//						}
//					}
//				}
//				if (dc != -1) break;
//			}
//			if (dc!=-1)
//			{
//				int* it = find(tmesh[crnb].cnct, tmesh[crnb].cnct+8, dc);
//				if (it != tmesh[crnb].cnct + 8)
//				{
//					int pos(it - tmesh[crnb].cnct);
//					int trid(tmesh[crnb].cnct[diag[pos]]);
//					cout << "trid: " << trid << "\n";
//					cout << "dc: " << dc << "\n";
//					getchar();
//					vector<int>::iterator it1 = find(tmesh[i].IEN.begin(), tmesh[i].IEN.end(), dc);
//					int pos1(it1 - tmesh[i].IEN.begin());
//					vector<int>::iterator it2 = find(tmesh[i].IEN.begin(), tmesh[i].IEN.end(), trid);
//					int pos2(it2 - tmesh[i].IEN.begin());
//					if (CheckSubKnotVector(tmesh[i].patch_ku[pos1], tmesh[i].patch_kv[pos1], tmesh[i].patch_kw[pos1], tmesh[i].patch_ku[pos2], tmesh[i].patch_kv[pos2], tmesh[i].patch_kw[pos2]))
//					{
//					vector<double> ku1(10), kv1(10), kw1(10);
//					vector<vector<double>> Tu, Tv, Tw;
//					vector<double> ku(tmesh[i].patch_ku[pos2].begin(), tmesh[i].patch_ku[pos2].end());
//					vector<double> kv(tmesh[i].patch_kv[pos2].begin(), tmesh[i].patch_kv[pos2].end());
//					vector<double> kw(tmesh[i].patch_kw[pos2].begin(), tmesh[i].patch_kw[pos2].end());
//					vector<double>::iterator it1, it2, it3;
//					it1 = set_union(tmesh[i].patch_ku[pos2].begin(), tmesh[i].patch_ku[pos2].end(), tmesh[i].patch_ku[pos1].begin(), tmesh[i].patch_ku[pos1].end(), ku1.begin());
//					it2 = set_union(tmesh[i].patch_kv[pos2].begin(), tmesh[i].patch_kv[pos2].end(), tmesh[i].patch_kv[pos1].begin(), tmesh[i].patch_kv[pos1].end(), kv1.begin());
//					it3 = set_union(tmesh[i].patch_kw[pos2].begin(), tmesh[i].patch_kw[pos2].end(), tmesh[i].patch_kw[pos1].begin(), tmesh[i].patch_kw[pos1].end(), kw1.begin());
//					ku1.resize(it1 - ku1.begin());
//					kv1.resize(it2 - kv1.begin());
//					kw1.resize(it3 - kw1.begin());
//					TMatrix(ku, ku1, 3, Tu);
//					TMatrix(kv, kv1, 3, Tv);
//					TMatrix(kw, kw1, 3, Tw);
//					it1 = search(ku1.begin(), ku1.end(), tmesh[i].patch_ku[pos1].begin(), tmesh[i].patch_ku[pos1].end());
//					it2 = search(kv1.begin(), kv1.end(), tmesh[i].patch_kv[pos1].begin(), tmesh[i].patch_kv[pos1].end());
//					it3 = search(kw1.begin(), kw1.end(), tmesh[i].patch_kw[pos1].begin(), tmesh[i].patch_kw[pos1].end());
//					if (it1 != ku1.end() && it2 != kv1.end() && it3 != kw1.end())
//					{
//					int loc1 = it1 - ku1.begin();
//					int loc2 = it2 - kv1.begin();
//					int loc3 = it3 - kw1.begin();
//					double tc = Tu[loc1][0] * Tv[loc2][0] * Tw[loc3][0];
//					cp[trid].trun = 1;
//					cp[trid].tbf.push_back(dc);
//					cp[trid].tc.push_back(tc);
//					}
//					}
//				}
//			}
//		}
//	}
//}

void TruncatedTspline_3D::Truncation()
{
	for (uint i = 0; i < tmesh.size(); i++)
	{
		if (tmesh[i].act == 1 && tmesh[i].type == 0)
		{
			for (uint j = 0; j < tmesh[i].IEN.size(); j++)//trun
			{
				for (uint k = 0; k < tmesh[i].IEN.size(); k++)//child
				{
					if (j != k)
					{
						int pos1(k), pos2(j);
						if (CheckSubKnotVector(tmesh[i].patch_ku[pos1], tmesh[i].patch_kv[pos1], tmesh[i].patch_kw[pos1], tmesh[i].patch_ku[pos2], tmesh[i].patch_kv[pos2], tmesh[i].patch_kw[pos2]))
						{
							vector<double> ku1(10), kv1(10), kw1(10);
							vector<vector<double>> Tu, Tv, Tw;
							vector<double> ku(tmesh[i].patch_ku[pos2].begin(), tmesh[i].patch_ku[pos2].end());
							vector<double> kv(tmesh[i].patch_kv[pos2].begin(), tmesh[i].patch_kv[pos2].end());
							vector<double> kw(tmesh[i].patch_kw[pos2].begin(), tmesh[i].patch_kw[pos2].end());
							vector<double>::iterator it1, it2, it3;
							it1 = set_union(tmesh[i].patch_ku[pos2].begin(), tmesh[i].patch_ku[pos2].end(), tmesh[i].patch_ku[pos1].begin(), tmesh[i].patch_ku[pos1].end(), ku1.begin());
							it2 = set_union(tmesh[i].patch_kv[pos2].begin(), tmesh[i].patch_kv[pos2].end(), tmesh[i].patch_kv[pos1].begin(), tmesh[i].patch_kv[pos1].end(), kv1.begin());
							it3 = set_union(tmesh[i].patch_kw[pos2].begin(), tmesh[i].patch_kw[pos2].end(), tmesh[i].patch_kw[pos1].begin(), tmesh[i].patch_kw[pos1].end(), kw1.begin());
							ku1.resize(it1 - ku1.begin());
							kv1.resize(it2 - kv1.begin());
							kw1.resize(it3 - kw1.begin());
							TMatrix(ku, ku1, 3, Tu);
							TMatrix(kv, kv1, 3, Tv);
							TMatrix(kw, kw1, 3, Tw);
							it1 = search(ku1.begin(), ku1.end(), tmesh[i].patch_ku[pos1].begin(), tmesh[i].patch_ku[pos1].end());
							it2 = search(kv1.begin(), kv1.end(), tmesh[i].patch_kv[pos1].begin(), tmesh[i].patch_kv[pos1].end());
							it3 = search(kw1.begin(), kw1.end(), tmesh[i].patch_kw[pos1].begin(), tmesh[i].patch_kw[pos1].end());
							if (it1 != ku1.end() && it2 != kv1.end() && it3 != kw1.end())
							{
								int loc1 = it1 - ku1.begin();
								int loc2 = it2 - kv1.begin();
								int loc3 = it3 - kw1.begin();
								double tc = Tu[loc1][0] * Tv[loc2][0] * Tw[loc3][0];
								if (tc != 0.)
								{
									cp[tmesh[i].IEN[j]].trun = 1;
									vector<int>::iterator it = find(cp[tmesh[i].IEN[j]].tbf.begin(), cp[tmesh[i].IEN[j]].tbf.end(), tmesh[i].IEN[k]);
									if (it == cp[tmesh[i].IEN[j]].tbf.end())
									{
										cp[tmesh[i].IEN[j]].tbf.push_back(tmesh[i].IEN[k]);
										cp[tmesh[i].IEN[j]].tc.push_back(tc);
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::IdentifyTarget(vector<int>& target)
{
	target.clear();
	//int rfid(-1), pid(2 * 25 + 2 * 5 + 2);//pid(124), pid(2*25+2*5+2)
	//for (uint i = 0; i < tmesh.size(); i++)
	//{
	//	for (int j = 0; j < 8; j++)
	//	{
	//		if (tmesh[i].cnct[j] == pid)
	//		{
	//			rfid = i; break;
	//		}
	//		if (rfid != -1) break;
	//	}
	//}
	//target.push_back(rfid);
	//for (uint i = 0; i < cp[pid].hex.size(); i++)
	//{
	//	int flag(0);
	//	for (uint j = 0; j < 12; j++)
	//	{
	//		for (uint k = 0; k < tmedge[tmesh[cp[pid].hex[i]].edge[j]].hex.size(); k++)
	//		{
	//			if (tmedge[tmesh[cp[pid].hex[i]].edge[j]].hex[k] == rfid)//share an edge with rfid
	//			{
	//				flag = 1; break;
	//			}
	//		}
	//	}
	//	if (flag == 0)
	//	{
	//		target.push_back(cp[pid].hex[i]); break;
	//	}
	//}

	//for (uint i = 0; i < target.size(); i++)
	//{
	//	//ElementSubdivide_8(target[i]);
	//	cout << target[i] << "\n";
	//}
	//getchar();

	//cube5-targets
	int nh(9);
	for (int i = 1; i < nh-1; i++)
	{
		target.push_back(i*nh*nh+i*nh+i);
	}
}

void TruncatedTspline_3D::IdentifyAddition(vector<int>& target)
{
	uint i, j, k;
	for (i = 0; i < tmesh.size(); i++) tmesh[i].ref_flag = 0;
	for (i = 0; i < target.size(); i++) tmesh[target[i]].ref_flag = 1;//subdv into 8
	for (i = 0; i < cp.size(); i++)
	{
		if (cp[i].type == 0)//interior regular node
		{
			int nref(0);
			for (j = 0; j < cp[i].hex.size(); j++)
			{
				if (tmesh[cp[i].hex[j]].ref_flag == 1) nref++;
			}
			if (nref>0 && nref < 8)
			{
				int ref3d(0);
				for (j = 0; j < cp[i].edge.size(); j++)
				{
					int nref_ed(0);
					for (k = 0; k < tmedge[cp[i].edge[j]].hex.size(); k++)
					{
						if (tmesh[tmedge[cp[i].edge[j]].hex[k]].ref_flag == 1) nref_ed++;
					}
					if (nref_ed>0 && nref_ed < nref)//3D case
					{
						ref3d = 1;
					}
				}
				if (ref3d == 1)
				{
					for (j = 0; j < cp[i].hex.size(); j++)
					{
						if (tmesh[cp[i].hex[j]].ref_flag != 1) tmesh[cp[i].hex[j]].ref_flag = 21;//tmp
					}
				}
			}
		}
	}

	//int sub4[4] = {22,25,38,41};
	//int sub2[2] = { 26,37 };
	//for (i = 0; i < 4; i++) tmesh[sub4[i]].ref_flag = 23;
	//for (i = 0; i < 2; i++) tmesh[sub2[i]].ref_flag = 31;

	//int sub8[2] = { 1 * 5 * 5 + 1 * 5 + 1, 3 * 5 * 5 + 3 * 5 + 3};

	//tmesh[sub8[0]].ref_flag = 1;
	//tmesh[sub8[1]].ref_flag = 1;
}

bool TruncatedTspline_3D::IdentifyAddition()
{
	uint i, j, k;
	vector<int> r1;
	int flag(0);
	for (i = 0; i < tmesh.size(); i++)
	{
		if (tmesh[i].act == 1 && tmesh[i].ref_flag==1)
		{
			for (j = 0; j < 8; j++)
			{
				for (k = 0; k < cp[tmesh[i].cnct[j]].hex.size(); k++)
				{
					int hxid(cp[tmesh[i].cnct[j]].hex[k]);
					if (hxid != i && tmesh[hxid].ref_flag==0)
					{
						vector<int>::iterator it2 = find(r1.begin(), r1.end(), hxid);
						if (it2 == r1.end())
						{
							r1.push_back(hxid);
						}
					}
				}
			}
		}
	}

	for (i = 0; i < r1.size(); i++)
	{
		int flag_fc(0), flag_ed(0), flag_vt(0);
		vector<int> fcnb, ednb, vtnb;
		for (j = 0; j < 6; j++)
		{
			int fcid(tmesh[r1[i]].face[j]);
			if (tmface[fcid].hex.size() == 2)
			{
				int tmp1(tmface[fcid].hex[0]);
				if (tmp1 == r1[i]) tmp1 = tmface[fcid].hex[1];
				fcnb.push_back(tmp1);
			}
		}
		for (j = 0; j < 12; j++)
		{
			int edid(tmesh[r1[i]].edge[j]);
			if (tmedge[edid].hex.size() == 4)
			{
				for (k = 0; k < tmedge[edid].hex.size(); k++)
				{
					if (tmedge[edid].hex[k] != r1[i])
					{
						vector<int>::iterator it = find(fcnb.begin(), fcnb.end(), tmedge[edid].hex[k]);
						if (it == fcnb.end())
						{
							ednb.push_back(tmedge[edid].hex[k]);
							break;
						}
					}
				}
			}
		}
		for (j = 0; j < 8; j++)
		{
			int pid(tmesh[r1[i]].cnct[j]);
			if (cp[pid].hex.size() == 8)
			{
				for (k = 0; k < cp[pid].hex.size(); k++)
				{
					if (cp[pid].hex[k] != r1[i])
					{
						vector<int>::iterator it1 = find(fcnb.begin(), fcnb.end(), cp[pid].hex[k]);
						vector<int>::iterator it2 = find(ednb.begin(), ednb.end(), cp[pid].hex[k]);
						if (it1 == fcnb.end() && it2 == ednb.end())
						{
							vtnb.push_back(cp[pid].hex[k]);
							break;
						}
					}
				}
			}
		}

		for (j = 0; j < fcnb.size(); j++)
		{
			if (tmesh[fcnb[j]].ref_flag == 1) flag_fc++;
		}
		for (j = 0; j < ednb.size(); j++)
		{
			if (tmesh[ednb[j]].ref_flag == 1) flag_ed++;
		}
		for (j = 0; j < vtnb.size(); j++)
		{
			if (tmesh[vtnb[j]].ref_flag == 1) flag_vt++;
		}

		if (flag_fc == 1 && flag_ed==0 && flag_vt != 0)
		{
			//no finished
			tmesh[r1[i]].ref_flag = 1;
			flag = 1;
		}
		else if (flag_fc == 0 && (flag_vt != 0 || flag_ed!=0))
		{
			tmesh[r1[i]].ref_flag = 1;
			flag = 1;
		}
	}

	if (flag == 1) return true;
	else return false;
}

bool TruncatedTspline_3D::Identify_FaceFace(int eid)//apply this one first until no such case
{
	int nfc(0);
	for (int i = 0; i < 6; i++)
	{
		if (tmface[tmesh[eid].face[i]].ctpt != -1) nfc++;
	}
	if (nfc < 2) return false;
	else if (nfc == 2)
	{
		if (tmface[tmesh[eid].face[0]].act == 0 && tmface[tmesh[eid].face[5]].act == 0)//opposite pair, split into 4
		{
			tmesh[eid].ref_flag = 23;//w direction
		}
		else if (tmface[tmesh[eid].face[1]].act == 0 && tmface[tmesh[eid].face[3]].act == 0)//opposite pair, split into 4
		{
			tmesh[eid].ref_flag = 22;//v direction
		}
		else if (tmface[tmesh[eid].face[2]].act == 0 && tmface[tmesh[eid].face[4]].act == 0)//opposite pair, split into 4
		{
			tmesh[eid].ref_flag = 21;//u direction
		}
		else if ((tmface[tmesh[eid].face[0]].act == 0 || tmface[tmesh[eid].face[5]].act == 0) && (tmface[tmesh[eid].face[1]].act == 0 || tmface[tmesh[eid].face[3]].act == 0))
		{
			tmesh[eid].ref_flag = 32;//v direction
		}
		else if ((tmface[tmesh[eid].face[0]].act == 0 || tmface[tmesh[eid].face[5]].act == 0) && (tmface[tmesh[eid].face[2]].act == 0 || tmface[tmesh[eid].face[4]].act == 0))
		{
			tmesh[eid].ref_flag = 31;//u direction
		}
		else if ((tmface[tmesh[eid].face[1]].act == 0 || tmface[tmesh[eid].face[3]].act == 0) && (tmface[tmesh[eid].face[2]].act == 0 || tmface[tmesh[eid].face[4]].act == 0))
		{
			tmesh[eid].ref_flag = 33;//v direction
		}
		return true;
	}
	else if (nfc == 3 || nfc == 4)
	{
		if (tmface[tmesh[eid].face[0]].act == 0 && tmface[tmesh[eid].face[5]].act == 0)//opposite pair, split into 4
		{
			tmesh[eid].ref_flag = 23;//w direction
		}
		else if (tmface[tmesh[eid].face[1]].act == 0 && tmface[tmesh[eid].face[3]].act == 0)//opposite pair, split into 4
		{
			tmesh[eid].ref_flag = 22;//v direction
		}
		else if (tmface[tmesh[eid].face[2]].act == 0 && tmface[tmesh[eid].face[4]].act == 0)//opposite pair, split into 4
		{
			tmesh[eid].ref_flag = 21;//u direction
		}
		else
		{
			tmesh[eid].ref_flag = 21;//u direction
		}
		return true;
	}
	else if (nfc > 4)
	{
		tmesh[eid].ref_flag = 1;//subdivide into 8
		return true;
	}
	return false;
}

bool TruncatedTspline_3D::Identify_FaceEdge(int eid)
{
	int nfc(0), pos(0);
	for (int i = 0; i < 6; i++)
	{
		if (tmface[tmesh[eid].face[i]].ctpt != -1)
		{
			pos = i; nfc++;
		}
	}
	if (nfc != 1) return false;

	int edppd[6][4] = { { 4, 5, 6, 7 }, { 1, 3, 9, 11 }, { 0, 2, 8, 10 }, { 1, 3, 9, 11 }, { 0, 2, 8, 10 }, { 4, 5, 6, 7 } };
	int edopo[6][4] = { { 8, 9, 10, 11 }, { 2, 6, 10, 7 }, { 3, 7, 11, 4 }, { 0, 5, 8, 4 }, { 1, 6, 9, 5 }, {0,1,2,3} };
	int opo_dir[6][4] = { { 1, 2, 1, 2 }, { 1, 3, 1, 3 }, { 2, 3, 2, 3 }, { 1, 3, 1, 3 }, { 2, 3, 2, 3 }, {1,2,1,2} };
	int ref_dir[3] = {0,0,0};
	int flag_ppd(0), flag_opo(0);
	for (int i = 0; i < 4; i++)
	{
		if (tmedge[tmesh[eid].edge[edppd[pos][i]]].act == 0) flag_ppd++;
		if (tmedge[tmesh[eid].edge[edopo[pos][i]]].act == 0) flag_opo++;
	}

	if (flag_ppd != 0) 
	{
		if (pos == 0 || pos == 5) ref_dir[2] = 1;
		else if (pos == 1 || pos == 3) ref_dir[1] = 1;
		else ref_dir[0] = 1;
	}
	if (flag_opo == 1)
	{
		if (tmedge[tmesh[eid].edge[edopo[pos][0]]].act == 0 || tmedge[tmesh[eid].edge[edopo[pos][2]]].act == 0)
		{
			ref_dir[opo_dir[pos][0]-1] = 1;
		}
		else
		{
			ref_dir[opo_dir[pos][1] - 1] = 1;
		}
	}
	else if (flag_opo == 2)
	{
		if (tmedge[tmesh[eid].edge[edopo[pos][0]]].act == 0 && tmedge[tmesh[eid].edge[edopo[pos][2]]].act == 0)
		{
			ref_dir[opo_dir[pos][0] - 1] = 1;
		}
		else if (tmedge[tmesh[eid].edge[edopo[pos][1]]].act == 0 && tmedge[tmesh[eid].edge[edopo[pos][3]]].act == 0)
		{
			ref_dir[opo_dir[pos][1] - 1] = 1;
		}
		else
		{
			ref_dir[opo_dir[pos][0] - 1] = 1; ref_dir[opo_dir[pos][1] - 1] = 1;
		}
	}
	else if (flag_opo == 3 || flag_opo == 4)
	{
		ref_dir[opo_dir[pos][0] - 1] = 1; ref_dir[opo_dir[pos][1] - 1] = 1;
	}

	if (ref_dir[0] == 1 && ref_dir[1] == 1 && ref_dir[2] == 1)
	{
		tmesh[eid].ref_flag = 1;
		return true;
	}
	else if (ref_dir[0] == 0 && ref_dir[1] == 1 && ref_dir[2] == 1)
	{
		tmesh[eid].ref_flag = 21;
		return true;
	}
	else if (ref_dir[0] == 1 && ref_dir[1] == 0 && ref_dir[2] == 1)
	{
		tmesh[eid].ref_flag = 22;
		return true;
	}
	else if (ref_dir[0] == 1 && ref_dir[1] == 1 && ref_dir[2] == 0)
	{
		tmesh[eid].ref_flag = 23;
		return true;
	}
	else if (ref_dir[0] == 1 && ref_dir[1] == 0 && ref_dir[2] == 0)
	{
		tmesh[eid].ref_flag = 31;
		return true;
	}
	else if (ref_dir[0] == 0 && ref_dir[1] == 1 && ref_dir[2] == 0)
	{
		tmesh[eid].ref_flag = 32;
		return true;
	}
	else if (ref_dir[0] == 0 && ref_dir[1] == 0 && ref_dir[2] == 1)
	{
		tmesh[eid].ref_flag = 33;
		return true;
	}
	else
	{
		return false;
	}

	//if (flag_ppd != 0 && flag_opo == 0)
	//{
	//	if (pos == 0 || pos == 5) tmesh[eid].ref_flag = 33;//w direction
	//	else if (pos == 1 || pos == 3) tmesh[eid].ref_flag = 32;//v direction
	//	else if (pos == 2 || pos == 4) tmesh[eid].ref_flag = 31;//u direction
	//	return true;
	//}
	//else if (flag_ppd == 0 && flag_opo != 0)
	//{

	//}
	//else if (flag_ppd != 0 && flag_opo != 0)
	//{
	//}
	//else
	//{
	//	return false;
	//}

	//int fcid(tmesh[eid].face[pos]);
	//for (int i = 0; i < 4; i++)
	//{
	//	for (int j = 0; j < 4; j++)
	//	{
	//		int edid(tmface[tmesh[eid].face[edppd[pos][i]]].edge[j]);
	//		int* it = find(tmface[fcid].edge, tmface[fcid].edge+4, edid);
	//		int edpos = it - tmface[fcid].edge;

	//	}
	//}
}

bool TruncatedTspline_3D::Template_FaceFace()
{
	bool flag(false);
	for (uint i = 0; i < tmesh.size(); i++)
	{
		if (tmesh[i].act == 1 && tmesh[i].ref_flag == 0 && Identify_FaceFace(i))
		{
			flag = true;
			if (tmesh[i].ref_flag == 1) ElementSubdivide_8(i);
			else if (tmesh[i].ref_flag == 21) ElementSubdivide_4(i, 0);
			else if (tmesh[i].ref_flag == 22) ElementSubdivide_4(i, 1);
			else if (tmesh[i].ref_flag == 23) ElementSubdivide_4(i, 2);
			else if (tmesh[i].ref_flag == 31) ElementSubdivide_2(i, 0);
			else if (tmesh[i].ref_flag == 32) ElementSubdivide_2(i, 1);
			else if (tmesh[i].ref_flag == 33) ElementSubdivide_2(i, 2);
		}
	}
	return flag;
}

bool TruncatedTspline_3D::Template_FaceEdge()
{
	bool flag(false);
	for (uint i = 0; i < tmesh.size(); i++)
	{
		if (tmesh[i].act == 1 && tmesh[i].ref_flag == 0 && Identify_FaceEdge(i))
		{
			flag = true;
			if (tmesh[i].ref_flag == 1) ElementSubdivide_8(i);
			else if (tmesh[i].ref_flag == 21) ElementSubdivide_4(i, 0);
			else if (tmesh[i].ref_flag == 22) ElementSubdivide_4(i, 1);
			else if (tmesh[i].ref_flag == 23) ElementSubdivide_4(i, 2);
			else if (tmesh[i].ref_flag == 31) ElementSubdivide_2(i, 0);
			else if (tmesh[i].ref_flag == 32) ElementSubdivide_2(i, 1);
			else if (tmesh[i].ref_flag == 33) ElementSubdivide_2(i, 2);
		}
	}
	return flag;
}

void TruncatedTspline_3D::RefineTopology()
{
	npt_old = cp.size();
	nel_old = tmesh.size();
	vector<int> target;
	IdentifyTarget(target);
	IdentifyAddition(target);
	//int nloop(0), loop_max(50);
	//while (Template_FaceFace() && nloop<loop_max)
	//{
	//	nloop++;
	//}
	//cout << "# of loops for face-face template: " << nloop << "\n";
	////getchar();
	//nloop = 0;
	//while (Template_FaceEdge() && nloop<loop_max)
	//{
	//	nloop++;
	//}
	//cout << "# of loops for face-face template: " << nloop << "\n";
	////getchar();

	for (uint i = 0; i < tmesh.size(); i++)
	{
		if (tmesh[i].ref_flag == 1) ElementSubdivide_8(i);
		else if (tmesh[i].ref_flag == 21) ElementSubdivide_4(i, 0);
		else if (tmesh[i].ref_flag == 22) ElementSubdivide_4(i, 1);
		else if (tmesh[i].ref_flag == 23) ElementSubdivide_4(i, 2);
		else if (tmesh[i].ref_flag == 31) ElementSubdivide_2(i,0);
		else if (tmesh[i].ref_flag == 32) ElementSubdivide_2(i, 1);
		else if (tmesh[i].ref_flag == 33) ElementSubdivide_2(i, 2);
	}
}

void TruncatedTspline_3D::RefineGeometry()
{
	CollectActives();
	UpdateConnect();
	FindEdgeTopoDirec();
	FindKnotInterval();

	//int kv_mod[2] = {42,82};
	//for (int i = 0; i < 2; i++)
	//{
	//	for (int j = 0; j < 4; j++)
	//	{
	//		cp[kv_mod[i]].kitvU[j] = 1.;
	//		cp[kv_mod[i]].kitvV[j] = 1.;
	//		cp[kv_mod[i]].kitvW[j] = 1.;
	//	}
	//}

	//int edid(403);
	//cout << "neighbor faces: ";
	//for (uint i = 0; i < tmedge[edid].face.size(); i++)
	//{
	//	cout << tmface[tmedge[edid].face[i]].id_act << " ";
	//}
	//cout << "\n";
	//getchar();
	//cout << "neighbor hex:\n";
	//for (uint i = 0; i < tmedge[edid].hex.size(); i++)
	//{
	//	cout << "hex id: "<< tmesh[tmedge[edid].hex[i]].id_act << "\n";
	//	for (int j = 0; j < 6; j++)
	//	{
	//		cout << tmface[tmesh[tmedge[edid].hex[i]].face[j]].id_act << "(" << tmface[tmesh[tmedge[edid].hex[i]].face[j]].act << ")  ";
	//	}
	//	cout << "\n";
	//}
	//cout << "\n";
	//getchar();
	//cout << tmesh[75].id_act << " " << tmesh[78].id_act << "\n";
	//getchar();

	//for (uint i = 0; i < cp.size(); i++)
	//{
	//	if (i==159)
	//	{
	//		cout << "pid: " << i << "\n";
	//		cout << "uv edges: " << cp[i].uved[0] << " " << cp[i].uved[1] << " " << cp[i].uved[2] << "\n";
	//		cout << "uv edges: " << tmedge[cp[i].uved[0]].id_act << " " << tmedge[cp[i].uved[1]].id_act << " " << tmedge[cp[i].uved[2]].id_act << "\n";
	//		cout << "pt[0] "<< tmedge[cp[i].uved[0]].pt[0] << ": " << tmedge[cp[i].uved[0]].pn[0][0] << "(type), " << tmedge[cp[i].uved[0]].pn[0][1] << "(ID)\n";
	//		cout << "pt[1] " << tmedge[cp[i].uved[0]].pt[1] << ": " << tmedge[cp[i].uved[0]].pn[1][0] << "(type), " << tmedge[cp[i].uved[0]].pn[1][1] << "(ID)\n";
	//		cout << "kitU: ";
	//		for (int j = 0; j < 4; j++) cout << cp[i].kitvU[j] << " ";
	//		cout << "\n";
	//		cout << "kitV: ";
	//		for (int j = 0; j < 4; j++) cout << cp[i].kitvV[j] << " ";
	//		cout << "\n";
	//		cout << "kitW: ";
	//		for (int j = 0; j < 4; j++) cout << cp[i].kitvW[j] << " ";
	//		cout << "\n";
	//		getchar();
	//	}
	//}

	SetLocalCoorSystem();
	FindIEN_PatchKV();
	//Update_IEN();

	Truncation();

	//int pid(33);
	//cout << "pid " << pid << " trun: " << cp[pid].trun << "\n";
	//for (uint i = 0; i < cp[pid].tbf.size(); i++)
	//{
	//	cout << cp[pid].tbf[i] << " ";
	//}
	//cout << "\n";
	//getchar();
}

void TruncatedTspline_3D::RefineGeometry_v1()
{
	CollectActives();
	UpdateConnect();
	FindEdgeTopoDirec();
	FindKnotInterval();

	SetLocalCoorSystem();
	FindIEN_PatchKV();

	for (uint i = 0; i < cp.size(); i++)
	{
		cp[i].coortmp[0] = 0.; cp[i].coortmp[1] = 0.; cp[i].coortmp[2] = 0.;
		if (i >= npt_old)
		{
			cp[i].coor[0] = 0.; cp[i].coor[1] = 0.; cp[i].coor[2] = 0.;
		}
	}
	vector<int> rfid;
	for (uint i = 0; i < tmesh.size(); i++)
	{
		if (tmesh[i].act == 0 && tmesh[i].ref_flag != 0)
		{
			rfid.push_back(i);
			CalPatchCP_Regular(i);
		}
	}

	UpdateGeometry(rfid);
}

void TruncatedTspline_3D::CalPatchCP_Regular(int eid)
{
	vector<int> IEN_new_all;
	vector<array<double, 5>> KU_new_all;
	vector<array<double, 5>> KV_new_all;
	vector<array<double, 5>> KW_new_all;
	for (uint i = 0; i<tmesh[eid].chd.size(); i++)
	{
		int cid(tmesh[eid].chd[i]);
		for (uint j = 0; j<tmesh[cid].IENtmp.size(); j++)
		{
			vector<int>::iterator it = find(IEN_new_all.begin(), IEN_new_all.end(), tmesh[cid].IENtmp[j]);
			if (it == IEN_new_all.end())
			{
				IEN_new_all.push_back(tmesh[cid].IENtmp[j]);
				array<double, 5> kutmp, kvtmp, kwtmp;
				for (int k = 0; k<5; k++)
				{
					kutmp[k] = tmesh[cid].patch_kutmp[j][k] + tmesh[eid].chd_o[i][0];
					kvtmp[k] = tmesh[cid].patch_kvtmp[j][k] + tmesh[eid].chd_o[i][1];
					kwtmp[k] = tmesh[cid].patch_kwtmp[j][k] + tmesh[eid].chd_o[i][2];
				}
				KU_new_all.push_back(kutmp);
				KV_new_all.push_back(kvtmp);
				KW_new_all.push_back(kwtmp);
			}
		}
	}

	vector<int> IEN_old(tmesh[eid].IEN);
	vector<vector<double>> cmat(IEN_new_all.size(), vector<double>(IEN_old.size(), 0.));
	for (uint i = 0; i<IEN_old.size(); i++)
	{
		vector<int>::iterator it = find(IEN_new_all.begin(), IEN_new_all.end(), IEN_old[i]);
		if (it != IEN_new_all.end())
		{
			int loc(it - IEN_new_all.begin());
			if (tmesh[eid].patch_ku[i] != KU_new_all[loc] || tmesh[eid].patch_kv[i] != KV_new_all[loc] || tmesh[eid].patch_kw[i] != KW_new_all[loc])
			{
				cp[IEN_old[i]].aff = 1;
			}
			else
			{
				cmat[loc][i] = 1.;
			}
		}
	}

	for (uint i = 0; i<IEN_new_all.size(); i++)
	{
		for (uint j = 0; j<IEN_old.size(); j++)
		{
			if (CheckSubKnotVector(KU_new_all[i], KV_new_all[i], KW_new_all[i], tmesh[eid].patch_ku[j], tmesh[eid].patch_kv[j], tmesh[eid].patch_kw[j]))
			{
				vector<double> ku1(10), kv1(10), kw1(10);
				vector<vector<double>> Tu, Tv, Tw;
				vector<double> ku(tmesh[eid].patch_ku[j].begin(), tmesh[eid].patch_ku[j].end());
				vector<double> kv(tmesh[eid].patch_kv[j].begin(), tmesh[eid].patch_kv[j].end());
				vector<double> kw(tmesh[eid].patch_kw[j].begin(), tmesh[eid].patch_kw[j].end());
				vector<double>::iterator it1, it2, it3;
				it1 = set_union(tmesh[eid].patch_ku[j].begin(), tmesh[eid].patch_ku[j].end(), KU_new_all[i].begin(), KU_new_all[i].end(), ku1.begin());
				it2 = set_union(tmesh[eid].patch_kv[j].begin(), tmesh[eid].patch_kv[j].end(), KV_new_all[i].begin(), KV_new_all[i].end(), kv1.begin());
				it3 = set_union(tmesh[eid].patch_kw[j].begin(), tmesh[eid].patch_kw[j].end(), KW_new_all[i].begin(), KW_new_all[i].end(), kw1.begin());
				ku1.resize(it1 - ku1.begin());
				kv1.resize(it2 - kv1.begin());
				kw1.resize(it3 - kw1.begin());
				TMatrix(ku, ku1, 3, Tu);
				TMatrix(kv, kv1, 3, Tv);
				TMatrix(kw, kw1, 3, Tw);
				it1 = search(ku1.begin(), ku1.end(), KU_new_all[i].begin(), KU_new_all[i].end());
				it2 = search(kv1.begin(), kv1.end(), KV_new_all[i].begin(), KV_new_all[i].end());
				it3 = search(kw1.begin(), kw1.end(), KW_new_all[i].begin(), KW_new_all[i].end());
				if (it1 != ku1.end() && it2 != kv1.end() && it3 != kw1.end())
				{
					int loc1 = it1 - ku1.begin();
					int loc2 = it2 - kv1.begin();
					int loc3 = it3 - kw1.begin();
					cmat[i][j] = Tu[loc1][0] * Tv[loc2][0] * Tw[loc3][0];
				}
			}
		}
	}
	for (uint i = 0; i<IEN_new_all.size(); i++)
	{
		if (cp[IEN_new_all[i]].update == 0)
		{
			for (uint j = 0; j<IEN_old.size(); j++)
			{
				if (cmat[i][j] != 0.)
				{
					cp[IEN_new_all[i]].coortmp[0] += cmat[i][j] * cp[IEN_old[j]].coor[0];
					cp[IEN_new_all[i]].coortmp[1] += cmat[i][j] * cp[IEN_old[j]].coor[1];
					cp[IEN_new_all[i]].coortmp[2] += cmat[i][j] * cp[IEN_old[j]].coor[2];
				}
			}
			cp[IEN_new_all[i]].update = 1;
		}
	}

	//check truncation
	double uvw[3][3] = { { 0., tmedge[tmesh[eid].edge[0]].len / 2., tmedge[tmesh[eid].edge[0]].len }, { 0., tmedge[tmesh[eid].edge[3]].len / 2., tmedge[tmesh[eid].edge[3]].len },
	{ 0., tmedge[tmesh[eid].edge[4]].len / 2., tmedge[tmesh[eid].edge[4]].len } };
	vector<array<double, 3>> spt(27);
	int loc(0);
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			for (int k = 0; k < 3; k++)
			{
				spt[loc][0] = uvw[0][k];
				spt[loc][1] = uvw[1][j];
				spt[loc][2] = uvw[2][i];
				loc++;
			}
		}
	}
	for (uint i = 0; i<IEN_old.size(); i++)
	{
		vector<double> coef;
		for (uint j = 0; j<IEN_new_all.size(); j++)
		{
			coef.push_back(cmat[j][i]);
		}
		if (!CheckFullRefine(spt, tmesh[eid].patch_ku[i], tmesh[eid].patch_kv[i], tmesh[eid].patch_kw[i], KU_new_all, KV_new_all, KW_new_all, coef))
		{
			cp[IEN_old[i]].truntmp = 1;
			for (uint j = 0; j<IEN_new_all.size(); j++)
			{
				if (cmat[j][i] != 0. && IEN_old[i] != IEN_new_all[j])
				{
					vector<int>::iterator it = find(cp[IEN_old[i]].tbftmp.begin(), cp[IEN_old[i]].tbftmp.end(), IEN_new_all[j]);
					if (it == cp[IEN_old[i]].tbftmp.end())
					{
						cp[IEN_old[i]].tbftmp.push_back(IEN_new_all[j]);
						cp[IEN_old[i]].tctmp.push_back(cmat[j][i]);
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::UpdateGeometry(vector<int>& rfid)
{
	for (uint i = 0; i<cp.size(); i++)
	{
		if (i<npt_old)
		{
			if (cp[i].truntmp == 0 && cp[i].aff == 1)
			{
				//cout << "update coor for old points...\n";
				//getchar();
				cp[i].coor[0] = cp[i].coortmp[0];
				cp[i].coor[1] = cp[i].coortmp[1];
				cp[i].coor[2] = cp[i].coortmp[2];
				//cp[i].w = cp[i].wtmp;
			}
			else if (cp[i].truntmp == 1)
			{
				//cout << "update trun points...\n";
				//getchar();
				cp[i].trun = 1;
				cp[i].tbf = cp[i].tbftmp;
				cp[i].tc = cp[i].tctmp;
				vector<int>().swap(cp[i].tbftmp);
				vector<double>().swap(cp[i].tctmp);
			}
		}
		else
		{
			cp[i].coor[0] = cp[i].coortmp[0];
			cp[i].coor[1] = cp[i].coortmp[1];
			cp[i].coor[2] = cp[i].coortmp[2];
			//cp[i].w = cp[i].wtmp;
		}
	}

	//update new elements
	for (uint i = 0; i<rfid.size(); i++)
	{
		if (tmesh[rfid[i]].type == 0 /*|| tmesh[rfid[i]].type == 1 || tmesh[rfid[i]].type == 2*/)
		{
			vector<int> trunIEN;
			vector<array<double, 5>> trun_patch_ku;
			vector<array<double, 5>> trun_patch_kv;
			vector<array<double, 5>> trun_patch_kw;
			for (uint j = 0; j<tmesh[rfid[i]].IEN.size(); j++)
			{
				if (cp[tmesh[rfid[i]].IEN[j]].trun == 1)
				{
					trunIEN.push_back(tmesh[rfid[i]].IEN[j]);
					trun_patch_ku.push_back(tmesh[rfid[i]].patch_ku[j]);
					trun_patch_kv.push_back(tmesh[rfid[i]].patch_kv[j]);
					trun_patch_kw.push_back(tmesh[rfid[i]].patch_kw[j]);
				}
			}
			for (uint j = 0; j<tmesh[rfid[i]].chd.size(); j++)
			{
				int chdid(tmesh[rfid[i]].chd[j]);
				tmesh[chdid].IEN.clear();
				tmesh[chdid].patch_ku.clear();
				tmesh[chdid].patch_kv.clear();
				tmesh[chdid].patch_kw.clear();
				for (uint k = 0; k<tmesh[chdid].IENtmp.size(); k++)
				{
					tmesh[chdid].IEN.push_back(tmesh[chdid].IENtmp[k]);
					if (cp[tmesh[chdid].IENtmp[k]].trun == 0)
					{
						tmesh[chdid].patch_ku.push_back(tmesh[chdid].patch_kutmp[k]);
						tmesh[chdid].patch_kv.push_back(tmesh[chdid].patch_kvtmp[k]);
						tmesh[chdid].patch_kw.push_back(tmesh[chdid].patch_kwtmp[k]);
					}
					else
					{
						vector<int>::iterator it = find(tmesh[rfid[i]].IEN.begin(), tmesh[rfid[i]].IEN.end(), tmesh[chdid].IENtmp[k]);
						if (it != tmesh[rfid[i]].IEN.end())
						{
							int loc(it - tmesh[rfid[i]].IEN.begin());
							array<double, 5> kutmp, kvtmp, kwtmp;
							for (int a = 0; a<5; a++)
							{
								kutmp[a] = tmesh[rfid[i]].patch_ku[loc][a] - tmesh[rfid[i]].chd_o[j][0];
								kvtmp[a] = tmesh[rfid[i]].patch_kv[loc][a] - tmesh[rfid[i]].chd_o[j][1];
								kwtmp[a] = tmesh[rfid[i]].patch_kw[loc][a] - tmesh[rfid[i]].chd_o[j][2];
							}
							tmesh[chdid].patch_ku.push_back(kutmp);
							tmesh[chdid].patch_kv.push_back(kvtmp);
							tmesh[chdid].patch_kw.push_back(kwtmp);
						}
						else
						{
							//cout<<i<<" "<<rfid[i]<<" "<<tmesh[rfid[i]].IEN.size()<<"\n";
							cout << "Cannot find truncated ID in the old set!\n";
							getchar();
						}
					}
				}
				for (uint k = 0; k<trunIEN.size(); k++)
				{
					vector<int>::iterator it = find(tmesh[chdid].IEN.begin(), tmesh[chdid].IEN.end(), trunIEN[k]);
					if (it == tmesh[chdid].IEN.end())
					{
						tmesh[chdid].IEN.push_back(trunIEN[k]);
						array<double, 5> kutmp, kvtmp, kwtmp;
						for (int a = 0; a<5; a++)
						{
							kutmp[a] = trun_patch_ku[k][a] - tmesh[rfid[i]].chd_o[j][0];
							kvtmp[a] = trun_patch_kv[k][a] - tmesh[rfid[i]].chd_o[j][1];
							kwtmp[a] = trun_patch_kw[k][a] - tmesh[rfid[i]].chd_o[j][2];
						}
						tmesh[chdid].patch_ku.push_back(kutmp);
						tmesh[chdid].patch_kv.push_back(kvtmp);
						tmesh[chdid].patch_kw.push_back(kwtmp);
					}
				}
			}
		}
		//else if (tmesh[rfid[i]].type == 4 || tmesh[rfid[i]].type == 5)
		//{
		//	for (int j = 0; j<4; j++)
		//	{
		//		int chdid(tmesh[rfid[i]].chd[j]);
		//		if (chdid != -1)
		//		{
		//			tmesh[chdid].IEN.clear();
		//			tmesh[chdid].patch_ku.clear();
		//			tmesh[chdid].patch_kv.clear();
		//			tmesh[chdid].IEN = tmesh[chdid].IENtmp;
		//			tmesh[chdid].patch_ku = tmesh[chdid].patch_kutmp;
		//			tmesh[chdid].patch_kv = tmesh[chdid].patch_kvtmp;
		//			vector<int>().swap(tmesh[chdid].IENtmp);
		//			vector<array<double, 5>>().swap(tmesh[chdid].patch_kutmp);
		//			vector<array<double, 5>>().swap(tmesh[chdid].patch_kvtmp);
		//		}
		//	}
		//}
	}

	//update old elements
	for (uint i = 0; i<nel_old; i++)
	{
		if (tmesh[i].act == 1 && (tmesh[i].type == 0 /*|| tmesh[i].type == 1 || tmesh[i].type == 2*/))
		{
			vector<int> ien_old(tmesh[i].IEN);
			vector<array<double, 5>> ku_old(tmesh[i].patch_ku);
			vector<array<double, 5>> kv_old(tmesh[i].patch_kv);
			vector<array<double, 5>> kw_old(tmesh[i].patch_kw);
			tmesh[i].IEN.clear();
			tmesh[i].patch_ku.clear();
			tmesh[i].patch_kv.clear();
			tmesh[i].patch_kw.clear();
			//
			for (uint j = 0; j<ien_old.size(); j++)
			{
				if (cp[ien_old[j]].trun == 1)
				{
					tmesh[i].IEN.push_back(ien_old[j]);
					tmesh[i].patch_ku.push_back(ku_old[j]);
					tmesh[i].patch_kv.push_back(kv_old[j]);
					tmesh[i].patch_kw.push_back(kw_old[j]);
				}
			}
			//
			for (uint j = 0; j<tmesh[i].IENtmp.size(); j++)
			{
				//tmesh[i].IEN.push_back(tmesh[i].IENtmp[j]);
				if (cp[tmesh[i].IENtmp[j]].trun == 0)
				{
					tmesh[i].IEN.push_back(tmesh[i].IENtmp[j]);
					tmesh[i].patch_ku.push_back(tmesh[i].patch_kutmp[j]);
					tmesh[i].patch_kv.push_back(tmesh[i].patch_kvtmp[j]);
					tmesh[i].patch_kw.push_back(tmesh[i].patch_kwtmp[j]);
				}
				//else
				//{
				//	vector<int>::iterator it=find(ien_old.begin(),ien_old.end(),tmesh[i].IENtmp[j]);
				//	int loc(it-ien_old.begin());
				//	tmesh[i].patch_ku.push_back(ku_old[loc]);
				//	tmesh[i].patch_kv.push_back(kv_old[loc]);
				//}
			}
			vector<int>().swap(tmesh[i].IENtmp);
			vector<array<double, 5>>().swap(tmesh[i].patch_kutmp);
			vector<array<double, 5>>().swap(tmesh[i].patch_kvtmp);
			vector<array<double, 5>>().swap(tmesh[i].patch_kwtmp);
		}
		/*else if (tmesh[i].act == 1 && tmesh[i].type == 4)
		{
			vector<int> ien_old(tmesh[i].IEN);
			vector<array<double, 5>> ku_old(tmesh[i].patch_ku);
			vector<array<double, 5>> kv_old(tmesh[i].patch_kv);
			tmesh[i].IEN.clear();
			tmesh[i].patch_ku.clear();
			tmesh[i].patch_kv.clear();
			uint n_1r(2 * cp[tmesh[i].cnct[0]].face.size() + 1);
			for (uint j = 0; j<tmesh[i].IENtmp.size(); j++)
			{
				tmesh[i].IEN.push_back(tmesh[i].IENtmp[j]);
				if (j >= n_1r)
				{
					if (cp[tmesh[i].IENtmp[j]].trun == 0)
					{
						tmesh[i].patch_ku.push_back(tmesh[i].patch_kutmp[j - n_1r]);
						tmesh[i].patch_kv.push_back(tmesh[i].patch_kvtmp[j - n_1r]);
					}
					else
					{
						vector<int>::iterator it = find(ien_old.begin(), ien_old.end(), tmesh[i].IENtmp[j]);
						int loc(it - ien_old.begin());
						tmesh[i].patch_ku.push_back(ku_old[loc - n_1r]);
						tmesh[i].patch_kv.push_back(kv_old[loc - n_1r]);
					}
				}
			}
			vector<int>().swap(tmesh[i].IENtmp);
			vector<array<double, 5>>().swap(tmesh[i].patch_kutmp);
			vector<array<double, 5>>().swap(tmesh[i].patch_kvtmp);
		}*/
	}
}

bool TruncatedTspline_3D::CheckFullRefine(const vector<array<double, 3>>& spt, const array<double, 5>& motu, const array<double, 5>& motv, const array<double, 5>& motw,
	const vector<array<double, 5>>& chdu, const vector<array<double, 5>>& chdv, const vector<array<double, 5>>& chdw, const vector<double>& coef)
{
	double tol(1.e-8);
	double sum(0.);
	for (uint i = 0; i<spt.size(); i++)
	{
		vector<double> ku(motu.begin(), motu.end());
		vector<double> kv(motv.begin(), motv.end());
		vector<double> kw(motw.begin(), motw.end());
		vector<double> uval, vval, wval;
		BSplineBasis bu, bv, bw;
		bu.Set(3, ku);
		bv.Set(3, kv);
		bw.Set(3, kw);
		bu.BasisFunction(0, spt[i][0], 0, uval);
		bv.BasisFunction(0, spt[i][1], 0, vval);
		bw.BasisFunction(0, spt[i][2], 0, wval);
		double Ni = uval[0] * vval[0] * wval[0];
		for (uint j = 0; j<chdu.size(); j++)
		{
			if (coef[j] != 0.)
			{
				ku.assign(chdu[j].begin(), chdu[j].end());
				kv.assign(chdv[j].begin(), chdv[j].end());
				kw.assign(chdw[j].begin(), chdw[j].end());
				bu.Set(3, ku);
				bv.Set(3, kv);
				bw.Set(3, kw);
				bu.BasisFunction(0, spt[i][0], 0, uval);
				bv.BasisFunction(0, spt[i][1], 0, vval);
				bw.BasisFunction(0, spt[i][2], 0, wval);
				Ni -= coef[j] * uval[0] * vval[0] * wval[0];
			}
		}
		if (Ni<0.) Ni = -Ni;
		sum += Ni;
	}
	if (sum / spt.size() < tol)
		return true;
	else
		return false;
}

bool TruncatedTspline_3D::CheckSubKnotVector(const array<double, 5>& ku1, const array<double, 5>& kv1, const array<double, 5>& kw1, 
	const array<double, 5>& ku2, const array<double, 5>& kv2, const array<double, 5>& kw2)// 1 is a child of 2
{
	if (ku1[0] >= ku2[0] && ku1[4] <= ku2[4] && kv1[0] >= kv2[0] && kv1[4] <= kv2[4] && kw1[0] >= kw2[0] && kw1[4] <= kw2[4])
	{
		double min_u1(10.), min_v1(10.), min_w1(10.), min_u2(10.), min_v2(10.), min_w2(10.);
		for (int i = 0; i<4; i++)
		{
			double tmp = ku1[i + 1] - ku1[i];
			if (tmp != 0. && tmp<min_u1) min_u1 = tmp;
			tmp = kv1[i + 1] - kv1[i];
			if (tmp != 0. && tmp<min_v1) min_v1 = tmp;
			tmp = kw1[i + 1] - kw1[i];
			if (tmp != 0. && tmp<min_w1) min_w1 = tmp;
			tmp = ku2[i + 1] - ku2[i];
			if (tmp != 0. && tmp<min_u2) min_u2 = tmp;
			tmp = kv2[i + 1] - kv2[i];
			if (tmp != 0. && tmp<min_v2) min_v2 = tmp;
			tmp = kw2[i + 1] - kw2[i];
			if (tmp != 0. && tmp<min_w2) min_w2 = tmp;
		}
		if (min_u1 <= min_u2 && min_v1 <= min_v2 && min_w1 <= min_w2)
		{
			for (int i = 0; i<5; i++)
			{
				array<double, 5>::const_iterator it1 = find(ku2.begin(), ku2.end(), ku1[i]);
				if (it1 == ku2.end())
				{
					return true;
				}
				array<double, 5>::const_iterator it2 = find(kv2.begin(), kv2.end(), kv1[i]);
				if (it2 == kv2.end())
				{
					return true;
				}
				array<double, 5>::const_iterator it3 = find(kw2.begin(), kw2.end(), kw1[i]);
				if (it2 == kw2.end())
				{
					return true;
				}
			}
			return false;
		}
		else
		{
			return false;
		}
	}
	else
	{
		return false;
	}
}

void TruncatedTspline_3D::run(string fn)
{
	SetProblem(fn);
	
	//RefineTest_2();
	RefineTopology();
	//RefineGeometry();
	RefineGeometry_v1();

	//AllBezierPatch();
	//CollectActives();

	string pfn("../io/hex_out/cube9"),testnum("1");
	//string pfn("../io/hex_out/cube_dense"), testnum("5");

	//VisualizeControlMesh(pfn+"_CM_"+testnum);
	//VisualizeTMesh(pfn + "_edge_" + testnum);
	//VisualizeFaceMesh(pfn+"_face_"+testnum);s
	VisualizeSolidVTK(pfn + "_geom_" + testnum);

	//CreateUniformCube("../io/hex_input/cube5");
	//VisualizeSolidVTK("../io/hex_out/cube_dense_1");
}

void TruncatedTspline_3D::runh(string fn)
{
	SetProblem(fn);

	vector<array<int, 2>> rfid;
	vector<array<int, 2>> gst;

	//Identify_Pseudo(rfid);//for cube9
	//Refine(rfid, gst);
	//Identify_Pseudo_1(rfid);
	//Refine(rfid, gst);

	//Identify_Test_2(rfid, gst);//for cube_dense
	//Refine(rfid, gst);
	//Identify_Test_3(rfid, gst);
	//Refine(rfid, gst);

	//Identify_Test_4(rfid, gst);//for cube_dense, boundary
	//Refine(rfid, gst);

	string pfn("../io/hex_out_1/cubeline0"), testnum("1"), levnum("0");
	//string pfn("../io/hex_out_1/cube_dense"), testnum("1"), levnum("0");
	//string pfn("../io/hex_out_1/cube_coarse"), testnum("1"), levnum("0");
	int lev(0);

	//PillowCube(fn+"_pillow");

	//OutputBasis(0,21,"../io/hex_out_1/cube3_basis_21");

	//OutputCM(lev, pfn + "_CM_" + testnum+"_"+levnum);
	OutputFace(lev, pfn + "_FC_" + testnum+"_"+levnum);
	OutputEdge(lev, pfn + "_ED_" + testnum+"_"+levnum);
	//OutputGeom(lev, pfn + "_geom_" + testnum+"_"+levnum);

	//VisualizeControlMesh(pfn+"_CM_"+testnum);
	//VisualizeTMesh(pfn + "_edge_" + testnum);
	//VisualizeFaceMesh(pfn+"_face_"+testnum);
	//VisualizeSolidVTK(pfn + "_geom_" + testnum);

	//CreateUniformCube("../io/hex_input/cube5");
}

void TruncatedTspline_3D::SetProblem(string fn)
{
	//read hex vtk
	string fname(fn+".vtk"),stmp;
	int npts,neles,itmp;
	ifstream fin;
	fin.open(fname);
	if(fin.is_open())
	{
		for(int i=0;i<4;i++) getline(fin,stmp);//skip lines
		fin>>stmp>>npts>>stmp;
		cp.resize(npts);
		for(int i=0;i<npts;i++)
		{
			cp[i].act = 1;
			fin>>cp[i].coor[0]>>cp[i].coor[1]>>cp[i].coor[2];
		}
		getline(fin,stmp);
		fin>>stmp>>neles>>itmp;
		tmesh.resize(neles);
		for(int i=0;i<neles;i++)
		{
			tmesh[i].act = 1;
			fin >> itmp >> tmesh[i].cnct[0] >> tmesh[i].cnct[1] >> tmesh[i].cnct[2] >> tmesh[i].cnct[3] >> 
				tmesh[i].cnct[4] >> tmesh[i].cnct[5] >> tmesh[i].cnct[6] >> tmesh[i].cnct[7];
		}
		fin.close();
	}
	else
	{
		cerr<<"Cannot open "<<fname<<"!\n";
	}

	//SetDomain();//normalize coordinates in [0,1]^3, for the cube poisson

	InitialConnect();
	//InitialRotate();
	//FindEdgeTopoDirec();
	//FindKnotInterval();
	//SetLocalCoorSystem();
	//FindIEN_PatchKV();
	//Update_IEN();

	hmesh.push_back(tmesh);
	hcp.push_back(cp);
	hface.push_back(tmface);
	hedge.push_back(tmedge);

	ReportXP();

	//construct boundary here
	SetSharpFeature();

	string fn1("../io/le_adapt/heli_coarse/heli");
	OutputEdge(0, fn1);
	OutputCM(0, fn1);
	cout << "done setting sharp feature\n";
	getchar();

	AllBezierLev(0);
	//for (uint i = 0; i < hmesh[0].size(); i++)
	//{
	//	if (hmesh[0][i].type == 1)
	//	{
	//		ConstructBezierBasis_Boundary(0,i);
	//	}
	//}

	BezierPoints_ini();//represent geometry using initial control points and blending functions

	SetSupport(0);
}

void TruncatedTspline_3D::SetSharpFeature()
{
	//sharp edge and sharp corner, indicated by control point
	//sharp edge
	//double tol(.3);
	//double tol(.57);//rod, base
	//double tol(.8);//hook
	double tol(.6);//heli coarse
	int fc_dir[6][3] = { { 0, 3, 2 }, { 0, 1, 5 }, { 1, 2, 6 }, { 3, 7, 6 }, { 0, 4, 7 }, { 4, 5, 6 } };
	uint i, j, k;
	for (i = 0; i < hedge[0].size(); i++)
	{
		if (hedge[0][i].type == 1)
		{
			vector<array<double, 3>> vec;
			for (j = 0; j < hedge[0][i].hex.size(); j++)
			{
				if (hmesh[0][hedge[0][i].hex[j]].type == 1)
				{
					int hxid(hedge[0][i].hex[j]);
					for (k = 0; k < 6; k++)
					{
						if (hface[0][hmesh[0][hxid].face[k]].type == 1)
						{
							vector<int>::iterator it = find(hedge[0][i].face.begin(), hedge[0][i].face.end(), hmesh[0][hxid].face[k]);
							if (it != hedge[0][i].face.end())
							{
								array<double, 3> tmp1, tmp2;
								for (int dof = 0; dof < 3; dof++)
								{
									tmp1[dof] = hcp[0][hmesh[0][hxid].cnct[fc_dir[k][1]]].coor[dof] - hcp[0][hmesh[0][hxid].cnct[fc_dir[k][0]]].coor[dof];
									tmp2[dof] = hcp[0][hmesh[0][hxid].cnct[fc_dir[k][2]]].coor[dof] - hcp[0][hmesh[0][hxid].cnct[fc_dir[k][1]]].coor[dof];
								}
								array<double, 3> tmp3 = { tmp1[1] * tmp2[2] - tmp1[2] * tmp2[1], -tmp1[0] * tmp2[2] + tmp1[2] * tmp2[0], tmp1[0] * tmp2[1] - tmp1[1] * tmp2[0] };
								double dis = sqrt(tmp3[0] * tmp3[0] + tmp3[1] * tmp3[1] + tmp3[2] * tmp3[2]);
								tmp3[0] /= dis; tmp3[1] /= dis; tmp3[2] /= dis;
								vec.push_back(tmp3);
							}
						}
					}
				}
			}
			if (vec.size() == 2)
			{
				double ang(vec[0][0] * vec[1][0] + vec[0][1] * vec[1][1] + vec[0][2] * vec[1][2]);
				if (ang < tol)
				{
					hedge[0][i].sharp = 1;
					hcp[0][hedge[0][i].pt[0]].sharp = 1;
					hcp[0][hedge[0][i].pt[1]].sharp = 1;
				}
			}
			else
			{
				cerr << "Something wrong in determining sharp edge!\n";
				getchar();
			}
		}
	}

	for (i = 0; i < hcp[0].size(); i++)
	{
		if (hcp[0][i].sharp == 1)
		{
			int nshp(0);
			for (j = 0; j < hcp[0][i].edge.size(); j++)
			{
				if (hedge[0][hcp[0][i].edge[j]].sharp == 1)
				{
					nshp++;
				}
			}
			if (nshp >= 3) hcp[0][i].sharp = 2;//sharp corner
			//additional
			if (nshp == 1) hcp[0][i].sharp = 2;
		}
	}

	//additional
	for (i = 0; i < hedge[0].size(); i++)
	{
		if (hedge[0][i].sharp == 1)
		{
			if (hcp[0][hedge[0][i].pt[0]].sharp == 0 && hcp[0][hedge[0][i].pt[1]].sharp == 0)
			{
				hedge[0][i].sharp = 0;
			}
		}
	}
	//for (i = 0; i < hcp[0].size(); i++)
	//{
	//	if ((hcp[0][i].bcxp == 1 && hcp[0][i].sharp == 1) || hcp[0][i].bcxp==2)
	//	{
	//		hcp[0][i].sharp = 2;
	//	}
	//}

	//int nshp_ed(9), nshp_cn(8);
	//int shp_ed[] = { 2792, 2808, 2824, 2840, 2856, 2872, 2888, 2904, 2920};
	//int shp_cn[] = {2600,2872,2436,2276,2596,2856,2760,2468};
	//for (int i = 0; i < nshp_ed; i++)
	//{
	//	if (hcp[0][shp_ed[i]].type == 1)
	//	{
	//		hcp[0][shp_ed[i]].sharp = 1;
	//	}
	//	else
	//	{
	//		cerr << "Sharp edge not on the boundary!\n";
	//		getchar();
	//	}
	//}
	//for (int i = 0; i < nshp_cn; i++)
	//{
	//	if (hcp[0][shp_cn[i]].type == 1)
	//	{
	//		hcp[0][shp_cn[i]].sharp = 2;
	//	}
	//	else
	//	{
	//		cerr << "Sharp corner not on the boundary!\n";
	//		getchar();
	//	}
	//}
	//for (uint i = 0; i < hedge[0].size(); i++)
	//{
	//	if (hedge[0][i].type == 1 && hcp[0][hedge[0][i].pt[0]].sharp != 0 && hcp[0][hedge[0][i].pt[1]].sharp != 0)
	//	{
	//		hedge[0][i].sharp = 1;
	//	}
	//}
}

void TruncatedTspline_3D::SetDomain()
{
	double tmp(1.e6);
	double x_range[3][2] = { { tmp, -tmp }, { tmp, -tmp }, { tmp, -tmp } };
	uint i, j;
	for (i = 0; i <cp.size(); i++)
	{
		for (j = 0; j < 3; j++)
		{
			if (cp[i].coor[j] < x_range[j][0]) x_range[j][0] = cp[i].coor[j];
			if (cp[i].coor[j] > x_range[j][1]) x_range[j][1] = cp[i].coor[j];
		}
	}
	double xh[3] = { x_range[0][1] - x_range[0][0], x_range[1][1] - x_range[1][0], x_range[2][1] - x_range[2][0] };
	for (i = 0; i <cp.size(); i++)
	{
		for (j = 0; j < 3; j++)
		{
			cp[i].coor[j] = (cp[i].coor[j] - x_range[j][0]) / xh[j];
		}
	}
}

void TruncatedTspline_3D::BezierPoints_ini()
{
	for (uint j = 0; j < hmesh[0].size(); j++)
	{
		for (uint k = 0; k < hmesh[0][j].IEN.size(); k++)
		{
			for (int k1 = 0; k1 < 64; k1++)
			{
				hmesh[0][j].bzpt[k1][0] += hmesh[0][j].bemat[k][k1] * hcp[0][hmesh[0][j].IEN[k]].coor[0];
				hmesh[0][j].bzpt[k1][1] += hmesh[0][j].bemat[k][k1] * hcp[0][hmesh[0][j].IEN[k]].coor[1];
				hmesh[0][j].bzpt[k1][2] += hmesh[0][j].bemat[k][k1] * hcp[0][hmesh[0][j].IEN[k]].coor[2];
			}
		}
	}
}

void TruncatedTspline_3D::BezierPoints_Refine(int lev, int pos, const vector<MatrixXd>& bsmat)
{
	for (uint i = 0; i < hmesh[lev][pos].chd.size(); i++)
	{
		int cid[2] = { lev + 1, hmesh[lev][pos].chd[i] };
		for (int j = 0; j < 64; j++)//chd
		{
			hmesh[cid[0]][cid[1]].bzpt[j][0] = 0.;
			hmesh[cid[0]][cid[1]].bzpt[j][1] = 0.;
			hmesh[cid[0]][cid[1]].bzpt[j][2] = 0.;
			for (int k = 0; k < 64; k++)//father
			{
				hmesh[cid[0]][cid[1]].bzpt[j][0] += bsmat[i](j, k)*hmesh[lev][pos].bzpt[k][0];
				hmesh[cid[0]][cid[1]].bzpt[j][1] += bsmat[i](j, k)*hmesh[lev][pos].bzpt[k][1];
				hmesh[cid[0]][cid[1]].bzpt[j][2] += bsmat[i](j, k)*hmesh[lev][pos].bzpt[k][2];
			}
		}
	}
}

void TruncatedTspline_3D::BezierSubdivMatrix(vector<MatrixXd>& bsmat)
{
	bsmat.resize(8);
	for (uint i = 0; i < bsmat.size(); i++)
	{
		bsmat[i] = MatrixXd::Zero(64, 64);
	}
	double bs1d[8][4] = { { 1., 0., 0., 0. }, { .5, .5, 0., 0. }, { .25, .5, .25, 0. }, { .125, .375, .375, .125 }, 
	{ .125, .375, .375, .125 }, { 0., .25, .5, .25 }, { 0., 0., .5, .5 }, { 0., 0., 0., 1. } };
	int i0, j0, k0, i1, j1, k1, loc0(0);
	//vector<int> loc1(8, 0);
	double val;
	for (k0 = 0; k0 < 4; k0++)
	{
		for (j0 = 0; j0 < 4; j0++)
		{
			for (i0 = 0; i0 < 4; i0++)
			{
				vector<int> loc1(8, 0);
				for (k1 = 0; k1 < 8; k1++)
				{
					for (j1 = 0; j1 < 8; j1++)
					{
						for (i1 = 0; i1 < 8; i1++)
						{
							val = bs1d[i1][i0] * bs1d[j1][j0] * bs1d[k1][k0];
							if (i1 < 4 && j1 < 4 && k1 < 4)
							{
								bsmat[0](loc1[0], loc0) = val;
								loc1[0]++;
							}
							else if (i1 >= 4 && j1 < 4 && k1 < 4)
							{
								bsmat[1](loc1[1], loc0) = val;
								loc1[1]++;
							}
							else if (i1 >= 4 && j1 >= 4 && k1 < 4)
							{
								bsmat[2](loc1[2], loc0) = val;
								loc1[2]++;
							}
							else if (i1 < 4 && j1 >= 4 && k1 < 4)
							{
								bsmat[3](loc1[3], loc0) = val;
								loc1[3]++;
							}
							else if (i1 < 4 && j1 < 4 && k1 >= 4)
							{
								bsmat[4](loc1[4], loc0) = val;
								loc1[4]++;
							}
							else if (i1 >= 4 && j1 < 4 && k1 >= 4)
							{
								bsmat[5](loc1[5], loc0) = val;
								loc1[5]++;
							}
							else if (i1 >= 4 && j1 >= 4 && k1 >= 4)
							{
								bsmat[6](loc1[6], loc0) = val;
								loc1[6]++;
							}
							else if (i1 < 4 && j1 >= 4 && k1 >= 4)
							{
								bsmat[7](loc1[7], loc0) = val;
								loc1[7]++;
							}
						}
					}
				}
				loc0++;
			}
		}
	}
}

void TruncatedTspline_3D::RefineTest_1()
{
	//the input is a cube with 9 elements in each direction
	//int i(4), j(4), k(4);
	//int rfid = 81 * k + 9 * j + i;
	int rfid(-1);
	for (uint i = 0; i < tmesh.size(); i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (tmesh[i].cnct[j] == 124)
			{
				rfid = i; break;
			}
			if (rfid != -1) break;
		}
	}
	ElementSubdivide_2(rfid,2);
	//VisualizeFaceMesh("../io/hex_out/cube9_face");
	//VisualizeTMesh("../io/hex_out/cube3_edge");
	//cout << "Done\n";
	//getchar();

	//CollectActives();
	//UpdateConnect();
	//FindEdgeTopoDirec();

	////int ed(183);
	////cout << "pid: " << tmedge[eaid[ed]].pt[0] << "type: " << tmedge[eaid[ed]].pn[0][0] << " next id: " << tmedge[eaid[ed]].pn[0][1] << "\n";
	////cout << "pid: " << tmedge[eaid[ed]].pt[1] << "type: " << tmedge[eaid[ed]].pn[1][0] << " next id: " << tmedge[eaid[ed]].pn[1][1] << "\n";
	////getchar();

	//FindKnotInterval();

	////for (uint i = 0; i < cp.size(); i++)
	////{
	////	if (i>63)
	////	{
	////		cout << "pid: " << i << "\n";
	////		cout << "uv edges: " << tmedge[cp[i].uved[0]].id_act << " " << tmedge[cp[i].uved[1]].id_act << " " << tmedge[cp[i].uved[2]].id_act << "\n";
	////		cout << "kitU: ";
	////		for (int j = 0; j < 4; j++) cout << cp[i].kitvU[j] << " ";
	////		cout << "\n";
	////		cout << "kitV: ";
	////		for (int j = 0; j < 4; j++) cout << cp[i].kitvV[j] << " ";
	////		cout << "\n";
	////		cout << "kitW: ";
	////		for (int j = 0; j < 4; j++) cout << cp[i].kitvW[j] << " ";
	////		cout << "\n";
	////		getchar();
	////	}
	////}

	//SetLocalCoorSystem();
	//FindIEN_PatchKV();
	//Update_IEN();

	//Truncation();

	//int itmp[8] = {0,3,12,15,48,51,60,63};
	//for (int i = 0; i < 8; i++)
	//{
	//	cp[itmp[i]].trun = 0;
	//}
	//for (uint i = 0; i < cp.size(); i++)
	//{
	//	if (cp[i].trun == 1)
	//	{
	//		cout << "trunid: " << i << "\n";
	//		cout << "tbf: ";
	//		for (uint j = 0; j < cp[i].tbf.size(); j++) cout << cp[i].tbf[j] << " ";
	//		cout << "\n";
	//		cout << "tc: ";
	//		for (uint j = 0; j < cp[i].tc.size(); j++) cout << cp[i].tc[j] << " ";
	//		cout << "\n";
	//		getchar();
	//	}
	//}

	//for (uint i = 0; i < tmesh.size(); i++)
	//{
	//	if ( tmesh[i].act == 1 && tmesh[i].type == 0)
	//	{
	//		cout << "eid: " << i << "\n";
	//		cout << "IEN size: " << tmesh[i].IEN.size() << "\n";
	//		for (uint j = 0; j < tmesh[i].IEN.size(); j++)
	//		{
	//			cout << "pid: "<<tmesh[i].IEN[j] << "\n";
	//			//cout << "rhx: " << cp[tmesh[i].IEN[j]].rhx << "\n";
	//			//cout << "uved: " << tmedge[cp[tmesh[i].IEN[j]].uved[0]].id_act << " " << tmedge[cp[tmesh[i].IEN[j]].uved[1]].id_act << " " << tmedge[cp[tmesh[i].IEN[j]].uved[2]].id_act << "\n";
	//			//cout << "uved[0] pre: " << tmedge[cp[tmesh[i].IEN[j]].uved[0]].pn[0][0] << " " << tmedge[cp[tmesh[i].IEN[j]].uved[0]].pn[0][1] << "\n";
	//			//cout << "uved[0] next: " << tmedge[cp[tmesh[i].IEN[j]].uved[0]].pn[1][0] << " " << tmedge[cp[tmesh[i].IEN[j]].uved[0]].pn[1][1] << "\n";
	//			//cout << "uved[1] pre: " << tmedge[cp[tmesh[i].IEN[j]].uved[1]].pn[0][0] << " " << tmedge[cp[tmesh[i].IEN[j]].uved[1]].pn[0][1] << "\n";
	//			//cout << "uved[1] next: " << tmedge[cp[tmesh[i].IEN[j]].uved[1]].pn[1][0] << " " << tmedge[cp[tmesh[i].IEN[j]].uved[1]].pn[1][1] << "\n";
	//			//cout << "uved[2] pre: " << tmedge[cp[tmesh[i].IEN[j]].uved[2]].pn[0][0] << " " << tmedge[cp[tmesh[i].IEN[j]].uved[2]].pn[0][1] << "\n";
	//			//cout << "uved[2] next: " << tmedge[cp[tmesh[i].IEN[j]].uved[2]].pn[1][0] << " " << tmedge[cp[tmesh[i].IEN[j]].uved[2]].pn[1][1] << "\n";
	//			//cout << "kitU: ";
	//			//for (int k = 0; k < 4; k++)
	//			//{
	//			//	cout << cp[tmesh[i].IEN[j]].kitvU[k] << " ";
	//			//}
	//			//cout << "\n";
	//			//cout << "kitV: ";
	//			//for (int k = 0; k < 4; k++)
	//			//{
	//			//	cout << cp[tmesh[i].IEN[j]].kitvV[k] << " ";
	//			//}
	//			//cout << "\n";
	//			//cout << "kitW: ";
	//			//for (int k = 0; k < 4; k++)
	//			//{
	//			//	cout << cp[tmesh[i].IEN[j]].kitvW[k] << " ";
	//			//}
	//			//cout << "\n";

	//			cout << "patch ku: ";
	//			for (int k = 0; k < 5; k++)
	//			{
	//				cout << tmesh[i].patch_ku[j][k] << " ";
	//			}
	//			cout << "\n";
	//			cout << "patch kv: ";
	//			for (int k = 0; k < 5; k++)
	//			{
	//				cout << tmesh[i].patch_kv[j][k] << " ";
	//			}
	//			cout << "\n";
	//			cout << "patch kw: ";
	//			for (int k = 0; k < 5; k++)
	//			{
	//				cout << tmesh[i].patch_kw[j][k] << " ";
	//			}
	//			cout << "\n";
	//			getchar();
	//		}
	//		cout << "end!\n";
	//		getchar();
	//	}
	//}
}

void TruncatedTspline_3D::RefineTest_2()
{
	//the input is a cube with 9 elements in each direction
	//int i(4), j(4), k(4);
	//int rfid = 81 * k + 9 * j + i;
	int rfid(-1);
	for (uint i = 0; i < tmesh.size(); i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (tmesh[i].cnct[j] == 124)
			{
				rfid = i; break;
			}
			if (rfid != -1) break;
		}
	}
	ElementSubdivide_2(rfid, 2);
	//VisualizeFaceMesh("../io/hex_out/cube9_face");
	//VisualizeTMesh("../io/hex_out/cube3_edge");
	//cout << "Done\n";
	//getchar();

	//CollectActives();
	//UpdateConnect();
	//FindEdgeTopoDirec();

	////int ed(183);
	////cout << "pid: " << tmedge[eaid[ed]].pt[0] << "type: " << tmedge[eaid[ed]].pn[0][0] << " next id: " << tmedge[eaid[ed]].pn[0][1] << "\n";
	////cout << "pid: " << tmedge[eaid[ed]].pt[1] << "type: " << tmedge[eaid[ed]].pn[1][0] << " next id: " << tmedge[eaid[ed]].pn[1][1] << "\n";
	////getchar();

	//FindKnotInterval();

	////for (uint i = 0; i < cp.size(); i++)
	////{
	////	if (i>63)
	////	{
	////		cout << "pid: " << i << "\n";
	////		cout << "uv edges: " << tmedge[cp[i].uved[0]].id_act << " " << tmedge[cp[i].uved[1]].id_act << " " << tmedge[cp[i].uved[2]].id_act << "\n";
	////		cout << "kitU: ";
	////		for (int j = 0; j < 4; j++) cout << cp[i].kitvU[j] << " ";
	////		cout << "\n";
	////		cout << "kitV: ";
	////		for (int j = 0; j < 4; j++) cout << cp[i].kitvV[j] << " ";
	////		cout << "\n";
	////		cout << "kitW: ";
	////		for (int j = 0; j < 4; j++) cout << cp[i].kitvW[j] << " ";
	////		cout << "\n";
	////		getchar();
	////	}
	////}

	//SetLocalCoorSystem();
	//FindIEN_PatchKV();
	//Update_IEN();

	//Truncation();
}

void TruncatedTspline_3D::PatchRefine_Regular(int lev, int eid)
{
	if (hmesh.size() < lev + 2)
	{
		vector<Vertex3D> ptmp;
		vector<Element3D> etmp;
		vector<Face3D> fctmp;
		vector<Edge3D> edtmp;
		hcp.push_back(ptmp);
		hmesh.push_back(etmp);
		hface.push_back(fctmp);
		hedge.push_back(edtmp);
	}
	double range[3][2] = { { hmesh[lev][eid].dm[0][0], hmesh[lev][eid].dm[0][1] }, { hmesh[lev][eid].dm[1][0], hmesh[lev][eid].dm[1][1] },
	{ hmesh[lev][eid].dm[2][0], hmesh[lev][eid].dm[2][1] } };
	uint n, i, j, k, loc(0);
	vector<array<double, 15>> pkuvw;
	vector<array<double, 3>> pnew;
	vector<vector<int>> chdid(hmesh[lev][eid].IEN.size());
	vector<vector<double>> coef(hmesh[lev][eid].IEN.size());
	//subdivision
	for (n = 0; n < hmesh[lev][eid].IEN.size(); n++)
	{
		int pid(hmesh[lev][eid].IEN[n]);
		vector<double> ku, kv, kw;
		BisectKnotInterval(hmesh[lev][eid].patch_ku[n], ku);
		BisectKnotInterval(hmesh[lev][eid].patch_kv[n], kv);
		BisectKnotInterval(hmesh[lev][eid].patch_kw[n], kw);
		vector<vector<double>> Tu, Tv, Tw;
		vector<double> ku0(hmesh[lev][eid].patch_ku[n].begin(), hmesh[lev][eid].patch_ku[n].end());
		vector<double> kv0(hmesh[lev][eid].patch_kv[n].begin(), hmesh[lev][eid].patch_kv[n].end());
		vector<double> kw0(hmesh[lev][eid].patch_kw[n].begin(), hmesh[lev][eid].patch_kw[n].end());
		TMatrix(ku0, ku, 3, Tu);
		TMatrix(kv0, kv, 3, Tv);
		TMatrix(kw0, kw, 3, Tw);
		for (k = 0; k < kw.size() - 4; k++)
		{
			for (j = 0; j < kv.size() - 4; j++)
			{
				for (i = 0; i < ku.size() - 4; i++)
				{
					if (ku[i + 4] > range[0][0] && ku[i] < range[0][1] && kv[j + 4] > range[1][0] && kv[j] < range[1][1] && kw[k + 4] > range[2][0] && kw[k] < range[2][1])
					{
						array<double, 15> ktmp = { ku[i], ku[i + 1], ku[i + 2], ku[i + 3], ku[i + 4],
							kv[j], kv[j + 1], kv[j + 2], kv[j + 3], kv[j + 4], kw[k], kw[k + 1], kw[k + 2], kw[k + 3], kw[k + 4] };
						vector<array<double, 15>>::iterator it1 = find(pkuvw.begin(), pkuvw.end(), ktmp);
						int pos = it1 - pkuvw.begin();
						double rfc (Tu[i][0] * Tv[j][0] * Tw[k][0]);
						chdid[n].push_back(pos);
						coef[n].push_back(rfc);
						if (it1 == pkuvw.end())
						{
							pkuvw.push_back(ktmp);
							array<double, 3> ptmp = { rfc*hcp[lev][pid].coor[0], rfc*hcp[lev][pid].coor[1], rfc*hcp[lev][pid].coor[2] };
							pnew.push_back(ptmp);
						}
						else
						{
							pnew[pos][0] += rfc*hcp[lev][pid].coor[0];
							pnew[pos][1] += rfc*hcp[lev][pid].coor[1];
							pnew[pos][2] += rfc*hcp[lev][pid].coor[2];
						}
					}
				}
			}
		}
	}
	double tol(1.e-6), dis(0.);
	vector<int> pnid(pnew.size());
	uint np0(hcp[lev + 1].size());
	for (i = 0; i < pnew.size(); i++)
	{
		int flag(0);
		for (j = 0; j < np0; j++)
		{
			dis = sqrt((pnew[i][0] - hcp[lev + 1][j].coor[0])*(pnew[i][0] - hcp[lev + 1][j].coor[0]) + (pnew[i][1] - hcp[lev + 1][j].coor[1])*(pnew[i][1] - hcp[lev + 1][j].coor[1])+
				(pnew[i][2] - hcp[lev + 1][j].coor[2])*(pnew[i][2] - hcp[lev + 1][j].coor[2]));
			if (dis < tol)
			{
				flag = 1; pnid[i] = j; break;
			}
		}
		if (flag == 0)
		{
			pnid[i] = hcp[lev + 1].size();
			Vertex3D cptmp;
			cptmp.coor[0] = pnew[i][0]; cptmp.coor[1] = pnew[i][1]; cptmp.coor[2] = pnew[i][2];
			cptmp.lev = lev + 1;
			hcp[lev + 1].push_back(cptmp);
		}
	}
	//children basis functions
	for (i = 0; i < chdid.size(); i++)
	{
		int pid(hmesh[lev][eid].IEN[i]);
		for (j = 0; j < chdid[i].size(); j++)
		{
			chdid[i][j] = pnid[chdid[i][j]];
			vector<int>::iterator it1 = find(hcp[lev][pid].chd.begin(), hcp[lev][pid].chd.end(), chdid[i][j]);
			if (it1 == hcp[lev][pid].chd.end())
			{
				hcp[lev][pid].chd.push_back(chdid[i][j]);
				hcp[lev][pid].coef.push_back(coef[i][j]);
			}
		}
	}
	//new elements
	double r1[3][3] = { { range[0][0], (range[0][0] + range[0][1]) / 2., range[0][1] }, { range[1][0], (range[1][0] + range[1][1]) / 2., range[1][1] },
	{ range[2][0], (range[2][0] + range[2][1]) / 2., range[2][1] }};
	double enew[8][3][2] = { { { r1[0][0], r1[0][1] }, { r1[1][0], r1[1][1] }, { r1[2][0], r1[2][1] } }, { { r1[0][1], r1[0][2] }, { r1[1][0], r1[1][1] }, { r1[2][0], r1[2][1] } },
	{ { r1[0][1], r1[0][2] }, { r1[1][1], r1[1][2] }, { r1[2][0], r1[2][1] } }, { { r1[0][0], r1[0][1] }, { r1[1][1], r1[1][2] }, { r1[2][0], r1[2][1] } }, 
	{ { r1[0][0], r1[0][1] }, { r1[1][0], r1[1][1] }, { r1[2][1], r1[2][2] } }, { { r1[0][1], r1[0][2] }, { r1[1][0], r1[1][1] }, { r1[2][1], r1[2][2] } },
	{ { r1[0][1], r1[0][2] }, { r1[1][1], r1[1][2] }, { r1[2][1], r1[2][2] } }, { { r1[0][0], r1[0][1] }, { r1[1][1], r1[1][2] }, { r1[2][1], r1[2][2] } }	};
	for (i = 0; i < 8; i++)
	{
		Element3D etmp;
		etmp.lev = lev + 1;
		etmp.prt = eid;
		for (j = 0; j < 3; j++)
		{
			for (k = 0; k < 2; k++)
			{
				etmp.dm[j][k] = enew[i][j][k];
			}
		}
		for (j = 0; j < pkuvw.size(); j++)
		{
			if (pkuvw[j][0] <= enew[i][0][1] && pkuvw[j][4] >= enew[i][0][0] && pkuvw[j][5] <= enew[i][1][1] && pkuvw[j][9] >= enew[i][1][0] &&
				pkuvw[j][10] <= enew[i][2][1] && pkuvw[j][14] >= enew[i][2][0])
			{
				etmp.IEN.push_back(pnid[j]);
				array<double, 5> utmp = { pkuvw[j][0], pkuvw[j][1], pkuvw[j][2], pkuvw[j][3], pkuvw[j][4] };
				array<double, 5> vtmp = { pkuvw[j][5], pkuvw[j][6], pkuvw[j][7], pkuvw[j][8], pkuvw[j][9] };
				array<double, 5> wtmp = { pkuvw[j][10], pkuvw[j][11], pkuvw[j][12], pkuvw[j][13], pkuvw[j][14] };
				etmp.patch_ku.push_back(utmp);
				etmp.patch_kv.push_back(vtmp);
				etmp.patch_kw.push_back(wtmp);
				if (utmp[2] == enew[i][0][0] && utmp[3] == enew[i][0][1] && vtmp[2] == enew[i][1][0] && vtmp[3] == enew[i][1][1] &&
					wtmp[2] == enew[i][2][0] && wtmp[3] == enew[i][2][1])
				{
					etmp.cnct[0] = pnid[j];
				}
				else if (utmp[1] == enew[i][0][0] && utmp[2] == enew[i][0][1] && vtmp[2] == enew[i][1][0] && vtmp[3] == enew[i][1][1] &&
					wtmp[2] == enew[i][2][0] && wtmp[3] == enew[i][2][1])
				{
					etmp.cnct[1] = pnid[j];
				}
				else if (utmp[1] == enew[i][0][0] && utmp[2] == enew[i][0][1] && vtmp[1] == enew[i][1][0] && vtmp[2] == enew[i][1][1] &&
					wtmp[2] == enew[i][2][0] && wtmp[3] == enew[i][2][1])
				{
					etmp.cnct[2] = pnid[j];
				}
				else if (utmp[2] == enew[i][0][0] && utmp[3] == enew[i][0][1] && vtmp[1] == enew[i][1][0] && vtmp[2] == enew[i][1][1] &&
					wtmp[2] == enew[i][2][0] && wtmp[3] == enew[i][2][1])
				{
					etmp.cnct[3] = pnid[j];
				}
				else if (utmp[2] == enew[i][0][0] && utmp[3] == enew[i][0][1] && vtmp[2] == enew[i][1][0] && vtmp[3] == enew[i][1][1] &&
					wtmp[1] == enew[i][2][0] && wtmp[2] == enew[i][2][1])
				{
					etmp.cnct[4] = pnid[j];
				}
				else if (utmp[1] == enew[i][0][0] && utmp[2] == enew[i][0][1] && vtmp[2] == enew[i][1][0] && vtmp[3] == enew[i][1][1] &&
					wtmp[1] == enew[i][2][0] && wtmp[2] == enew[i][2][1])
				{
					etmp.cnct[5] = pnid[j];
				}
				else if (utmp[1] == enew[i][0][0] && utmp[2] == enew[i][0][1] && vtmp[1] == enew[i][1][0] && vtmp[2] == enew[i][1][1] &&
					wtmp[1] == enew[i][2][0] && wtmp[2] == enew[i][2][1])
				{
					etmp.cnct[6] = pnid[j];
				}
				else if (utmp[2] == enew[i][0][0] && utmp[3] == enew[i][0][1] && vtmp[1] == enew[i][1][0] && vtmp[2] == enew[i][1][1] &&
					wtmp[1] == enew[i][2][0] && wtmp[2] == enew[i][2][1])
				{
					etmp.cnct[7] = pnid[j];
				}
			}
		}
		hmesh[lev][eid].chd.push_back(hmesh[lev+1].size());
		hmesh[lev + 1].push_back(etmp);
	}

	hmesh[lev][eid].act = 0;
}

void TruncatedTspline_3D::BisectKnotInterval(const array<double, 5>& kv_in, vector<double>& kv_out)
{
	kv_out.clear();
	for (int i = 0; i < 4; i++)
	{
		kv_out.push_back(kv_in[i]);
		if (kv_in[i] < kv_in[i + 1])
		{
			kv_out.push_back((kv_in[i] + kv_in[i+1]) / 2.);
		}
	}
	kv_out.push_back(kv_in[4]);
}

void TruncatedTspline_3D::PatchRefine_Irregular(int lev, int eid)
{
	if (hmesh.size() < lev + 2)
	{
		vector<Vertex3D> ptmp;
		vector<Element3D> etmp;
		vector<Face3D> fctmp;
		vector<Edge3D> edtmp;
		hcp.push_back(ptmp);
		hmesh.push_back(etmp);
		hface.push_back(fctmp);
		hedge.push_back(edtmp);
	}

	CatmullClark(lev, eid);

	//double range[3][2] = { { hmesh[lev][eid].dm[0][0], hmesh[lev][eid].dm[0][1] }, { hmesh[lev][eid].dm[1][0], hmesh[lev][eid].dm[1][1] },
	//{ hmesh[lev][eid].dm[2][0], hmesh[lev][eid].dm[2][1] } };
	//vector<double> ku0(8), kv0(8), kw0(8), ku1(9), kv1(9), kw1(9);
	//uint n, i, j, k;
	//for (i = 0; i < 4; i++)
	//{
	//	ku0[i] = range[0][0]; ku0[i + 4] = range[0][1];
	//	kv0[i] = range[1][0]; kv0[i + 4] = range[1][1];
	//	kw0[i] = range[2][0]; kw0[i + 4] = range[2][1];
	//	ku1[i] = range[0][0]; ku1[i + 5] = range[0][1];
	//	kv1[i] = range[1][0]; kv1[i + 5] = range[1][1];
	//	kw1[i] = range[2][0]; kw1[i + 5] = range[2][1];
	//}
	//ku1[4] = (range[0][0] + range[0][1]) / 2.;
	//kv1[4] = (range[1][0] + range[1][1]) / 2.;
	//kw1[4] = (range[2][0] + range[2][1]) / 2.;
	//vector<vector<double>> Tu, Tv, Tw;
	//TMatrix(ku0, ku1, 3, Tu);
	//TMatrix(kv0, kv1, 3, Tv);
	//TMatrix(kw0, kw1, 3, Tw);
	////calculate new control points using Catmull-Clark
	//vector<array<double, 3>> pnew;
	//vector<vector<int>> chdid(hmesh[lev][eid].IEN.size());
	//vector<vector<double>> coef(hmesh[lev][eid].IEN.size());


	//double r1[3][3] = { { range[0][0], (range[0][0] + range[0][1]) / 2., range[0][1] }, { range[1][0], (range[1][0] + range[1][1]) / 2., range[1][1] },
	//{ range[2][0], (range[2][0] + range[2][1]) / 2., range[2][1] } };
	//double e_dm[8][3][2] = { { { r1[0][0], r1[0][1] }, { r1[1][0], r1[1][1] }, { r1[2][0], r1[2][1] } }, { { r1[0][1], r1[0][2] }, { r1[1][0], r1[1][1] }, { r1[2][0], r1[2][1] } },
	//{ { r1[0][1], r1[0][2] }, { r1[1][1], r1[1][2] }, { r1[2][0], r1[2][1] } }, { { r1[0][0], r1[0][1] }, { r1[1][1], r1[1][2] }, { r1[2][0], r1[2][1] } },
	//{ { r1[0][0], r1[0][1] }, { r1[1][0], r1[1][1] }, { r1[2][1], r1[2][2] } }, { { r1[0][1], r1[0][2] }, { r1[1][0], r1[1][1] }, { r1[2][1], r1[2][2] } },
	//{ { r1[0][1], r1[0][2] }, { r1[1][1], r1[1][2] }, { r1[2][1], r1[2][2] } }, { { r1[0][0], r1[0][1] }, { r1[1][1], r1[1][2] }, { r1[2][1], r1[2][2] } } };
}

void TruncatedTspline_3D::CatmullClark(int lev, int eid)
{
	uint i, j, k;
	vector<int> bdid, fcid, edid;
	bdid.push_back(eid);
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].hex.size(); j++)
		{
			vector<int>::iterator it = find(bdid.begin(), bdid.end(), hcp[lev][hmesh[lev][eid].cnct[i]].hex[j]);
			if (it == bdid.end())
			{
				bdid.push_back(hcp[lev][hmesh[lev][eid].cnct[i]].hex[j]);
			}
		}
		for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].face.size(); j++)
		{
			vector<int>::iterator it = find(fcid.begin(), fcid.end(), hcp[lev][hmesh[lev][eid].cnct[i]].face[j]);
			if (it == fcid.end())
			{
				fcid.push_back(hcp[lev][hmesh[lev][eid].cnct[i]].face[j]);
			}
		}
		for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].edge.size(); j++)
		{
			vector<int>::iterator it = find(edid.begin(), edid.end(), hcp[lev][hmesh[lev][eid].cnct[i]].edge[j]);
			if (it == edid.end())
			{
				edid.push_back(hcp[lev][hmesh[lev][eid].cnct[i]].edge[j]);
			}
		}
	}
	//calculate coordinates of new points
	vector<array<double, 3>> pn_bd(bdid.size()), pn_fc(fcid.size()), pn_ed(edid.size()), pn_vt(8);
	vector<array<double, 3>> pn_fc0(fcid.size()), pn_ed0(edid.size());
	for (i = 0; i < bdid.size(); i++)
	{
		pn_bd[i][0] = 0.; pn_bd[i][1] = 0.; pn_bd[i][2] = 0.;
		for (j = 0; j < 8; j++)
		{
			pn_bd[i][0] += .125*hcp[lev][hmesh[lev][bdid[i]].cnct[j]].coor[0];
			pn_bd[i][1] += .125*hcp[lev][hmesh[lev][bdid[i]].cnct[j]].coor[1];
			pn_bd[i][2] += .125*hcp[lev][hmesh[lev][bdid[i]].cnct[j]].coor[2];
		}
	}
	for (i = 0; i < fcid.size(); i++)
	{
		pn_fc0[i][0] = 0.; pn_fc0[i][1] = 0.; pn_fc0[i][2] = 0.;
		for (j = 0; j < 4; j++)
		{
			pn_fc0[i][0] += .25*hcp[lev][hface[lev][fcid[i]].cnct[j]].coor[0];
			pn_fc0[i][1] += .25*hcp[lev][hface[lev][fcid[i]].cnct[j]].coor[1];
			pn_fc0[i][2] += .25*hcp[lev][hface[lev][fcid[i]].cnct[j]].coor[2];
		}
		vector<int>::iterator it1 = find(bdid.begin(), bdid.end(), hface[lev][fcid[i]].hex[0]);
		vector<int>::iterator it2 = find(bdid.begin(), bdid.end(), hface[lev][fcid[i]].hex[1]);
		int pos1(it1 - bdid.begin()), pos2(it2 - bdid.begin());
		pn_fc[i][0] = (pn_bd[pos1][0] + pn_bd[pos2][0] + 2.*pn_fc0[i][0]) / 4.;
		pn_fc[i][1] = (pn_bd[pos1][1] + pn_bd[pos2][1] + 2.*pn_fc0[i][1]) / 4.;
		pn_fc[i][2] = (pn_bd[pos1][2] + pn_bd[pos2][2] + 2.*pn_fc0[i][2]) / 4.;
	}
	for (i = 0; i < edid.size(); i++)
	{
		pn_ed0[i][0] = (hcp[lev][hedge[lev][edid[i]].pt[0]].coor[0] + hcp[lev][hedge[lev][edid[i]].pt[1]].coor[0]) / 2.;
		pn_ed0[i][1] = (hcp[lev][hedge[lev][edid[i]].pt[0]].coor[1] + hcp[lev][hedge[lev][edid[i]].pt[1]].coor[1]) / 2.;
		pn_ed0[i][2] = (hcp[lev][hedge[lev][edid[i]].pt[0]].coor[2] + hcp[lev][hedge[lev][edid[i]].pt[1]].coor[2]) / 2.;
		array<double, 3> f_avg = { 0., 0., 0. }, b_avg = {0.,0.,0.};
		for (j = 0; j < hedge[lev][edid[i]].hex.size(); j++)
		{
			vector<int>::iterator it = find(bdid.begin(), bdid.end(), hedge[lev][edid[i]].hex[j]);
			int pos(it - bdid.begin());
			b_avg[0] += pn_bd[pos][0]; b_avg[1] += pn_bd[pos][1]; b_avg[2] += pn_bd[pos][2];
		}
		b_avg[0] /= hedge[lev][edid[i]].hex.size(); b_avg[1] /= hedge[lev][edid[i]].hex.size(); b_avg[2] /= hedge[lev][edid[i]].hex.size();
		for (j = 0; j < hedge[lev][edid[i]].face.size(); j++)
		{
			vector<int>::iterator it = find(fcid.begin(), fcid.end(), hedge[lev][edid[i]].face[j]);
			int pos(it - fcid.begin());
			f_avg[0] += pn_fc0[pos][0]; f_avg[1] += pn_fc0[pos][1]; f_avg[2] += pn_fc0[pos][2];
		}
		f_avg[0] /= hedge[lev][edid[i]].face.size(); f_avg[1] /= hedge[lev][edid[i]].face.size(); f_avg[2] /= hedge[lev][edid[i]].face.size();
		uint n = hedge[lev][edid[i]].face.size();
		pn_ed[i][0] = (b_avg[0] + 2.*f_avg[0] + (n - 3)*pn_ed0[i][0]) / n;
		pn_ed[i][1] = (b_avg[1] + 2.*f_avg[1] + (n - 3)*pn_ed0[i][1]) / n;
		pn_ed[i][2] = (b_avg[2] + 2.*f_avg[2] + (n - 3)*pn_ed0[i][2]) / n;
	}
	for (i = 0; i < 8; i++)
	{
		pn_vt[i][0] = hcp[lev][hmesh[lev][eid].cnct[i]].coor[0];
		pn_vt[i][1] = hcp[lev][hmesh[lev][eid].cnct[i]].coor[1];
		pn_vt[i][2] = hcp[lev][hmesh[lev][eid].cnct[i]].coor[2];
		array<double, 3> b_avg = { 0., 0., 0. }, f_avg = { 0., 0., 0. }, e_avg = { 0., 0., 0. };
		uint n(hcp[lev][hmesh[lev][eid].cnct[i]].hex.size());
		for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].hex.size(); j++)
		{
			vector<int>::iterator it = find(bdid.begin(), bdid.end(), hcp[lev][hmesh[lev][eid].cnct[i]].hex[j]);
			int pos(it - bdid.begin());
			b_avg[0] += pn_bd[pos][0]; b_avg[1] += pn_bd[pos][1]; b_avg[2] += pn_bd[pos][2];
		}
		b_avg[0] /= n; b_avg[1] /= n; b_avg[2] /= n;
		n = hcp[lev][hmesh[lev][eid].cnct[i]].face.size();
		for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].face.size(); j++)
		{
			vector<int>::iterator it = find(fcid.begin(), fcid.end(), hcp[lev][hmesh[lev][eid].cnct[i]].face[j]);
			int pos(it - fcid.begin());
			f_avg[0] += pn_fc0[pos][0]; f_avg[1] += pn_fc0[pos][1]; f_avg[2] += pn_fc0[pos][2];
		}
		f_avg[0] /= n; f_avg[1] /= n; f_avg[2] /= n;
		n = hcp[lev][hmesh[lev][eid].cnct[i]].edge.size();
		for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].edge.size(); j++)
		{
			vector<int>::iterator it = find(edid.begin(), edid.end(), hcp[lev][hmesh[lev][eid].cnct[i]].edge[j]);
			int pos(it - edid.begin());
			e_avg[0] += pn_ed0[pos][0]; e_avg[1] += pn_ed0[pos][1]; e_avg[2] += pn_ed0[pos][2];
		}
		e_avg[0] /= n; e_avg[1] /= n; e_avg[2] /= n;
		pn_vt[i][0] = (b_avg[0] + 3.*f_avg[0] + 3.*e_avg[0] + pn_vt[i][0]) / 8.;
		pn_vt[i][1] = (b_avg[1] + 3.*f_avg[1] + 3.*e_avg[1] + pn_vt[i][1]) / 8.;
		pn_vt[i][2] = (b_avg[2] + 3.*f_avg[2] + 3.*e_avg[2] + pn_vt[i][2]) / 8.;
	}
	//find global index of new points at Level+1
	vector<int> pnid_bd(pn_bd.size()), pnid_fc(pn_fc.size()), pnid_ed(pn_ed.size()), pnid_vt(pn_vt.size());
	for (i = 0; i < bdid.size(); i++)
	{
		if (hmesh[lev][bdid[i]].pbd_id == -1)
		{
			Vertex3D cptmp;
			cptmp.coor[0] = pn_bd[i][0]; cptmp.coor[1] = pn_bd[i][1]; cptmp.coor[2] = pn_bd[i][2];
			cptmp.lev = lev + 1;
			hcp[lev + 1].push_back(cptmp);
			hmesh[lev][bdid[i]].pbd_id = hcp[lev + 1].size() - 1;
		}
		pnid_bd[i] = hmesh[lev][bdid[i]].pbd_id;
	}
	for (i = 0; i < fcid.size(); i++)
	{
		if (hface[lev][fcid[i]].pfc_id == -1)
		{
			Vertex3D cptmp;
			cptmp.coor[0] = pn_fc[i][0]; cptmp.coor[1] = pn_fc[i][1]; cptmp.coor[2] = pn_fc[i][2];
			cptmp.lev = lev + 1;
			hcp[lev + 1].push_back(cptmp);
			hface[lev][fcid[i]].pfc_id = hcp[lev + 1].size() - 1;
		}
		pnid_fc[i] = hface[lev][fcid[i]].pfc_id;
	}
	for (i = 0; i < edid.size(); i++)
	{
		if (hedge[lev][edid[i]].ped_id == -1)
		{
			Vertex3D cptmp;
			cptmp.coor[0] = pn_ed[i][0]; cptmp.coor[1] = pn_ed[i][1]; cptmp.coor[2] = pn_ed[i][2];
			cptmp.lev = lev + 1;
			hcp[lev + 1].push_back(cptmp);
			hedge[lev][edid[i]].ped_id = hcp[lev + 1].size() - 1;
		}
		pnid_ed[i] = hedge[lev][edid[i]].ped_id;
	}
	for (i = 0; i < 8; i++)
	{
		if (hcp[lev][hmesh[lev][eid].cnct[i]].pvt_id == -1)
		{
			Vertex3D cptmp;
			cptmp.coor[0] = pn_vt[i][0]; cptmp.coor[1] = pn_vt[i][1]; cptmp.coor[2] = pn_vt[i][2];
			cptmp.lev = lev + 1;
			hcp[lev + 1].push_back(cptmp);
			hcp[lev][hmesh[lev][eid].cnct[i]].pvt_id = hcp[lev + 1].size() - 1;
		}
		pnid_vt[i] = hcp[lev][hmesh[lev][eid].cnct[i]].pvt_id;
	}

	/*double tol(1.e-6), dis(0.);
	uint np0(hcp[lev + 1].size());
	for (i = 0; i < pn_bd.size(); i++)
	{
		int flag(0);
		for (j = 0; j < np0; j++)
		{
			dis = sqrt((pn_bd[i][0] - hcp[lev + 1][j].coor[0])*(pn_bd[i][0] - hcp[lev + 1][j].coor[0]) + (pn_bd[i][1] - hcp[lev + 1][j].coor[1])*(pn_bd[i][1] - hcp[lev + 1][j].coor[1]) +
				(pn_bd[i][2] - hcp[lev + 1][j].coor[2])*(pn_bd[i][2] - hcp[lev + 1][j].coor[2]));
			if (dis < tol)
			{
				flag = 1; pnid_bd[i] = j; break;
			}
		}
		if (flag == 0)
		{
			pnid_bd[i] = hcp[lev + 1].size();
			Vertex3D cptmp;
			cptmp.coor[0] = pn_bd[i][0]; cptmp.coor[1] = pn_bd[i][1]; cptmp.coor[2] = pn_bd[i][2];
			cptmp.lev = lev + 1;
			hcp[lev + 1].push_back(cptmp);
		}
	}
	for (i = 0; i < pn_fc.size(); i++)
	{
		int flag(0);
		for (j = 0; j < np0; j++)
		{
			dis = sqrt((pn_fc[i][0] - hcp[lev + 1][j].coor[0])*(pn_fc[i][0] - hcp[lev + 1][j].coor[0]) + (pn_fc[i][1] - hcp[lev + 1][j].coor[1])*(pn_fc[i][1] - hcp[lev + 1][j].coor[1]) +
				(pn_fc[i][2] - hcp[lev + 1][j].coor[2])*(pn_fc[i][2] - hcp[lev + 1][j].coor[2]));
			if (dis < tol)
			{
				flag = 1; pnid_fc[i] = j; break;
			}
		}
		if (flag == 0)
		{
			pnid_fc[i] = hcp[lev + 1].size();
			Vertex3D cptmp;
			cptmp.coor[0] = pn_fc[i][0]; cptmp.coor[1] = pn_fc[i][1]; cptmp.coor[2] = pn_fc[i][2];
			cptmp.lev = lev + 1;
			hcp[lev + 1].push_back(cptmp);
		}
	}
	for (i = 0; i < pn_ed.size(); i++)
	{
		int flag(0);
		for (j = 0; j < np0; j++)
		{
			dis = sqrt((pn_ed[i][0] - hcp[lev + 1][j].coor[0])*(pn_ed[i][0] - hcp[lev + 1][j].coor[0]) + (pn_ed[i][1] - hcp[lev + 1][j].coor[1])*(pn_ed[i][1] - hcp[lev + 1][j].coor[1]) +
				(pn_ed[i][2] - hcp[lev + 1][j].coor[2])*(pn_ed[i][2] - hcp[lev + 1][j].coor[2]));
			if (dis < tol)
			{
				flag = 1; pnid_ed[i] = j; break;
			}
		}
		if (flag == 0)
		{
			pnid_ed[i] = hcp[lev + 1].size();
			Vertex3D cptmp;
			cptmp.coor[0] = pn_ed[i][0]; cptmp.coor[1] = pn_ed[i][1]; cptmp.coor[2] = pn_ed[i][2];
			cptmp.lev = lev + 1;
			hcp[lev + 1].push_back(cptmp);
		}
	}
	for (i = 0; i < pn_vt.size(); i++)
	{
		int flag(0);
		for (j = 0; j < np0; j++)
		{
			dis = sqrt((pn_vt[i][0] - hcp[lev + 1][j].coor[0])*(pn_vt[i][0] - hcp[lev + 1][j].coor[0]) + (pn_vt[i][1] - hcp[lev + 1][j].coor[1])*(pn_vt[i][1] - hcp[lev + 1][j].coor[1]) +
				(pn_vt[i][2] - hcp[lev + 1][j].coor[2])*(pn_vt[i][2] - hcp[lev + 1][j].coor[2]));
			if (dis < tol)
			{
				flag = 1; pnid_vt[i] = j; break;
			}
		}
		if (flag == 0)
		{
			pnid_vt[i] = hcp[lev + 1].size();
			Vertex3D cptmp;
			cptmp.coor[0] = pn_vt[i][0]; cptmp.coor[1] = pn_vt[i][1]; cptmp.coor[2] = pn_vt[i][2];
			cptmp.lev = lev + 1;
			hcp[lev + 1].push_back(cptmp);
		}
	}*/

	//find children id and corresponding coefficients
	//vector<vector<int>> chdid(hmesh[lev][eid].IEN.size());
	//vector<vector<double>> coef(hmesh[lev][eid].IEN.size());

	vector<array<int, 8>> bdmp(bdid.size());
	vector<array<double, 8>> bdc(bdid.size());
	vector<vector<int>> fcmp(fcid.size());
	vector<vector<double>> fcc(fcid.size());
	vector<vector<int>> edmp(edid.size());
	vector<vector<double>> edc(edid.size());
	vector<vector<int>> vtmp(8);
	vector<vector<double>> vtc(8);
	//body points
	for (i = 0; i < bdid.size(); i++)
	{
		for (j = 0; j < 8; j++)
		{
			bdmp[i][j]=hmesh[lev][bdid[i]].cnct[j];
			bdc[i][j] = .125;
		}
	}
	//face points
	for (i = 0; i < fcid.size(); i++)
	{
		for (j = 0; j < 4; j++)
		{
			fcmp[i].push_back(hface[lev][fcid[i]].cnct[j]);
			fcc[i].push_back(2.*.25/4.);
		}
		for (j = 0; j < hface[lev][fcid[i]].hex.size(); j++)
		{
			int hxid(hface[lev][fcid[i]].hex[j]);
			for (k = 0; k < 8; k++)
			{
				vector<int>::iterator it = find(fcmp[i].begin(),fcmp[i].end(),hmesh[lev][hxid].cnct[k]);
				double ctmp(.125/4.);
				if (it == fcmp[i].end())
				{
					fcmp[i].push_back(hmesh[lev][hxid].cnct[k]);
					fcc[i].push_back(ctmp);
				}
				else
				{
					int pos(it - fcmp[i].begin());
					fcc[i][pos] += ctmp;
				}
			}
		}
	}
	//cout
	//for (i = 0; i < fcc.size(); i++)
	//{
	//	double sum(0.);
	//	for (j = 0; j < fcc[i].size(); j++)
	//	{
	//		sum += fcc[i][j];
	//	}
	//	if (sum != 1.)
	//	{
	//		cout << "face point sum not 1\n";
	//		getchar();
	//	}
	//}
	//edge points
	for (i = 0; i < edid.size(); i++)
	{
		uint n(hedge[lev][edid[i]].hex.size());
		for (j = 0; j < 2; j++)
		{
			edmp[i].push_back(hedge[lev][edid[i]].pt[j]);
			edc[i].push_back(.5*double(n-3)/n);
		}
		for (j = 0; j < hedge[lev][edid[i]].hex.size(); j++)
		{
			int hxid(hedge[lev][edid[i]].hex[j]);
			for (k = 0; k < 8; k++)
			{
				vector<int>::iterator it = find(edmp[i].begin(), edmp[i].end(), hmesh[lev][hxid].cnct[k]);
				double ctmp(.125 / double(n*n));
				if (it == edmp[i].end())
				{
					edmp[i].push_back(hmesh[lev][hxid].cnct[k]);
					edc[i].push_back(ctmp);
				}
				else
				{
					int pos(it - edmp[i].begin());
					edc[i][pos] += ctmp;
				}
			}
		}
		for (j = 0; j < hedge[lev][edid[i]].face.size(); j++)
		{
			int fcid(hedge[lev][edid[i]].face[j]);
			for (k = 0; k < 4; k++)
			{
				vector<int>::iterator it = find(edmp[i].begin(), edmp[i].end(), hface[lev][fcid].cnct[k]);
				double ctmp(2.*.25 / double(n*n));
				if (it == edmp[i].end())
				{
					edmp[i].push_back(hface[lev][fcid].cnct[k]);
					edc[i].push_back(ctmp);
				}
				else
				{
					int pos(it - edmp[i].begin());
					edc[i][pos] += ctmp;
				}
			}
		}
	}
	//cout
	//for (i = 0; i < edc.size(); i++)
	//{
	//	double sum(0.), tol(1.e-10);
	//	for (j = 0; j < edc[i].size(); j++)
	//	{
	//		sum += edc[i][j];
	//	}
	//	if (fabs(sum-1.)>tol)
	//	{
	//		cout << "edge point " << sum <<"\n";
	//		//cout << "edge valence hex: " << edvl_hx[i] << "\n";
	//		////cout << "edge valence face: " << edvl_fc[i] << "\n";
	//		//cout << "# contribution: " << edmp[i].size() << "\n";
	//		//for (j = 0; j < edmp[i].size(); j++)
	//		//{
	//		//	cout << setw(6)<< edmp[i][j] << " ";
	//		//}
	//		//cout << "\n";
	//		//for (j = 0; j < edc[i].size(); j++)
	//		//{
	//		//	cout << setw(6) << edc[i][j] << " ";
	//		//}
	//		//cout << "\n";
	//		getchar();
	//	}
	//}
	//vertex points
	for (i = 0; i < 8; i++)
	{
		int ptid(hmesh[lev][eid].cnct[i]);
		uint nhx(hcp[lev][ptid].hex.size()), nfc(hcp[lev][ptid].face.size()), ned(hcp[lev][ptid].edge.size());
		vtmp[i].push_back(ptid);
		vtc[i].push_back(.125);
		for (j = 0; j < nhx; j++)
		{
			int hxid(hcp[lev][ptid].hex[j]);
			for (k = 0; k < 8; k++)
			{
				vector<int>::iterator it = find(vtmp[i].begin(),vtmp[i].end(),hmesh[lev][hxid].cnct[k]);
				double ctmp(.125/(8.*nhx));
				if (it == vtmp[i].end())
				{
					vtmp[i].push_back(hmesh[lev][hxid].cnct[k]);
					vtc[i].push_back(ctmp);
				}
				else
				{
					int pos(it - vtmp[i].begin());
					vtc[i][pos] += ctmp;
				}
			}
		}
		for (j = 0; j < nfc; j++)
		{
			int fcid(hcp[lev][ptid].face[j]);
			for (k = 0; k < 4; k++)
			{
				vector<int>::iterator it = find(vtmp[i].begin(), vtmp[i].end(), hface[lev][fcid].cnct[k]);
				double ctmp(3.*.25 / (8.*nfc));
				if (it == vtmp[i].end())
				{
					vtmp[i].push_back(hface[lev][fcid].cnct[k]);
					vtc[i].push_back(ctmp);
				}
				else
				{
					int pos(it - vtmp[i].begin());
					vtc[i][pos] += ctmp;
				}
			}
		}
		for (j = 0; j < ned; j++)
		{
			int edid(hcp[lev][ptid].edge[j]);
			for (k = 0; k < 2; k++)
			{
				vector<int>::iterator it = find(vtmp[i].begin(), vtmp[i].end(), hedge[lev][edid].pt[k]);
				double ctmp(3.*.5 / (8.*ned));
				if (it == vtmp[i].end())
				{
					vtmp[i].push_back(hedge[lev][edid].pt[k]);
					vtc[i].push_back(ctmp);
				}
				else
				{
					int pos(it - vtmp[i].begin());
					vtc[i][pos] += ctmp;
				}
			}
		}
	}
	//cout
	//for (i = 0; i < vtc.size(); i++)
	//{
	//	double sum(0.);
	//	for (j = 0; j < vtc[i].size(); j++)
	//	{
	//		sum += vtc[i][j];
	//	}
	//	if (fabs(sum - 1.)>tol)
	//	{
	//		cout << "vertex point " << sum << "\n";
	//		getchar();
	//	}
	//}
	//children and coef
	for (i = 0; i < bdmp.size(); i++)
	{
		for (j = 0; j < bdmp[i].size(); j++)
		{
			vector<int>::iterator it = find(hcp[lev][bdmp[i][j]].chd.begin(), hcp[lev][bdmp[i][j]].chd.end(), pnid_bd[i]);
			if (it == hcp[lev][bdmp[i][j]].chd.end())
			{
				hcp[lev][bdmp[i][j]].chd.push_back(pnid_bd[i]);
				hcp[lev][bdmp[i][j]].coef.push_back(bdc[i][j]);
			}
		}
	}
	for (i = 0; i < fcmp.size(); i++)
	{
		for (j = 0; j < fcmp[i].size(); j++)
		{
			vector<int>::iterator it = find(hcp[lev][fcmp[i][j]].chd.begin(), hcp[lev][fcmp[i][j]].chd.end(), pnid_fc[i]);
			if (it == hcp[lev][fcmp[i][j]].chd.end())
			{
				hcp[lev][fcmp[i][j]].chd.push_back(pnid_fc[i]);
				hcp[lev][fcmp[i][j]].coef.push_back(fcc[i][j]);
			}
		}
	}
	for (i = 0; i < edmp.size(); i++)
	{
		for (j = 0; j < edmp[i].size(); j++)
		{
			vector<int>::iterator it = find(hcp[lev][edmp[i][j]].chd.begin(), hcp[lev][edmp[i][j]].chd.end(), pnid_ed[i]);
			if (it == hcp[lev][edmp[i][j]].chd.end())
			{
				hcp[lev][edmp[i][j]].chd.push_back(pnid_ed[i]);
				hcp[lev][edmp[i][j]].coef.push_back(edc[i][j]);
			}
		}
	}
	for (i = 0; i < vtmp.size(); i++)
	{
		for (j = 0; j < vtmp[i].size(); j++)
		{
			vector<int>::iterator it = find(hcp[lev][vtmp[i][j]].chd.begin(), hcp[lev][vtmp[i][j]].chd.end(), pnid_vt[i]);
			if (it == hcp[lev][vtmp[i][j]].chd.end())
			{
				hcp[lev][vtmp[i][j]].chd.push_back(pnid_vt[i]);
				hcp[lev][vtmp[i][j]].coef.push_back(vtc[i][j]);
			}
		}
	}
	//local index of new points
	vector<int> ed_loc(12), fc_loc(6), vt_loc(pnid_vt);
	int bd_loc(pnid_bd[0]);
	for (i = 0; i < 12; i++)
	{
		vector<int>::iterator it = find(edid.begin(), edid.end(), hmesh[lev][eid].edge[i]);
		int pos(it - edid.begin());
		ed_loc[i] = pnid_ed[pos];
	}
	for (i = 0; i < 6; i++)
	{
		vector<int>::iterator it = find(fcid.begin(), fcid.end(), hmesh[lev][eid].face[i]);
		int pos(it - fcid.begin());
		fc_loc[i] = pnid_fc[pos];
	}
	//construct new hex
	int enew[8][8] = { { vt_loc[0], ed_loc[0], fc_loc[0], ed_loc[3], ed_loc[4], fc_loc[1], bd_loc, fc_loc[4] },
	{ ed_loc[0], vt_loc[1], ed_loc[1], fc_loc[0], fc_loc[1], ed_loc[5], fc_loc[2], bd_loc },
	{ fc_loc[0], ed_loc[1], vt_loc[2], ed_loc[2], bd_loc, fc_loc[2], ed_loc[6], fc_loc[3] },
	{ ed_loc[3], fc_loc[0], ed_loc[2], vt_loc[3], fc_loc[4], bd_loc, fc_loc[3], ed_loc[7] },
	{ ed_loc[4], fc_loc[1], bd_loc, fc_loc[4], vt_loc[4], ed_loc[8], fc_loc[5], ed_loc[11] },
	{ fc_loc[1], ed_loc[5], fc_loc[2], bd_loc, ed_loc[8], vt_loc[5], ed_loc[9], fc_loc[5] },
	{ bd_loc, fc_loc[2], ed_loc[6], fc_loc[3], fc_loc[5], ed_loc[9], vt_loc[6], ed_loc[10] },
	{ fc_loc[4], bd_loc, fc_loc[3], ed_loc[7], ed_loc[11], fc_loc[5], ed_loc[10], vt_loc[7] } };

	for (i = 0; i < 8; i++)
	{
		Element3D etmp;
		etmp.type = 2;//tmp, determined by the topology at level (lev+1)
		etmp.lev = lev + 1;
		etmp.prt = eid;
		for (j = 0; j < 8; j++)
		{
			etmp.cnct[j] = enew[i][j];
		}
		hmesh[lev][eid].chd.push_back(hmesh[lev+1].size());
		hmesh[lev + 1].push_back(etmp);
	}

	hmesh[lev][eid].act = 0;
}

void TruncatedTspline_3D::PatchRefine_Boundary(int lev, int eid)
{
	if (hmesh.size() < lev + 2)
	{
		vector<Vertex3D> ptmp;
		vector<Element3D> etmp;
		vector<Face3D> fctmp;
		vector<Edge3D> edtmp;
		hcp.push_back(ptmp);
		hmesh.push_back(etmp);
		hface.push_back(fctmp);
		hedge.push_back(edtmp);
	}

	uint i, j, k;
	vector<int> bdid, fcid, edid;
	bdid.push_back(eid);
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].hex.size(); j++)
		{
			vector<int>::iterator it = find(bdid.begin(), bdid.end(), hcp[lev][hmesh[lev][eid].cnct[i]].hex[j]);
			if (it == bdid.end())
			{
				bdid.push_back(hcp[lev][hmesh[lev][eid].cnct[i]].hex[j]);
			}
		}
		for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].face.size(); j++)
		{
			vector<int>::iterator it = find(fcid.begin(), fcid.end(), hcp[lev][hmesh[lev][eid].cnct[i]].face[j]);
			if (it == fcid.end())
			{
				fcid.push_back(hcp[lev][hmesh[lev][eid].cnct[i]].face[j]);
			}
		}
		for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].edge.size(); j++)
		{
			vector<int>::iterator it = find(edid.begin(), edid.end(), hcp[lev][hmesh[lev][eid].cnct[i]].edge[j]);
			if (it == edid.end())
			{
				edid.push_back(hcp[lev][hmesh[lev][eid].cnct[i]].edge[j]);
			}
		}
	}
	//calculate coordinates of new points
	vector<array<double, 3>> pn_bd(bdid.size()), pn_fc(fcid.size()), pn_ed(edid.size()), pn_vt(8);
	vector<array<double, 3>> pn_fc0(fcid.size()), pn_ed0(edid.size());
	vector<int> fc_type(fcid.size(),0), ed_type(edid.size(),0), vt_type(8,0);
	vector<int> ed_shp(edid.size(),0), vt_shp(8,0);
	for (i = 0; i < bdid.size(); i++)
	{
		pn_bd[i][0] = 0.; pn_bd[i][1] = 0.; pn_bd[i][2] = 0.;
		for (j = 0; j < 8; j++)
		{
			pn_bd[i][0] += .125*hcp[lev][hmesh[lev][bdid[i]].cnct[j]].coor[0];
			pn_bd[i][1] += .125*hcp[lev][hmesh[lev][bdid[i]].cnct[j]].coor[1];
			pn_bd[i][2] += .125*hcp[lev][hmesh[lev][bdid[i]].cnct[j]].coor[2];
		}
	}
	for (i = 0; i < fcid.size(); i++)
	{
		pn_fc0[i][0] = 0.; pn_fc0[i][1] = 0.; pn_fc0[i][2] = 0.;
		for (j = 0; j < 4; j++)
		{
			pn_fc0[i][0] += .25*hcp[lev][hface[lev][fcid[i]].cnct[j]].coor[0];
			pn_fc0[i][1] += .25*hcp[lev][hface[lev][fcid[i]].cnct[j]].coor[1];
			pn_fc0[i][2] += .25*hcp[lev][hface[lev][fcid[i]].cnct[j]].coor[2];
		}
		if (hface[lev][fcid[i]].type==0)
		{
			vector<int>::iterator it1 = find(bdid.begin(), bdid.end(), hface[lev][fcid[i]].hex[0]);
			vector<int>::iterator it2 = find(bdid.begin(), bdid.end(), hface[lev][fcid[i]].hex[1]);
			int pos1(it1 - bdid.begin()), pos2(it2 - bdid.begin());
			pn_fc[i][0] = (pn_bd[pos1][0] + pn_bd[pos2][0] + 2.*pn_fc0[i][0]) / 4.;
			pn_fc[i][1] = (pn_bd[pos1][1] + pn_bd[pos2][1] + 2.*pn_fc0[i][1]) / 4.;
			pn_fc[i][2] = (pn_bd[pos1][2] + pn_bd[pos2][2] + 2.*pn_fc0[i][2]) / 4.;
		}
		else if (hface[lev][fcid[i]].type == 1)
		{
			pn_fc[i][0] = pn_fc0[i][0];
			pn_fc[i][1] = pn_fc0[i][1];
			pn_fc[i][2] = pn_fc0[i][2];
			fc_type[i] = 1;
		}
	}
	for (i = 0; i < edid.size(); i++)
	{
		pn_ed0[i][0] = (hcp[lev][hedge[lev][edid[i]].pt[0]].coor[0] + hcp[lev][hedge[lev][edid[i]].pt[1]].coor[0]) / 2.;
		pn_ed0[i][1] = (hcp[lev][hedge[lev][edid[i]].pt[0]].coor[1] + hcp[lev][hedge[lev][edid[i]].pt[1]].coor[1]) / 2.;
		pn_ed0[i][2] = (hcp[lev][hedge[lev][edid[i]].pt[0]].coor[2] + hcp[lev][hedge[lev][edid[i]].pt[1]].coor[2]) / 2.;
		if (hedge[lev][edid[i]].sharp == 1)//boundary sharp edge
		{
			pn_ed[i][0] = pn_ed0[i][0]; pn_ed[i][1] = pn_ed0[i][1]; pn_ed[i][2] = pn_ed0[i][2];
			ed_type[i] = 1;
			ed_shp[i] = 1;
		}
		else if (hedge[lev][edid[i]].type==1)//boundary non-sharp edge
		{
			array<double, 3> f_avg = { 0., 0., 0. };
			int nfc(0);
			for (j = 0; j < hedge[lev][edid[i]].face.size(); j++)
			{
				if (hface[lev][hedge[lev][edid[i]].face[j]].type == 1)
				{
					vector<int>::iterator it = find(fcid.begin(), fcid.end(), hedge[lev][edid[i]].face[j]);
					int pos(it - fcid.begin());
					f_avg[0] += pn_fc0[pos][0]; f_avg[1] += pn_fc0[pos][1]; f_avg[2] += pn_fc0[pos][2];
					nfc++;
				}
			}
			if (nfc != 2)
			{
				cerr << "# of boundary faces connected to the edge is wrong!\n";
				getchar();
			}
			f_avg[0] /= nfc; f_avg[1] /= nfc; f_avg[2] /= nfc;
			pn_ed[i][0] = (f_avg[0] + pn_ed0[i][0]) / nfc;
			pn_ed[i][1] = (f_avg[1] + pn_ed0[i][1]) / nfc;
			pn_ed[i][2] = (f_avg[2] + pn_ed0[i][2]) / nfc;
			ed_type[i] = 1;
			ed_shp[i] = 0;
		}
		else//interior
		{
			array<double, 3> f_avg = { 0., 0., 0. }, b_avg = { 0., 0., 0. };
			for (j = 0; j < hedge[lev][edid[i]].hex.size(); j++)
			{
				vector<int>::iterator it = find(bdid.begin(), bdid.end(), hedge[lev][edid[i]].hex[j]);
				int pos(it - bdid.begin());
				b_avg[0] += pn_bd[pos][0]; b_avg[1] += pn_bd[pos][1]; b_avg[2] += pn_bd[pos][2];
			}
			b_avg[0] /= hedge[lev][edid[i]].hex.size(); b_avg[1] /= hedge[lev][edid[i]].hex.size(); b_avg[2] /= hedge[lev][edid[i]].hex.size();
			for (j = 0; j < hedge[lev][edid[i]].face.size(); j++)
			{
				vector<int>::iterator it = find(fcid.begin(), fcid.end(), hedge[lev][edid[i]].face[j]);
				int pos(it - fcid.begin());
				f_avg[0] += pn_fc0[pos][0]; f_avg[1] += pn_fc0[pos][1]; f_avg[2] += pn_fc0[pos][2];
			}
			f_avg[0] /= hedge[lev][edid[i]].face.size(); f_avg[1] /= hedge[lev][edid[i]].face.size(); f_avg[2] /= hedge[lev][edid[i]].face.size();
			uint n = hedge[lev][edid[i]].face.size();
			pn_ed[i][0] = (b_avg[0] + 2.*f_avg[0] + (n - 3)*pn_ed0[i][0]) / n;
			pn_ed[i][1] = (b_avg[1] + 2.*f_avg[1] + (n - 3)*pn_ed0[i][1]) / n;
			pn_ed[i][2] = (b_avg[2] + 2.*f_avg[2] + (n - 3)*pn_ed0[i][2]) / n;
		}
	}
	for (i = 0; i < 8; i++)
	{
		pn_vt[i][0] = hcp[lev][hmesh[lev][eid].cnct[i]].coor[0];
		pn_vt[i][1] = hcp[lev][hmesh[lev][eid].cnct[i]].coor[1];
		pn_vt[i][2] = hcp[lev][hmesh[lev][eid].cnct[i]].coor[2];
		if (hcp[lev][hmesh[lev][eid].cnct[i]].sharp == 2)//boundary sharp corner
		{
			vt_type[i] = 1;
			vt_shp[i] = 2;
		}
		else if (hcp[lev][hmesh[lev][eid].cnct[i]].sharp == 1)//boundary sharp edge point
		{
			array<double, 3> e_avg = { 0., 0., 0. };
			int ned(0);
			for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].edge.size(); j++)
			{
				if (hedge[lev][hcp[lev][hmesh[lev][eid].cnct[i]].edge[j]].sharp == 1)
				{
					ned++;
					vector<int>::iterator it = find(edid.begin(), edid.end(), hcp[lev][hmesh[lev][eid].cnct[i]].edge[j]);
					int pos(it - edid.begin());
					e_avg[0] += pn_ed0[pos][0]; e_avg[1] += pn_ed0[pos][1]; e_avg[2] += pn_ed0[pos][2];
				}
			}
			if (ned != 2)
			{
				cerr << "# of sharp edges connected to the point is wrong!\n";
				cout << ned << "\n";
				getchar();
			}
			e_avg[0] /= ned; e_avg[1] /= ned; e_avg[2] /= ned;
			pn_vt[i][0] = (e_avg[0] + pn_vt[i][0]) / ned;
			pn_vt[i][1] = (e_avg[1] + pn_vt[i][1]) / ned;
			pn_vt[i][2] = (e_avg[2] + pn_vt[i][2]) / ned;
			vt_type[i] = 1;
			vt_shp[i] = 1;
		}
		else if (hcp[lev][hmesh[lev][eid].cnct[i]].sharp == 0 && hcp[lev][hmesh[lev][eid].cnct[i]].type == 1)//boundary non-sharp
		{
			array<double, 3> f_avg = { 0., 0., 0. }, e_avg = { 0., 0., 0. };
			int n(0);
			for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].face.size(); j++)
			{
				if (hface[lev][hcp[lev][hmesh[lev][eid].cnct[i]].face[j]].type == 1)
				{
					n++;
					vector<int>::iterator it = find(fcid.begin(), fcid.end(), hcp[lev][hmesh[lev][eid].cnct[i]].face[j]);
					int pos(it - fcid.begin());
					f_avg[0] += pn_fc0[pos][0]; f_avg[1] += pn_fc0[pos][1]; f_avg[2] += pn_fc0[pos][2];
				}
			}
			f_avg[0] /= n; f_avg[1] /= n; f_avg[2] /= n;
			n = 0;
			for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].edge.size(); j++)
			{
				if (hedge[lev][hcp[lev][hmesh[lev][eid].cnct[i]].edge[j]].type == 1)
				{
					n++;
					vector<int>::iterator it = find(edid.begin(), edid.end(), hcp[lev][hmesh[lev][eid].cnct[i]].edge[j]);
					int pos(it - edid.begin());
					e_avg[0] += pn_ed0[pos][0]; e_avg[1] += pn_ed0[pos][1]; e_avg[2] += pn_ed0[pos][2];
				}
			}
			e_avg[0] /= n; e_avg[1] /= n; e_avg[2] /= n;
			pn_vt[i][0] = (f_avg[0] + 2.*e_avg[0] + (n-3)*pn_vt[i][0]) / n;
			pn_vt[i][1] = (f_avg[1] + 2.*e_avg[1] + (n - 3)*pn_vt[i][1]) / n;
			pn_vt[i][2] = (f_avg[2] + 2.*e_avg[2] + (n - 3)*pn_vt[i][2]) / n;
			vt_type[i] = 1;
			vt_shp[i] = 0;
		}
		else if (hcp[lev][hmesh[lev][eid].cnct[i]].type != 1)//interior
		{
			array<double, 3> b_avg = { 0., 0., 0. }, f_avg = { 0., 0., 0. }, e_avg = { 0., 0., 0. };
			uint n(hcp[lev][hmesh[lev][eid].cnct[i]].hex.size());
			for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].hex.size(); j++)
			{
				vector<int>::iterator it = find(bdid.begin(), bdid.end(), hcp[lev][hmesh[lev][eid].cnct[i]].hex[j]);
				int pos(it - bdid.begin());
				b_avg[0] += pn_bd[pos][0]; b_avg[1] += pn_bd[pos][1]; b_avg[2] += pn_bd[pos][2];
			}
			b_avg[0] /= n; b_avg[1] /= n; b_avg[2] /= n;
			n = hcp[lev][hmesh[lev][eid].cnct[i]].face.size();
			for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].face.size(); j++)
			{
				vector<int>::iterator it = find(fcid.begin(), fcid.end(), hcp[lev][hmesh[lev][eid].cnct[i]].face[j]);
				int pos(it - fcid.begin());
				f_avg[0] += pn_fc0[pos][0]; f_avg[1] += pn_fc0[pos][1]; f_avg[2] += pn_fc0[pos][2];
			}
			f_avg[0] /= n; f_avg[1] /= n; f_avg[2] /= n;
			n = hcp[lev][hmesh[lev][eid].cnct[i]].edge.size();
			for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].edge.size(); j++)
			{
				vector<int>::iterator it = find(edid.begin(), edid.end(), hcp[lev][hmesh[lev][eid].cnct[i]].edge[j]);
				int pos(it - edid.begin());
				e_avg[0] += pn_ed0[pos][0]; e_avg[1] += pn_ed0[pos][1]; e_avg[2] += pn_ed0[pos][2];
			}
			e_avg[0] /= n; e_avg[1] /= n; e_avg[2] /= n;
			pn_vt[i][0] = (b_avg[0] + 3.*f_avg[0] + 3.*e_avg[0] + pn_vt[i][0]) / 8.;
			pn_vt[i][1] = (b_avg[1] + 3.*f_avg[1] + 3.*e_avg[1] + pn_vt[i][1]) / 8.;
			pn_vt[i][2] = (b_avg[2] + 3.*f_avg[2] + 3.*e_avg[2] + pn_vt[i][2]) / 8.;
		}
	}
	//find global index of new points at Level+1
	vector<int> pnid_bd(pn_bd.size()), pnid_fc(pn_fc.size()), pnid_ed(pn_ed.size()), pnid_vt(pn_vt.size());
	for (i = 0; i < bdid.size(); i++)
	{
		if (hmesh[lev][bdid[i]].pbd_id == -1)
		{
			Vertex3D cptmp;
			cptmp.coor[0] = pn_bd[i][0]; cptmp.coor[1] = pn_bd[i][1]; cptmp.coor[2] = pn_bd[i][2];
			cptmp.lev = lev + 1;
			hcp[lev + 1].push_back(cptmp);
			hmesh[lev][bdid[i]].pbd_id = hcp[lev + 1].size() - 1;
		}
		pnid_bd[i] = hmesh[lev][bdid[i]].pbd_id;
	}
	for (i = 0; i < fcid.size(); i++)
	{
		if (hface[lev][fcid[i]].pfc_id == -1)
		{
			Vertex3D cptmp;
			cptmp.coor[0] = pn_fc[i][0]; cptmp.coor[1] = pn_fc[i][1]; cptmp.coor[2] = pn_fc[i][2];
			cptmp.lev = lev + 1;
			cptmp.type = fc_type[i];
			hcp[lev + 1].push_back(cptmp);
			hface[lev][fcid[i]].pfc_id = hcp[lev + 1].size() - 1;
		}
		pnid_fc[i] = hface[lev][fcid[i]].pfc_id;
	}
	for (i = 0; i < edid.size(); i++)
	{
		if (hedge[lev][edid[i]].ped_id == -1)
		{
			Vertex3D cptmp;
			cptmp.coor[0] = pn_ed[i][0]; cptmp.coor[1] = pn_ed[i][1]; cptmp.coor[2] = pn_ed[i][2];
			cptmp.lev = lev + 1;
			cptmp.type = ed_type[i];
			cptmp.sharp = ed_shp[i];
			hcp[lev + 1].push_back(cptmp);
			hedge[lev][edid[i]].ped_id = hcp[lev + 1].size() - 1;
		}
		pnid_ed[i] = hedge[lev][edid[i]].ped_id;
	}
	for (i = 0; i < 8; i++)
	{
		if (hcp[lev][hmesh[lev][eid].cnct[i]].pvt_id == -1)
		{
			Vertex3D cptmp;
			cptmp.coor[0] = pn_vt[i][0]; cptmp.coor[1] = pn_vt[i][1]; cptmp.coor[2] = pn_vt[i][2];
			cptmp.lev = lev + 1;
			cptmp.type = vt_type[i];
			cptmp.sharp = vt_shp[i];
			hcp[lev + 1].push_back(cptmp);
			hcp[lev][hmesh[lev][eid].cnct[i]].pvt_id = hcp[lev + 1].size() - 1;
		}
		pnid_vt[i] = hcp[lev][hmesh[lev][eid].cnct[i]].pvt_id;
	}

	/*double tol(1.e-6), dis(0.);
	uint np0(hcp[lev + 1].size());
	for (i = 0; i < pn_bd.size(); i++)
	{
		int flag(0);
		for (j = 0; j < np0; j++)
		{
			dis = sqrt((pn_bd[i][0] - hcp[lev + 1][j].coor[0])*(pn_bd[i][0] - hcp[lev + 1][j].coor[0]) + (pn_bd[i][1] - hcp[lev + 1][j].coor[1])*(pn_bd[i][1] - hcp[lev + 1][j].coor[1]) +
				(pn_bd[i][2] - hcp[lev + 1][j].coor[2])*(pn_bd[i][2] - hcp[lev + 1][j].coor[2]));
			if (dis < tol)
			{
				flag = 1; pnid_bd[i] = j; break;
			}
		}
		if (flag == 0)
		{
			pnid_bd[i] = hcp[lev + 1].size();
			Vertex3D cptmp;
			cptmp.coor[0] = pn_bd[i][0]; cptmp.coor[1] = pn_bd[i][1]; cptmp.coor[2] = pn_bd[i][2];
			cptmp.lev = lev + 1;
			hcp[lev + 1].push_back(cptmp);
		}
	}
	for (i = 0; i < pn_fc.size(); i++)
	{
		int flag(0);
		for (j = 0; j < np0; j++)
		{
			dis = sqrt((pn_fc[i][0] - hcp[lev + 1][j].coor[0])*(pn_fc[i][0] - hcp[lev + 1][j].coor[0]) + (pn_fc[i][1] - hcp[lev + 1][j].coor[1])*(pn_fc[i][1] - hcp[lev + 1][j].coor[1]) +
				(pn_fc[i][2] - hcp[lev + 1][j].coor[2])*(pn_fc[i][2] - hcp[lev + 1][j].coor[2]));
			if (dis < tol)
			{
				flag = 1; pnid_fc[i] = j; break;
			}
		}
		if (flag == 0)
		{
			pnid_fc[i] = hcp[lev + 1].size();
			Vertex3D cptmp;
			cptmp.coor[0] = pn_fc[i][0]; cptmp.coor[1] = pn_fc[i][1]; cptmp.coor[2] = pn_fc[i][2];
			cptmp.lev = lev + 1;
			cptmp.type = fc_type[i];
			hcp[lev + 1].push_back(cptmp);
		}
	}
	for (i = 0; i < pn_ed.size(); i++)
	{
		int flag(0);
		for (j = 0; j < np0; j++)
		{
			dis = sqrt((pn_ed[i][0] - hcp[lev + 1][j].coor[0])*(pn_ed[i][0] - hcp[lev + 1][j].coor[0]) + (pn_ed[i][1] - hcp[lev + 1][j].coor[1])*(pn_ed[i][1] - hcp[lev + 1][j].coor[1]) +
				(pn_ed[i][2] - hcp[lev + 1][j].coor[2])*(pn_ed[i][2] - hcp[lev + 1][j].coor[2]));
			if (dis < tol)
			{
				flag = 1; pnid_ed[i] = j; break;
			}
		}
		if (flag == 0)
		{
			pnid_ed[i] = hcp[lev + 1].size();
			Vertex3D cptmp;
			cptmp.coor[0] = pn_ed[i][0]; cptmp.coor[1] = pn_ed[i][1]; cptmp.coor[2] = pn_ed[i][2];
			cptmp.lev = lev + 1;
			cptmp.type = ed_type[i];
			cptmp.sharp = ed_shp[i];
			hcp[lev + 1].push_back(cptmp);
		}
	}
	for (i = 0; i < pn_vt.size(); i++)
	{
		int flag(0);
		for (j = 0; j < np0; j++)
		{
			dis = sqrt((pn_vt[i][0] - hcp[lev + 1][j].coor[0])*(pn_vt[i][0] - hcp[lev + 1][j].coor[0]) + (pn_vt[i][1] - hcp[lev + 1][j].coor[1])*(pn_vt[i][1] - hcp[lev + 1][j].coor[1]) +
				(pn_vt[i][2] - hcp[lev + 1][j].coor[2])*(pn_vt[i][2] - hcp[lev + 1][j].coor[2]));
			if (dis < tol)
			{
				flag = 1; pnid_vt[i] = j; break;
			}
		}
		if (flag == 0)
		{
			pnid_vt[i] = hcp[lev + 1].size();
			Vertex3D cptmp;
			cptmp.coor[0] = pn_vt[i][0]; cptmp.coor[1] = pn_vt[i][1]; cptmp.coor[2] = pn_vt[i][2];
			cptmp.lev = lev + 1;
			cptmp.type = vt_type[i];
			cptmp.sharp = vt_shp[i];
			hcp[lev + 1].push_back(cptmp);
		}
	}*/


	//find children id and corresponding coefficients
	//vector<vector<int>> chdid(hmesh[lev][eid].IEN.size());
	//vector<vector<double>> coef(hmesh[lev][eid].IEN.size());

	vector<array<int, 8>> bdmp(bdid.size());
	vector<array<double, 8>> bdc(bdid.size());
	vector<vector<int>> fcmp(fcid.size());
	vector<vector<double>> fcc(fcid.size());
	vector<vector<int>> edmp(edid.size());
	vector<vector<double>> edc(edid.size());
	vector<vector<int>> vtmp(8);
	vector<vector<double>> vtc(8);
	//body points
	for (i = 0; i < bdid.size(); i++)
	{
		for (j = 0; j < 8; j++)
		{
			bdmp[i][j] = hmesh[lev][bdid[i]].cnct[j];
			bdc[i][j] = .125;
		}
	}
	//face points
	for (i = 0; i < fcid.size(); i++)
	{
		if (hface[lev][fcid[i]].type == 0)
		{
			for (j = 0; j < 4; j++)
			{
				fcmp[i].push_back(hface[lev][fcid[i]].cnct[j]);
				fcc[i].push_back(2.*.25 / 4.);
			}
			for (j = 0; j < hface[lev][fcid[i]].hex.size(); j++)
			{
				int hxid(hface[lev][fcid[i]].hex[j]);
				for (k = 0; k < 8; k++)
				{
					vector<int>::iterator it = find(fcmp[i].begin(), fcmp[i].end(), hmesh[lev][hxid].cnct[k]);
					double ctmp(.125 / 4.);
					if (it == fcmp[i].end())
					{
						fcmp[i].push_back(hmesh[lev][hxid].cnct[k]);
						fcc[i].push_back(ctmp);
					}
					else
					{
						int pos(it - fcmp[i].begin());
						fcc[i][pos] += ctmp;
					}
				}
			}
		}
		else if (hface[lev][fcid[i]].type == 1)
		{
			for (j = 0; j < 4; j++)
			{
				fcmp[i].push_back(hface[lev][fcid[i]].cnct[j]);
				fcc[i].push_back(.25);
			}
		}
	}
	//cout
	/*for (i = 0; i < fcc.size(); i++)
	{
		double sum(0.);
		for (j = 0; j < fcc[i].size(); j++)
		{
			sum += fcc[i][j];
		}
		if (sum != 1.)
		{
			cout << "face point sum not 1\n";
			getchar();
		}
	}*/
	//edge points
	for (i = 0; i < edid.size(); i++)
	{
		if (hedge[lev][edid[i]].sharp == 1)
		{
			for (j = 0; j < 2; j++)
			{
				edmp[i].push_back(hedge[lev][edid[i]].pt[j]);
				edc[i].push_back(.5);
			}
		}
		else if (hedge[lev][edid[i]].type == 1)
		{
			for (j = 0; j < 2; j++)
			{
				edmp[i].push_back(hedge[lev][edid[i]].pt[j]);
				edc[i].push_back(.375);
			}
			for (j = 0; j < hedge[lev][edid[i]].face.size(); j++)
			{
				if (hface[lev][hedge[lev][edid[i]].face[j]].type == 1)
				{
					int fcid(hedge[lev][edid[i]].face[j]);
					for (k = 0; k < 4; k++)
					{
						vector<int>::iterator it = find(edmp[i].begin(), edmp[i].end(), hface[lev][fcid].cnct[k]);
						if (it == edmp[i].end())
						{
							edmp[i].push_back(hface[lev][fcid].cnct[k]);
							edc[i].push_back(.0625);
						}
					}
				}
			}
		}
		else
		{
			uint n(hedge[lev][edid[i]].hex.size());
			for (j = 0; j < 2; j++)
			{
				edmp[i].push_back(hedge[lev][edid[i]].pt[j]);
				edc[i].push_back(.5*double(n - 3) / n);
			}
			for (j = 0; j < hedge[lev][edid[i]].hex.size(); j++)
			{
				int hxid(hedge[lev][edid[i]].hex[j]);
				for (k = 0; k < 8; k++)
				{
					vector<int>::iterator it = find(edmp[i].begin(), edmp[i].end(), hmesh[lev][hxid].cnct[k]);
					double ctmp(.125 / double(n*n));
					if (it == edmp[i].end())
					{
						edmp[i].push_back(hmesh[lev][hxid].cnct[k]);
						edc[i].push_back(ctmp);
					}
					else
					{
						int pos(it - edmp[i].begin());
						edc[i][pos] += ctmp;
					}
				}
			}
			for (j = 0; j < hedge[lev][edid[i]].face.size(); j++)
			{
				int fcid(hedge[lev][edid[i]].face[j]);
				for (k = 0; k < 4; k++)
				{
					vector<int>::iterator it = find(edmp[i].begin(), edmp[i].end(), hface[lev][fcid].cnct[k]);
					double ctmp(2.*.25 / double(n*n));
					if (it == edmp[i].end())
					{
						edmp[i].push_back(hface[lev][fcid].cnct[k]);
						edc[i].push_back(ctmp);
					}
					else
					{
						int pos(it - edmp[i].begin());
						edc[i][pos] += ctmp;
					}
				}
			}
		}
	}
	//cout
	//for (i = 0; i < edc.size(); i++)
	//{
	//	double sum(0.), tol(1.e-10);
	//	for (j = 0; j < edc[i].size(); j++)
	//	{
	//		sum += edc[i][j];
	//	}
	//	if (fabs(sum-1.)>tol)
	//	{
	//		cout << "edge point " << sum <<"\n";
	//		//cout << "edge valence hex: " << edvl_hx[i] << "\n";
	//		////cout << "edge valence face: " << edvl_fc[i] << "\n";
	//		//cout << "# contribution: " << edmp[i].size() << "\n";
	//		//for (j = 0; j < edmp[i].size(); j++)
	//		//{
	//		//	cout << setw(6)<< edmp[i][j] << " ";
	//		//}
	//		//cout << "\n";
	//		//for (j = 0; j < edc[i].size(); j++)
	//		//{
	//		//	cout << setw(6) << edc[i][j] << " ";
	//		//}
	//		//cout << "\n";
	//		getchar();
	//	}
	//}
	//vertex points
	for (i = 0; i < 8; i++)
	{
		if (hcp[lev][hmesh[lev][eid].cnct[i]].sharp==2)
		{
			vtmp[i].push_back(hmesh[lev][eid].cnct[i]);
			vtc[i].push_back(1.);
		}
		else if (hcp[lev][hmesh[lev][eid].cnct[i]].sharp == 1)
		{
			int ptid(hmesh[lev][eid].cnct[i]);
			vtmp[i].push_back(ptid);
			vtc[i].push_back(.75);
			for (j = 0; j < hcp[lev][ptid].edge.size(); j++)
			{
				if (hedge[lev][hcp[lev][ptid].edge[j]].sharp == 1)
				{
					int ptmp = hedge[lev][hcp[lev][ptid].edge[j]].pt[0];
					if (ptmp == ptid) ptmp = hedge[lev][hcp[lev][ptid].edge[j]].pt[1];
					vtmp[i].push_back(ptmp);
					vtc[i].push_back(.125);
				}
			}
		}
		else if (hcp[lev][hmesh[lev][eid].cnct[i]].type == 1)
		{
			int ptid(hmesh[lev][eid].cnct[i]), nv(0);
			for (j = 0; j < hcp[lev][ptid].face.size(); j++)
			{
				if (hface[lev][hcp[lev][ptid].face[j]].type == 1) nv++;
			}
			vtmp[i].push_back(ptid);
			vtc[i].push_back(1.-7./(4.*nv));
			double ctmp[2] = { 3. / (2.*nv*nv), 1. / (4.*nv*nv) };
			for (j = 0; j < hcp[lev][ptid].edge.size(); j++)
			{
				if (hedge[lev][hcp[lev][ptid].edge[j]].type == 1)
				{
					int edid(hcp[lev][ptid].edge[j]);
					int ptmp(hedge[lev][edid].pt[0]);
					if (ptmp == ptid) ptmp = hedge[lev][edid].pt[1];
					vtmp[i].push_back(ptmp);
					vtc[i].push_back(ctmp[0]);
				}
			}
			for (j = 0; j < hcp[lev][ptid].face.size(); j++)
			{
				if (hface[lev][hcp[lev][ptid].face[j]].type == 1)
				{
					int fcid(hcp[lev][ptid].face[j]);
					for (k = 0; k < 4; k++)
					{
						vector<int>::iterator it = find(vtmp[i].begin(), vtmp[i].end(), hface[lev][fcid].cnct[k]);
						if (it == vtmp[i].end())
						{
							vtmp[i].push_back(hface[lev][fcid].cnct[k]);
							vtc[i].push_back(ctmp[1]);
						}
					}
				}
			}
		}
		else
		{
			int ptid(hmesh[lev][eid].cnct[i]);
			uint nhx(hcp[lev][ptid].hex.size()), nfc(hcp[lev][ptid].face.size()), ned(hcp[lev][ptid].edge.size());
			vtmp[i].push_back(ptid);
			vtc[i].push_back(.125);
			for (j = 0; j < nhx; j++)
			{
				int hxid(hcp[lev][ptid].hex[j]);
				for (k = 0; k < 8; k++)
				{
					vector<int>::iterator it = find(vtmp[i].begin(), vtmp[i].end(), hmesh[lev][hxid].cnct[k]);
					double ctmp(.125 / (8.*nhx));
					if (it == vtmp[i].end())
					{
						vtmp[i].push_back(hmesh[lev][hxid].cnct[k]);
						vtc[i].push_back(ctmp);
					}
					else
					{
						int pos(it - vtmp[i].begin());
						vtc[i][pos] += ctmp;
					}
				}
			}
			for (j = 0; j < nfc; j++)
			{
				int fcid(hcp[lev][ptid].face[j]);
				for (k = 0; k < 4; k++)
				{
					vector<int>::iterator it = find(vtmp[i].begin(), vtmp[i].end(), hface[lev][fcid].cnct[k]);
					double ctmp(3.*.25 / (8.*nfc));
					if (it == vtmp[i].end())
					{
						vtmp[i].push_back(hface[lev][fcid].cnct[k]);
						vtc[i].push_back(ctmp);
					}
					else
					{
						int pos(it - vtmp[i].begin());
						vtc[i][pos] += ctmp;
					}
				}
			}
			for (j = 0; j < ned; j++)
			{
				int edid(hcp[lev][ptid].edge[j]);
				for (k = 0; k < 2; k++)
				{
					vector<int>::iterator it = find(vtmp[i].begin(), vtmp[i].end(), hedge[lev][edid].pt[k]);
					double ctmp(3.*.5 / (8.*ned));
					if (it == vtmp[i].end())
					{
						vtmp[i].push_back(hedge[lev][edid].pt[k]);
						vtc[i].push_back(ctmp);
					}
					else
					{
						int pos(it - vtmp[i].begin());
						vtc[i][pos] += ctmp;
					}
				}
			}
		}
	}
	//cout
	/*for (i = 0; i < vtc.size(); i++)
	{
		double sum(0.);
		for (j = 0; j < vtc[i].size(); j++)
		{
			sum += vtc[i][j];
		}
		if (fabs(sum - 1.)>tol)
		{
			cout << "vertex point " << sum << "\n";
			cout << hmesh[lev][eid].cnct[i]<< " vertex type " << hcp[lev][hmesh[lev][eid].cnct[i]].type << "\n";
			for (j = 0; j < vtmp[i].size(); j++)
			{
				cout << vtmp[i][j] << " ";
			}
			cout << "\n";
			for (j = 0; j < vtc[i].size(); j++)
			{
				cout<< vtc[i][j]<<" ";
			}
			cout << "\n";
			getchar();
		}
	}*/
	//children and coef
	for (i = 0; i < bdmp.size(); i++)
	{
		for (j = 0; j < bdmp[i].size(); j++)
		{
			vector<int>::iterator it = find(hcp[lev][bdmp[i][j]].chd.begin(), hcp[lev][bdmp[i][j]].chd.end(), pnid_bd[i]);
			if (it == hcp[lev][bdmp[i][j]].chd.end())
			{
				hcp[lev][bdmp[i][j]].chd.push_back(pnid_bd[i]);
				hcp[lev][bdmp[i][j]].coef.push_back(bdc[i][j]);
			}
		}
	}
	for (i = 0; i < fcmp.size(); i++)
	{
		for (j = 0; j < fcmp[i].size(); j++)
		{
			vector<int>::iterator it = find(hcp[lev][fcmp[i][j]].chd.begin(), hcp[lev][fcmp[i][j]].chd.end(), pnid_fc[i]);
			if (it == hcp[lev][fcmp[i][j]].chd.end())
			{
				hcp[lev][fcmp[i][j]].chd.push_back(pnid_fc[i]);
				hcp[lev][fcmp[i][j]].coef.push_back(fcc[i][j]);
			}
		}
	}
	for (i = 0; i < edmp.size(); i++)
	{
		for (j = 0; j < edmp[i].size(); j++)
		{
			vector<int>::iterator it = find(hcp[lev][edmp[i][j]].chd.begin(), hcp[lev][edmp[i][j]].chd.end(), pnid_ed[i]);
			if (it == hcp[lev][edmp[i][j]].chd.end())
			{
				hcp[lev][edmp[i][j]].chd.push_back(pnid_ed[i]);
				hcp[lev][edmp[i][j]].coef.push_back(edc[i][j]);
			}
		}
	}
	for (i = 0; i < vtmp.size(); i++)
	{
		for (j = 0; j < vtmp[i].size(); j++)
		{
			vector<int>::iterator it = find(hcp[lev][vtmp[i][j]].chd.begin(), hcp[lev][vtmp[i][j]].chd.end(), pnid_vt[i]);
			if (it == hcp[lev][vtmp[i][j]].chd.end())
			{
				hcp[lev][vtmp[i][j]].chd.push_back(pnid_vt[i]);
				hcp[lev][vtmp[i][j]].coef.push_back(vtc[i][j]);
			}
		}
	}
	//local index of new points
	vector<int> ed_loc(12), fc_loc(6), vt_loc(pnid_vt);
	int bd_loc(pnid_bd[0]);
	for (i = 0; i < 12; i++)
	{
		vector<int>::iterator it = find(edid.begin(), edid.end(), hmesh[lev][eid].edge[i]);
		int pos(it - edid.begin());
		ed_loc[i] = pnid_ed[pos];
	}
	for (i = 0; i < 6; i++)
	{
		vector<int>::iterator it = find(fcid.begin(), fcid.end(), hmesh[lev][eid].face[i]);
		int pos(it - fcid.begin());
		fc_loc[i] = pnid_fc[pos];
	}
	//construct new hex
	int enew[8][8] = { { vt_loc[0], ed_loc[0], fc_loc[0], ed_loc[3], ed_loc[4], fc_loc[1], bd_loc, fc_loc[4] },
	{ ed_loc[0], vt_loc[1], ed_loc[1], fc_loc[0], fc_loc[1], ed_loc[5], fc_loc[2], bd_loc },
	{ fc_loc[0], ed_loc[1], vt_loc[2], ed_loc[2], bd_loc, fc_loc[2], ed_loc[6], fc_loc[3] },
	{ ed_loc[3], fc_loc[0], ed_loc[2], vt_loc[3], fc_loc[4], bd_loc, fc_loc[3], ed_loc[7] },
	{ ed_loc[4], fc_loc[1], bd_loc, fc_loc[4], vt_loc[4], ed_loc[8], fc_loc[5], ed_loc[11] },
	{ fc_loc[1], ed_loc[5], fc_loc[2], bd_loc, ed_loc[8], vt_loc[5], ed_loc[9], fc_loc[5] },
	{ bd_loc, fc_loc[2], ed_loc[6], fc_loc[3], fc_loc[5], ed_loc[9], vt_loc[6], ed_loc[10] },
	{ fc_loc[4], bd_loc, fc_loc[3], ed_loc[7], ed_loc[11], fc_loc[5], ed_loc[10], vt_loc[7] } };

	for (i = 0; i < 8; i++)
	{
		Element3D etmp;
		etmp.type = 0;//tmp, determined by the topology at level (lev+1)
		etmp.lev = lev + 1;
		etmp.prt = eid;
		for (j = 0; j < 8; j++)
		{
			etmp.cnct[j] = enew[i][j];
		}
		hmesh[lev][eid].chd.push_back(hmesh[lev + 1].size());
		hmesh[lev + 1].push_back(etmp);
	}

	hmesh[lev][eid].act = 0;
}

void TruncatedTspline_3D::ConstructBezierBasis(int lev, int eid)
{
	//find IENtmp first
	hmesh[lev][eid].IEN.clear();
	uint i, j, k, hxid;
	vector<int> loc(hcp[lev].size(), -1);
	vector<int> hx1r(1, eid);
	for (i = 0; i < 8; i++)
	{
		loc[hmesh[lev][eid].cnct[i]] = hmesh[lev][eid].IEN.size();
		hmesh[lev][eid].IEN.push_back(hmesh[lev][eid].cnct[i]);
	}
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].hex.size(); j++)
		{
			hxid = hcp[lev][hmesh[lev][eid].cnct[i]].hex[j];
			vector<int>::iterator it1 = find(hx1r.begin(), hx1r.end(), hxid);
			if (it1 == hx1r.end())
			{
				hx1r.push_back(hxid);
				for (k = 0; k < 8; k++)
				{
					vector<int>::iterator it = find(hmesh[lev][eid].IEN.begin(), hmesh[lev][eid].IEN.end(), hmesh[lev][hxid].cnct[k]);
					if (it == hmesh[lev][eid].IEN.end())
					{
						loc[hmesh[lev][hxid].cnct[k]] = hmesh[lev][eid].IEN.size();
						hmesh[lev][eid].IEN.push_back(hmesh[lev][hxid].cnct[k]);
					}
				}
			}
		}
	}
	for (i = 0; i < hmesh[lev][eid].bemat.size(); i++)
	{
		hmesh[lev][eid].bemat[i].clear();
	}
	hmesh[lev][eid].bemat.clear();
	hmesh[lev][eid].bemat.resize(hmesh[lev][eid].IEN.size(), vector<double>(64, 0.));
	//8 body points, not consider boundary yet
	double w[2] = { 2. / 3., 1. / 3. };
	double a[8] = { w[0] * w[0] * w[0], w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[0] * w[0],
		w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[1] * w[1], w[1] * w[1] * w[0] };
	int bpi[8][8] = { { 0, 1, 2, 3, 4, 5, 6, 7 }, { 1, 2, 3, 0, 5, 6, 7, 4 }, { 2, 3, 0, 1, 6, 7, 4, 5 }, { 3, 0, 1, 2, 7, 4, 5, 6 },
	{ 4, 5, 6, 7, 0, 1, 2, 3 }, { 5, 6, 7, 4, 1, 2, 3, 0 }, { 6, 7, 4, 5, 2, 3, 0, 1 }, { 7, 4, 5, 6, 3, 0, 1, 2 } };
	vector<array<array<double, 8>, 8>> bpm(hx1r.size());
	vector<array<array<int, 8>, 8>> bpmap(hx1r.size());
	for (i = 0; i < hx1r.size(); i++)//which element
	{
		for (j = 0; j < 8; j++)//which body point, bezier
		{
			for (k = 0; k < 8; k++)//which local corner point, b-splines
			{
				bpm[i][j][k] = a[k];
				bpmap[i][j][k] = loc[hmesh[lev][hx1r[i]].cnct[bpi[j][k]]];
			}
		}
	}
	int layer[4] = { 0, 16, 32, 48 };
	int bpbz[8] = { 5 + layer[1], 6 + layer[1], 10 + layer[1], 9 + layer[1], 5 + layer[2], 6 + layer[2], 10 + layer[2], 9 + layer[2] };
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			hmesh[lev][eid].bemat[bpmap[0][i][j]][bpbz[i]] = bpm[0][i][j];
		}
	}
	//2*12 edge points
	int edi[12][2] = { { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 0 }, { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 4 } };
	int edbz[12][2] = { { 1, 2 }, { 7, 11 }, { 14, 13 }, { 8, 4 }, { 0 + layer[1], 0 + layer[2] }, { 3 + layer[1], 3 + layer[2] },
	{ 15 + layer[1], 15 + layer[2] }, { 12 + layer[1], 12 + layer[2] }, { 1 + layer[3], 2 + layer[3] }, { 7 + layer[3], 11 + layer[3] }, { 14 + layer[3], 13 + layer[3] }, { 8 + layer[3], 4 + layer[3] } };
	int pos1, pos2;
	for (i = 0; i < 12; i++)
	{
		uint nhex = hedge[lev][hmesh[lev][eid].edge[i]].hex.size();
		for (j = 0; j<hedge[lev][hmesh[lev][eid].edge[i]].hex.size(); j++)
		{
			hxid = hedge[lev][hmesh[lev][eid].edge[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			pos1 = it - hx1r.begin();
			int* it1 = find(hmesh[lev][hxid].cnct, hmesh[lev][hxid].cnct + 8, hmesh[lev][eid].cnct[edi[i][0]]);
			pos2 = it1 - hmesh[lev][hxid].cnct;
			for (k = 0; k < 8; k++)
			{
				hmesh[lev][eid].bemat[bpmap[pos1][pos2][k]][edbz[i][0]] += bpm[pos1][pos2][k] / nhex;
			}
			int* it2 = find(hmesh[lev][hxid].cnct, hmesh[lev][hxid].cnct + 8, hmesh[lev][eid].cnct[edi[i][1]]);
			pos2 = it2 - hmesh[lev][hxid].cnct;
			for (k = 0; k < 8; k++)
			{
				hmesh[lev][eid].bemat[bpmap[pos1][pos2][k]][edbz[i][1]] += bpm[pos1][pos2][k] / nhex;
			}
		}
	}
	//8 corner points
	int cnbz[8] = { 0, 3, 15, 12, 0 + layer[3], 3 + layer[3], 15 + layer[3], 12 + layer[3] };
	for (i = 0; i < 8; i++)
	{
		uint nhex = hcp[lev][hmesh[lev][eid].cnct[i]].hex.size();
		for (j = 0; j<nhex; j++)
		{
			hxid = hcp[lev][hmesh[lev][eid].cnct[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			pos1 = it - hx1r.begin();
			int* it1 = find(hmesh[lev][hxid].cnct, hmesh[lev][hxid].cnct + 8, hmesh[lev][eid].cnct[i]);
			pos2 = it1 - hmesh[lev][hxid].cnct;
			for (k = 0; k < 8; k++)
			{
				hmesh[lev][eid].bemat[bpmap[pos1][pos2][k]][cnbz[i]] += bpm[pos1][pos2][k] / nhex;
			}
		}
	}
	//4*6 face points
	int fci[6][4] = { { 0, 1, 3, 2 }, { 0, 1, 4, 5 }, { 1, 2, 5, 6 }, { 3, 2, 7, 6 }, { 0, 3, 4, 7 }, { 4, 5, 7, 6 } };
	int fcbz[6][4] = { { 5, 6, 9, 10 }, { 1 + layer[1], 2 + layer[1], 1 + layer[2], 2 + layer[2] }, { 7 + layer[1], 11 + layer[1], 7 + layer[2], 11 + layer[2] },
	{ 13 + layer[1], 14 + layer[1], 13 + layer[2], 14 + layer[2] }, { 4 + layer[1], 8 + layer[1], 4 + layer[2], 8 + layer[2] }, { 5 + layer[3], 6 + layer[3], 9 + layer[3], 10 + layer[3] } };
	for (i = 0; i < 6; i++)
	{
		uint nhex = hface[lev][hmesh[lev][eid].face[i]].hex.size();
		for (j = 0; j < nhex; j++)
		{
			hxid = hface[lev][hmesh[lev][eid].face[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			pos1 = it - hx1r.begin();
			for (int j1 = 0; j1 < 4; j1++)
			{
				int* it1 = find(hmesh[lev][hxid].cnct, hmesh[lev][hxid].cnct + 8, hmesh[lev][eid].cnct[fci[i][j1]]);
				pos2 = it1 - hmesh[lev][hxid].cnct;
				for (k = 0; k < 8; k++)
				{
					hmesh[lev][eid].bemat[bpmap[pos1][pos2][k]][fcbz[i][j1]] += bpm[pos1][pos2][k] / nhex;
				}
			}
		}
	}
}

void TruncatedTspline_3D::ConstructBezierBasis_1(int lev, int eid)//old idea to use open knot vector by pillowing layers, troublesome
{
	//find IEN first, element eid plus one-ring neighborhood
	hmesh[lev][eid].IEN.clear();
	uint i, j, k, hxid;
	vector<int> loc(hcp[lev].size(), -1);
	vector<int> hx1r(1, eid);
	for (i = 0; i < 8; i++)
	{
		loc[hmesh[lev][eid].cnct[i]] = hmesh[lev][eid].IEN.size();
		hmesh[lev][eid].IEN.push_back(hmesh[lev][eid].cnct[i]);
	}
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].hex.size(); j++)
		{
			hxid = hcp[lev][hmesh[lev][eid].cnct[i]].hex[j];
			vector<int>::iterator it1 = find(hx1r.begin(), hx1r.end(), hxid);
			if (it1 == hx1r.end())
			{
				hx1r.push_back(hxid);
				for (k = 0; k < 8; k++)
				{
					vector<int>::iterator it = find(hmesh[lev][eid].IEN.begin(), hmesh[lev][eid].IEN.end(), hmesh[lev][hxid].cnct[k]);
					if (it == hmesh[lev][eid].IEN.end())
					{
						loc[hmesh[lev][hxid].cnct[k]] = hmesh[lev][eid].IEN.size();
						hmesh[lev][eid].IEN.push_back(hmesh[lev][hxid].cnct[k]);
					}
				}
			}
		}
	}
	for (i = 0; i < hmesh[lev][eid].bemat.size(); i++)
	{
		hmesh[lev][eid].bemat[i].clear();
	}
	hmesh[lev][eid].bemat.clear();
	hmesh[lev][eid].bemat.resize(hmesh[lev][eid].IEN.size(), vector<double>(64, 0.));
	//8 body points
	//double w[2] = { 2. / 3., 1. / 3. };
	//double a[8] = { w[0] * w[0] * w[0], w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[0] * w[0],
	//	w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[1] * w[1], w[1] * w[1] * w[0] };
	vector<array<int, 6>> hx1r_type(hx1r.size());
	vector<array<double, 9>> lens(hx1r.size());
	int ed_loc[3] = { 0, 3, 4 };
	int fc_loc[3][2] = { { 4, 2 }, { 1, 3 }, { 0, 5 } };
	for (i = 0; i < hx1r.size(); i++)
	{
		for (j = 0; j < 9; j++) lens[i][j] = 0.;
		if (hmesh[lev][hx1r[i]].type != 1)
		{
			for (j = 0; j < 3; j++)
			{
				lens[i][3 * j] = hedge[lev][hmesh[lev][hx1r[i]].edge[ed_loc[j]]].len;
				for (k = 0; k < 2; k++)
				{
					int fnb = hface[lev][hmesh[lev][hx1r[i]].face[fc_loc[j][k]]].hex[0];
					if (fnb == hx1r[i]) fnb = hface[lev][hmesh[lev][hx1r[i]].face[fc_loc[j][k]]].hex[1];
					int* it = find(hmesh[lev][fnb].face, hmesh[lev][fnb].face + 6, hmesh[lev][hx1r[i]].face[fc_loc[j][k]]);
					int pos(it - hmesh[lev][fnb].face);
					lens[i][3 * j+k+1] = hedge[lev][hmesh[lev][fnb].edge[fc_ppd_ed[pos]]].len;
				}
			}
		}
		//for (j = 0; j < 3; j++)
		//{
		//	if (hedge[lev][hmesh[lev][hx1r[i]].edge[loc_tmp[j]]].len == 0.)
		//	{
		//		hx1r_type[i][2*j] = 1;
		//	}
		//}
		//if (hx1r_type[i][0] == 0 && hx1r_type[i][2] == 0 && hx1r_type[i][4] == 0)
		//{
		//	//check three directions for face neighbors
		//	//int fc_loc[3][2] = { { 2, 4 }, { 1, 3 }, {0,5} };
		//	for (j = 0; j < 3; j++)
		//	{
		//		int fnb[2] = { hface[lev][hmesh[lev][hx1r[i]].face[fc_loc[j][0]]].hex[0], hface[lev][hmesh[lev][hx1r[i]].face[fc_loc[j][1]]].hex[0]};
		//		if (hface[lev][hmesh[lev][hx1r[i]].face[fc_loc[j][0]]].hex.size() != 2 || hface[lev][hmesh[lev][hx1r[i]].face[fc_loc[j][1]]].hex.size() != 2)
		//		{
		//			cerr << "Edge interval config wrong!\n"; 
		//			getchar();
		//		}
		//		if (fnb[0] == hx1r[i]) fnb[0] = hface[lev][hmesh[lev][hx1r[i]].face[fc_loc[j][0]]].hex[1];
		//		if (fnb[1] == hx1r[i]) fnb[1] = hface[lev][hmesh[lev][hx1r[i]].face[fc_loc[j][1]]].hex[1];
		//		int* it0 = find(hmesh[lev][fnb[0]].face, hmesh[lev][fnb[0]].face + 6, hmesh[lev][hx1r[i]].face[fc_loc[j][0]]);
		//		int* it1 = find(hmesh[lev][fnb[1]].face, hmesh[lev][fnb[1]].face + 6, hmesh[lev][hx1r[i]].face[fc_loc[j][1]]);
		//		int pos[2] = { it0 - hmesh[lev][fnb[0]].face, it1 - hmesh[lev][fnb[1]].face };
		//		if (it0 == hmesh[lev][fnb[0]].face + 6 || it1 == hmesh[lev][fnb[1]].face + 6)
		//		{
		//			cerr << "Cannot find the face in a face neighbor!\n";
		//			getchar();
		//		}
		//		if (hedge[lev][hmesh[lev][fnb[0]].edge[fc_ppd_ed[pos[0]]]].len == 0.)
		//		{
		//			hx1r_type[i][2*j] == 2;
		//		}
		//		if (hedge[lev][hmesh[lev][fnb[1]].edge[fc_ppd_ed[pos[1]]]].len == 0.)
		//		{
		//			hx1r_type[i][2 * j+1] == 2;
		//		}
		//	}
		//}
	}

	int bpi[8][8] = { { 0, 1, 2, 3, 4, 5, 6, 7 }, { 1, 2, 3, 0, 5, 6, 7, 4 }, { 2, 3, 0, 1, 6, 7, 4, 5 }, { 3, 0, 1, 2, 7, 4, 5, 6 },
	{ 4, 5, 6, 7, 0, 1, 2, 3 }, { 5, 6, 7, 4, 1, 2, 3, 0 }, { 6, 7, 4, 5, 2, 3, 0, 1 }, { 7, 4, 5, 6, 3, 0, 1, 2 } };
	vector<array<array<double, 8>, 8>> bpm(hx1r.size());
	vector<array<array<int, 8>, 8>> bpmap(hx1r.size());
	for (i = 0; i < hx1r.size(); i++)//which element
	{
		if (hmesh[lev][hx1r[i]].type != 1)
		{
			double w[3][4];
			for (j = 0; j < 3; j++)
			{
				w[j][0] = (lens[i][3 * j] + lens[i][3 * j + 2]) / (lens[i][3 * j] + lens[i][3 * j + 1] + lens[i][3 * j + 2]);
				w[j][1] = 1. - w[j][0];
				w[j][2] = (lens[i][3 * j] + lens[i][3 * j + 1]) / (lens[i][3 * j] + lens[i][3 * j + 1] + lens[i][3 * j + 2]);
				w[j][3] = 1. - w[j][2];
			}
			double au[8][8] = { { w[0][0], w[0][1], w[0][1], w[0][0], w[0][0], w[0][1], w[0][1], w[0][0] }, 
			{ w[0][3], w[0][2], w[0][2], w[0][3], w[0][3], w[0][2], w[0][2], w[0][3] }, 
			{ w[0][3], w[0][2], w[0][2], w[0][3], w[0][3], w[0][2], w[0][2], w[0][3] },
			{ w[0][0], w[0][1], w[0][1], w[0][0], w[0][0], w[0][1], w[0][1], w[0][0] },
			{ w[0][0], w[0][1], w[0][1], w[0][0], w[0][0], w[0][1], w[0][1], w[0][0] },
			{ w[0][3], w[0][2], w[0][2], w[0][3], w[0][3], w[0][2], w[0][2], w[0][3] },
			{ w[0][3], w[0][2], w[0][2], w[0][3], w[0][3], w[0][2], w[0][2], w[0][3] },
			{ w[0][0], w[0][1], w[0][1], w[0][0], w[0][0], w[0][1], w[0][1], w[0][0] }};
			double av[8][8] = { { w[1][0], w[1][0], w[1][1], w[1][1], w[1][0], w[1][0], w[1][1], w[1][1] },
			{ w[1][0], w[1][0], w[1][1], w[1][1], w[1][0], w[1][0], w[1][1], w[1][1] },
			{ w[1][3], w[1][3], w[1][2], w[1][2], w[1][3], w[1][3], w[1][2], w[1][2] },
			{ w[1][3], w[1][3], w[1][2], w[1][2], w[1][3], w[1][3], w[1][2], w[1][2] },
			{ w[1][0], w[1][0], w[1][1], w[1][1], w[1][0], w[1][0], w[1][1], w[1][1] },
			{ w[1][0], w[1][0], w[1][1], w[1][1], w[1][0], w[1][0], w[1][1], w[1][1] },
			{ w[1][3], w[1][3], w[1][2], w[1][2], w[1][3], w[1][3], w[1][2], w[1][2] },
			{ w[1][3], w[1][3], w[1][2], w[1][2], w[1][3], w[1][3], w[1][2], w[1][2] }};
			double aw[8][8] = { { w[2][0], w[2][0], w[2][0], w[2][0], w[2][1], w[2][1], w[2][1], w[2][1] },
			{ w[2][0], w[2][0], w[2][0], w[2][0], w[2][1], w[2][1], w[2][1], w[2][1] },
			{ w[2][0], w[2][0], w[2][0], w[2][0], w[2][1], w[2][1], w[2][1], w[2][1] },
			{ w[2][0], w[2][0], w[2][0], w[2][0], w[2][1], w[2][1], w[2][1], w[2][1] },
			{ w[2][3], w[2][3], w[2][3], w[2][3], w[2][2], w[2][2], w[2][2], w[2][2] },
			{ w[2][3], w[2][3], w[2][3], w[2][3], w[2][2], w[2][2], w[2][2], w[2][2] },
			{ w[2][3], w[2][3], w[2][3], w[2][3], w[2][2], w[2][2], w[2][2], w[2][2] },
			{ w[2][3], w[2][3], w[2][3], w[2][3], w[2][2], w[2][2], w[2][2], w[2][2] }};
			for (j = 0; j < 8; j++)//which body point, bezier
			{
				for (k = 0; k < 8; k++)//which local corner point, b-splines
				{
					bpm[i][j][k] = au[j][k]*av[j][k]*aw[j][k];
					bpmap[i][j][k] = loc[hmesh[lev][hx1r[i]].cnct[bpi[j][k]]];
				}
			}
		}
		else
		{
			//zero-parametric-area

		}

		////double w[3][2] = { { 2. / 3., 1. / 3. }, { 2. / 3., 1. / 3. }, { 2. / 3., 1. / 3. } };
		//double a[8] = { w[0][0] * w[1][0] * w[2][0], w[0][1] * w[1][0] * w[2][0], w[0][1] * w[1][1] * w[2][0], w[0][1] * w[1][0] * w[2][0],
		//	w[0][1] * w[1][0] * w[2][0], w[0][1] * w[1][1] * w[2][0], w[0][1] * w[1][1] * w[2][1], w[0][1] * w[1][1] * w[2][0] };
		//for (j = 0; j < 8; j++)//which body point, bezier
		//{
		//	for (k = 0; k < 8; k++)//which local corner point, b-splines
		//	{
		//		//bpm[i][j][k] = a[k];
		//		bpmap[i][j][k] = loc[hmesh[lev][hx1r[i]].cnct[bpi[j][k]]];
		//	}
		//}
	}
	int layer[4] = { 0, 16, 32, 48 };
	int bpbz[8] = { 5 + layer[1], 6 + layer[1], 10 + layer[1], 9 + layer[1], 5 + layer[2], 6 + layer[2], 10 + layer[2], 9 + layer[2] };
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			hmesh[lev][eid].bemat[bpmap[0][i][j]][bpbz[i]] = bpm[0][i][j];
		}
	}
	//2*12 edge points
	int edi[12][2] = { { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 0 }, { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 4 } };
	int edbz[12][2] = { { 1, 2 }, { 7, 11 }, { 14, 13 }, { 8, 4 }, { 0 + layer[1], 0 + layer[2] }, { 3 + layer[1], 3 + layer[2] },
	{ 15 + layer[1], 15 + layer[2] }, { 12 + layer[1], 12 + layer[2] }, { 1 + layer[3], 2 + layer[3] }, { 7 + layer[3], 11 + layer[3] }, { 14 + layer[3], 13 + layer[3] }, { 8 + layer[3], 4 + layer[3] } };
	int pos1, pos2;
	for (i = 0; i < 12; i++)
	{
		uint nhex = hedge[lev][hmesh[lev][eid].edge[i]].hex.size();
		for (j = 0; j<hedge[lev][hmesh[lev][eid].edge[i]].hex.size(); j++)
		{
			hxid = hedge[lev][hmesh[lev][eid].edge[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			pos1 = it - hx1r.begin();
			int* it1 = find(hmesh[lev][hxid].cnct, hmesh[lev][hxid].cnct + 8, hmesh[lev][eid].cnct[edi[i][0]]);
			pos2 = it1 - hmesh[lev][hxid].cnct;
			for (k = 0; k < 8; k++)
			{
				hmesh[lev][eid].bemat[bpmap[pos1][pos2][k]][edbz[i][0]] += bpm[pos1][pos2][k] / nhex;
			}
			int* it2 = find(hmesh[lev][hxid].cnct, hmesh[lev][hxid].cnct + 8, hmesh[lev][eid].cnct[edi[i][1]]);
			pos2 = it2 - hmesh[lev][hxid].cnct;
			for (k = 0; k < 8; k++)
			{
				hmesh[lev][eid].bemat[bpmap[pos1][pos2][k]][edbz[i][1]] += bpm[pos1][pos2][k] / nhex;
			}
		}
	}
	//8 corner points
	int cnbz[8] = { 0, 3, 15, 12, 0 + layer[3], 3 + layer[3], 15 + layer[3], 12 + layer[3] };
	for (i = 0; i < 8; i++)
	{
		uint nhex = hcp[lev][hmesh[lev][eid].cnct[i]].hex.size();
		for (j = 0; j<nhex; j++)
		{
			hxid = hcp[lev][hmesh[lev][eid].cnct[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			pos1 = it - hx1r.begin();
			int* it1 = find(hmesh[lev][hxid].cnct, hmesh[lev][hxid].cnct + 8, hmesh[lev][eid].cnct[i]);
			pos2 = it1 - hmesh[lev][hxid].cnct;
			for (k = 0; k < 8; k++)
			{
				hmesh[lev][eid].bemat[bpmap[pos1][pos2][k]][cnbz[i]] += bpm[pos1][pos2][k] / nhex;
			}
		}
	}
	//4*6 face points
	int fci[6][4] = { { 0, 1, 3, 2 }, { 0, 1, 4, 5 }, { 1, 2, 5, 6 }, { 3, 2, 7, 6 }, { 0, 3, 4, 7 }, { 4, 5, 7, 6 } };
	int fcbz[6][4] = { { 5, 6, 9, 10 }, { 1 + layer[1], 2 + layer[1], 1 + layer[2], 2 + layer[2] }, { 7 + layer[1], 11 + layer[1], 7 + layer[2], 11 + layer[2] },
	{ 13 + layer[1], 14 + layer[1], 13 + layer[2], 14 + layer[2] }, { 4 + layer[1], 8 + layer[1], 4 + layer[2], 8 + layer[2] }, { 5 + layer[3], 6 + layer[3], 9 + layer[3], 10 + layer[3] } };
	for (i = 0; i < 6; i++)
	{
		uint nhex = hface[lev][hmesh[lev][eid].face[i]].hex.size();
		for (j = 0; j < nhex; j++)
		{
			hxid = hface[lev][hmesh[lev][eid].face[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			pos1 = it - hx1r.begin();
			for (int j1 = 0; j1 < 4; j1++)
			{
				int* it1 = find(hmesh[lev][hxid].cnct, hmesh[lev][hxid].cnct + 8, hmesh[lev][eid].cnct[fci[i][j1]]);
				pos2 = it1 - hmesh[lev][hxid].cnct;
				for (k = 0; k < 8; k++)
				{
					hmesh[lev][eid].bemat[bpmap[pos1][pos2][k]][fcbz[i][j1]] += bpm[pos1][pos2][k] / nhex;
				}
			}
		}
	}
}

void TruncatedTspline_3D::ConstructBezierBasis_Boundary(int lev, int eid)
{
	//find IEN first
	hmesh[lev][eid].IEN.clear();
	uint i, j, k, hxid;
	vector<int> loc(hcp[lev].size(), -1);
	vector<int> hx1r(1, eid);
	for (i = 0; i < 8; i++)
	{
		loc[hmesh[lev][eid].cnct[i]] = hmesh[lev][eid].IEN.size();
		hmesh[lev][eid].IEN.push_back(hmesh[lev][eid].cnct[i]);
	}
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].hex.size(); j++)
		{
			hxid = hcp[lev][hmesh[lev][eid].cnct[i]].hex[j];
			vector<int>::iterator it1 = find(hx1r.begin(), hx1r.end(), hxid);
			if (it1 == hx1r.end())
			{
				hx1r.push_back(hxid);
				for (k = 0; k < 8; k++)
				{
					vector<int>::iterator it = find(hmesh[lev][eid].IEN.begin(), hmesh[lev][eid].IEN.end(), hmesh[lev][hxid].cnct[k]);
					if (it == hmesh[lev][eid].IEN.end())
					{
						loc[hmesh[lev][hxid].cnct[k]] = hmesh[lev][eid].IEN.size();
						hmesh[lev][eid].IEN.push_back(hmesh[lev][hxid].cnct[k]);
					}
				}
			}
		}
	}
	for (i = 0; i < hmesh[lev][eid].bemat.size(); i++)
	{
		hmesh[lev][eid].bemat[i].clear();
	}
	hmesh[lev][eid].bemat.clear();
	hmesh[lev][eid].bemat.resize(hmesh[lev][eid].IEN.size(), vector<double>(64, 0.));
	//8 body points
	double w[2] = { 2. / 3., 1. / 3. };
	double a[8] = { w[0] * w[0] * w[0], w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[0] * w[0],
		w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[1] * w[1], w[1] * w[1] * w[0] };
	int bpi[8][8] = { { 0, 1, 2, 3, 4, 5, 6, 7 }, { 1, 2, 3, 0, 5, 6, 7, 4 }, { 2, 3, 0, 1, 6, 7, 4, 5 }, { 3, 0, 1, 2, 7, 4, 5, 6 },
	{ 4, 5, 6, 7, 0, 1, 2, 3 }, { 5, 6, 7, 4, 1, 2, 3, 0 }, { 6, 7, 4, 5, 2, 3, 0, 1 }, { 7, 4, 5, 6, 3, 0, 1, 2 } };
	vector<array<array<double, 8>, 8>> bpm(hx1r.size());
	vector<array<array<int, 8>, 8>> bpmap(hx1r.size());
	for (i = 0; i < hx1r.size(); i++)//which element
	{
		for (j = 0; j < 8; j++)//which body point, bezier
		{
			for (k = 0; k < 8; k++)//which local corner point, b-splines
			{
				bpm[i][j][k] = a[k];
				bpmap[i][j][k] = loc[hmesh[lev][hx1r[i]].cnct[bpi[j][k]]];
			}
		}
	}
	int layer[4] = { 0, 16, 32, 48 };
	int bpbz[8] = { 5 + layer[1], 6 + layer[1], 10 + layer[1], 9 + layer[1], 5 + layer[2], 6 + layer[2], 10 + layer[2], 9 + layer[2] };
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			hmesh[lev][eid].bemat[bpmap[0][i][j]][bpbz[i]] = bpm[0][i][j];
		}
	}
	int pos1, pos2;
	//4*6 face points
	//double af[4][4] = { { w[0] * w[0], w[1] * w[0], w[1] * w[0], w[1] * w[1] }, { w[1] * w[0], w[0] * w[0], w[1] * w[1], w[1] * w[0] },
	//{ w[1] * w[0], w[1] * w[1], w[0] * w[0], w[1] * w[0] }, { w[1] * w[1], w[1] * w[0], w[1] * w[0], w[0] * w[0] } };
	double af[4] = { w[0] * w[0], w[1] * w[0], w[1] * w[1], w[1] * w[0] };
	int f_cnct[4][4] = { { 0, 1, 2, 3 }, { 1, 2, 3, 0 }, { 2, 3, 0, 1 }, {3,0,1,2} };
	int fci[6][4] = { { 0, 1, 3, 2 }, { 0, 1, 4, 5 }, { 1, 2, 5, 6 }, { 3, 2, 7, 6 }, { 0, 3, 4, 7 }, { 4, 5, 7, 6 } };
	int fcbz[6][4] = { { 5, 6, 9, 10 }, { 1 + layer[1], 2 + layer[1], 1 + layer[2], 2 + layer[2] }, { 7 + layer[1], 11 + layer[1], 7 + layer[2], 11 + layer[2] },
	{ 13 + layer[1], 14 + layer[1], 13 + layer[2], 14 + layer[2] }, { 4 + layer[1], 8 + layer[1], 4 + layer[2], 8 + layer[2] }, { 5 + layer[3], 6 + layer[3], 9 + layer[3], 10 + layer[3] } };
	//find all boundary faces
	vector<int> fc_b;
	vector<array<array<double, 4>, 4>> fpm;
	vector<array<array<int, 4>, 4>> fpmap;//reference is face, note that reference is not solid
	for (i = 0; i < hx1r.size(); i++)
	{
		for (j = 0; j < 6; j++)
		{
			if (hface[lev][hmesh[lev][hx1r[i]].face[j]].hex.size() == 1)
			{
				int fcid(hmesh[lev][hx1r[i]].face[j]);
				fc_b.push_back(fcid);
				array<array<double, 4>, 4> fpm_tmp;
				array<array<int, 4>, 4> fpmap_tmp;
				for (int j1 = 0; j1 < 4; j1++)//Bezier
				{
					for (k = 0; k < 4; k++)//B-splines
					{
						fpm_tmp[j1][k] = af[k];
						fpmap_tmp[j1][k] = loc[hface[lev][fcid].cnct[f_cnct[j1][k]]];
					}
				}
				fpm.push_back(fpm_tmp);
				fpmap.push_back(fpmap_tmp);
			}
		}
	}
	//determine coefs
	for (i = 0; i < 6; i++)
	{
		uint nhex = hface[lev][hmesh[lev][eid].face[i]].hex.size();
		if (nhex == 2)
		{
			for (j = 0; j < nhex; j++)
			{
				hxid = hface[lev][hmesh[lev][eid].face[i]].hex[j];
				vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
				pos1 = it - hx1r.begin();
				for (int j1 = 0; j1 < 4; j1++)
				{
					int* it1 = find(hmesh[lev][hxid].cnct, hmesh[lev][hxid].cnct + 8, hmesh[lev][eid].cnct[fci[i][j1]]);
					pos2 = it1 - hmesh[lev][hxid].cnct;
					for (k = 0; k < 8; k++)
					{
						hmesh[lev][eid].bemat[bpmap[pos1][pos2][k]][fcbz[i][j1]] += bpm[pos1][pos2][k] / nhex;
					}
				}
			}
		}
		else if (nhex == 1)//new, for boundary face
		{
			int fcid = hmesh[lev][eid].face[i];
			vector<int>::iterator it = find(fc_b.begin(), fc_b.end(), fcid);
			pos1 = it - fc_b.begin();
			for (int j1 = 0; j1 < 4; j1++)
			{
				int* it1 = find(hface[lev][fcid].cnct, hface[lev][fcid].cnct + 4, hmesh[lev][eid].cnct[fci[i][j1]]);
				pos2 = it1 - hface[lev][fcid].cnct;
				for (k = 0; k < 4; k++)
				{
					hmesh[lev][eid].bemat[fpmap[pos1][pos2][k]][fcbz[i][j1]] = fpm[pos1][pos2][k];
				}
			}
			/*int* it1 = find(hface[lev][fcid].cnct, hface[lev][fcid].cnct + 4, hmesh[lev][eid].cnct[fci[i][0]]);
			int start(it1 - hface[lev][fcid].cnct);
			int fcbz1[4] = { fcbz[i][0], fcbz[i][1], fcbz[i][3], fcbz[i][2] };
			if (start == 1)
			{
				fcbz1[0] = fcbz[i][2]; fcbz1[1] = fcbz[i][0]; fcbz1[2] = fcbz[i][1]; fcbz1[3] = fcbz[i][3];
			}
			else if (start == 2)
			{
				fcbz1[0] = fcbz[i][3]; fcbz1[1] = fcbz[i][2]; fcbz1[2] = fcbz[i][0]; fcbz1[3] = fcbz[i][1];
			}
			else if (start == 3)
			{
				fcbz1[0] = fcbz[i][1]; fcbz1[1] = fcbz[i][3]; fcbz1[2] = fcbz[i][2]; fcbz1[3] = fcbz[i][0];
			}
			if (hface[lev][fcid].cnct[(start + 1) % 4] != hmesh[lev][eid].cnct[fci[i][1]])
			{
				if (start == 0)
				{
					fcbz1[0] = fcbz[i][0]; fcbz1[1] = fcbz[i][2]; fcbz1[2] = fcbz[i][3]; fcbz1[3] = fcbz[i][1];
				}
				else if (start == 1)
				{
					fcbz1[0] = fcbz[i][1]; fcbz1[1] = fcbz[i][0]; fcbz1[2] = fcbz[i][2]; fcbz1[3] = fcbz[i][3];
				}
				else if (start == 2)
				{
					fcbz1[0] = fcbz[i][3]; fcbz1[1] = fcbz[i][1]; fcbz1[2] = fcbz[i][0]; fcbz1[3] = fcbz[i][2];
				}
				else if (start == 3)
				{
					fcbz1[0] = fcbz[i][2]; fcbz1[1] = fcbz[i][3]; fcbz1[2] = fcbz[i][1]; fcbz1[3] = fcbz[i][0];
				}
			}
			for (int j1 = 0; j1 < 4; j1++)
			{
				for (k = 0; k < 4; k++)
				{
					hmesh[lev][eid].bemat[fpmap[pos1][j1][k]][fcbz1[j1]] = fpm[pos1][j1][k];
				}
			}*/
		}
	}
	//2*12 edge points
	int edi[12][2] = { { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 0 }, { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 4 } };
	int edbz[12][2] = { { 1, 2 }, { 7, 11 }, { 14, 13 }, { 8, 4 }, { 0 + layer[1], 0 + layer[2] }, { 3 + layer[1], 3 + layer[2] },
	{ 15 + layer[1], 15 + layer[2] }, { 12 + layer[1], 12 + layer[2] }, { 1 + layer[3], 2 + layer[3] }, { 7 + layer[3], 11 + layer[3] }, { 14 + layer[3], 13 + layer[3] }, { 8 + layer[3], 4 + layer[3] } };
	for (i = 0; i < 12; i++)
	{
		if (hedge[lev][hmesh[lev][eid].edge[i]].type != 1)//non-boundary
		{
			uint nhex = hedge[lev][hmesh[lev][eid].edge[i]].hex.size();
			for (j = 0; j<hedge[lev][hmesh[lev][eid].edge[i]].hex.size(); j++)
			{
				hxid = hedge[lev][hmesh[lev][eid].edge[i]].hex[j];
				vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
				pos1 = it - hx1r.begin();
				int* it1 = find(hmesh[lev][hxid].cnct, hmesh[lev][hxid].cnct + 8, hmesh[lev][eid].cnct[edi[i][0]]);
				pos2 = it1 - hmesh[lev][hxid].cnct;
				for (k = 0; k < 8; k++)
				{
					hmesh[lev][eid].bemat[bpmap[pos1][pos2][k]][edbz[i][0]] += bpm[pos1][pos2][k] / nhex;
				}
				int* it2 = find(hmesh[lev][hxid].cnct, hmesh[lev][hxid].cnct + 8, hmesh[lev][eid].cnct[edi[i][1]]);
				pos2 = it2 - hmesh[lev][hxid].cnct;
				for (k = 0; k < 8; k++)
				{
					hmesh[lev][eid].bemat[bpmap[pos1][pos2][k]][edbz[i][1]] += bpm[pos1][pos2][k] / nhex;
				}
			}
		}
		else if (hedge[lev][hmesh[lev][eid].edge[i]].type == 1 && hedge[lev][hmesh[lev][eid].edge[i]].sharp == 0)//boundary, non-sharp
		{
			int nfc_b(0);
			for (j = 0; j < hedge[lev][hmesh[lev][eid].edge[i]].face.size(); j++)
			{
				if (hface[lev][hedge[lev][hmesh[lev][eid].edge[i]].face[j]].type == 1) nfc_b++;
			}
			for (j = 0; j<hedge[lev][hmesh[lev][eid].edge[i]].face.size(); j++)
			{
				int fcid(hedge[lev][hmesh[lev][eid].edge[i]].face[j]);
				if (hface[lev][fcid].type == 1)//boundary face
				{
					vector<int>::iterator it = find(fc_b.begin(), fc_b.end(), fcid);
					pos1 = it - fc_b.begin();
					for (int j1 = 0; j1 < 2; j1++)
					{
						int* it1 = find(hface[lev][fcid].cnct, hface[lev][fcid].cnct + 4, hmesh[lev][eid].cnct[edi[i][j1]]);
						pos2 = it1 - hface[lev][fcid].cnct;
						for (k = 0; k < 4; k++)
						{
							hmesh[lev][eid].bemat[fpmap[pos1][pos2][k]][edbz[i][j1]] += fpm[pos1][pos2][k]/nfc_b;
						}
					}
				}
			}
		}
		else if (hedge[lev][hmesh[lev][eid].edge[i]].type == 1 && hedge[lev][hmesh[lev][eid].edge[i]].sharp == 1)//boundary, sharp edge
		{
			int bid[2] = { loc[hmesh[lev][eid].cnct[edi[i][0]]], loc[hmesh[lev][eid].cnct[edi[i][1]]] };
			hmesh[lev][eid].bemat[bid[0]][edbz[i][0]] = w[0];
			hmesh[lev][eid].bemat[bid[0]][edbz[i][1]] = w[1];
			hmesh[lev][eid].bemat[bid[1]][edbz[i][0]] = w[1];
			hmesh[lev][eid].bemat[bid[1]][edbz[i][1]] = w[0];
		}
	}
	//8 corner points
	int cnbz[8] = { 0, 3, 15, 12, 0 + layer[3], 3 + layer[3], 15 + layer[3], 12 + layer[3] };
	for (i = 0; i < 8; i++)
	{
		if (hcp[lev][hmesh[lev][eid].cnct[i]].type != 1)//non-boundary vertex points
		{
			uint nhex = hcp[lev][hmesh[lev][eid].cnct[i]].hex.size();
			for (j = 0; j<nhex; j++)
			{
				hxid = hcp[lev][hmesh[lev][eid].cnct[i]].hex[j];
				vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
				pos1 = it - hx1r.begin();
				int* it1 = find(hmesh[lev][hxid].cnct, hmesh[lev][hxid].cnct + 8, hmesh[lev][eid].cnct[i]);
				pos2 = it1 - hmesh[lev][hxid].cnct;
				for (k = 0; k < 8; k++)
				{
					hmesh[lev][eid].bemat[bpmap[pos1][pos2][k]][cnbz[i]] += bpm[pos1][pos2][k] / nhex;
				}
			}
		}
		else if (hcp[lev][hmesh[lev][eid].cnct[i]].type == 1 && hcp[lev][hmesh[lev][eid].cnct[i]].sharp==0)//boundary vertex points, non-sharp
		{
			int nfc_b(0);
			for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].face.size(); j++)
			{
				if (hface[lev][hcp[lev][hmesh[lev][eid].cnct[i]].face[j]].type == 1) nfc_b++;
			}
			for (j = 0; j<hcp[lev][hmesh[lev][eid].cnct[i]].face.size(); j++)
			{
				int fcid(hcp[lev][hmesh[lev][eid].cnct[i]].face[j]);
				if (hface[lev][fcid].type == 1)//boundary face
				{
					vector<int>::iterator it = find(fc_b.begin(), fc_b.end(), fcid);
					pos1 = it - fc_b.begin();
					int* it1 = find(hface[lev][fcid].cnct, hface[lev][fcid].cnct + 4, hmesh[lev][eid].cnct[i]);
					pos2 = it1 - hface[lev][fcid].cnct;
					for (k = 0; k < 4; k++)
					{
						hmesh[lev][eid].bemat[fpmap[pos1][pos2][k]][cnbz[i]] += fpm[pos1][pos2][k] / nfc_b;
					}
				}
			}
		}
		else if (hcp[lev][hmesh[lev][eid].cnct[i]].type == 1 && hcp[lev][hmesh[lev][eid].cnct[i]].sharp == 1)//boundary vertex points, sharp edge
		{
			//hmesh[lev][eid].bemat[loc[hmesh[lev][eid].cnct[i]]][cnbz[i]] = 1.;
			vector<int> shp_ed;
			for (j = 0; j < hcp[lev][hmesh[lev][eid].cnct[i]].edge.size(); j++)
			{
				if (hedge[lev][hcp[lev][hmesh[lev][eid].cnct[i]].edge[j]].sharp == 1)
				{
					shp_ed.push_back(hcp[lev][hmesh[lev][eid].cnct[i]].edge[j]);
				}
			}
			if (shp_ed.size() == 2)
			{
				for (j = 0; j < shp_ed.size(); j++)
				{
					if (hedge[lev][shp_ed[j]].pt[0] == hmesh[lev][eid].cnct[i])
					{
						hmesh[lev][eid].bemat[loc[hedge[lev][shp_ed[j]].pt[0]]][cnbz[i]] = 2. / 3.;
						hmesh[lev][eid].bemat[loc[hedge[lev][shp_ed[j]].pt[1]]][cnbz[i]] = 1. / 6.;
					}
					else
					{
						hmesh[lev][eid].bemat[loc[hedge[lev][shp_ed[j]].pt[1]]][cnbz[i]] = 2. / 3.;
						hmesh[lev][eid].bemat[loc[hedge[lev][shp_ed[j]].pt[0]]][cnbz[i]] = 1. / 6.;
					}
				}
			}
			else
			{
				cerr << "# of sharp edges of the point is wrong!\n";
				cout << shp_ed.size() << "\n";
				getchar();
			}
		}
		else if (hcp[lev][hmesh[lev][eid].cnct[i]].type == 1 && hcp[lev][hmesh[lev][eid].cnct[i]].sharp == 2)//boundary vertex points, sharp corner
		{
			hmesh[lev][eid].bemat[loc[hmesh[lev][eid].cnct[i]]][cnbz[i]] = 1.;
		}
	}
}

void TruncatedTspline_3D::ConstructConnect(int lev)//no need for all of them
{
	uint i, j;
	//clear
	for (i = 0; i < hcp[lev].size(); i++)
	{
		//hcp[lev][i].type = 0;
		hcp[lev][i].edge.clear();
		hcp[lev][i].face.clear();
		hcp[lev][i].hex.clear();
	}
	for (i = 0; i < hedge[lev].size(); i++)
	{
		//hedge[lev][i].type = 0;
		hedge[lev][i].face.clear();
		hedge[lev][i].hex.clear();
	}
	for (i = 0; i < hface[lev].size(); i++)
	{
		//hface[lev][i].type = 0;
		hface[lev][i].hex.clear();
	}
	//for (i = 0; i < hmesh[lev].size(); i++)
	//{
	//	//hmesh[lev][i].bc_lev=0;
	//	//hmesh[lev][i].type = 0;
	//}
	//vertex-to-hex, edge-to-hex, face-to-hex
	for (i = 0; i<hmesh[lev].size(); i++)
	{
		for (j = 0; j<8; j++)
		{
			hcp[lev][hmesh[lev][i].cnct[j]].hex.push_back(i);
		}
		for (j = 0; j<12; j++)
		{
			hedge[lev][hmesh[lev][i].edge[j]].hex.push_back(i);
		}
		for (j = 0; j<6; j++)
		{
			hface[lev][hmesh[lev][i].face[j]].hex.push_back(i);
		}
	}
	//vertex-to-face, edge-to-face
	for (i = 0; i<hface[lev].size(); i++)
	{
		for (j = 0; j<4; j++)
		{
			hcp[lev][hface[lev][i].cnct[j]].face.push_back(i);
			hedge[lev][hface[lev][i].edge[j]].face.push_back(i);
		}
	}
	//vertex-to-edge
	for (i = 0; i<hedge[lev].size(); i++)
	{
		for (j = 0; j<2; j++)
		{
			hcp[lev][hedge[lev][i].pt[j]].edge.push_back(i);
		}
	}
	//check boundary type
	for (i = 0; i < hface[lev].size(); i++)
	{
		int nbc(0);
		for (j = 0; j < 4; j++)
		{
			if (hcp[lev][hface[lev][i].cnct[j]].type == 1) nbc++;
		}
		if (nbc == 4)
		{
			hface[lev][i].type = 1;
			hmesh[lev][hface[lev][i].hex[0]].type = 1;
			//for (j = 0; j < 4; j++)
			//	hedge[lev][hface[lev][i].edge[j]].type = 1;
		}
	}
	for (i = 0; i < hedge[lev].size(); i++)
	{
		int nbc(0), nshp(0);
		for (j = 0; j < 2; j++)
		{
			if (hcp[lev][hedge[lev][i].pt[j]].type == 1) nbc++;
			if (hcp[lev][hedge[lev][i].pt[j]].sharp != 0) nshp++;
		}
		if (nbc == 2)
		{
			hedge[lev][i].type = 1;
			if (nshp == 2) hedge[lev][i].sharp = 1;
		}
	}

	//new, additional boundary elements
	for (i = 0; i < hmesh[lev].size(); i++)
	{
		if (hmesh[lev][i].type != 1)
		{
			for (j = 0; j < 8; j++)
			{
				if (hcp[lev][hmesh[lev][i].cnct[j]].type == 1)
				{
					hmesh[lev][i].type = 1; break;
				}
			}
		}
	}
	for (i = 0; i<hcp[lev].size(); i++)
	{
		if (hcp[lev][i].type == 1)
		{
			int count(0);
			for (j = 0; j < hcp[lev][i].edge.size(); j++)
			{
				if (hedge[lev][hcp[lev][i].edge[j]].type == 2) count++;
			}
			if (count == 1) hcp[lev][i].bcxp = 1;
			else if (count>1) hcp[lev][i].bcxp = 2;
		}
	}
	

	////find BC face, edge, vertex, not necessary
	//for (i = 0; i<hface[lev].size(); i++)
	//{
	//	if (hface[lev][i].hex.size() == 1)
	//	{
	//		hface[lev][i].type = 1;
	//		hmesh[lev][hface[lev][i].hex[0]].type = 1;
	//		for (j = 0; j<4; j++)
	//		{
	//			hcp[lev][hface[lev][i].cnct[j]].type = 1;
	//			hedge[lev][hface[lev][i].edge[j]].type = 1;
	//		}
	//	}
	//}
	////find extraordinary edges and vertices
	//for (i = 0; i<hedge[lev].size(); i++)
	//{
	//	if (hedge[lev][i].type != 1 && hedge[lev][i].hex.size() != 4)
	//	{
	//		hedge[lev][i].type = 2;
	//		if (hcp[lev][hedge[lev][i].pt[0]].type != 1)
	//			hcp[lev][hedge[lev][i].pt[0]].type = 3;
	//		if (hcp[lev][hedge[lev][i].pt[1]].type != 1)
	//			hcp[lev][hedge[lev][i].pt[1]].type = 3;
	//	}
	//}
	////boundary
	//for (i = 0; i<hcp[lev].size(); i++)
	//{
	//	if (hcp[lev][i].type == 1)
	//	{
	//		int val(0);
	//		for (j = 0; j<hcp[lev][i].face.size(); j++)
	//		{
	//			if (hface[lev][hcp[lev][i].face[j]].type == 1) val++;
	//		}
	//		if (val == 3 || val>4) hcp[lev][i].type = 13;
	//	}
	//}
	////find irregular elements
	//for (i = 0; i<hmesh[lev].size(); i++)
	//{
	//	if (hmesh[lev][i].type != 1)
	//	{
	//		for (j = 0; j<12; j++)
	//		{
	//			if (hedge[lev][hmesh[lev][i].edge[j]].type == 2)
	//			{
	//				hmesh[lev][i].type = 2;
	//				break;
	//			}
	//		}
	//	}
	//}
}

void TruncatedTspline_3D::ConstructFaceEdge(int lev, int eid)//no need for all of them
{
	if (hmesh[lev][eid].edge[0] != -1 || hmesh[lev][eid].face[0] != -1) return;//means already constructed

	int edloc[12][2] = { { 0,1 },{ 1,2 },{ 2,3 },{ 3,0 },{0,4},{1,5},{2,6},{3,7},{4,5},{5,6},{6,7},{7,4} };
	int fcloc[6][4] = { {0,1,2,3},{0,1,5,4},{1,2,6,5},{2,3,7,6},{3,0,4,7},{4,5,6,7} };
	int fced[6][4] = { {0,1,2,3},{0,5,8,4},{1,6,9,5},{2,7,10,6},{3,4,11,7},{8,9,10,11} };
	uint i(eid), j, k, k1, k2;

	//existing edges and faces in one-ring elements
	vector<int> edge_r1, face_r1;
	for (j = 0; j < 8; j++)
	{
		for (k = 0; k < hcp[lev][hmesh[lev][eid].cnct[j]].hex.size(); k++)
		{
			int hxid(hcp[lev][hmesh[lev][eid].cnct[j]].hex[k]);
			if (hmesh[lev][hxid].edge[0] != -1)
			{
				for (k1 = 0; k1 < 12; k1++)
				{
					vector<int>::iterator it = find(edge_r1.begin(),edge_r1.end(), hmesh[lev][hxid].edge[k1]);
					if (it == edge_r1.end())
					{
						edge_r1.push_back(hmesh[lev][hxid].edge[k1]);
					}
				}
			}
			if (hmesh[lev][hxid].face[0] != -1)
			{
				for (k1 = 0; k1 < 6; k1++)
				{
					vector<int>::iterator it = find(face_r1.begin(), face_r1.end(), hmesh[lev][hxid].face[k1]);
					if (it == face_r1.end())
					{
						face_r1.push_back(hmesh[lev][hxid].face[k1]);
					}
				}
			}
		}
	}

	//construct edges
	for (j = 0; j < 12; j++)
	{
		Edge3D edtmp;
		edtmp.pt[0] = hmesh[lev][i].cnct[edloc[j][0]];
		edtmp.pt[1] = hmesh[lev][i].cnct[edloc[j][1]];
		int flag(-1);
		for (k = 0; k < edge_r1.size(); k++)
		{
			if ((edtmp.pt[0] == hedge[lev][edge_r1[k]].pt[0] && edtmp.pt[1] == hedge[lev][edge_r1[k]].pt[1]) ||
				(edtmp.pt[0] == hedge[lev][edge_r1[k]].pt[1] && edtmp.pt[1] == hedge[lev][edge_r1[k]].pt[0]))
			{
				flag = k; break;
			}
		}
		if (flag == -1)
		{
			hedge[lev].push_back(edtmp);
			hmesh[lev][i].edge[j] = hedge[lev].size() - 1;
		}
		else
		{
			hmesh[lev][i].edge[j] = edge_r1[flag];
		}
	}
	//construct faces
	for (j = 0; j < 6; j++)
	{
		Face3D fc;
		for (k = 0; k<4; k++)
		{
			fc.cnct[k] = hmesh[lev][i].cnct[fcloc[j][k]];
			fc.edge[k] = hmesh[lev][i].edge[fced[j][k]];
		}
		array<int, 4> fcsort = { fc.cnct[0],fc.cnct[1],fc.cnct[2],fc.cnct[3] };
		sort(fcsort.begin(), fcsort.end());
		int flag(-1);
		for (k = 0; k < face_r1.size(); k++)
		{
			array<int, 4> fctmp = { hface[lev][face_r1[k]].cnct[0],hface[lev][face_r1[k]].cnct[1],
				hface[lev][face_r1[k]].cnct[2],hface[lev][face_r1[k]].cnct[3] };
			sort(fctmp.begin(), fctmp.end());
			if (fcsort == fctmp)
			{
				flag = k; break;
			}
		}
		if (flag == -1)
		{
			hface[lev].push_back(fc);
			hmesh[lev][i].face[j] = hface[lev].size() - 1;
		}
		else
		{
			hmesh[lev][i].face[j] = face_r1[flag];
		}
	}

	//for (j = 0; j<4; j++)
	//{
	//	Edge3D edtmp;
	//	edtmp.pt[0] = hmesh[lev][i].cnct[j];
	//	edtmp.pt[1] = hmesh[lev][i].cnct[(j + 1) % 4];
	//	vector<Edge3D>::iterator it = find(hedge[lev].begin(), hedge[lev].end(), edtmp);
	//	int edid(it - hedge[lev].begin());
	//	if (it == hedge[lev].end())
	//	{
	//		hedge[lev].push_back(edtmp);
	//	}
	//	hmesh[lev][i].edge[j] = edid;
	//}
	//for (j = 0; j<4; j++)
	//{
	//	Edge3D edtmp;
	//	edtmp.pt[0] = hmesh[lev][i].cnct[j];
	//	edtmp.pt[1] = hmesh[lev][i].cnct[j + 4];
	//	vector<Edge3D>::iterator it = find(hedge[lev].begin(), hedge[lev].end(), edtmp);
	//	int edid(it - hedge[lev].begin());
	//	if (it == hedge[lev].end())
	//	{
	//		hedge[lev].push_back(edtmp);
	//	}
	//	hmesh[lev][i].edge[j + 4] = edid;
	//}
	//for (j = 0; j<4; j++)
	//{
	//	Edge3D edtmp;
	//	edtmp.pt[0] = hmesh[lev][i].cnct[j + 4];
	//	edtmp.pt[1] = hmesh[lev][i].cnct[(j + 1) % 4 + 4];
	//	vector<Edge3D>::iterator it = find(hedge[lev].begin(), hedge[lev].end(), edtmp);
	//	int edid(it - hedge[lev].begin());
	//	if (it == hedge[lev].end())
	//	{
	//		hedge[lev].push_back(edtmp);
	//	}
	//	hmesh[lev][i].edge[j + 8] = edid;
	//}

	////construct faces
	////one bottom face
	//Face3D fc1;
	//for (j = 0; j<4; j++)
	//{
	//	fc1.cnct[j] = hmesh[lev][i].cnct[j];
	//	fc1.edge[j] = hmesh[lev][i].edge[j];
	//}
	//vector<Face3D>::iterator it1 = find(hface[lev].begin(), hface[lev].end(), fc1);
	//int fc1id(it1 - hface[lev].begin());
	//if (it1 == hface[lev].end())
	//{
	//	hface[lev].push_back(fc1);
	//}
	//hmesh[lev][i].face[0] = fc1id;
	////4 side faces
	//for (j = 0; j<4; j++)
	//{
	//	Face3D fc;
	//	for (int k = 0; k<4; k++)
	//	{
	//		fc.cnct[k] = hmesh[lev][i].cnct[fc_cnct[j][k]];
	//		fc.edge[k] = hmesh[lev][i].edge[ed_cnct[j][k]];
	//	}
	//	vector<Face3D>::iterator it = find(hface[lev].begin(), hface[lev].end(), fc);
	//	int fcid(it - hface[lev].begin());
	//	if (it == hface[lev].end())
	//	{
	//		hface[lev].push_back(fc);
	//	}
	//	hmesh[lev][i].face[j + 1] = fcid;
	//}
	////one top face
	//Face3D fc2;
	//for (j = 0; j<4; j++)
	//{
	//	fc2.cnct[j] = hmesh[lev][i].cnct[j + 4];
	//	fc2.edge[j] = hmesh[lev][i].edge[j + 8];
	//}
	//vector<Face3D>::iterator it2 = find(hface[lev].begin(), hface[lev].end(), fc2);
	//int fc2id(it2 - hface[lev].begin());
	//if (it2 == hface[lev].end())
	//{
	//	hface[lev].push_back(fc2);
	//}
	//hmesh[lev][i].face[5] = fc2id;
}

void TruncatedTspline_3D::Refine_Ghost(const vector<array<int, 2>>& rfid)
{
	//has to be irregular elements
	for (uint i = 0; i < rfid.size(); i++)
	{
		if (hmesh[rfid[i][0]][rfid[i][1]].type == 0 || hmesh[rfid[i][0]][rfid[i][1]].type == 2)
		{
			if (hmesh[rfid[i][0]][rfid[i][1]].chd.size() == 0)
			{
				PatchRefine_Irregular(rfid[i][0], rfid[i][1]);
			}
		}
		else if (hmesh[rfid[i][0]][rfid[i][1]].type == 1)
		{
			if (hmesh[rfid[i][0]][rfid[i][1]].chd.size() == 0)
			{
				PatchRefine_Boundary(rfid[i][0], rfid[i][1]);
			}
		}
		//else if (hmesh[rfid[i][0]][rfid[i][1]].type == 2)
		//{
		//	PatchRefine_Irregular(rfid[i][0], rfid[i][1]);
		//}
		for (uint j = 0; j < hmesh[rfid[i][0]][rfid[i][1]].chd.size(); j++)
		{
			hmesh[rfid[i][0] + 1][hmesh[rfid[i][0]][rfid[i][1]].chd[j]].act = 0;
			hmesh[rfid[i][0] + 1][hmesh[rfid[i][0]][rfid[i][1]].chd[j]].ghost = 1;
		}
		hmesh[rfid[i][0]][rfid[i][1]].act = 1;
	}
}

void TruncatedTspline_3D::Selection(int lev)
{
	uint i, j, k, m;
	for (i = 0; i < hcp[lev].size(); i++)
	{
		hcp[lev][i].act = 0;
		hcp[lev][i].supp.clear();
	}
	for (i = 0; i < hmesh[lev].size(); i++)
	{
		if (hmesh[lev][i].ghost == 0)
		{
			for (j = 0; j < hmesh[lev][i].IEN.size(); j++)
			{
				hcp[lev][hmesh[lev][i].IEN[j]].supp.push_back(i);
			}
		}
	}
	//for (uint i = 0; i < hcp[lev].size(); i++)
	//{
	//	if (hcp[lev][i].supp.size() == 64)//tmp
	//	{
	//		int flag(0);
	//		for (uint j = 0; j < hcp[lev][i].supp.size(); j++)
	//		{
	//			if (hmesh[lev][hcp[lev][i].supp[j]].act == 1)
	//			{
	//				flag = 1; break;
	//			}
	//		}
	//		if (flag == 1)
	//		{
	//			hcp[lev][i].act = 1;
	//		}
	//	}
	//}

	for (i = 0; i < hcp[lev].size(); i++)
	{
		int flag(0);
		for (j = 0; j < hcp[lev][i].hex.size(); j++)
		{
			int hxid(hcp[lev][i].hex[j]);
			if (hmesh[lev][hxid].ghost == 1)
			{
				flag = 1; break;
			}
			for (k = 0; k < 8; k++)
			{
				int pid(hmesh[lev][hxid].cnct[k]);
				for (m = 0; m < hcp[lev][pid].hex.size(); m++)
				{
					if (hmesh[lev][hcp[lev][pid].hex[m]].ghost == 1)
					{
						flag = 1; break;
					}
				}
				if (flag == 1) break;
			}
			if (flag == 1) break;
		}
		if (flag == 0)//possibly active
		{
			int act_hx(0);
			for (j = 0; j < hcp[lev][i].supp.size(); j++)
			{
				if (hmesh[lev][hcp[lev][i].supp[j]].act == 1)
				{
					act_hx = 1; break;
				}
			}
			if (act_hx == 1)
			{
				hcp[lev][i].act = 1;
			}
		}
	}
}

void TruncatedTspline_3D::SetSupport(int lev)
{
	uint i, j;
	for (i = 0; i < hcp[lev].size(); i++)
	{
		hcp[lev][i].supp.clear();
	}
	for (i = 0; i < hmesh[lev].size(); i++)
	{
		if (hmesh[lev][i].ghost == 0)
		{
			for (j = 0; j < hmesh[lev][i].IEN.size(); j++)
			{
				hcp[lev][hmesh[lev][i].IEN[j]].supp.push_back(i);
			}
		}
	}
}

void TruncatedTspline_3D::Select()
{
	uint lev, i, j, k, m;
	for (lev = 0; lev < hcp.size(); lev++)
	{
		for (i = 0; i < hcp[lev].size(); i++)
		{
			hcp[lev][i].act = 0;
		}
		////set supp for new level
		//for (i = 0; i < hmesh[lev].size(); i++)
		//{
		//	if (hmesh[lev][i].ghost == 0)//because IEN only available for non-ghost elements
		//	{
		//		for (j = 0; j < hmesh[lev][i].IEN.size(); j++)
		//		{
		//			hcp[lev][hmesh[lev][i].IEN[j]].supp.push_back(i);
		//		}
		//	}
		//}

		for (i = 0; i < hcp[lev].size(); i++)
		{
			int flag(0);//two-ring elements no ghost
			for (j = 0; j < hcp[lev][i].hex.size(); j++)
			{
				int hxid(hcp[lev][i].hex[j]);
				if (hmesh[lev][hxid].ghost == 1)
				{
					flag = 1; break;
				}
				for (k = 0; k < 8; k++)
				{
					int pid(hmesh[lev][hxid].cnct[k]);
					for (m = 0; m < hcp[lev][pid].hex.size(); m++)
					{
						if (hmesh[lev][hcp[lev][pid].hex[m]].ghost == 1)
						{
							flag = 1; break;
						}
					}
					if (flag == 1) break;
				}
				if (flag == 1) break;
			}
			if (flag == 0)//possibly active
			{
				int act_hx(0);
				for (j = 0; j < hcp[lev][i].supp.size(); j++)
				{
					if (hmesh[lev][hcp[lev][i].supp[j]].act == 1)
					{
						act_hx = 1; break;
					}
				}
				if (act_hx == 1)
				{
					hcp[lev][i].act = 1;
				}
			}
		}
	}
}

void TruncatedTspline_3D::Truncate(int lev)//lev is a high level or a refined level
{
	if (lev <= 0) return;
	uint i, j, k;
	//point-wise truncation
	for (i = 0; i < hcp[lev - 1].size(); i++)
	{
		//if (hcp[lev - 1][i].act == 1)
		{
			for (j = 0; j < hcp[lev - 1][i].chd.size(); j++)
			{
				if (hcp[lev][hcp[lev - 1][i].chd[j]].act == 1)
				{
					hcp[lev - 1][i].coef[j] = 0.;
				}
			}
		}
	}

	//element-wise truncation
	for (i = 0; i < hmesh[lev].size(); i++)
	{
		if (hmesh[lev][i].trun == 1)
		{
			hmesh[lev][i].trun = 0;
			hmesh[lev][i].IEN_act.clear();
			for (j = 0; j < hmesh[lev][i].tmat.size(); j++)
			{
				hmesh[lev][i].tmat[j].clear();
			}
			hmesh[lev][i].tmat.clear();
		}
		if (hmesh[lev][i].act == 1 && hmesh[lev][i].prt != -1)//must be active high-level elements
		{
			int flag(0);
			for (j = 0; j < hmesh[lev][i].IEN.size(); j++)
			{
				if (hcp[lev][hmesh[lev][i].IEN[j]].act == 0)
				{
					flag++;
				}
			}
			if (flag == hmesh[lev][i].IEN.size())
			{
				cerr << "All the basis functions on " << lev << " " << i << " are passive!\n";
				return;
			}
			//if (flag != 0)
			{
				hmesh[lev][i].trun = 1;
				for (j = 0; j < hmesh[lev][i].IEN.size(); j++)
				{
					if (hcp[lev][hmesh[lev][i].IEN[j]].act == 1)
					{
						array<int, 2> btmp = { lev, hmesh[lev][i].IEN[j] };
						vector<double> ctmp(hmesh[lev][i].IEN.size(), 0.);
						ctmp[j] = 1.;
						hmesh[lev][i].IEN_act.push_back(btmp);
						hmesh[lev][i].tmat.push_back(ctmp);
					}
				}

				int prt(hmesh[lev][i].prt);
				int lv(lev - 1);
				int eid0(i), lv0(lev);
				MatrixXd m0 = MatrixXd::Identity(hmesh[lv0][eid0].IEN.size(), hmesh[lev][i].IEN.size());
				while (prt != -1 && lv >= 0)
				{
					MatrixXd m1 = MatrixXd::Zero(hmesh[lv][prt].IEN.size(), hmesh[lv0][eid0].IEN.size());
					for (j = 0; j < hmesh[lv][prt].IEN.size(); j++)
					{
						for (k = 0; k < hcp[lv][hmesh[lv][prt].IEN[j]].chd.size(); k++)
						{
							int cid(hcp[lv][hmesh[lv][prt].IEN[j]].chd[k]);
							vector<int>::iterator it = find(hmesh[lv0][eid0].IEN.begin(), hmesh[lv0][eid0].IEN.end(), cid);
							if (it != hmesh[lv0][eid0].IEN.end())
							{
								int pos(it - hmesh[lv0][eid0].IEN.begin());
								m1(j, pos) = hcp[lv][hmesh[lv][prt].IEN[j]].coef[k];
							}
						}
					}
					//cout
					//if (lev == 2 && lv == 0)
					//{
					//	vector<double> sum0(hmesh[lev][i].IEN.size(), 0.);
					//	cout << "sum of m0 before:\n";
					//	for (j = 0; j < hmesh[lev][i].IEN.size(); j++)
					//	{
					//		for (k = 0; k < hmesh[lv0][eid0].IEN.size(); k++)
					//		{
					//			sum0[j] += m0(k, j);
					//		}
					//		cout << sum0[j] << "\n";
					//	}
					//	//vector<double> sum1(hmesh[lv0][eid0].IEN.size(), 0.);
					//	//cout << "sum of m1:\n";
					//	//for (j = 0; j < hmesh[lv0][eid0].IEN.size(); j++)
					//	//{
					//	//	for (k = 0; k < hmesh[lv][prt].IEN.size(); k++)
					//	//	{
					//	//		sum1[j] += m1(k, j);
					//	//	}
					//	//	cout << sum1[j] << "\n";
					//	//}
					//	getchar();
					//}
					MatrixXd mtmp = m1*m0;
					m0.resize(hmesh[lv][prt].IEN.size(), hmesh[lev][i].IEN.size());
					m0 = mtmp;
					//cout
					//if (lev == 2 && lv == 0)
					//{
					//	vector<double> sum0(hmesh[lev][i].IEN.size(), 0.);
					//	cout << "sum of m0 after:\n";
					//	for (j = 0; j < hmesh[lev][i].IEN.size(); j++)
					//	{
					//		for (k = 0; k < hmesh[lv][prt].IEN.size(); k++)
					//		{
					//			sum0[j] += m0(k, j);
					//		}
					//		cout << sum0[j] << "\n";
					//	}
					//	getchar();
					//}
					for (j = 0; j < hmesh[lv][prt].IEN.size(); j++)
					{
						if (hcp[lv][hmesh[lv][prt].IEN[j]].act == 1)
						{
							array<int, 2> btmp = { lv, hmesh[lv][prt].IEN[j] };
							vector<double> ctmp(hmesh[lev][i].IEN.size());
							for (k = 0; k < hmesh[lev][i].IEN.size(); k++)
							{
								ctmp[k] = m0(j,k);
							}
							hmesh[lev][i].IEN_act.push_back(btmp);
							hmesh[lev][i].tmat.push_back(ctmp);
						}
					}
					eid0 = prt;
					lv0 = lv;
					prt = hmesh[lv][prt].prt;
					lv--;
				}
				//cout
				//if (lev == 2)
				//{
				//	vector<double> sum(hmesh[lev][i].IEN.size(), 0.);
				//	cout << "sum of trun ele: " << hmesh[lev][i].type <<"\n";
				//	for (j = 0; j < hmesh[lev][i].IEN.size(); j++)
				//	{
				//		for (k = 0; k < hmesh[lev][i].IEN_act.size(); k++)
				//		{
				//			sum[j] += hmesh[lev][i].tmat[k][j];
				//		}
				//		cout << sum[j] << "\n";
				//	}
				//	getchar();
				//}
			}
		}
	}

	//for (i = 0; i < hmesh[lev].size(); i++)
	//{
	//	if (hmesh[lev][i].trun == 1)
	//	{
	//		for (j = 0; j < hmesh[lev][i].IEN_act.size(); j++)
	//		{
	//			int idtmp[2] = { hmesh[lev][i].IEN_act[j][0], hmesh[lev][i].IEN_act[j][1] };
	//			if (hcp[idtmp[0]][idtmp[1]].act == 0)
	//			{
	//				cout << "Inactive basis function!\n";
	//				cout << idtmp[0] << " " << idtmp[1] << "\n";
	//				getchar();
	//			}
	//		}
	//	}
	//}
}

void TruncatedTspline_3D::Basis_Regular(int lev, int eid, const array<double, 3>& u, vector<double>& Nt, vector<array<double, 3>>& dNdt)
{
	Nt.clear();
	dNdt.clear();
	if (hmesh[lev][eid].trun == 0)
	{
		Nt.resize(hmesh[lev][eid].IEN.size());
		dNdt.resize(hmesh[lev][eid].IEN.size());
		vector<double> ku(5, 0.), kv(5, 0.), kw(5, 0.), uval, vval, wval;
		BSplineBasis bu, bv, bw;
		for (uint i = 0; i<hmesh[lev][eid].IEN.size(); i++)
		{
			ku.assign(hmesh[lev][eid].patch_ku[i].begin(), hmesh[lev][eid].patch_ku[i].end());
			kv.assign(hmesh[lev][eid].patch_kv[i].begin(), hmesh[lev][eid].patch_kv[i].end());
			kw.assign(hmesh[lev][eid].patch_kw[i].begin(), hmesh[lev][eid].patch_kw[i].end());
			bu.Set(3, ku);
			bv.Set(3, kv);
			bw.Set(3, kw);
			bu.BasisFunction(0, u[0], 1, uval);
			bv.BasisFunction(0, u[1], 1, vval);
			bw.BasisFunction(0, u[2], 1, wval);
			Nt[i] = uval[0] * vval[0] * wval[0];
			dNdt[i][0] = uval[1] * vval[0] * wval[0];
			dNdt[i][1] = uval[0] * vval[1] * wval[0];
			dNdt[i][2] = uval[0] * vval[0] * wval[1];
		}
	}
	else
	{
		Nt.resize(hmesh[lev][eid].IEN_act.size());
		dNdt.resize(hmesh[lev][eid].IEN_act.size());
		vector<double> Nt0(hmesh[lev][eid].IEN.size());
		vector<array<double, 3>> dNdt0(hmesh[lev][eid].IEN.size());
		vector<double> ku(5, 0.), kv(5, 0.), kw(5, 0.), uval, vval, wval;
		BSplineBasis bu, bv, bw;
		for (uint i = 0; i<hmesh[lev][eid].IEN.size(); i++)
		{
			ku.assign(hmesh[lev][eid].patch_ku[i].begin(), hmesh[lev][eid].patch_ku[i].end());
			kv.assign(hmesh[lev][eid].patch_kv[i].begin(), hmesh[lev][eid].patch_kv[i].end());
			kw.assign(hmesh[lev][eid].patch_kw[i].begin(), hmesh[lev][eid].patch_kw[i].end());
			bu.Set(3, ku);
			bv.Set(3, kv);
			bw.Set(3, kw);
			bu.BasisFunction(0, u[0], 1, uval);
			bv.BasisFunction(0, u[1], 1, vval);
			bw.BasisFunction(0, u[2], 1, wval);
			Nt0[i] = uval[0] * vval[0] * wval[0];
			dNdt0[i][0] = uval[1] * vval[0] * wval[0];
			dNdt0[i][1] = uval[0] * vval[1] * wval[0];
			dNdt0[i][2] = uval[0] * vval[0] * wval[1];
		}
		for (uint i = 0; i < hmesh[lev][eid].IEN_act.size(); i++)
		{
			Nt[i] = 0.; dNdt[i][0] = 0.; dNdt[i][1] = 0.; dNdt[i][2] = 0.;
			for (uint j = 0; j < hmesh[lev][eid].IEN.size(); j++)
			{
				if (hmesh[lev][eid].tmat[i][j] != 0.)
				{
					Nt[i] += hmesh[lev][eid].tmat[i][j] * Nt0[j];
					dNdt[i][0] += hmesh[lev][eid].tmat[i][j] * dNdt0[j][0];
					dNdt[i][1] += hmesh[lev][eid].tmat[i][j] * dNdt0[j][1];
					dNdt[i][2] += hmesh[lev][eid].tmat[i][j] * dNdt0[j][2];
				}
			}
		}
	}
}

void TruncatedTspline_3D::Basis_Irregular(int lev, int eid, const array<double, 3>& u, vector<double>& Nt, vector<array<double, 3>>& dNdt)
{
	Nt.clear();
	dNdt.clear();
	if (hmesh[lev][eid].trun == 0)
	{
		Nt.resize(hmesh[lev][eid].IEN.size());
		dNdt.resize(hmesh[lev][eid].IEN.size());
		BezierElement3D bzel;
		vector<double> Bt;
		vector<array<double, 3>> dBdt;
		bzel.Basis(u[0], u[1], u[2], Bt, dBdt);
		for (uint i = 0; i < hmesh[lev][eid].IEN.size(); i++)
		{
			Nt[i] = 0.;
			dNdt[i][0] = 0.; dNdt[i][1] = 0.; dNdt[i][2] = 0.;
			for (uint j = 0; j < 64; j++)
			{
				Nt[i] += hmesh[lev][eid].bemat[i][j] * Bt[j];
				dNdt[i][0] += hmesh[lev][eid].bemat[i][j] * dBdt[j][0];
				dNdt[i][1] += hmesh[lev][eid].bemat[i][j] * dBdt[j][1];
				dNdt[i][2] += hmesh[lev][eid].bemat[i][j] * dBdt[j][2];
			}
		}
	}
	else
	{
		Nt.resize(hmesh[lev][eid].IEN_act.size());
		dNdt.resize(hmesh[lev][eid].IEN_act.size());
		vector<double> Nt0(hmesh[lev][eid].IEN.size());
		vector<array<double, 3>> dNdt0(hmesh[lev][eid].IEN.size());
		BezierElement3D bzel;
		vector<double> Bt;
		vector<array<double, 3>> dBdt;
		bzel.Basis(u[0], u[1], u[2], Bt, dBdt);
		for (uint i = 0; i < hmesh[lev][eid].IEN.size(); i++)
		{
			Nt0[i] = 0.;
			dNdt0[i][0] = 0.; dNdt0[i][1] = 0.; dNdt0[i][2] = 0.;
			for (uint j = 0; j < 64; j++)
			{
				Nt0[i] += hmesh[lev][eid].bemat[i][j] * Bt[j];
				dNdt0[i][0] += hmesh[lev][eid].bemat[i][j] * dBdt[j][0];
				dNdt0[i][1] += hmesh[lev][eid].bemat[i][j] * dBdt[j][1];
				dNdt0[i][2] += hmesh[lev][eid].bemat[i][j] * dBdt[j][2];
			}
		}
		for (uint i = 0; i < hmesh[lev][eid].IEN_act.size(); i++)
		{
			Nt[i] = 0.; dNdt[i][0] = 0.; dNdt[i][1] = 0.; dNdt[i][2] = 0.;
			for (uint j = 0; j < hmesh[lev][eid].IEN.size(); j++)
			{
				if (hmesh[lev][eid].tmat[i][j] != 0.)
				{
					Nt[i] += hmesh[lev][eid].tmat[i][j] * Nt0[j];
					dNdt[i][0] += hmesh[lev][eid].tmat[i][j] * dNdt0[j][0];
					dNdt[i][1] += hmesh[lev][eid].tmat[i][j] * dNdt0[j][1];
					dNdt[i][2] += hmesh[lev][eid].tmat[i][j] * dNdt0[j][2];
				}
			}
		}
	}
}

void TruncatedTspline_3D::Identify_Pseudo(vector<array<int, 2>>& rfid)
{
	//int nh(9);
	//for (int i = 1; i < nh - 1; i++)
	//{
	//	array<int, 2> tmp = { 0, i*nh*nh + i*nh + i };
	//	rfid.push_back(tmp);
	//}

	rfid.clear();
	int nh(9+1), lev(0);
	vector<int> p_rf;
	for (int i = 2; i < nh - 2; i++)
	{
		p_rf.push_back(i*nh*nh + i*nh + i);
	}
	for (uint i = 0; i < p_rf.size(); i++)
	{
		for (uint j = 0; j < hcp[lev][p_rf[i]].hex.size(); j++)
		{
			array<int, 2> tmp = { lev, hcp[lev][p_rf[i]].hex[j] };
			vector<array<int, 2>>::iterator it = find(rfid.begin(),rfid.end(),tmp);
			if (it == rfid.end()) rfid.push_back(tmp);
		}
	}
	//cout <<"#rfid: "<< rfid.size() << "\n";
	//for (uint i = 0; i < rfid.size(); i++)
	//{
	//	cout << rfid[i][1] << " ";
	//}
	//cout << "\n";
	//getchar();
}

void TruncatedTspline_3D::Identify_Pseudo_1(vector<array<int, 2>>& rfid)
{
	rfid.clear();
	int lev(hmesh.size()-1);
	vector<int> p_rf;
	for (uint i = 0; i < hcp[lev].size(); i++)
	{
		if (hcp[lev][i].act == 1) p_rf.push_back(i);
	}
	for (uint i = 0; i < p_rf.size(); i++)
	{
		for (uint j = 0; j < hcp[lev][p_rf[i]].hex.size(); j++)
		{
			array<int, 2> tmp = { lev, hcp[lev][p_rf[i]].hex[j] };
			vector<array<int, 2>>::iterator it = find(rfid.begin(), rfid.end(), tmp);
			if (it == rfid.end()) rfid.push_back(tmp);
		}
	}
}

void TruncatedTspline_3D::Identify_Test_1(vector<array<int, 2>>& rfid, vector<array<int, 2>>& gst)
{
	rfid.clear();
	gst.clear();
	int lev(0);
	int pid(-1);
	for (uint i = 0; i < hmesh[lev].size(); i++)
	{
		if (hmesh[lev][i].type == 2)
		{
			for (int j = 0; j < 8; j++)
			{
				if (hcp[lev][hmesh[lev][i].cnct[j]].type == 0)
				{
					pid = hmesh[lev][i].cnct[j]; break;
				}
			}
		}
		if (pid != -1) break;
	}
	for (uint i = 0; i < hcp[lev][pid].hex.size(); i++)
	{
		array<int, 2> tmp = { lev, hcp[lev][pid].hex[i] };
		rfid.push_back(tmp);
	}
	for (uint i = 0; i < rfid.size(); i++)
	{
		for (int j = 0; j < 8; j++)
		{
			int pt(hmesh[lev][rfid[i][1]].cnct[j]);
			for (uint k = 0; k < hcp[lev][pt].hex.size(); k++)
			{
				array<int, 2> tmp = { lev, hcp[lev][pt].hex[k] };
				vector<array<int, 2>>::iterator it1 = find(gst.begin(),gst.end(),tmp);
				vector<array<int, 2>>::iterator it2 = find(rfid.begin(), rfid.end(), tmp);
				if (it1 == gst.end() && it2 == rfid.end())
				{
					gst.push_back(tmp);
				}
			}
		}
	}
}

void TruncatedTspline_3D::Identify_Test_2(vector<array<int, 2>>& rfid, vector<array<int, 2>>& gst)
{
	rfid.clear();
	gst.clear();
	int lev(0);
	int pid(-1);
	for (uint i = 0; i < hmesh[lev].size(); i++)
	{
		if (hmesh[lev][i].type == 2)
		{
			for (int j = 0; j < 8; j++)
			{
				if (hcp[lev][hmesh[lev][i].cnct[j]].type == 3)
				{
					pid = hmesh[lev][i].cnct[j]; break;
				}
			}
		}
		if (pid != -1) break;
	}
	for (uint i = 0; i < hcp[lev][pid].hex.size(); i++)
	{
		array<int, 2> tmp = { lev, hcp[lev][pid].hex[i] };
		rfid.push_back(tmp);
	}
	for (uint i = 0; i < rfid.size(); i++)
	{
		for (int j = 0; j < 8; j++)
		{
			int pt(hmesh[lev][rfid[i][1]].cnct[j]);
			for (uint k = 0; k < hcp[lev][pt].hex.size(); k++)
			{
				array<int, 2> tmp = { lev, hcp[lev][pt].hex[k] };
				vector<array<int, 2>>::iterator it1 = find(gst.begin(), gst.end(), tmp);
				vector<array<int, 2>>::iterator it2 = find(rfid.begin(), rfid.end(), tmp);
				if (it1 == gst.end() && it2 == rfid.end())
				{
					gst.push_back(tmp);
				}
			}
		}
	}
}

void TruncatedTspline_3D::Identify_Test_3(vector<array<int, 2>>& rfid, vector<array<int, 2>>& gst)
{
	rfid.clear();
	gst.clear();
	int lev(hcp.size()-1);
	int pid(-1);
	for (uint i = 0; i < hcp[lev].size(); i++)
	{
		if (hcp[lev][i].act == 1)
		{
			pid = i; break;
		}
	}
	if (pid == -1)
	{
		cerr << "Cannot find active points at level " << lev << "!\n";
		getchar();
	}
	for (uint i = 0; i < hcp[lev][pid].hex.size(); i++)
	{
		array<int, 2> tmp = { lev, hcp[lev][pid].hex[i] };
		rfid.push_back(tmp);
	}
	for (uint i = 0; i < rfid.size(); i++)
	{
		for (int j = 0; j < 8; j++)
		{
			int pt(hmesh[lev][rfid[i][1]].cnct[j]);
			for (uint k = 0; k < hcp[lev][pt].hex.size(); k++)
			{
				array<int, 2> tmp = { lev, hcp[lev][pt].hex[k] };
				vector<array<int, 2>>::iterator it1 = find(gst.begin(), gst.end(), tmp);
				vector<array<int, 2>>::iterator it2 = find(rfid.begin(), rfid.end(), tmp);
				if (it1 == gst.end() && it2 == rfid.end())
				{
					gst.push_back(tmp);
				}
			}
		}
	}
}

void TruncatedTspline_3D::Identify_Test_4(vector<array<int, 2>>& rfid, vector<array<int, 2>>& gst)
{
	rfid.clear();
	gst.clear();
	int lev(0);
	//int pid(3460);
	int pid(2792);
	//for (uint i = 0; i < hcp[lev].size(); i++)
	//{
	//	if (hcp[lev][i].type == 1)
	//	{
	//		pid=
	//		for (int j = 0; j < 8; j++)
	//		{
	//			if (hcp[lev][hmesh[lev][i].cnct[j]].type == 3)
	//			{
	//				pid = hmesh[lev][i].cnct[j]; break;
	//			}
	//		}
	//	}
	//	if (pid != -1) break;
	//}
	for (uint i = 0; i < hcp[lev][pid].hex.size(); i++)
	{
		array<int, 2> tmp = { lev, hcp[lev][pid].hex[i] };
		rfid.push_back(tmp);
	}
	for (uint i = 0; i < rfid.size(); i++)
	{
		for (int j = 0; j < 8; j++)
		{
			int pt(hmesh[lev][rfid[i][1]].cnct[j]);
			for (uint k = 0; k < hcp[lev][pt].hex.size(); k++)
			{
				array<int, 2> tmp = { lev, hcp[lev][pt].hex[k] };
				vector<array<int, 2>>::iterator it1 = find(gst.begin(), gst.end(), tmp);
				vector<array<int, 2>>::iterator it2 = find(rfid.begin(), rfid.end(), tmp);
				if (it1 == gst.end() && it2 == rfid.end())
				{
					gst.push_back(tmp);
				}
			}
		}
	}
}

void TruncatedTspline_3D::Refine(vector<array<int, 2>>& rfid, vector<array<int, 2>>& gst)
{
	vector<MatrixXd> bsmat;
	BezierSubdivMatrix(bsmat);

	cout << "# of to-be-refined elements: " << rfid.size() << "\n";
	for (uint i = 0; i < rfid.size(); i++)
	{
		if (i!=0 && i % 200 == 0) cout << i << " ";
		//cout << "Refine ID: " << i << "/" << rfid.size()<<"\n";
		if (hmesh[rfid[i][0]][rfid[i][1]].type == 0 || hmesh[rfid[i][0]][rfid[i][1]].type == 2)
		{
			if (hmesh[rfid[i][0]][rfid[i][1]].chd.size() == 0)
			{
				PatchRefine_Irregular(rfid[i][0], rfid[i][1]);
			}
			else//previously refined to ghost children elements
			{
				hmesh[rfid[i][0]][rfid[i][1]].act = 0;
				for (uint j = 0; j < hmesh[rfid[i][0]][rfid[i][1]].chd.size(); j++)
				{
					hmesh[rfid[i][0] + 1][hmesh[rfid[i][0]][rfid[i][1]].chd[j]].act = 1;
					hmesh[rfid[i][0] + 1][hmesh[rfid[i][0]][rfid[i][1]].chd[j]].ghost = 0;
				}
			}
		}
		else if (hmesh[rfid[i][0]][rfid[i][1]].type == 1)
		{
			if (hmesh[rfid[i][0]][rfid[i][1]].chd.size() == 0)
			{
				PatchRefine_Boundary(rfid[i][0], rfid[i][1]);
			}
			else
			{
				hmesh[rfid[i][0]][rfid[i][1]].act = 0;
				for (uint j = 0; j < hmesh[rfid[i][0]][rfid[i][1]].chd.size(); j++)
				{
					hmesh[rfid[i][0] + 1][hmesh[rfid[i][0]][rfid[i][1]].chd[j]].act = 1;
					hmesh[rfid[i][0] + 1][hmesh[rfid[i][0]][rfid[i][1]].chd[j]].ghost = 0;
				}
			}
		}

		BezierPoints_Refine(rfid[i][0],rfid[i][1],bsmat);

		//else if (hmesh[rfid[i][0]][rfid[i][1]].type == 2)
		//{
		//	PatchRefine_Irregular(rfid[i][0], rfid[i][1]);
		//}
	}
	cout << "# of to-be-refined ghost: " << gst.size() << "\n";
	Refine_Ghost(gst);

	//int lev(rfid[0][0] + 1);//tmp
	vector<int> lev;
	for (uint i = 0; i < rfid.size(); i++)
	{
		vector<int>::iterator it = find(lev.begin(), lev.end(), rfid[i][0] + 1);
		if (it == lev.end()) lev.push_back(rfid[i][0] + 1);
	}
	for (uint il = 0; il < lev.size(); il++)
	{
		for (uint i = 0; i < hcp[lev[il]].size(); i++)
		{
			hcp[lev[il]][i].hex.clear();
		}
	}
	for (uint il = 0; il < lev.size(); il++)
	{
		for (uint i = 0; i < hmesh[lev[il]].size(); i++)
		{
			for (int j = 0; j < 8; j++)
			{
				hcp[lev[il]][hmesh[lev[il]][i].cnct[j]].hex.push_back(i);
			}
		}
	}
	for (uint i = 0; i < rfid.size(); i++)
	{
		for (uint j = 0; j < hmesh[rfid[i][0]][rfid[i][1]].chd.size(); j++)
		{
			int eid[2] = { rfid[i][0] + 1, hmesh[rfid[i][0]][rfid[i][1]].chd[j] };
			ConstructFaceEdge(eid[0], eid[1]);
		}
		vector<int>::iterator it = find(lev.begin(), lev.end(), rfid[i][0] + 1);
		if (it == lev.end()) lev.push_back(rfid[i][0] + 1);
	}
	for (uint i = 0; i < gst.size(); i++)
	{
		for (uint j = 0; j < hmesh[gst[i][0]][gst[i][1]].chd.size(); j++)
		{
			int eid[2] = { gst[i][0] + 1, hmesh[gst[i][0]][gst[i][1]].chd[j] };
			ConstructFaceEdge(eid[0], eid[1]);
		}
	}
	//for (uint i = 0; i < hmesh[lev].size(); i++)
	//{
	//	ConstructFaceEdge(lev, i);
	//}
	for (uint i = 0; i < lev.size(); i++)
	{
		ConstructConnect(lev[i]);
	}
	//construct basis functions for new high-level elements
	for (uint i = 0; i < rfid.size(); i++)
	{
		for (uint j = 0; j < hmesh[rfid[i][0]][rfid[i][1]].chd.size(); j++)
		{
			int eid[2] = { rfid[i][0] + 1, hmesh[rfid[i][0]][rfid[i][1]].chd[j] };
			if (hmesh[eid[0]][eid[1]].ghost == 0 && hmesh[eid[0]][eid[1]].IEN.size()==0)
			{
				if (hmesh[eid[0]][eid[1]].type == 0 || hmesh[eid[0]][eid[1]].type == 2)
				{
					ConstructBezierBasis(eid[0], eid[1]);
				}
				else if (hmesh[eid[0]][eid[1]].type == 1)
				{
					ConstructBezierBasis_Boundary(eid[0], eid[1]);
				}
			}
		}
	}
	//for (uint i = 0; i < hmesh[lev].size(); i++)
	//{
	//	if (hmesh[lev][i].ghost == 0)
	//	{
	//		if (hmesh[lev][i].type == 0 || hmesh[lev][i].type == 2)
	//		{
	//			ConstructBezierBasis(lev, i);
	//		}
	//		else if (hmesh[lev][i].type == 1)
	//		{
	//			ConstructBezierBasis_Boundary(lev, i);
	//		}
	//	}
	//}

	for (uint i = 0; i < lev.size(); i++)
	{
		SetSupport(lev[i]);
	}
	Select();

	for (uint i = 1; i < hmesh.size(); i++)
	{
		Truncate(i);
	}

	////Selection(lev);
	////SetSupport(lev);
	////Select();
	////Truncate(lev);
}

void TruncatedTspline_3D::OutputCM(int lev, string fn)
{
	string fname(fn + "_CM.vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << hcp[lev].size() << " float\n";
		for (uint i = 0; i<hcp[lev].size(); i++)
		{
			fout << hcp[lev][i].coor[0] << " " << hcp[lev][i].coor[1] << " " << hcp[lev][i].coor[2] << "\n";
		}
		fout << "\nCELLS " << hmesh[lev].size() << " " << 9 * hmesh[lev].size() << '\n';
		for (uint i = 0; i<hmesh[lev].size(); i++)
		{
			fout << "8 ";
			for (int j = 0; j<8; j++)
			{
				fout << hmesh[lev][i].cnct[j] << ' ';
			}
			fout << '\n';
		}
		fout << "\nCELL_TYPES " << hmesh[lev].size() << '\n';
		for (uint i = 0; i<hmesh[lev].size(); i++)
		{
			fout << "12\n";
		}
		
		fout << "POINT_DATA " << hcp[lev].size() << "\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
		for (uint i = 0; i<hcp[lev].size(); i++)
		{
			fout << hcp[lev][i].act << "\n";
			//fout << hcp[lev][i].type << "\n";
			//if (hcp[lev][i].act == 1 && hcp[lev][i].type == 1)
			//{
			//	fout << "1\n";
			//}
			//else
			//{
			//	fout << "0\n";
			//}
		}

		fout<<"\nCELL_DATA "<<hmesh[lev].size()<<"\nSCALARS eact float 1\nLOOKUP_TABLE default\n";
		for(uint i=0;i<hmesh[lev].size();i++)
		{
			fout<<hmesh[lev][i].act<<"\n";
			//fout << hmesh[lev][i].type << "\n";
			//fout << hmesh[lev][i].jacobFlag << "\n";
		}

		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::OutputFace(int lev, string fn)
{
	string fname(fn + "_face.vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << hcp[lev].size() << " float\n";
		for (uint i = 0; i<hcp[lev].size(); i++)
		{
			fout << hcp[lev][i].coor[0] << " " << hcp[lev][i].coor[1] << " " << hcp[lev][i].coor[2] << "\n";
		}
		fout << "\nCELLS " << hface[lev].size() << " " << 5 * hface[lev].size() << '\n';
		for (uint i = 0; i<hface[lev].size(); i++)
		{
			fout << "4 ";
			for (int j = 0; j<4; j++)
			{
				fout << hface[lev][i].cnct[j] << ' ';
			}
			fout << '\n';
		}
		fout << "\nCELL_TYPES " << hface[lev].size() << '\n';
		for (uint i = 0; i<hface[lev].size(); i++)
		{
			fout << "9\n";
		}

		//fout << "POINT_DATA " << hcp[lev].size() << "\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<hcp[lev].size(); i++)
		//{
		//	fout << hcp[lev][i].act << "\n";
		//}

		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::OutputEdge(int lev, string fn)
{
	string fname(fn + "_edge.vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << hcp[lev].size() << " float\n";
		for (uint i = 0; i<hcp[lev].size(); i++)
		{
			fout << hcp[lev][i].coor[0] << " " << hcp[lev][i].coor[1] << " " << hcp[lev][i].coor[2] << "\n";
		}
		fout << "\nCELLS " << hedge[lev].size() << " " << 3 * hedge[lev].size() << '\n';
		for (uint i = 0; i<hedge[lev].size(); i++)
		{
			fout << "2 ";
			for (int j = 0; j<2; j++)
			{
				fout << hedge[lev][i].pt[j] << ' ';
			}
			fout << '\n';
		}
		fout << "\nCELL_TYPES " << hedge[lev].size() << '\n';
		for (uint i = 0; i<hedge[lev].size(); i++)
		{
			fout << "3\n";
		}

		//fout << "POINT_DATA " << hcp[lev].size() << "\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<hcp[lev].size(); i++)
		//{
		//	fout << hcp[lev][i].sharp << "\n";
		//	//fout << hcp[lev][i].bcxp << "\n";
		//}
		fout << "\nCELL_DATA " << hedge[lev].size() << "\nSCALARS eact float 1\nLOOKUP_TABLE default\n";
		for (uint i = 0; i<hedge[lev].size(); i++)
		{
			fout << hedge[lev][i].sharp << "\n";
			//fout << hedge[lev][i].type << "\n";
		}

		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::OutputGeom(int lev, string fn)
{
	vector<array<double, 3>> spt;
	vector<array<double, 3>> sval;
	vector<double> ssum;
	vector<array<int, 8>> sele;
	vector<array<double, 3>> lpt;//visulize parameter lines
	vector<array<int, 2>> led;//line connectivity
	int ns(2), ne_ref(0), loc0, loc1, loc2;

	//for (uint lev = 0; lev < hmesh.size(); lev++)
	{
		for (uint eid = 0; eid < hmesh[lev].size(); eid++)
		{
			if (hmesh[lev][eid].act == 1 /*&& (hmesh[lev][eid].type == 0 || hmesh[lev][eid].type == 2)*/)
			{
				vector<double> su(ns), sv(ns), sw(ns);
				double ul[3] = { hmesh[lev][eid].dm[0][1] - hmesh[lev][eid].dm[0][0], hmesh[lev][eid].dm[1][1] - hmesh[lev][eid].dm[1][0], 
					hmesh[lev][eid].dm[2][1] - hmesh[lev][eid].dm[2][0]};
				for (int i = 0; i<ns; i++)
				{
					su[i] = i*ul[0] / (ns - 1) + hmesh[lev][eid].dm[0][0];
					sv[i] = i*ul[1] / (ns - 1) + hmesh[lev][eid].dm[1][0];
					sw[i] = i*ul[2] / (ns - 1) + hmesh[lev][eid].dm[2][0];
				}
				for (int a = 0; a<ns; a++)
				{
					for (int b = 0; b<ns; b++)
					{
						for (int c = 0; c < ns; c++)
						{
							array<double, 3> pt;
							array<double,3> uval = { su[c], sv[b], sw[a] };
							GeomMap(lev, eid, uval, pt);
							double sumtmp = BasisSum(lev, eid, uval);
							//GeomMap_Lev(lev, eid, uval, pt);
							//double sumtmp = BasisSum_Lev(lev, eid, uval);
							spt.push_back(pt);
							ssum.push_back(sumtmp);
							//if(a==0||a==ns-1||b==0||b==ns-1)
							//{
							//	lpt.push_back(pt);
							//}
						}
					}
				}

				for (int a = 0; a<ns - 1; a++)
				{
					for (int b = 0; b<ns - 1; b++)
					{
						for (int c = 0; c < ns - 1; c++)
						{
							array<int, 8> el;
							el[0] = ne_ref + a*ns*ns + b*ns + c;
							el[1] = ne_ref + a*ns*ns + b*ns + c + 1;
							el[2] = ne_ref + a*ns*ns + (b + 1)*ns + c + 1;
							el[3] = ne_ref + a*ns*ns + (b + 1)*ns + c;
							el[4] = ne_ref + (a + 1)*ns*ns + b*ns + c;
							el[5] = ne_ref + (a + 1)*ns*ns + b*ns + c + 1;
							el[6] = ne_ref + (a + 1)*ns*ns + (b + 1)*ns + c + 1;
							el[7] = ne_ref + (a + 1)*ns*ns + (b + 1)*ns + c;
							sele.push_back(el);
						}
					}
				}
				ne_ref += ns*ns*ns;
			}
		}
	}

	string fname = fn + ".vtk";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << spt.size() << " float\n";
		for (uint i = 0; i<spt.size(); i++)
		{
			fout << spt[i][0] << " " << spt[i][1] << " " << spt[i][2] << "\n";
		}
		fout << "\nCELLS " << sele.size() << " " << 9 * sele.size() << '\n';
		for (uint i = 0; i<sele.size(); i++)
		{
			fout << "8 " << sele[i][0] << " " << sele[i][1] << " " << sele[i][2] << " " << sele[i][3] << " " << sele[i][4] << " " << sele[i][5] << " " << sele[i][6] << " " << sele[i][7] << '\n';
		}
		fout << "\nCELL_TYPES " << sele.size() << '\n';
		for (uint i = 0; i<sele.size(); i++)
		{
			fout << "12\n";
		}
		fout << "\nPOINT_DATA " << ssum.size() << "\nSCALARS sum FLOAT\nLOOKUP_TABLE default\n";
		for (uint i = 0; i<ssum.size(); i++)
		{
			fout << ssum[i] << "\n";
		}
		//fout<<"\nPOINT_DATA "<<sval.size()<<"\nNORMALS Normal FLOAT\n";
		//for(uint i=0;i<sval.size();i++)
		//{
		//	fout<<sval[i][0]<<" "<<sval[i][1]<<" "<<sval[i][2]<<"\n";
		//}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::GeomMap(int lev, int eid, const array<double, 3>& u, array<double, 3>& pt)
{
	vector<double> Nt;
	vector<array<double, 3>> dNdt;
	//if (hmesh[lev][eid].type == 0)
	//{
	//	Basis_Regular(lev, eid, u, Nt, dNdt);
	//}
	//else if (hmesh[lev][eid].type == 2 || hmesh[lev][eid].type == 1)
	{
		Basis_Irregular(lev, eid, u, Nt, dNdt);
	}
	double sum(0.);
	for (uint i = 0; i < Nt.size(); i++)
	{
		sum += Nt[i];
	}
	pt[0] = 0.; pt[1] = 0.; pt[2] = 0.;
	if (hmesh[lev][eid].trun == 1)
	{
		for (uint i = 0; i < hmesh[lev][eid].IEN_act.size(); i++)
		{
			int lid(hmesh[lev][eid].IEN_act[i][0]);
			int pid(hmesh[lev][eid].IEN_act[i][1]);
			//pt[0] += Nt[i] * hcp[lid][pid].coor[0];
			//pt[1] += Nt[i] * hcp[lid][pid].coor[1];
			//pt[2] += Nt[i] * hcp[lid][pid].coor[2];
			double tmp(Nt[i] / sum);
			pt[0] += tmp * hcp[lid][pid].coor[0];
			pt[1] += tmp * hcp[lid][pid].coor[1];
			pt[2] += tmp * hcp[lid][pid].coor[2];
		}
	}
	else
	{
		for (uint i = 0; i < hmesh[lev][eid].IEN.size(); i++)
		{
			int pid(hmesh[lev][eid].IEN[i]);
			//pt[0] += Nt[i] * hcp[lev][pid].coor[0];
			//pt[1] += Nt[i] * hcp[lev][pid].coor[1];
			//pt[2] += Nt[i] * hcp[lev][pid].coor[2];
			double tmp(Nt[i] / sum);
			pt[0] += tmp * hcp[lev][pid].coor[0];
			pt[1] += tmp * hcp[lev][pid].coor[1];
			pt[2] += tmp * hcp[lev][pid].coor[2];
		}
	}
}

void TruncatedTspline_3D::GeomMap_Bezier(int lev, int eid, const array<double, 3>& u, array<double, 3>& pt)
{
	BezierElement3D bzel;
	vector<double> Bt;
	vector<array<double, 3>> dBdt;
	bzel.Basis(u[0], u[1], u[2], Bt, dBdt);
	pt[0] = 0.; pt[1] = 0.; pt[2] = 0.;
	for (int i = 0; i < 64; i++)
	{
		pt[0] += Bt[i] * hmesh[lev][eid].bzpt[i][0];
		pt[1] += Bt[i] * hmesh[lev][eid].bzpt[i][1];
		pt[2] += Bt[i] * hmesh[lev][eid].bzpt[i][2];
	}
}

void TruncatedTspline_3D::OutputGeom_All(string fn)
{
	vector<array<double, 3>> spt;
	vector<array<double, 3>> sval;
	vector<double> ssum;
	vector<array<int, 8>> sele;
	vector<array<double, 3>> lpt;//visulize parameter lines
	vector<array<int, 2>> led;//line connectivity
	int ns(2), ne_ref(0), loc0, loc1, loc2;

	for (uint lev = 0; lev < hmesh.size(); lev++)
	{
		for (uint eid = 0; eid < hmesh[lev].size(); eid++)
		{
			if (hmesh[lev][eid].act == 1 /*&& (hmesh[lev][eid].type == 1 || hmesh[lev][eid].type == 2)*/)
			{
				vector<double> su(ns), sv(ns), sw(ns);
				double ul[3] = { hmesh[lev][eid].dm[0][1] - hmesh[lev][eid].dm[0][0], hmesh[lev][eid].dm[1][1] - hmesh[lev][eid].dm[1][0],
					hmesh[lev][eid].dm[2][1] - hmesh[lev][eid].dm[2][0] };
				for (int i = 0; i<ns; i++)
				{
					su[i] = i*ul[0] / (ns - 1) + hmesh[lev][eid].dm[0][0];//maybe not useful
					sv[i] = i*ul[1] / (ns - 1) + hmesh[lev][eid].dm[1][0];
					sw[i] = i*ul[2] / (ns - 1) + hmesh[lev][eid].dm[2][0];
				}
				for (int a = 0; a<ns; a++)
				{
					for (int b = 0; b<ns; b++)
					{
						for (int c = 0; c < ns; c++)
						{
							array<double, 3> pt;
							array<double, 3> uval = { su[c], sv[b], sw[a] };
							GeomMap(lev, eid, uval, pt);
							//GeomMap_Bezier(lev, eid, uval, pt);
							double sumtmp = BasisSum(lev, eid, uval);
							//GeomMap_Lev(lev, eid, uval, pt);
							//double sumtmp = BasisSum_Lev(lev, eid, uval);
							spt.push_back(pt);
							ssum.push_back(sumtmp);
							//if(a==0||a==ns-1||b==0||b==ns-1)
							//{
							//	lpt.push_back(pt);
							//}
						}
					}
				}

				for (int a = 0; a<ns - 1; a++)
				{
					for (int b = 0; b<ns - 1; b++)
					{
						for (int c = 0; c < ns - 1; c++)
						{
							array<int, 8> el;
							el[0] = ne_ref + a*ns*ns + b*ns + c;
							el[1] = ne_ref + a*ns*ns + b*ns + c + 1;
							el[2] = ne_ref + a*ns*ns + (b + 1)*ns + c + 1;
							el[3] = ne_ref + a*ns*ns + (b + 1)*ns + c;
							el[4] = ne_ref + (a + 1)*ns*ns + b*ns + c;
							el[5] = ne_ref + (a + 1)*ns*ns + b*ns + c + 1;
							el[6] = ne_ref + (a + 1)*ns*ns + (b + 1)*ns + c + 1;
							el[7] = ne_ref + (a + 1)*ns*ns + (b + 1)*ns + c;
							sele.push_back(el);
						}
					}
				}
				ne_ref += ns*ns*ns;
			}
		}
	}

	string fname = fn + "_geom.vtk";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << spt.size() << " float\n";
		for (uint i = 0; i<spt.size(); i++)
		{
			fout << spt[i][0] << " " << spt[i][1] << " " << spt[i][2] << "\n";
		}
		fout << "\nCELLS " << sele.size() << " " << 9 * sele.size() << '\n';
		for (uint i = 0; i<sele.size(); i++)
		{
			fout << "8 " << sele[i][0] << " " << sele[i][1] << " " << sele[i][2] << " " << sele[i][3] << " " << sele[i][4] << " " << sele[i][5] << " " << sele[i][6] << " " << sele[i][7] << '\n';
		}
		fout << "\nCELL_TYPES " << sele.size() << '\n';
		for (uint i = 0; i<sele.size(); i++)
		{
			fout << "12\n";
		}
		fout << "\nPOINT_DATA " << ssum.size() << "\nSCALARS sum FLOAT\nLOOKUP_TABLE default\n";
		for (uint i = 0; i<ssum.size(); i++)
		{
			fout << ssum[i] << "\n";
		}
		//fout<<"\nPOINT_DATA "<<sval.size()<<"\nNORMALS Normal FLOAT\n";
		//for(uint i=0;i<sval.size();i++)
		//{
		//	fout<<sval[i][0]<<" "<<sval[i][1]<<" "<<sval[i][2]<<"\n";
		//}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

double TruncatedTspline_3D::BasisSum(int lev, int eid, const array<double, 3>& u)
{
	vector<double> Nt;
	vector<array<double, 3>> dNdt;
	//if (hmesh[lev][eid].type == 0)
	//{
	//	Basis_Regular(lev, eid, u, Nt, dNdt);
	//}
	//else if (hmesh[lev][eid].type == 2 || hmesh[lev][eid].type == 1)
	{
		Basis_Irregular(lev, eid, u, Nt, dNdt);
	}
	double sum(0.);
	for (uint i = 0; i < Nt.size(); i++) sum += Nt[i];
	return sum;
}

void TruncatedTspline_3D::Basis_Regular_Lev(int lev, int eid, const array<double, 3>& u, vector<double>& Nt, vector<array<double, 3>>& dNdt)
{
	Nt.clear();
	dNdt.clear();
	Nt.resize(hmesh[lev][eid].IEN.size());
	dNdt.resize(hmesh[lev][eid].IEN.size());
	vector<double> ku(5, 0.), kv(5, 0.), kw(5, 0.), uval, vval, wval;
	BSplineBasis bu, bv, bw;
	for (uint i = 0; i < hmesh[lev][eid].IEN.size(); i++)
	{
		ku.assign(hmesh[lev][eid].patch_ku[i].begin(), hmesh[lev][eid].patch_ku[i].end());
		kv.assign(hmesh[lev][eid].patch_kv[i].begin(), hmesh[lev][eid].patch_kv[i].end());
		kw.assign(hmesh[lev][eid].patch_kw[i].begin(), hmesh[lev][eid].patch_kw[i].end());
		bu.Set(3, ku);
		bv.Set(3, kv);
		bw.Set(3, kw);
		bu.BasisFunction(0, u[0], 1, uval);
		bv.BasisFunction(0, u[1], 1, vval);
		bw.BasisFunction(0, u[2], 1, wval);
		Nt[i] = uval[0] * vval[0] * wval[0];
		dNdt[i][0] = uval[1] * vval[0] * wval[0];
		dNdt[i][1] = uval[0] * vval[1] * wval[0];
		dNdt[i][2] = uval[0] * vval[0] * wval[1];
	}
}

void TruncatedTspline_3D::Basis_Irregular_Lev(int lev, int eid, const array<double, 3>& u, vector<double>& Nt, vector<array<double, 3>>& dNdt)
{
	Nt.clear();
	dNdt.clear();
	Nt.resize(hmesh[lev][eid].IEN.size());
	dNdt.resize(hmesh[lev][eid].IEN.size());
	BezierElement3D bzel;
	vector<double> Bt;
	vector<array<double, 3>> dBdt;
	bzel.Basis(u[0], u[1], u[2], Bt, dBdt);
	for (uint i = 0; i < hmesh[lev][eid].IEN.size(); i++)
	{
		Nt[i] = 0.;
		dNdt[i][0] = 0.; dNdt[i][1] = 0.; dNdt[i][2] = 0.;
		for (uint j = 0; j < 64; j++)
		{
			Nt[i] += hmesh[lev][eid].bemat[i][j] * Bt[j];
			dNdt[i][0] += hmesh[lev][eid].bemat[i][j] * dBdt[j][0];
			dNdt[i][1] += hmesh[lev][eid].bemat[i][j] * dBdt[j][1];
			dNdt[i][2] += hmesh[lev][eid].bemat[i][j] * dBdt[j][2];
		}
	}
}

void TruncatedTspline_3D::GeomMap_Lev(int lev, int eid, const array<double, 3>& u, array<double, 3>& pt)
{
	vector<double> Nt;
	vector<array<double, 3>> dNdt;
	if (hmesh[lev][eid].type == 0)
	{
		Basis_Regular_Lev(lev, eid, u, Nt, dNdt);
	}
	else if (hmesh[lev][eid].type == 1)
	{
		Basis_Irregular_Lev(lev, eid, u, Nt, dNdt);
	}
	else if (hmesh[lev][eid].type == 2)
	{
		Basis_Irregular_Lev(lev, eid, u, Nt, dNdt);
	}
	pt[0] = 0.; pt[1] = 0.; pt[2] = 0.;
	for (uint i = 0; i < hmesh[lev][eid].IEN.size(); i++)
	{
		int pid(hmesh[lev][eid].IEN[i]);
		pt[0] += Nt[i] * hcp[lev][pid].coor[0];
		pt[1] += Nt[i] * hcp[lev][pid].coor[1];
		pt[2] += Nt[i] * hcp[lev][pid].coor[2];
	}
}

double TruncatedTspline_3D::BasisSum_Lev(int lev, int eid, const array<double, 3>& u)
{
	vector<double> Nt;
	vector<array<double, 3>> dNdt;
	if (hmesh[lev][eid].type == 0)
	{
		Basis_Regular_Lev(lev, eid, u, Nt, dNdt);
	}
	else if (hmesh[lev][eid].type == 1)
	{
		Basis_Irregular_Lev(lev, eid, u, Nt, dNdt);
	}
	else if (hmesh[lev][eid].type == 2)
	{
		Basis_Irregular_Lev(lev, eid, u, Nt, dNdt);
	}
	double sum(0.);
	for (uint i = 0; i < Nt.size(); i++) sum += Nt[i];
	return sum;
}

void TruncatedTspline_3D::AllBezierLev(int lev)
{
	cout << "# elements: " << hmesh[lev].size() << "\n";
#pragma omp parallel for
	for (int i = 0; i < hmesh[lev].size(); i++)
	{
		if (i != 0 && i % 500 == 0)
		{
			cout << i << " ";
		}
		if (hmesh[lev][i].type != 1)
		{
			ConstructBezierBasis(lev, i);
		}
		else
		{
			ConstructBezierBasis_Boundary(lev, i);
		}
	}
	//for (int i = 0; i < hmesh[lev].size(); i++)
	//{
	//	if (hmesh[lev][i].act==1 && hmesh[lev][i].type != 1)
	//	{
	//		ConstructBezierBasis(lev,i);
	//	}
	//}
}

void TruncatedTspline_3D::AnalysisInterface_Elastic(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)//test, cube
{
	bzmesh.clear();
	IDBC.clear();
	gh.clear();
	double tmp(1.e6);
	double x_range[3][2] = { { tmp, -tmp }, { tmp, -tmp }, { tmp, -tmp } };
	uint i, j, k, k1;
	for (i = 0; i < hcp[0].size(); i++)
	{
		for (j = 0; j < 3; j++)
		{
			if (hcp[0][i].coor[j] < x_range[j][0]) x_range[j][0] = hcp[0][i].coor[j];
			if (hcp[0][i].coor[j] > x_range[j][1]) x_range[j][1] = hcp[0][i].coor[j];
		}
	}
	double xh[3] = { x_range[0][1] - x_range[0][0], x_range[1][1] - x_range[1][0], x_range[2][1] - x_range[2][0]};
	int loc(0);
	vector<vector<int>> aloc(hcp.size());
	for (i = 0; i < hcp.size(); i++)
	{
		aloc[i].resize(hcp[i].size(), -1);
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				aloc[i][j] = loc++;
			}
		}
	}
	IDBC.resize(3 * loc);
	gh.resize(3 * loc,0.);
	loc = 0;
	int count(0);
	for (i = 0; i < hcp.size(); i++)
	{
		//aloc[i].resize(hcp[i].size(), -1);
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				if (hcp[i][j].coor[0] == x_range[0][0])
				{
					IDBC[3 * loc] = -1;
				}
				else if (hcp[i][j].coor[0] == x_range[0][1])
				{
					IDBC[3 * loc] = -1; gh[3 * loc] = .1*xh[0];
				}
				else
				{
					IDBC[3 * loc] = count++;
				}
				if (hcp[i][j].coor[1] == x_range[1][0])
				{
					IDBC[3 * loc+1] = -1;
				}
				else
				{
					IDBC[3 * loc+1] = count++;
				}
				if (hcp[i][j].coor[2] == x_range[2][0])
				{
					IDBC[3 * loc + 2] = -1;
				}
				else
				{
					IDBC[3 * loc + 2] = count++;
				}
				loc++;
			}
		}
	}
	for (i = 0; i < hmesh.size(); i++)
	{
		for (j = 0; j < hmesh[i].size(); j++)
		{
			if (hmesh[i][j].act == 1 /*&& hmesh[i][j].type!=1*/)
			{
				BezierElement3D bztmp;
				if (hmesh[i][j].trun == 0)
				{
					bztmp.IEN.resize(hmesh[i][j].IEN.size());
					bztmp.cmat.resize(hmesh[i][j].IEN.size(), vector<double>(64));
					for (k = 0; k < hmesh[i][j].IEN.size(); k++)
					{
						bztmp.IEN[k] = aloc[i][hmesh[i][j].IEN[k]];
						for (k1 = 0; k1 < 64; k1++)
						{
							bztmp.cmat[k][k1] = hmesh[i][j].bemat[k][k1];
							bztmp.pts[k1][0] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[0];
							bztmp.pts[k1][1] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[1];
							bztmp.pts[k1][2] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[2];
						}
					}
				}
				else
				{
				}
				bzmesh.push_back(bztmp);
			}
		}
	}
}

void TruncatedTspline_3D::AnalysisInterface_Poisson(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	bzmesh.clear();
	IDBC.clear();
	gh.clear();
	double tmp(1.e6);
	double x_range[3][2] = { { tmp, -tmp }, { tmp, -tmp }, { tmp, -tmp } };
	uint i, j, k, k1, k2;
	for (i = 0; i < hcp[0].size(); i++)
	{
		for (j = 0; j < 3; j++)
		{
			if (hcp[0][i].coor[j] < x_range[j][0]) x_range[j][0] = hcp[0][i].coor[j];
			if (hcp[0][i].coor[j] > x_range[j][1]) x_range[j][1] = hcp[0][i].coor[j];
		}
	}
	double xh[3] = { x_range[0][1] - x_range[0][0], x_range[1][1] - x_range[1][0], x_range[2][1] - x_range[2][0] };
	int loc(0);
	vector<vector<int>> aloc(hcp.size());
	for (i = 0; i < hcp.size(); i++)
	{
		aloc[i].resize(hcp[i].size(), -1);
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				aloc[i][j] = loc++;
			}
		}
	}
	IDBC.resize(loc);
	gh.resize(loc, 0.);
	loc = 0;
	int count(0);
	for (i = 0; i < hcp.size(); i++)
	{
		//aloc[i].resize(hcp[i].size(), -1);
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				if (hcp[i][j].coor[0] == x_range[0][0] || hcp[i][j].coor[0] == x_range[0][1] ||
					hcp[i][j].coor[1] == x_range[1][0] || hcp[i][j].coor[1] == x_range[1][1] || 
					hcp[i][j].coor[2] == x_range[2][0] || hcp[i][j].coor[2] == x_range[2][1])
				{
					IDBC[loc] = -1;
					//gh[loc] = SpecifyDirichBC_2(hcp[i][j].coor);
					//gh[loc] = SpecifyDirichBC_3(hcp[i][j].coor);
					gh[loc] = SpecifyDirichBC_4(hcp[i][j].coor);
				}
				else
				{
					IDBC[loc] = count++;
				}
				loc++;
			}
		}
	}
	for (i = 0; i < hmesh.size(); i++)
	{
		for (j = 0; j < hmesh[i].size(); j++)
		{
			if (hmesh[i][j].act == 1 /*&& hmesh[i][j].type!=1*/)
			{
				BezierElement3D bztmp;
				bztmp.prt[0] = i; bztmp.prt[1] = j;
				bztmp.trun = hmesh[i][j].trun;

				for (k1 = 0; k1 < 64; k1++)
				{
					bztmp.pts[k1][0] = hmesh[i][j].bzpt[k1][0];
					bztmp.pts[k1][1] = hmesh[i][j].bzpt[k1][1];
					bztmp.pts[k1][2] = hmesh[i][j].bzpt[k1][2];
				}

				if (hmesh[i][j].trun == 0)
				{
					bztmp.IEN.resize(hmesh[i][j].IEN.size());
					bztmp.cmat.resize(hmesh[i][j].IEN.size(), vector<double>(64));
					for (k = 0; k < hmesh[i][j].IEN.size(); k++)
					{
						bztmp.IEN[k] = aloc[i][hmesh[i][j].IEN[k]];
						for (k1 = 0; k1 < 64; k1++)
						{
							bztmp.cmat[k][k1] = hmesh[i][j].bemat[k][k1];
							//bztmp.pts[k1][0] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[0];
							//bztmp.pts[k1][1] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[1];
							//bztmp.pts[k1][2] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[2];
						}
					}
				}
				else
				{
					bztmp.IEN.resize(hmesh[i][j].IEN_act.size());
					bztmp.cmat.resize(hmesh[i][j].IEN_act.size(), vector<double>(64));
					for (k = 0; k < hmesh[i][j].IEN_act.size(); k++)
					{
						int lev(hmesh[i][j].IEN_act[k][0]);
						int pid(hmesh[i][j].IEN_act[k][1]);
						if (aloc[lev][pid]==-1)
						{
							cout << "wrong aloc!\n";
							getchar();
						}
						bztmp.IEN[k] = aloc[lev][pid];
						for (k1 = 0; k1 < 64; k1++)
						{
							bztmp.cmat[k][k1] = 0.;
							for (k2 = 0; k2 < hmesh[i][j].IEN.size(); k2++)
							{
								bztmp.cmat[k][k1] += hmesh[i][j].tmat[k][k2] * hmesh[i][j].bemat[k2][k1];
							}
						}
					}
					//for (k = 0; k < hmesh[i][j].IEN.size(); k++)
					//{
					//	for (k1 = 0; k1 < 64; k1++)
					//	{
					//		bztmp.pts[k1][0] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[0];
					//		bztmp.pts[k1][1] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[1];
					//		bztmp.pts[k1][2] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[2];
					//	}
					//}
				}
				bzmesh.push_back(bztmp);
			}
		}
	}
}

void TruncatedTspline_3D::AnalysisInterface_Poisson_1(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	bzmesh.clear();
	IDBC.clear();
	gh.clear();
	//int i, j, k, k1, k2;
	int loc(0);
	vector<vector<int>> aloc(hcp.size());
	for (uint i = 0; i < hcp.size(); i++)
	{
		aloc[i].resize(hcp[i].size(), -1);
		for (uint j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				aloc[i][j] = loc++;
			}
		}
	}
	FittingBC(IDBC, gh);
	cout << "Bezier extracting...\n";
	//cout << "# Bezier: " << hmesh[0].size() << "\n";
	vector<array<int, 2>> eact;
	for (uint i = 0; i < hmesh.size(); i++)
	{
		for (uint j = 0; j < hmesh[i].size(); j++)
		{
			if (hmesh[i][j].act == 1)
			{
				array<int, 2> tmp = { i, j };
				eact.push_back(tmp);
			}
		}
	}
	bzmesh.resize(eact.size());
//#pragma omp parallel for
	//for (int i = 0; i < hmesh.size(); i++)
	{
		//for (int j = 0; j < hmesh[i].size(); j++)
#pragma omp parallel for
		for (int eid = 0; eid < eact.size(); eid++)
		{
			int i(eact[eid][0]), j(eact[eid][1]);
			//if (hmesh[i][j].act == 1)
			{
				if (eid != 0 && eid % 500 == 0)
				{
					cout << eid << " ";
				}
				double tmp;
				//BezierElement3D bztmp;
				bzmesh[eid].prt[0] = i; bzmesh[eid].prt[1] = j;
				bzmesh[eid].trun = hmesh[i][j].trun;
				if (hmesh[i][j].type == 1) bzmesh[eid].type = 1;
				if (hmesh[i][j].trun == 0)
				{
					bzmesh[eid].IEN.resize(hmesh[i][j].IEN.size());
					bzmesh[eid].cmat.resize(hmesh[i][j].IEN.size(), vector<double>(64));
					for (uint k = 0; k < hmesh[i][j].IEN.size(); k++)
					{
						bzmesh[eid].IEN[k] = aloc[i][hmesh[i][j].IEN[k]];
						for (int k1 = 0; k1 < 64; k1++)
						{
							tmp = hmesh[i][j].bemat[k][k1];
							bzmesh[eid].cmat[k][k1] = tmp;
							bzmesh[eid].pts[k1][0] += tmp * hcp[i][hmesh[i][j].IEN[k]].coor[0];
							bzmesh[eid].pts[k1][1] += tmp * hcp[i][hmesh[i][j].IEN[k]].coor[1];
							bzmesh[eid].pts[k1][2] += tmp * hcp[i][hmesh[i][j].IEN[k]].coor[2];
						}
					}
				}
				else
				{
					bzmesh[eid].IEN.resize(hmesh[i][j].IEN_act.size());
					bzmesh[eid].cmat.resize(hmesh[i][j].IEN_act.size(), vector<double>(64));
					for (int k = 0; k < hmesh[i][j].IEN_act.size(); k++)
					{
						int lev(hmesh[i][j].IEN_act[k][0]);
						int pid(hmesh[i][j].IEN_act[k][1]);
						if (aloc[lev][pid] == -1)
						{
							cout << "wrong aloc!\n";
							getchar();
						}
						bzmesh[eid].IEN[k] = aloc[lev][pid];
						for (int k1 = 0; k1 < 64; k1++)
						{
							bzmesh[eid].cmat[k][k1] = 0.;
							for (int k2 = 0; k2 < hmesh[i][j].IEN.size(); k2++)
							{
								bzmesh[eid].cmat[k][k1] += hmesh[i][j].tmat[k][k2] * hmesh[i][j].bemat[k2][k1];
							}
						}
					}
					for (int k = 0; k < hmesh[i][j].IEN.size(); k++)
					{
						for (int k1 = 0; k1 < 64; k1++)
						{
							tmp = hmesh[i][j].bemat[k][k1];
							bzmesh[eid].pts[k1][0] += tmp * hcp[i][hmesh[i][j].IEN[k]].coor[0];
							bzmesh[eid].pts[k1][1] += tmp * hcp[i][hmesh[i][j].IEN[k]].coor[1];
							bzmesh[eid].pts[k1][2] += tmp * hcp[i][hmesh[i][j].IEN[k]].coor[2];
						}
					}
				}
				//bzmesh.push_back(bztmp);
			}
		}
	}
}

void TruncatedTspline_3D::AnalysisInterface_Laplace(const vector<array<int, 2>>& pbc, const vector<double>& pdisp, vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	bzmesh.clear();
	IDBC.clear();
	gh.clear();
	uint i, j, k, k1, k2;
	int loc(0);
	vector<vector<int>> aloc(hcp.size());
	for (i = 0; i < hcp.size(); i++)
	{
		aloc[i].resize(hcp[i].size(), -1);
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				aloc[i][j] = loc++;
			}
		}
	}
	IDBC.resize(loc);
	gh.resize(loc, 0.);
	loc = 0;
	int count(0);
	for (i = 0; i < hcp.size(); i++)
	{
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				array<int, 2> ptmp = { i, j };
				vector<array<int, 2>>::const_iterator it = find(pbc.begin(), pbc.end(), ptmp);
				if (it != pbc.end())
				{
					IDBC[loc] = -1;
					gh[loc] = pdisp[it - pbc.begin()];
					//cout << gh[loc] << "\n";
					//getchar();
				}
				else
				{
					IDBC[loc] = count++;
				}
				loc++;
			}
		}
	}
	for (i = 0; i < hmesh.size(); i++)
	{
		for (j = 0; j < hmesh[i].size(); j++)
		{
			if (hmesh[i][j].act == 1 /*&& hmesh[i][j].type!=1*/)
			{
				BezierElement3D bztmp;
				bztmp.prt[0] = i; bztmp.prt[1] = j;
				bztmp.trun = hmesh[i][j].trun;
				if (hmesh[i][j].type == 1) bztmp.type = 1;
				if (hmesh[i][j].trun == 0)
				{
					bztmp.IEN.resize(hmesh[i][j].IEN.size());
					bztmp.cmat.resize(hmesh[i][j].IEN.size(), vector<double>(64));
					for (k = 0; k < hmesh[i][j].IEN.size(); k++)
					{
						bztmp.IEN[k] = aloc[i][hmesh[i][j].IEN[k]];
						for (k1 = 0; k1 < 64; k1++)
						{
							bztmp.cmat[k][k1] = hmesh[i][j].bemat[k][k1];
							bztmp.pts[k1][0] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[0];
							bztmp.pts[k1][1] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[1];
							bztmp.pts[k1][2] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[2];
						}
					}
				}
				else
				{
					bztmp.IEN.resize(hmesh[i][j].IEN_act.size());
					bztmp.cmat.resize(hmesh[i][j].IEN_act.size(), vector<double>(64));
					for (k = 0; k < hmesh[i][j].IEN_act.size(); k++)
					{
						int lev(hmesh[i][j].IEN_act[k][0]);
						int pid(hmesh[i][j].IEN_act[k][1]);
						if (aloc[lev][pid] == -1)
						{
							cout << "wrong aloc!\n";
							getchar();
						}
						bztmp.IEN[k] = aloc[lev][pid];
						for (k1 = 0; k1 < 64; k1++)
						{
							bztmp.cmat[k][k1] = 0.;
							for (k2 = 0; k2 < hmesh[i][j].IEN.size(); k2++)
							{
								bztmp.cmat[k][k1] += hmesh[i][j].tmat[k][k2] * hmesh[i][j].bemat[k2][k1];
							}
						}
					}
					for (k = 0; k < hmesh[i][j].IEN.size(); k++)
					{
						for (k1 = 0; k1 < 64; k1++)
						{
							bztmp.pts[k1][0] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[0];
							bztmp.pts[k1][1] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[1];
							bztmp.pts[k1][2] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[2];
						}
					}
				}
				bzmesh.push_back(bztmp);
			}
		}
	}
}

void TruncatedTspline_3D::AnalysisInterface_LeastSquare(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	bzmesh.clear();
	IDBC.clear();
	gh.clear();
	double tmp(1.e6);
	double x_range[3][2] = { { tmp, -tmp }, { tmp, -tmp }, { tmp, -tmp } };
	uint i, j, k, k1, k2;
	for (i = 0; i < hcp[0].size(); i++)
	{
		for (j = 0; j < 3; j++)
		{
			if (hcp[0][i].coor[j] < x_range[j][0]) x_range[j][0] = hcp[0][i].coor[j];
			if (hcp[0][i].coor[j] > x_range[j][1]) x_range[j][1] = hcp[0][i].coor[j];
		}
	}
	double xh[3] = { x_range[0][1] - x_range[0][0], x_range[1][1] - x_range[1][0], x_range[2][1] - x_range[2][0] };
	int loc(0);
	vector<vector<int>> aloc(hcp.size());
	for (i = 0; i < hcp.size(); i++)
	{
		aloc[i].resize(hcp[i].size(), -1);
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				aloc[i][j] = loc++;
			}
		}
	}
	IDBC.resize(loc);
	gh.resize(loc, 0.);
	loc = 0;
	int count(0);
	for (i = 0; i < hcp.size(); i++)
	{
		//aloc[i].resize(hcp[i].size(), -1);
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				//if (hcp[i][j].coor[0] == x_range[0][0] || hcp[i][j].coor[0] == x_range[0][1] ||
				//	hcp[i][j].coor[1] == x_range[1][0] || hcp[i][j].coor[1] == x_range[1][1] ||
				//	hcp[i][j].coor[2] == x_range[2][0] || hcp[i][j].coor[2] == x_range[2][1])
				//{
				//	IDBC[loc] = -1;
				//	//gh[loc] = SpecifyDirichBC_2(hcp[i][j].coor);
				//	//gh[loc] = SpecifyDirichBC_3(hcp[i][j].coor);
				//	gh[loc] = SpecifyDirichBC_4(hcp[i][j].coor);
				//}
				//else
				//{
					IDBC[loc] = count++;
				//}
				loc++;
			}
		}
	}
	for (i = 0; i < hmesh.size(); i++)
	{
		for (j = 0; j < hmesh[i].size(); j++)
		{
			if (hmesh[i][j].act == 1 /*&& hmesh[i][j].type!=1*/)
			{
				BezierElement3D bztmp;
				bztmp.prt[0] = i; bztmp.prt[1] = j;
				bztmp.trun = hmesh[i][j].trun;

				for (k1 = 0; k1 < 64; k1++)
				{
					bztmp.pts[k1][0] = hmesh[i][j].bzpt[k1][0];
					bztmp.pts[k1][1] = hmesh[i][j].bzpt[k1][1];
					bztmp.pts[k1][2] = hmesh[i][j].bzpt[k1][2];
				}

				if (hmesh[i][j].trun == 0)
				{
					bztmp.IEN.resize(hmesh[i][j].IEN.size());
					bztmp.cmat.resize(hmesh[i][j].IEN.size(), vector<double>(64));
					for (k = 0; k < hmesh[i][j].IEN.size(); k++)
					{
						bztmp.IEN[k] = aloc[i][hmesh[i][j].IEN[k]];
						for (k1 = 0; k1 < 64; k1++)
						{
							bztmp.cmat[k][k1] = hmesh[i][j].bemat[k][k1];
							//bztmp.pts[k1][0] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[0];
							//bztmp.pts[k1][1] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[1];
							//bztmp.pts[k1][2] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[2];
						}
					}
				}
				else
				{
					bztmp.IEN.resize(hmesh[i][j].IEN_act.size());
					bztmp.cmat.resize(hmesh[i][j].IEN_act.size(), vector<double>(64));
					for (k = 0; k < hmesh[i][j].IEN_act.size(); k++)
					{
						int lev(hmesh[i][j].IEN_act[k][0]);
						int pid(hmesh[i][j].IEN_act[k][1]);
						if (aloc[lev][pid] == -1)
						{
							cout << "wrong aloc!\n";
							getchar();
						}
						bztmp.IEN[k] = aloc[lev][pid];
						for (k1 = 0; k1 < 64; k1++)
						{
							bztmp.cmat[k][k1] = 0.;
							for (k2 = 0; k2 < hmesh[i][j].IEN.size(); k2++)
							{
								bztmp.cmat[k][k1] += hmesh[i][j].tmat[k][k2] * hmesh[i][j].bemat[k2][k1];
							}
						}
					}
					//for (k = 0; k < hmesh[i][j].IEN.size(); k++)
					//{
					//	for (k1 = 0; k1 < 64; k1++)
					//	{
					//		bztmp.pts[k1][0] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[0];
					//		bztmp.pts[k1][1] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[1];
					//		bztmp.pts[k1][2] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[2];
					//	}
					//}
				}
				bzmesh.push_back(bztmp);
			}
		}
	}
}

double TruncatedTspline_3D::SpecifyDirichBC(double x[3])
{
	//double tmp1 = SpecifyDirichBC_5(x);
	//double tmp1 = SpecifyDirichBC_6(x);
	//double tmp1 = SpecifyDirichBC_7(x);
	//double tmp1 = SpecifyDirichBC_8(x);
	double tmp1 = SpecifyDirichBC_9(x);
	return tmp1;
}

double TruncatedTspline_3D::SpecifyDirichBC_2(double x[3])
{
	double tmp1 = 1. / exp((20.*x[0] - 7.)*(20.*x[0] - 7.) + (20.*x[1] - 7.)*(20.*x[1] - 7.) + (20.*x[2] - 7.)*(20.*x[2] - 7.));
	double tmp2 = 1. / exp((20.*x[0] - 13.)*(20.*x[0] - 13.) + (20.*x[1] - 13.)*(20.*x[1] - 13.) + (20.*x[2] - 13.)*(20.*x[2] - 13.));
	return 2.*(tmp1 + tmp2) / 3.;
}

double TruncatedTspline_3D::SpecifyDirichBC_3(double x[3])
{
	return 2./(3.*exp((20.*x[0] - 10.)*(20.*x[0] - 10.) + (20.*x[1] - 10.)*(20.*x[1] - 10.) + (20.*x[2] - 10.)*(20.*x[2] - 10.)));
}

double TruncatedTspline_3D::SpecifyDirichBC_4(double x[3])
{
	return tanh(1. - 50.*(-0.408248*x[0] - 0.408248*x[1] + 0.816497*x[2]));
}

double TruncatedTspline_3D::SpecifyDirichBC_5(double x[3])
{
	return (x[0] * x[0] + x[1] * x[1] + x[2] * x[2])*(x[0] + x[1] + x[2]) + x[0] * x[1] * x[2];
}

double TruncatedTspline_3D::SpecifyDirichBC_6(double x[3])
{
	return x[0] * (1. - x[0])*x[1] * (1. - x[1])*x[2] * (1. - x[2]);
}

double TruncatedTspline_3D::SpecifyDirichBC_7(double x[3])
{
	double x1[3] = { (x[0] - dmrg[0][0]), (x[1] - dmrg[1][0]), (x[2] - dmrg[2][0]) };
	return tanh(acoef*(nmpl[0] * x1[0] + nmpl[1] * x1[1] + nmpl[2] * x1[2]));
}

double TruncatedTspline_3D::SpecifyDirichBC_8(double x[3])
{
	double x1[3] = { (x[0] - dmrg[0][0]) / dmlen[0], (x[1] - dmrg[1][0]) / dmlen[1], (x[2] - dmrg[2][0]) / dmlen[2] };
	return 1. / exp(acoef*((x1[0] - nmpl[0])*(x1[0] - nmpl[0]) + (x1[1] - nmpl[1])*(x1[1] - nmpl[1]) + (x1[2] - nmpl[2])*(x1[2] - nmpl[2])));
}

double TruncatedTspline_3D::SpecifyDirichBC_9(double x[3])
{
	double PI(3.141592654);
	return sin(PI*x[0]) * sin(PI*x[1]) * sin(PI*x[2]);
}

void TruncatedTspline_3D::Identify_Poisson(const vector<array<double, 2>>& eh, const vector<double>& err, vector<array<int, 2>>& rfid, vector<array<int, 2>>& gst)
{
	uint i, j, k;
	vector<vector<double>> err_bf(hcp.size());
	for (i = 0; i < hcp.size(); i++)
	{
		err_bf[i].resize(hcp[i].size(),0.);
	}
	for (i = 0; i < eh.size(); i++)
	{
		if (hmesh[eh[i][0]][eh[i][1]].trun == 0)
		{
			for (j = 0; j < hmesh[eh[i][0]][eh[i][1]].IEN.size(); j++)
			{
				err_bf[eh[i][0]][hmesh[eh[i][0]][eh[i][1]].IEN[j]] += err[i];
			}
		}
		else
		{
			for (j = 0; j < hmesh[eh[i][0]][eh[i][1]].IEN_act.size(); j++)
			{
				int tmp[2] = { hmesh[eh[i][0]][eh[i][1]].IEN_act[j][0], hmesh[eh[i][0]][eh[i][1]].IEN_act[j][1] };
				err_bf[tmp[0]][tmp[1]] += err[i];
			}
		}
	}
	double err_max(0.);
	for (i = 0; i < hcp.size(); i++)
	{
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				if (err_bf[i][j]>err_max) err_max = err_bf[i][j];
			}
		}
	}
	double eta(0.7);
	double tol(eta*err_max);
	vector<array<int, 2>> rf_pid;
	for (i = 0; i < hcp.size(); i++)
	{
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				if (err_bf[i][j]>tol)
				{
					array<int, 2> rftmp = { i, j };
					rf_pid.push_back(rftmp);
				}
			}
		}
	}
	rfid.clear();
	gst.clear();
	for (i = 0; i < rf_pid.size(); i++)
	{
		//check support, refine 1-ring as long as 1-ring elements are at the same level
		for (j = 0; j < hcp[rf_pid[i][0]][rf_pid[i][1]].hex.size(); j++)
		{
			if (hmesh[rf_pid[i][0]][hcp[rf_pid[i][0]][rf_pid[i][1]].hex[j]].act == 1)
			{
				array<int, 2> tmp = { rf_pid[i][0], hcp[rf_pid[i][0]][rf_pid[i][1]].hex[j] };
				vector<array<int, 2>>::iterator it = find(rfid.begin(), rfid.end(), tmp);
				if (it == rfid.end())
					rfid.push_back(tmp);
			}
		}
	}
	//cout << "Max error: "<< err_max << "\n";
	//cout << "# of pid: " << rf_pid.size() << "\n";
	//cout << "# of rfid: " << rfid.size() << "\n";
	//getchar();
	for (i = 0; i < rfid.size(); i++)
	{
		int lev(rfid[i][0]);
		for (j = 0; j < 8; j++)
		{
			int pt(hmesh[lev][rfid[i][1]].cnct[j]);
			for (k = 0; k < hcp[lev][pt].hex.size(); k++)
			{
				if (hmesh[lev][hcp[lev][pt].hex[k]].chd.size() == 0)
				{
					array<int, 2> tmp = { lev, hcp[lev][pt].hex[k] };
					vector<array<int, 2>>::iterator it1 = find(gst.begin(), gst.end(), tmp);
					vector<array<int, 2>>::iterator it2 = find(rfid.begin(), rfid.end(), tmp);
					if (it1 == gst.end() && it2 == rfid.end())
					{
						gst.push_back(tmp);
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::Identify_Poisson_1(const vector<array<double, 2>>& eh, const vector<double>& err, vector<array<int, 2>>& rfid, vector<array<int, 2>>& gst)
{
	uint i, j, k;
	vector<vector<double>> err_bf(hcp.size());
	for (i = 0; i < hcp.size(); i++)
	{
		err_bf[i].resize(hcp[i].size(), 0.);
	}
	for (i = 0; i < eh.size(); i++)
	{
		if (hmesh[eh[i][0]][eh[i][1]].trun == 0)
		{
			for (j = 0; j < hmesh[eh[i][0]][eh[i][1]].IEN.size(); j++)
			{
				err_bf[eh[i][0]][hmesh[eh[i][0]][eh[i][1]].IEN[j]] += err[i];
			}
		}
		else
		{
			for (j = 0; j < hmesh[eh[i][0]][eh[i][1]].IEN_act.size(); j++)
			{
				int tmp[2] = { hmesh[eh[i][0]][eh[i][1]].IEN_act[j][0], hmesh[eh[i][0]][eh[i][1]].IEN_act[j][1] };
				err_bf[tmp[0]][tmp[1]] += err[i];
			}
		}
	}
	double err_max(0.);
	for (i = 0; i < hcp.size(); i++)
	{
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				if (err_bf[i][j]>err_max) err_max = err_bf[i][j];
			}
		}
	}
	//double eta(0.7);//hook
	double eta(0.3);//base, head
	//double eta(0.);//
	double tol(eta*err_max);
	vector<array<int, 2>> rf_pid;
	for (i = 0; i < hcp.size(); i++)
	{
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				if (err_bf[i][j]>tol)
				{
					array<int, 2> rftmp = { i, j };
					rf_pid.push_back(rftmp);
				}
			}
		}
	}
	rfid.clear();
	gst.clear();
	for (i = 0; i < rf_pid.size(); i++)
	{
		//check support, refine 1-ring as long as 1-ring elements are at the same level
		int ring1(0);
		for (j = 0; j < hcp[rf_pid[i][0]][rf_pid[i][1]].hex.size(); j++)
		{
			if (hmesh[rf_pid[i][0]][hcp[rf_pid[i][0]][rf_pid[i][1]].hex[j]].act == 1)
			{
				ring1 = 1;
				array<int, 2> tmp = { rf_pid[i][0], hcp[rf_pid[i][0]][rf_pid[i][1]].hex[j] };
				vector<array<int, 2>>::iterator it = find(rfid.begin(), rfid.end(), tmp);
				if (it == rfid.end())
					rfid.push_back(tmp);
			}
		}
		if (ring1 == 0)//new
		{
			for (j = 0; j < hcp[rf_pid[i][0]][rf_pid[i][1]].supp.size(); j++)
			{
				if (hmesh[rf_pid[i][0]][hcp[rf_pid[i][0]][rf_pid[i][1]].supp[j]].act == 1)
				{
					array<int, 2> tmp = { rf_pid[i][0], hcp[rf_pid[i][0]][rf_pid[i][1]].supp[j] };
					vector<array<int, 2>>::iterator it = find(rfid.begin(), rfid.end(), tmp);
					if (it == rfid.end())
						rfid.push_back(tmp);
				}
			}
		}
	}
	//cout << "Max error: "<< err_max << "\n";
	//cout << "# of pid: " << rf_pid.size() << "\n";
	cout << "# of rfid: " << rfid.size() << "\n";
	//getchar();
	for (i = 0; i < rfid.size(); i++)
	{
		int lev(rfid[i][0]);
		for (j = 0; j < 8; j++)
		{
			int pt(hmesh[lev][rfid[i][1]].cnct[j]);
			for (k = 0; k < hcp[lev][pt].hex.size(); k++)
			{
				if (hmesh[lev][hcp[lev][pt].hex[k]].chd.size() == 0)
				{
					array<int, 2> tmp = { lev, hcp[lev][pt].hex[k] };
					vector<array<int, 2>>::iterator it1 = find(gst.begin(), gst.end(), tmp);
					vector<array<int, 2>>::iterator it2 = find(rfid.begin(), rfid.end(), tmp);
					if (it1 == gst.end() && it2 == rfid.end())
					{
						gst.push_back(tmp);
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::Identify_Laplace(const vector<array<double, 2>>& eh, const vector<double>& err, vector<array<int, 2>>& rfid, vector<array<int, 2>>& gst)
{
	uint i, j, k;
	vector<vector<double>> err_bf(hcp.size());
	for (i = 0; i < hcp.size(); i++)
	{
		err_bf[i].resize(hcp[i].size(), 0.);
	}
	for (i = 0; i < eh.size(); i++)
	{
		if (hmesh[eh[i][0]][eh[i][1]].trun == 0)
		{
			for (j = 0; j < hmesh[eh[i][0]][eh[i][1]].IEN.size(); j++)
			{
				err_bf[eh[i][0]][hmesh[eh[i][0]][eh[i][1]].IEN[j]] += err[i];
			}
		}
		else
		{
			for (j = 0; j < hmesh[eh[i][0]][eh[i][1]].IEN_act.size(); j++)
			{
				int tmp[2] = { hmesh[eh[i][0]][eh[i][1]].IEN_act[j][0], hmesh[eh[i][0]][eh[i][1]].IEN_act[j][1] };
				err_bf[tmp[0]][tmp[1]] += err[i];
			}
		}
	}
	double err_max(0.);
	for (i = 0; i < hcp.size(); i++)
	{
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				if (err_bf[i][j]>err_max) err_max = err_bf[i][j];
			}
		}
	}
	double eta(0.5);
	double tol(eta*err_max);
	vector<array<int, 2>> rf_pid;
	for (i = 0; i < hcp.size(); i++)
	{
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				if (err_bf[i][j]>tol)
				{
					array<int, 2> rftmp = { i, j };
					rf_pid.push_back(rftmp);
				}
			}
		}
	}
	rfid.clear();
	gst.clear();
	for (i = 0; i < rf_pid.size(); i++)
	{
		//check support, refine 1-ring as long as 1-ring elements are at the same level
		int ring1(0);
		for (j = 0; j < hcp[rf_pid[i][0]][rf_pid[i][1]].hex.size(); j++)
		{
			if (hmesh[rf_pid[i][0]][hcp[rf_pid[i][0]][rf_pid[i][1]].hex[j]].act == 1)
			{
				ring1 = 1;
				array<int, 2> tmp = { rf_pid[i][0], hcp[rf_pid[i][0]][rf_pid[i][1]].hex[j] };
				vector<array<int, 2>>::iterator it = find(rfid.begin(), rfid.end(), tmp);
				if (it == rfid.end())
					rfid.push_back(tmp);
			}
		}
		if (ring1 == 0)//new
		{
			for (j = 0; j < hcp[rf_pid[i][0]][rf_pid[i][1]].supp.size(); j++)
			{
				if (hmesh[rf_pid[i][0]][hcp[rf_pid[i][0]][rf_pid[i][1]].supp[j]].act == 1)
				{
					array<int, 2> tmp = { rf_pid[i][0], hcp[rf_pid[i][0]][rf_pid[i][1]].supp[j] };
					vector<array<int, 2>>::iterator it = find(rfid.begin(), rfid.end(), tmp);
					if (it == rfid.end())
						rfid.push_back(tmp);
				}
			}
		}
	}
	//cout << "Max error: "<< err_max << "\n";
	//cout << "# of pid: " << rf_pid.size() << "\n";
	cout << "# of rfid: " << rfid.size() << "\n";
	//getchar();
	for (i = 0; i < rfid.size(); i++)
	{
		int lev(rfid[i][0]);
		for (j = 0; j < 8; j++)
		{
			int pt(hmesh[lev][rfid[i][1]].cnct[j]);
			for (k = 0; k < hcp[lev][pt].hex.size(); k++)
			{
				if (hmesh[lev][hcp[lev][pt].hex[k]].chd.size() == 0)
				{
					array<int, 2> tmp = { lev, hcp[lev][pt].hex[k] };
					vector<array<int, 2>>::iterator it1 = find(gst.begin(), gst.end(), tmp);
					vector<array<int, 2>>::iterator it2 = find(rfid.begin(), rfid.end(), tmp);
					if (it1 == gst.end() && it2 == rfid.end())
					{
						gst.push_back(tmp);
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::Identify_LeastSquare(vector<array<int, 2>>& rfid, vector<array<int, 2>>& gst)
{
	//identify a sphere
	uint i, j, k;
	double cent[3] = { .5, .5, .5 };
	//double r(0.15);
	double r(0.23);

	vector<array<int, 2>> rf_pid;
	for (i = 0; i < hcp.size(); i++)
	{
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				int flag(0);
				for (k = 0; k<hcp[i][j].hex.size(); k++)
				{
					int hxid(hcp[i][j].hex[k]);
					if (hmesh[i][hxid].act == 1)
					{
						int count(0);
						for (int k0 = 0; k0 < 8; k0++)
						{
							int pid = hmesh[i][hxid].cnct[k0];
							double dist = sqrt((hcp[i][pid].coor[0] - cent[0])*(hcp[i][pid].coor[0] - cent[0])
								+ (hcp[i][pid].coor[1] - cent[1])*(hcp[i][pid].coor[1] - cent[1]) + (hcp[i][pid].coor[2] - cent[2])*(hcp[i][pid].coor[2] - cent[2]));
							//cout << dist << "\n"; getchar();
							if (dist < r) count++;
						}
						if (count>0 && count < 8) flag = 1;
					}
				}
				if (flag==1)
				{
					array<int, 2> rftmp = { i, j };
					rf_pid.push_back(rftmp);
				}
			}
		}
	}

	rfid.clear();
	gst.clear();
	for (i = 0; i < rf_pid.size(); i++)
	{
		//check support, refine 1-ring as long as 1-ring elements are at the same level
		int ring1(0);
		for (j = 0; j < hcp[rf_pid[i][0]][rf_pid[i][1]].hex.size(); j++)
		{
			if (hmesh[rf_pid[i][0]][hcp[rf_pid[i][0]][rf_pid[i][1]].hex[j]].act == 1)
			{
				ring1 = 1;
				array<int, 2> tmp = { rf_pid[i][0], hcp[rf_pid[i][0]][rf_pid[i][1]].hex[j] };
				vector<array<int, 2>>::iterator it = find(rfid.begin(), rfid.end(), tmp);
				if (it == rfid.end())
					rfid.push_back(tmp);
			}
		}
		if (ring1 == 0)//new
		{
			for (j = 0; j < hcp[rf_pid[i][0]][rf_pid[i][1]].supp.size(); j++)
			{
				if (hmesh[rf_pid[i][0]][hcp[rf_pid[i][0]][rf_pid[i][1]].supp[j]].act == 1)
				{
					array<int, 2> tmp = { rf_pid[i][0], hcp[rf_pid[i][0]][rf_pid[i][1]].supp[j] };
					vector<array<int, 2>>::iterator it = find(rfid.begin(), rfid.end(), tmp);
					if (it == rfid.end())
						rfid.push_back(tmp);
				}
			}
		}
	}
	//cout << "Max error: "<< err_max << "\n";
	//cout << "# of pid: " << rf_pid.size() << "\n";
	cout << "# of rfid: " << rfid.size() << "\n";
	//getchar();
	for (i = 0; i < rfid.size(); i++)
	{
		int lev(rfid[i][0]);
		for (j = 0; j < 8; j++)
		{
			int pt(hmesh[lev][rfid[i][1]].cnct[j]);
			for (k = 0; k < hcp[lev][pt].hex.size(); k++)
			{
				if (hmesh[lev][hcp[lev][pt].hex[k]].chd.size() == 0)
				{
					array<int, 2> tmp = { lev, hcp[lev][pt].hex[k] };
					vector<array<int, 2>>::iterator it1 = find(gst.begin(), gst.end(), tmp);
					vector<array<int, 2>>::iterator it2 = find(rfid.begin(), rfid.end(), tmp);
					if (it1 == gst.end() && it2 == rfid.end())
					{
						gst.push_back(tmp);
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::Identify_LeastSquare_Line(vector<array<int, 2>>& rfid, vector<array<int, 2>>& gst)
{
	//identify a sphere
	uint i, j, k;

	vector<array<int, 2>> rf_pid;
	for (i = 0; i < hcp.size(); i++)
	{
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				int flag(0);
				for (k = 0; k<hcp[i][j].hex.size(); k++)
				{
					int hxid(hcp[i][j].hex[k]);
					if (hmesh[i][hxid].act == 1)
					{
						int count(0);
						double hxdm[3][2] = { { 1.e6, -1.e6 }, { 1.e6, -1.e6 }, { 1.e6, -1.e6 } };
						for (int k0 = 0; k0 < 8; k0++)
						{
							int pid = hmesh[i][hxid].cnct[k0];
							for (int k1 = 0; k1<3; k1++)
							{
								if (hcp[i][pid].coor[k1]<hxdm[k1][0]) hxdm[k1][0] = hcp[i][pid].coor[k1];
								if (hcp[i][pid].coor[k1]>hxdm[k1][1]) hxdm[k1][1] = hcp[i][pid].coor[k1];
							}
						}
						double a[4];
						a[0] = hxdm[0][0]>hxdm[1][0] ? hxdm[0][0] : hxdm[1][0];
						a[1] = hxdm[0][1]<hxdm[1][1] ? hxdm[0][1] : hxdm[1][1];
						if (a[0] < a[1])
						{
							a[2] = a[0]>hxdm[2][0] ? a[0] : hxdm[2][0];
							a[3] = a[1]<hxdm[2][1] ? a[1] : hxdm[2][1];
							if (a[2] < a[3]) flag = 1;
						}
					}
				}
				if (flag == 1)
				{
					array<int, 2> rftmp = { i, j };
					rf_pid.push_back(rftmp);
				}
			}
		}
	}

	rfid.clear();
	gst.clear();
	for (i = 0; i < rf_pid.size(); i++)
	{
		//check support, refine 1-ring as long as 1-ring elements are at the same level
		int ring1(0);
		for (j = 0; j < hcp[rf_pid[i][0]][rf_pid[i][1]].hex.size(); j++)
		{
			if (hmesh[rf_pid[i][0]][hcp[rf_pid[i][0]][rf_pid[i][1]].hex[j]].act == 1)
			{
				ring1 = 1;
				array<int, 2> tmp = { rf_pid[i][0], hcp[rf_pid[i][0]][rf_pid[i][1]].hex[j] };
				vector<array<int, 2>>::iterator it = find(rfid.begin(), rfid.end(), tmp);
				if (it == rfid.end())
					rfid.push_back(tmp);
			}
		}
		if (ring1 == 0)//new
		{
			for (j = 0; j < hcp[rf_pid[i][0]][rf_pid[i][1]].supp.size(); j++)
			{
				if (hmesh[rf_pid[i][0]][hcp[rf_pid[i][0]][rf_pid[i][1]].supp[j]].act == 1)
				{
					array<int, 2> tmp = { rf_pid[i][0], hcp[rf_pid[i][0]][rf_pid[i][1]].supp[j] };
					vector<array<int, 2>>::iterator it = find(rfid.begin(), rfid.end(), tmp);
					if (it == rfid.end())
						rfid.push_back(tmp);
				}
			}
		}
	}
	//cout << "Max error: "<< err_max << "\n";
	//cout << "# of pid: " << rf_pid.size() << "\n";
	cout << "# of rfid: " << rfid.size() << "\n";
	//getchar();
	for (i = 0; i < rfid.size(); i++)
	{
		int lev(rfid[i][0]);
		for (j = 0; j < 8; j++)
		{
			int pt(hmesh[lev][rfid[i][1]].cnct[j]);
			for (k = 0; k < hcp[lev][pt].hex.size(); k++)
			{
				if (hmesh[lev][hcp[lev][pt].hex[k]].chd.size() == 0)
				{
					array<int, 2> tmp = { lev, hcp[lev][pt].hex[k] };
					vector<array<int, 2>>::iterator it1 = find(gst.begin(), gst.end(), tmp);
					vector<array<int, 2>>::iterator it2 = find(rfid.begin(), rfid.end(), tmp);
					if (it1 == gst.end() && it2 == rfid.end())
					{
						gst.push_back(tmp);
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::OutputBasis(int lev, int pid, string fn)
{
	vector<array<double, 3>> spt;
	vector<array<double, 3>> sval;
	vector<double> ssum;
	vector<array<int, 8>> sele;
	vector<array<double, 3>> lpt;//visulize parameter lines
	vector<array<int, 2>> led;//line connectivity
	int ns(5), ne_ref(0), loc0, loc1, loc2;

	for (uint eid = 0; eid < hmesh[lev].size(); eid++)
	{
		if (hmesh[lev][eid].act == 1 /*&& (hmesh[lev][eid].type == 0 || hmesh[lev][eid].type == 2)*/)
		{
			vector<double> su(ns), sv(ns), sw(ns);
			double ul[3] = { hmesh[lev][eid].dm[0][1] - hmesh[lev][eid].dm[0][0], hmesh[lev][eid].dm[1][1] - hmesh[lev][eid].dm[1][0],
				hmesh[lev][eid].dm[2][1] - hmesh[lev][eid].dm[2][0] };
			for (int i = 0; i<ns; i++)
			{
				su[i] = i*ul[0] / (ns - 1) + hmesh[lev][eid].dm[0][0];
				sv[i] = i*ul[1] / (ns - 1) + hmesh[lev][eid].dm[1][0];
				sw[i] = i*ul[2] / (ns - 1) + hmesh[lev][eid].dm[2][0];
			}
			int pos(-1);
			vector<int>::iterator it = find(hmesh[lev][eid].IEN.begin(), hmesh[lev][eid].IEN.end(), pid);
			if (it != hmesh[lev][eid].IEN.end()) pos = it - hmesh[lev][eid].IEN.begin();
			for (int a = 0; a<ns; a++)
			{
				for (int b = 0; b<ns; b++)
				{
					for (int c = 0; c < ns; c++)
					{
						array<double, 3> pt;
						array<double, 3> uval = { su[c], sv[b], sw[a] };
						GeomMap(lev, eid, uval, pt);
						spt.push_back(pt);
						if (pos != -1)
						{
							vector<double> Nt;
							vector<array<double, 3>> dNdt;
							Basis_Irregular(lev, eid, uval, Nt, dNdt);
							ssum.push_back(Nt[pos]);
						}
						else
						{
							ssum.push_back(0.);
						}
					}
				}
			}

			for (int a = 0; a<ns - 1; a++)
			{
				for (int b = 0; b<ns - 1; b++)
				{
					for (int c = 0; c < ns - 1; c++)
					{
						array<int, 8> el;
						el[0] = ne_ref + a*ns*ns + b*ns + c;
						el[1] = ne_ref + a*ns*ns + b*ns + c + 1;
						el[2] = ne_ref + a*ns*ns + (b + 1)*ns + c + 1;
						el[3] = ne_ref + a*ns*ns + (b + 1)*ns + c;
						el[4] = ne_ref + (a + 1)*ns*ns + b*ns + c;
						el[5] = ne_ref + (a + 1)*ns*ns + b*ns + c + 1;
						el[6] = ne_ref + (a + 1)*ns*ns + (b + 1)*ns + c + 1;
						el[7] = ne_ref + (a + 1)*ns*ns + (b + 1)*ns + c;
						sele.push_back(el);
					}
				}
			}
			ne_ref += ns*ns*ns;
		}
	}

	string fname = fn + ".vtk";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << spt.size() << " float\n";
		for (uint i = 0; i<spt.size(); i++)
		{
			fout << spt[i][0] << " " << spt[i][1] << " " << spt[i][2] << "\n";
		}
		fout << "\nCELLS " << sele.size() << " " << 9 * sele.size() << '\n';
		for (uint i = 0; i<sele.size(); i++)
		{
			fout << "8 " << sele[i][0] << " " << sele[i][1] << " " << sele[i][2] << " " << sele[i][3] << " " << sele[i][4] << " " << sele[i][5] << " " << sele[i][6] << " " << sele[i][7] << '\n';
		}
		fout << "\nCELL_TYPES " << sele.size() << '\n';
		for (uint i = 0; i<sele.size(); i++)
		{
			fout << "12\n";
		}
		fout << "\nPOINT_DATA " << ssum.size() << "\nSCALARS sum FLOAT\nLOOKUP_TABLE default\n";
		for (uint i = 0; i<ssum.size(); i++)
		{
			fout << ssum[i] << "\n";
		}
		//fout<<"\nPOINT_DATA "<<sval.size()<<"\nNORMALS Normal FLOAT\n";
		//for(uint i=0;i<sval.size();i++)
		//{
		//	fout<<sval[i][0]<<" "<<sval[i][1]<<" "<<sval[i][2]<<"\n";
		//}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}

	//int lev(0);
	//for (uint i = 0; i < hmesh[lev].size(); i++)
	//{
	//	if (hmesh[lev][i].act == 1)
	//	{
	//		cout << "eid: " << i << "\n";
	//		for (uint j = 0; j < hmesh[lev][i].IEN.size(); j++)
	//		{
	//			cout << "pid: " << hmesh[lev][i].IEN[j] << "\n";
	//			for (uint k = 0; k < 64; k++)
	//			{
	//				cout << hmesh[lev][i].bemat[j][k] << " ";
	//			}
	//			cout << "\n";
	//			getchar();
	//		}
	//	}
	//}
}

void TruncatedTspline_3D::PillowCube(string fn)
{
	double tmp(1.e6);
	double x_range[3][2] = { { tmp, -tmp }, { tmp, -tmp }, { tmp, -tmp } };
	uint i, j, k;
	for (i = 0; i < cp.size(); i++)
	{
		for (j = 0; j < 3; j++)
		{
			if (cp[i].coor[j] < x_range[j][0]) x_range[j][0] = cp[i].coor[j];
			if (cp[i].coor[j] > x_range[j][1]) x_range[j][1] = cp[i].coor[j];
		}
	}
	double xh[3] = { x_range[0][1] - x_range[0][0], x_range[1][1] - x_range[1][0], x_range[2][1] - x_range[2][0] };
	int nplw(2);
	int nelx(2*nplw+1);
	int eid_del(nplw*nelx*nelx+nplw*nelx+nplw);
	double plw_h[3] = {xh[0]/nplw,xh[1]/nplw,xh[2]/nplw};
	vector<array<double, 3>> psm(nelx+1);
	for (i = 0; i <= nplw; i++)
	{
		for (j = 0; j < 3; j++)
		{
			psm[i][j] = x_range[j][0] - double(nplw - i)*plw_h[j];
			psm[i+nplw+1][j] = x_range[j][1] + double(i)*plw_h[j];
		}
	}

	int nsmp(nelx);
	int npt = (nsmp + 1)*(nsmp + 1)*(nsmp + 1);
	int nel = nsmp*nsmp*nsmp;
	vector<array<double, 3>> spt(npt);
	vector<array<int, 8>> sele0(nel);
	int loc(0);
	for (i = 0; i < nsmp + 1; i++)
	{
		for (j = 0; j < nsmp + 1; j++)
		{
			for (k = 0; k < nsmp + 1; k++)
			{
				spt[loc][0] = psm[k][0];
				spt[loc][1] = psm[j][1];
				spt[loc][2] = psm[i][2];
				loc++;
			}
		}
	}
	loc = 0;
	for (i = 0; i < nsmp; i++)
	{
		for (j = 0; j < nsmp; j++)
		{
			for (k = 0; k < nsmp; k++)
			{
				sele0[loc][0] = i*(nsmp + 1)*(nsmp + 1) + j*(nsmp + 1) + k;
				sele0[loc][1] = i*(nsmp + 1)*(nsmp + 1) + j*(nsmp + 1) + k + 1;
				sele0[loc][2] = i*(nsmp + 1)*(nsmp + 1) + (j + 1)*(nsmp + 1) + k + 1;
				sele0[loc][3] = i*(nsmp + 1)*(nsmp + 1) + (j + 1)*(nsmp + 1) + k;
				sele0[loc][4] = (i + 1)*(nsmp + 1)*(nsmp + 1) + j*(nsmp + 1) + k;
				sele0[loc][5] = (i + 1)*(nsmp + 1)*(nsmp + 1) + j*(nsmp + 1) + k + 1;
				sele0[loc][6] = (i + 1)*(nsmp + 1)*(nsmp + 1) + (j + 1)*(nsmp + 1) + k + 1;
				sele0[loc][7] = (i + 1)*(nsmp + 1)*(nsmp + 1) + (j + 1)*(nsmp + 1) + k;
				loc++;
			}
		}
	}
	vector<array<int, 8>> sele(nel-1+tmesh.size());
	loc = 0;
	for (i = 0; i < sele0.size(); i++)
	{
		if (i != eid_del)
		{
			for (j = 0; j < 8; j++) sele[loc][j] = sele0[i][j];
			loc++;
		}
	}
	vector<int> id_new(cp.size());
	for (i = 0; i < cp.size(); i++)
	{
		array<double, 3> tmp = { cp[i].coor[0], cp[i].coor[1], cp[i].coor[2] };
		vector<array<double, 3>>::iterator it = find(spt.begin(),spt.end(),tmp);
		id_new[i] = it - spt.begin();
		if (it == spt.end()) spt.push_back(tmp);
	}
	for (i = 0; i < tmesh.size(); i++)
	{
		for (j = 0; j < 8; j++) sele[loc][j] = id_new[tmesh[i].cnct[j]];
		loc++;
	}

	string fname = fn + ".vtk";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nCube hex test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << spt.size() << " float\n";
		for (uint i = 0; i<spt.size(); i++)
		{
			fout << spt[i][0] << " " << spt[i][1] << " " << spt[i][2] << "\n";
		}
		fout << "\nCELLS " << sele.size() << " " << 9 * sele.size() << '\n';
		for (uint i = 0; i<sele.size(); i++)
		{
			fout << "8 " << sele[i][0] << " " << sele[i][1] << " " << sele[i][2] << " " << sele[i][3] << " " << sele[i][4] << " " << sele[i][5] << " " << sele[i][6] << " " << sele[i][7] << '\n';
		}
		fout << "\nCELL_TYPES " << sele.size() << '\n';
		for (uint i = 0; i<sele.size(); i++)
		{
			fout << "12\n";
		}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::VisualizeBezier(const vector<BezierElement3D>& bzmesh, string fn)
{
	vector<array<int, 8>> cnct(bzmesh.size()*27);
	int loc(0);
	for (uint eid = 0; eid < bzmesh.size(); eid++)
	{
		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				for (int k = 0; k < 3; k++)
				{
					cnct[loc][0] = 64 * eid + 16 * i + 4 * j + k;
					cnct[loc][1] = 64 * eid + 16 * i + 4 * j + k+1;
					cnct[loc][2] = 64 * eid + 16 * i + 4 * (j+1) + k + 1;
					cnct[loc][3] = 64 * eid + 16 * i + 4 * (j + 1) + k;
					cnct[loc][4] = 64 * eid + 16 * (i+1) + 4 * j + k;
					cnct[loc][5] = 64 * eid + 16 * (i+1) + 4 * j + k + 1;
					cnct[loc][6] = 64 * eid + 16 * (i+1) + 4 * (j + 1) + k + 1;
					cnct[loc][7] = 64 * eid + 16 * (i+1) + 4 * (j + 1) + k;
					loc++;
				}
			}
		}
	}

	string fname = fn + "_bezier.vtk";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << 64*bzmesh.size() << " float\n";
		for (uint i = 0; i<bzmesh.size(); i++)
		{
			for (int j = 0; j < 64; j++)
				fout << bzmesh[i].pts[j][0] << " " << bzmesh[i].pts[j][1] << " " << bzmesh[i].pts[j][2] << "\n";
		}
		fout << "\nCELLS " << cnct.size() << " " << 9 * cnct.size() << '\n';
		for (uint i = 0; i<cnct.size(); i++)
		{
			fout << "8 " << cnct[i][0] << " " << cnct[i][1] << " " << cnct[i][2] << " " << cnct[i][3] << " " << cnct[i][4] << " " << cnct[i][5] << " " << cnct[i][6] << " " << cnct[i][7] << '\n';
		}
		fout << "\nCELL_TYPES " << cnct.size() << '\n';
		for (uint i = 0; i<cnct.size(); i++)
		{
			fout << "12\n";
		}
		//fout << "\nPOINT_DATA " << 64 * bzmesh.size() << "\nSCALARS sum FLOAT\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<bzmesh.size(); i++)
		//{
		//	for (int j = 0; j < 64; j++)
		//		fout << "1\n";
		//}
		//fout<<"\nPOINT_DATA "<<sval.size()<<"\nNORMALS Normal FLOAT\n";
		//for(uint i=0;i<sval.size();i++)
		//{
		//	fout<<sval[i][0]<<" "<<sval[i][1]<<" "<<sval[i][2]<<"\n";
		//}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::SetInitialBC(vector<array<int, 2>>& ebc, vector<double>& edisp, vector<array<int, 2>>& pbc, vector<double>& pdisp)
{
	//list of element
	//cube4
	//int nbc1(1), nbc2(1);
	//int bc1[] = { 20,24,36,40 };
	//int bc2[] = { 23,27,39,43 };
	//cube9
	//int nbc1(4), nbc2(4);
	//int bc1[] = { 679, 680, 688, 689 };
	//int bc2[] = { 40, 41, 49, 50 };
	//rod CAD model
	//int nbc1(10), nbc2(8);
	//int bc1[] = {1249,1250,1251,1252,1253,1257,1258,1259,1260,1261};
	//int bc2[] = { 775, 781, 783, 795, 801, 803, 853, 865 };
	//base CAD model
	//int nbc1(15), nbc2(16);
	//int bc1[] = { 8954,8972,8986,9086,9101,9118,9221,9236,9251,9345,9355,9370,9467,9480,9497 };
	//int bc2[] = { 7867,8095,8128,8212,8261,8301,8417,8426,8462,8495,8496,10181,10283,10364,10372,10439 };
	//cross hole CAD model
	//int nbc1(16), nbc2(16);
	//int bc1[] = { 2394,2395,2450,2451,2397,2396,2453,2452,2534,2535,2478,2479,2537,2536,2481,2480 };
	//int bc2[] = { 943,942,363,362,88,941,6,361,608,607,859,858,40,606,76,857 };
	//head model
	//int nbc1(9), nbc2(40);
	//int bc1[] = { 5579,5580,6077,5581,5582,6079,6281,6282,6553 };
	//int bc2[] = { 2658,2659,2684,2685,2686,4002,4003,4004,2655,2656,2681,2682,2683,3999,4000,4001,2283,2284,2309,2310,2311,3708,3709,3710,
	//	2280,2281,2306,2307,2308,3705,3706,3707,2277,2278,2303,2304,2305,3702,3703,3704 };
	//statue model
	int nbc1(41), nbc2(27);
	int bc1[] = { 11851,11852,11853,12181,12182,11906,11908,11910,12270,12272,11907,11909,11911,12271,12273,11897,11898,11899,12247,12248,
	11894,11887,11900,11901,11902,11903,11904,12249,12250,12252,12253,11888,11891,11892,12237,12238,11885,11889,11890,12235,12236};
	int bc2[] = { 9093,9094,9564,9565,9570,9572,9571,9096,9098,9567,9569,9578,9095,9097,9566,9568,9577,9103,9104,9582,9583,9588,9105,9107,9585,9587,9590 };
	//hook model
	//int nbc1(18), nbc2(29);
	//int bc1[] = { 5075,5077,5079,5074,5076,5078,5069,5070,5071,5059,5065,5067,5058,5064,5066,5054,5061,5063 };
	//int bc2[] = { 3612,3613,3610,3611,3766,3767,3764,3608,3609,3606,3607,3762,3763,3760,3603,3604,3601,3602,3718,3719,3715,3605,3600,3597,3598,3711,3712,3714,3717 };
	//gear model
	//int nbc1(33), nbc2(24);
	//int bc1[] = { 14589,14572,14571,14570,14569,14540,14539,14538,14534,14533,14532,14585,14568,14567,14566,14565,14537,14536,14535,14531,14530,14529,
	//14581,14564,14563,14562,14561,14528,14527,14526,14519,14518,14517};
	//int bc2[] = { 14344,14346,14345,11042,11043,11044,11048,11049,14347,14349,14348,11045,11046,11047,11050,11051,14357,14359,14358,11052,11053,11054,11058,11059 };

	ebc.clear();
	edisp.clear();
	pbc.clear();
	pdisp.clear();
	for (int i = 0; i < nbc1; i++)
	{
		array<int, 2> tmp1 = { 0, bc1[i] };
		ebc.push_back(tmp1);
		edisp.push_back(100.);
		for (int j = 0; j < 8; j++)
		{
			if (hcp[0][hmesh[0][bc1[i]].cnct[j]].type == 1)
			{
				int pid(hmesh[0][bc1[i]].cnct[j]);
				for (uint k = 0; k < hcp[0][pid].face.size(); k++)
				{
					if (hface[0][hcp[0][pid].face[k]].type == 1)
					{
						for (int k1 = 0; k1 < 4; k1++)
						{
							array<int, 2> tmp = { 0, hface[0][hcp[0][pid].face[k]].cnct[k1] };
							vector<array<int, 2>>::iterator it = find(pbc.begin(), pbc.end(), tmp);
							if (it == pbc.end())
							{
								pbc.push_back(tmp);
								pdisp.push_back(100.);
							}
						}
					}
				}
			}
		}
	}
	for (int i = 0; i < nbc2; i++)
	{
		array<int, 2> tmp1 = { 0, bc2[i] };
		ebc.push_back(tmp1);
		edisp.push_back(0.);
		for (int j = 0; j < 8; j++)
		{
			if (hcp[0][hmesh[0][bc2[i]].cnct[j]].type == 1)
			{
				int pid(hmesh[0][bc2[i]].cnct[j]);
				for (uint k = 0; k < hcp[0][pid].face.size(); k++)
				{
					if (hface[0][hcp[0][pid].face[k]].type == 1)
					{
						for (int k1 = 0; k1 < 4; k1++)
						{
							array<int, 2> tmp = { 0, hface[0][hcp[0][pid].face[k]].cnct[k1] };
							vector<array<int, 2>>::iterator it = find(pbc.begin(), pbc.end(), tmp);
							if (it == pbc.end())
							{
								pbc.push_back(tmp);
								pdisp.push_back(0.);
							}
						}
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::SetBC(vector<array<int, 2>>& ebc, vector<double>& edisp, vector<array<int, 2>>& pbc, vector<double>& pdisp)
{
	vector<array<int, 2>> ebc_new, pbc_new;
	vector<double> edisp_new, pdisp_new;
	for (uint i = 0; i < pbc.size(); i++)
	{
		if (hcp[pbc[i][0]][pbc[i][1]].act == 1)
		{
			pbc_new.push_back(pbc[i]);
			pdisp_new.push_back(pdisp[i]);
		}
	}
	for (uint i = 0; i < ebc.size(); i++)
	{
		if (hmesh[ebc[i][0]][ebc[i][1]].act == 1)
		{
			ebc_new.push_back(ebc[i]);
			edisp_new.push_back(edisp[i]);
		}
		else if (hmesh[ebc[i][0]][ebc[i][1]].act == 0)
		{
			for (uint k2 = 0; k2 < hmesh[ebc[i][0]][ebc[i][1]].chd.size(); k2++)
			{
				array<int, 2> eid = { ebc[i][0] + 1, hmesh[ebc[i][0]][ebc[i][1]].chd[k2] };
				if (hmesh[eid[0]][eid[1]].act == 1 && hmesh[eid[0]][eid[1]].type == 1)
				{
					ebc_new.push_back(eid);
					edisp_new.push_back(edisp[i]);
					for (int j = 0; j < 8; j++)
					{
						array<int, 2> pid1 = { eid[0], hmesh[eid[0]][eid[1]].cnct[j] };
						if (hcp[pid1[0]][pid1[1]].act == 1 && hcp[pid1[0]][pid1[1]].type == 1)
						{
							for (uint k = 0; k < hcp[pid1[0]][pid1[1]].face.size(); k++)
							{
								array<int, 2> fcid = { eid[0], hcp[pid1[0]][pid1[1]].face[k] };
								if (hface[fcid[0]][fcid[1]].type == 1)
								{
									for (int k1 = 0; k1 < 4; k1++)
									{
										array<int, 2> pid2 = { eid[0], hface[fcid[0]][fcid[1]].cnct[k1] };
										if (hcp[pid2[0]][pid2[1]].act == 1 && hcp[pid2[0]][pid2[1]].type == 1)
										{
											vector<array<int, 2>>::iterator it = find(pbc_new.begin(), pbc_new.end(), pid2);
											if (it == pbc_new.end())
											{
												pbc_new.push_back(pid2);
												pdisp_new.push_back(edisp[i]);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	ebc.clear();
	edisp.clear();
	pbc.clear();
	pdisp.clear();
	ebc = ebc_new;
	edisp = edisp_new;
	pbc = pbc_new;
	pdisp = pdisp_new;

	//cout << "pbc:\n";
	//for (uint i = 0; i < pbc.size(); i++)
	//{
	//	cout << pbc[i][1] << " " << pdisp[i] << "\n";
	//}
	//getchar();
}

void TruncatedTspline_3D::FittingBC(vector<int>& IDBC1, vector<double>& gh1)
{
	IDBC1.clear();
	gh1.clear();

	uint i, j, k, k1, k2;
	int loc(0);
	//boundary points
	vector<vector<int>> flag(hcp.size());
	for (i = 0; i < hcp.size(); i++)
	{
		flag[i].resize(hcp[i].size(), 0);
	}
	for (i = 0; i < hmesh.size(); i++)
	{
		for (j = 0; j < hmesh[i].size(); j++)
		{
			if (hmesh[i][j].act == 1 && hmesh[i][j].type == 1)
			{
				if (hmesh[i][j].trun == 0)
				{
					for (k = 0; k < hmesh[i][j].IEN.size(); k++)
					{
						flag[i][hmesh[i][j].IEN[k]] = 1;
					}
				}
				else
				{
					for (k = 0; k < hmesh[i][j].IEN_act.size(); k++)
					{
						flag[hmesh[i][j].IEN_act[k][0]][hmesh[i][j].IEN_act[k][1]] = 1;
					}
				}
			}
		}
	}

	vector<vector<int>> aloc(hcp.size());
	vector<array<double, 3>> cpts;
	loc = 0;
	for (i = 0; i < hcp.size(); i++)
	{
		aloc[i].resize(hcp[i].size(), -1);
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (flag[i][j] == 1)
			{
				aloc[i][j] = loc++;
				array<double, 3> tmp = { hcp[i][j].coor[0], hcp[i][j].coor[1], hcp[i][j].coor[2] };
				cpts.push_back(tmp);
			}
		}
	}
	vector<int> IDBC(loc, -1);
	vector<double> gh(loc, 0.);
	loc = 0;
	int count(0);
	for (i = 0; i < hcp.size(); i++)
	{
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (flag[i][j] == 1)
			{
				if (hcp[i][j].type == 1)
				{
					IDBC[loc] = count++;
				}
				loc++;
			}
		}
	}
	vector<BezierElement3D> bzmesh;
	for (i = 0; i < hmesh.size(); i++)
	{
		for (j = 0; j < hmesh[i].size(); j++)
		{
			if (hmesh[i][j].act == 1 && hmesh[i][j].type==1)
			{
				BezierElement3D bztmp;
				bztmp.prt[0] = i; bztmp.prt[1] = j;
				bztmp.trun = hmesh[i][j].trun;
				if (hmesh[i][j].type == 1) bztmp.type = 1;
				for (k = 0; k < 6; k++)
				{
					if (hface[i][hmesh[i][j].face[k]].type == 1)
					{
						bztmp.bfc.push_back(k);
					}
				}
				if (hmesh[i][j].trun == 0)
				{
					bztmp.IEN.resize(hmesh[i][j].IEN.size());
					bztmp.cmat.resize(hmesh[i][j].IEN.size(), vector<double>(64));
					for (k = 0; k < hmesh[i][j].IEN.size(); k++)
					{
						bztmp.IEN[k] = aloc[i][hmesh[i][j].IEN[k]];
						for (k1 = 0; k1 < 64; k1++)
						{
							bztmp.cmat[k][k1] = hmesh[i][j].bemat[k][k1];
							bztmp.pts[k1][0] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[0];
							bztmp.pts[k1][1] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[1];
							bztmp.pts[k1][2] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[2];
						}
					}
				}
				else
				{
					bztmp.IEN.resize(hmesh[i][j].IEN_act.size());
					bztmp.cmat.resize(hmesh[i][j].IEN_act.size(), vector<double>(64));
					for (k = 0; k < hmesh[i][j].IEN_act.size(); k++)
					{
						int lev(hmesh[i][j].IEN_act[k][0]);
						int pid(hmesh[i][j].IEN_act[k][1]);
						if (aloc[lev][pid] == -1)
						{
							cout << "wrong aloc!\n";
							getchar();
						}
						bztmp.IEN[k] = aloc[lev][pid];
						for (k1 = 0; k1 < 64; k1++)
						{
							bztmp.cmat[k][k1] = 0.;
							for (k2 = 0; k2 < hmesh[i][j].IEN.size(); k2++)
							{
								bztmp.cmat[k][k1] += hmesh[i][j].tmat[k][k2] * hmesh[i][j].bemat[k2][k1];
							}
						}
					}
					for (k = 0; k < hmesh[i][j].IEN.size(); k++)
					{
						for (k1 = 0; k1 < 64; k1++)
						{
							bztmp.pts[k1][0] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[0];
							bztmp.pts[k1][1] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[1];
							bztmp.pts[k1][2] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[2];
						}
					}
				}
				bzmesh.push_back(bztmp);
			}
		}
	}

	LeastSquare ls;
	vector<double> sol;
	ls.SetProblem(IDBC, gh);
	ls.GetEqParameter(dmrg, nmpl, acoef);
	//ls.VisualizeBoundarySurface(bzmesh, cpts, "../io/complex2/rod2");
	//cout << "done output boundary surface!\n";
	//getchar();
	ls.Run_Fitting(bzmesh, "", sol);
	//ls.VisualizeBoundarySurface(bzmesh, cpts, "../io/complex2/rod2");
	//cout << "done output boundary surface!\n";
	//getchar();

	IDBC1.clear();
	gh1.clear();
	int loc1(0);
	loc = 0;
	//int count = 0;
	count = 0;
	for (i = 0; i < hcp.size(); i++)
	{
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				if (flag[i][j] == 1)
				{
					if (hcp[i][j].type == 1)
					{
						IDBC1.push_back(-1);
						gh1.push_back(sol[loc]);
						//double tmp = SpecifyDirichBC(hcp[i][j].coor);
						//gh1.push_back(tmp);
					}
					else
					{
						IDBC1.push_back(count);
						gh1.push_back(0.);
						count++;
					}
					loc++;
				}
				else
				{
					IDBC1.push_back(count);
					gh1.push_back(0.);
					count++;
				}
			}
		}
	}
}

void TruncatedTspline_3D::InputCheck(string fn)
{
	OutputGeom_All(fn);
	cout << "Output Geom done!\n";
	getchar();
}

void TruncatedTspline_3D::MeshRepair(string fn_in, string fn_out)
{
	string fname(fn_in + ".vtk"), stmp;
	int npts, neles, itmp;
	ifstream fin;
	fin.open(fname);
	if (fin.is_open())
	{
		for (int i = 0; i<4; i++) getline(fin, stmp);//skip lines
		fin >> stmp >> npts >> stmp;
		cp.resize(npts);
		for (int i = 0; i<npts; i++)
		{
			cp[i].act = 1;
			fin >> cp[i].coor[0] >> cp[i].coor[1] >> cp[i].coor[2];
		}
		getline(fin, stmp);
		fin >> stmp >> neles >> itmp;
		tmesh.resize(neles);
		for (int i = 0; i<neles; i++)
		{
			fin >> itmp >> tmesh[i].cnct[0] >> tmesh[i].cnct[1] >> tmesh[i].cnct[2] >> tmesh[i].cnct[3] >>
				tmesh[i].cnct[4] >> tmesh[i].cnct[5] >> tmesh[i].cnct[6] >> tmesh[i].cnct[7];
		}
		fin.close();
	}
	else
	{
		cerr << "Cannot open " << fname << "!\n";
	}
	InitialConnect();

	int npr(8);
	int pr[] = {6180,6181,6182,6183,6169,6168,6171,6170};//cross hole model, point ids for bad elements
	vector<int> ebad;
	for (int i = 0; i < npr; i++)
	{
		for (uint j = 0; j < cp[pr[i]].hex.size(); j++)
		{
			int hxid(cp[pr[i]].hex[j]);
			if (tmesh[hxid].type == 1)
			{
				vector<int>::iterator it = find(ebad.begin(), ebad.end(), hxid);
				if (it == ebad.end())
				{
					ebad.push_back(hxid);
				}
			}
		}
	}
	double tol(1.e-6);
	vector<array<int, 2>> move;
	int pair[6][8] = { { 0, 1, 2, 3, 4, 5, 6, 7 }, { 0, 1, 5, 4, 3, 2, 6, 7 }, { 1, 2, 6, 5, 0, 3, 7, 4 }, { 3, 2, 6, 7, 0, 1, 5, 4 },
	{ 0, 3, 7, 4, 1, 2, 6, 5 }, { 4, 5, 6, 7, 0, 1, 2, 3 } };
	for (uint i = 0; i < ebad.size(); i++)
	{
		int fc_loc(-1);
		for (int j = 0; j < 6; j++)
		{
			if (tmface[tmesh[ebad[i]].face[j]].type == 1)
			{
				fc_loc = j; break;
			}
		}
		if (fc_loc != -1)
		{
			for (int j = 0; j < 4; j++)
			{
				array<int,2> ptmp = { tmesh[ebad[i]].cnct[pair[fc_loc][j + 4]], tmesh[ebad[i]].cnct[pair[fc_loc][j]] };
				vector<array<int, 2>>::iterator it = find(move.begin(), move.end(), ptmp);
				if (it == move.end())
				{
					move.push_back(ptmp);
				}
			}
		}
	}

	//for (uint i = 0; i < cp.size(); i++)
	//{
	//	if (cp[i].type != 1)
	//	{
	//		for (uint j = 0; j < cp.size(); j++)
	//		{
	//			double dis = sqrt((cp[i].coor[0] - cp[j].coor[0])*(cp[i].coor[0] - cp[j].coor[0]) + (cp[i].coor[1] - cp[j].coor[1])*(cp[i].coor[1] - cp[j].coor[1]) +
	//				(cp[i].coor[2] - cp[j].coor[2])*(cp[i].coor[2] - cp[j].coor[2]));
	//			if (i != j && dis < tol)
	//			{
	//				//move[i] = 1; break;
	//				array<int, 2> tmp = { i, j };
	//				move.push_back(tmp);
	//				break;
	//			}
	//		}
	//	}
	//}
	int fc_dir[6][3] = { { 0, 3, 2 }, { 0, 1, 5 }, { 1, 2, 6 }, { 3, 7, 6 }, { 0, 4, 7 }, { 4, 5, 6 } };
	for (uint i = 0; i < move.size(); i++)
	{
		vector<array<double, 3>> vec;
		for (uint j = 0; j < cp[move[i][1]].hex.size(); j++)
		{
			if (tmesh[cp[move[i][1]].hex[j]].type == 1)
			{
				int hxid(cp[move[i][1]].hex[j]);
				for (int k = 0; k < 6; k++)
				{
					if (tmface[tmesh[hxid].face[k]].type == 1)
					{
						array<double, 3> tmp1, tmp2;
						for (int dof = 0; dof < 3; dof++)
						{
							tmp1[dof] = cp[tmesh[hxid].cnct[fc_dir[k][1]]].coor[dof] - cp[tmesh[hxid].cnct[fc_dir[k][0]]].coor[dof];
							tmp2[dof] = cp[tmesh[hxid].cnct[fc_dir[k][2]]].coor[dof] - cp[tmesh[hxid].cnct[fc_dir[k][1]]].coor[dof];
						}
						array<double, 3> tmp3 = { tmp1[1] * tmp2[2] - tmp1[2] * tmp2[1], -tmp1[0] * tmp2[2] + tmp1[2] * tmp2[0], tmp1[0] * tmp2[1] - tmp1[1] * tmp2[0] };
						double dis = sqrt(tmp3[0] * tmp3[0] + tmp3[1] * tmp3[1] + tmp3[2] * tmp3[2]);
						tmp3[0] /= dis; tmp3[1] /= dis; tmp3[2] /= dis;
						vec.push_back(tmp3);
					}
				}
			}
		}
		array<double, 3> nm = { 0., 0., 0. };
		for (uint j = 0; j < vec.size(); j++)
		{
			nm[0] += vec[j][0]; nm[1] += vec[j][1]; nm[2] += vec[j][2];
		}
		nm[0] /= vec.size(); nm[1] /= vec.size(); nm[2] /= vec.size();
		nm[0] = -nm[0]; nm[1] = -nm[1]; nm[2] = -nm[2];

		double lmin(1.e6);
		for (uint j = 0; j < cp[move[i][0]].edge.size(); j++)
		{
			int edid = cp[move[i][0]].edge[j];
			double dis = sqrt((cp[tmedge[edid].pt[1]].coor[0] - cp[tmedge[edid].pt[0]].coor[0])*(cp[tmedge[edid].pt[1]].coor[0] - cp[tmedge[edid].pt[0]].coor[0]) +
				(cp[tmedge[edid].pt[1]].coor[1] - cp[tmedge[edid].pt[0]].coor[1])*(cp[tmedge[edid].pt[1]].coor[1] - cp[tmedge[edid].pt[0]].coor[1]) +
				(cp[tmedge[edid].pt[1]].coor[2] - cp[tmedge[edid].pt[0]].coor[2])*(cp[tmedge[edid].pt[1]].coor[2] - cp[tmedge[edid].pt[0]].coor[2]));
			if (dis>tol && dis < lmin) lmin = dis;
		}
		double c_amp(2.5);
		nm[0] *= c_amp*lmin; nm[1] *= c_amp*lmin; nm[2] *= c_amp*lmin;

		cp[move[i][0]].coor[0] = cp[move[i][1]].coor[0] + nm[0];
		cp[move[i][0]].coor[1] = cp[move[i][1]].coor[1] + nm[1];
		cp[move[i][0]].coor[2] = cp[move[i][1]].coor[2] + nm[2];
	}

	//string fn2(fn_out + "_tmp.vtk");
	//ofstream fout;
	//fout.open(fn2.c_str());
	//if (fout.is_open())
	//{
	//	fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
	//	fout << "POINTS " << cp.size() << " float\n";
	//	for (uint i = 0; i<cp.size(); i++)
	//	{
	//		fout << cp[i].coor[0] << " " << cp[i].coor[1] << " " << cp[i].coor[2] << "\n";
	//	}
	//	fout << "\nCELLS " << tmedge.size() << " " << 3 * tmedge.size() << '\n';
	//	for (uint i = 0; i<tmedge.size(); i++)
	//	{
	//		fout << "2 ";
	//		for (int j = 0; j<2; j++)
	//		{
	//			fout << tmedge[i].pt[j] << ' ';
	//		}
	//		fout << '\n';
	//	}
	//	fout << "\nCELL_TYPES " << tmedge.size() << '\n';
	//	for (uint i = 0; i<tmedge.size(); i++)
	//	{
	//		fout << "3\n";
	//	}
	////	fout << "POINT_DATA " << cp.size() << "\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
	////	for (uint i = 0; i<cp.size(); i++)
	////	{
	////		fout << move[i] << "\n";
	////	}
	////	//fout << "\nCELL_DATA " << hedge[lev].size() << "\nSCALARS eact float 1\nLOOKUP_TABLE default\n";
	////	//for (uint i = 0; i<hedge[lev].size(); i++)
	////	//{
	////	//	fout << hedge[lev][i].sharp << "\n";
	////	//}
	//	fout.close();
	//}
	//else
	//{
	//	cout << "Cannot open " << fn2 << "!\n";
	//}

	string fn2(fn_out + ".vtk");
	ofstream fout;
	fout.open(fn2.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << cp.size() << " float\n";
		for (uint i = 0; i<cp.size(); i++)
		{
			fout << cp[i].coor[0] << " " << cp[i].coor[1] << " " << cp[i].coor[2] << "\n";
		}
		fout << "\nCELLS " << tmesh.size() << " " << 9 * tmesh.size() << '\n';
		for (uint i = 0; i<tmesh.size(); i++)
		{
			fout << "8 ";
			for (int j = 0; j<8; j++)
			{
				fout << tmesh[i].cnct[j] << ' ';
			}
			fout << '\n';
		}
		fout << "\nCELL_TYPES " << tmesh.size() << '\n';
		for (uint i = 0; i<tmesh.size(); i++)
		{
			fout << "12\n";
		}
		//fout << "POINT_DATA " << hcp[lev].size() << "\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<hcp[lev].size(); i++)
		//{
		//	fout << hcp[lev][i].act << "\n";
		//}
		//fout << "\nCELL_DATA " << hmesh[lev].size() << "\nSCALARS eact float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<hmesh[lev].size(); i++)
		//{
		//	//fout<<hmesh[lev][i].act<<"\n";
		//	fout << hmesh[lev][i].type << "\n";
		//}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fn2 << "!\n";
	}

	cout << "Done mesh repair!\n";
	getchar();
}

void TruncatedTspline_3D::ReportXP()
{
	vector<int> pflag(cp.size(),0);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].type == 3)//interior extraordinary points
		{
			pflag[i] = 1;
			count++;
		}
		else if (cp[i].type == 1)
		{
			int nfc(0);
			for (uint j = 0; j < cp[i].face.size(); j++)
			{
				if (tmface[cp[i].face[j]].type == 1) nfc++;
			}
			if (nfc != 4)
			{
				pflag[i] = 1;
				count++;
			}
		}
	}
	cout << "# of XP: " << count << "\n";
	count = 0;
	for (uint i = 0; i < tmesh.size(); i++)
	{
		//if (tmesh[i].type == 2) count++;
		int flag(0);
		for (int j = 0; j < 8; j++)
		{
			if (pflag[tmesh[i].cnct[j]] == 1)
			{
				flag = 1; break;
			}
		}
		if (flag == 1) count++;
	}
	cout << "# of XE: " << count << "\n";
	//getchar();
}

void TruncatedTspline_3D::OutputRefineID(string fn, const vector<array<int, 2>>& rfid, const vector<array<int, 2>>& gst)
{
	string fname = fn + "_rfid.txt";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << rfid.size() << "\n";
		for (uint i = 0; i < rfid.size(); i++)
		{
			fout << rfid[i][0] << " " << rfid[i][1] << "\n";
		}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}

	string fn1 = fn + "_gst.txt";
	fout.open(fn1.c_str());
	if (fout.is_open())
	{
		fout << gst.size() << "\n";
		for (uint i = 0; i < gst.size(); i++)
		{
			fout << gst[i][0] << " " << gst[i][1] << "\n";
		}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fn1 << "!\n";
	}
}

void TruncatedTspline_3D::InputRefineID(string fn, vector<array<int, 2>>& rfid, vector<array<int, 2>>& gst)
{
	int tmp;
	rfid.clear();
	gst.clear();
	string fname = fn + "_rfid.txt";
	ifstream fin;
	fin.open(fname.c_str());
	if (fin.is_open())
	{
		fin >> tmp;
		rfid.resize(tmp);
		for (uint i = 0; i < rfid.size(); i++)
		{
			fin >> rfid[i][0] >> rfid[i][1];
		}
		fin.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}

	string fn1 = fn + "_gst.txt";
	fin.open(fn1.c_str());
	if (fin.is_open())
	{
		fin >> tmp;
		gst.resize(tmp);
		for (uint i = 0; i < gst.size(); i++)
		{
			fin >> gst[i][0] >> gst[i][1];
		}
		fin.close();
	}
	else
	{
		cout << "Cannot open " << fn1 << "!\n";
	}
}

void TruncatedTspline_3D::InputRefineID_Manual(string fn, vector<array<int, 2>>& rfid, vector<array<int, 2>>& gst)
{
	int tmp;
	uint i, j, k;

	rfid.clear();
	gst.clear();
	string fname = fn + "_rfid.txt";
	ifstream fin;
	fin.open(fname.c_str());
	if (fin.is_open())
	{
		fin >> tmp;
		rfid.resize(tmp);
		for (uint i = 0; i < rfid.size(); i++)
		{
			fin >> rfid[i][0] >> rfid[i][1];
		}
		fin.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}

	//cout << "Max error: "<< err_max << "\n";
	//cout << "# of pid: " << rf_pid.size() << "\n";
	cout << "# of rfid: " << rfid.size() << "\n";
	//getchar();
	for (i = 0; i < rfid.size(); i++)
	{
		int lev(rfid[i][0]);
		for (j = 0; j < 8; j++)
		{
			int pt(hmesh[lev][rfid[i][1]].cnct[j]);
			for (k = 0; k < hcp[lev][pt].hex.size(); k++)
			{
				if (hmesh[lev][hcp[lev][pt].hex[k]].chd.size() == 0)
				{
					array<int, 2> tmp = { lev, hcp[lev][pt].hex[k] };
					vector<array<int, 2>>::iterator it1 = find(gst.begin(), gst.end(), tmp);
					vector<array<int, 2>>::iterator it2 = find(rfid.begin(), rfid.end(), tmp);
					if (it1 == gst.end() && it2 == rfid.end())
					{
						gst.push_back(tmp);
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::GetRemoveRegion(double xy[3][2])
{
	double tmp(1.e6);
	double x_range[3][2] = { { tmp, -tmp }, { tmp, -tmp }, { tmp, -tmp } };
	uint i, j;
	for (i = 0; i <cp.size(); i++)
	{
		for (j = 0; j < 3; j++)
		{
			if (cp[i].coor[j] < x_range[j][0]) x_range[j][0] = cp[i].coor[j];
			if (cp[i].coor[j] > x_range[j][1]) x_range[j][1] = cp[i].coor[j];
		}
	}
	double orig[3] = { (x_range[0][0] + x_range[0][1]) / 2., (x_range[1][0] + x_range[1][1]) / 2., (x_range[2][0] + x_range[2][1]) / 2. };
	double xh[3] = { x_range[0][1] - x_range[0][0], x_range[1][1] - x_range[1][0], x_range[2][1] - x_range[2][0] };
	int dirlg(0);
	double hmax(0.);
	for (i = 0; i < 3; i++)
	{
		if (xh[i]>hmax)
		{
			hmax = xh[i];
			dirlg = i;
		}
	}
	//rod
	//if (dirlg == 0)
	//{
	//	cout << "x is the longest!\n";
	//	xy[0][0] = x_range[0][0]; xy[0][1] = x_range[0][1];
	//	xy[1][0] = orig[1]; xy[1][1] = x_range[1][1];
	//	xy[2][0] = orig[2]; xy[2][1] = x_range[2][1];
	//	//cout << x_range[0][0] << " " << x_range[0][1] << " " << xy[0][0] << " " << xy[0][1] << "\n";
	//	//cout << x_range[1][0] << " " << x_range[1][1] << " " << xy[1][0] << " " << xy[1][1] << "\n";
	//	//cout << x_range[2][0] << " " << x_range[2][1] << " " << xy[2][0] << " " << xy[2][1] << "\n";
	//	//getchar();
	//}
	//else if (dirlg == 1)
	//{
	//	cout << "y is the longest!\n";
	//	xy[0][0] = orig[0]; xy[0][1] = x_range[0][1];
	//	xy[1][0] = x_range[1][0]; xy[1][1] = x_range[1][1];
	//	xy[2][0] = orig[2]; xy[2][1] = x_range[2][1];
	//}
	//else
	//{
	//	cout << "z is the longest!\n";
	//	xy[0][0] = orig[0]; xy[0][1] = x_range[0][1];
	//	xy[1][0] = orig[1]; xy[1][1] = x_range[1][1];
	//	xy[2][0] = x_range[2][0]; xy[2][1] = x_range[2][1];
	//}

	////hook
	//xy[0][0] = x_range[0][0]; xy[0][1] = (x_range[0][0]+orig[0])/2.;
	//xy[1][0] = x_range[1][0]; xy[1][1] = x_range[1][1];
	//xy[2][0] = x_range[2][0]; xy[2][1] = x_range[2][1];

	//base
	//xy[0][0] = x_range[0][0]; xy[0][1] = orig[0];
	//xy[1][0] = x_range[1][0]; xy[1][1] = orig[1];
	//xy[2][0] = x_range[2][0]; xy[2][1] = x_range[2][1];

	//gear
	//xy[0][0] = x_range[0][0]; xy[0][1] = 0.9*orig[0] + 0.1*x_range[0][0];
	//xy[1][0] = x_range[1][0]; xy[1][1] = 0.8*orig[1] + 0.2*x_range[1][1];
	//xy[2][0] = 0.8*orig[2] + 0.2*x_range[2][1]; xy[2][1] = x_range[2][1];

	//statue
	//xy[0][0] = 0.9*orig[0]+0.1*x_range[0][1]; xy[0][1] = x_range[0][1];
	//xy[1][0] = x_range[1][0]; xy[1][1] = 0.7*orig[1] + 0.3*x_range[1][1];
	//xy[2][0] = 0.55*orig[2] + 0.45*x_range[2][1]; xy[2][1] = x_range[2][1];

	xy[0][0] = orig[0]; xy[0][1] = x_range[0][1];
	xy[1][0] = x_range[1][0]; xy[1][1] = orig[1];
	xy[2][0] = orig[2]; xy[2][1] = x_range[2][1];
}

void TruncatedTspline_3D::OutputRemoveCM(string fn, double xy[3][2])
{
	int lev(0);
	string fname(fn + "_remv_CM.vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << hcp[lev].size() << " float\n";
		for (uint i = 0; i<hcp[lev].size(); i++)
		{
			fout << hcp[lev][i].coor[0] << " " << hcp[lev][i].coor[1] << " " << hcp[lev][i].coor[2] << "\n";
		}
		vector<int> outid;
		for (uint i = 0; i < hmesh[lev].size(); i++)
		{
			array<double, 3> ctp = { 0., 0., 0. };
			for (int j = 0; j < 8; j++)
			{
				ctp[0] += hcp[lev][hmesh[lev][i].cnct[j]].coor[0];
				ctp[1] += hcp[lev][hmesh[lev][i].cnct[j]].coor[1];
				ctp[2] += hcp[lev][hmesh[lev][i].cnct[j]].coor[2];
			}
			ctp[0] /= 8.; ctp[1] /= 8.; ctp[2] /= 8.;
			if (ctp[0]>=xy[0][0] && ctp[0]<=xy[0][1] && ctp[1]>=xy[1][0] && ctp[1]<=xy[1][1] && ctp[2]>=xy[2][0] && ctp[2] <= xy[2][1])
			{
				continue;
			}
			else
			{
				outid.push_back(i);
			}
		}

		fout << "\nCELLS " << outid.size() << " " << 9 * outid.size() << '\n';
		for (uint i = 0; i<outid.size(); i++)
		{
			fout << "8 ";
			for (int j = 0; j<8; j++)
			{
				fout << hmesh[lev][outid[i]].cnct[j] << ' ';
			}
			fout << '\n';
		}
		fout << "\nCELL_TYPES " << outid.size() << '\n';
		for (uint i = 0; i<outid.size(); i++)
		{
			fout << "12\n";
		}

		//fout << "POINT_DATA " << hcp[lev].size() << "\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<hcp[lev].size(); i++)
		//{
		//	fout << hcp[lev][i].act << "\n";
		//}
		//fout << "\nCELL_DATA " << hmesh[lev].size() << "\nSCALARS eact float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<hmesh[lev].size(); i++)
		//{
		//	//fout<<hmesh[lev][i].act<<"\n";
		//	fout << hmesh[lev][i].type << "\n";
		//}

		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::CreateRemoveView(string fn_in, string fn_out)
{
	vector<array<double, 3>> pts;
	vector<double> val;
	vector<array<int, 8>> cube;
	vector<array<double, 3>> lpt;
	vector<array<int, 2>> line;

	string fname(fn_in + "_disp.vtk"), stmp;
	int npts, neles, itmp;
	ifstream fin;
	fin.open(fname);
	if (fin.is_open())
	{
		for (int i = 0; i<4; i++) getline(fin, stmp);//skip lines
		fin >> stmp >> npts >> stmp;
		pts.resize(npts);
		val.resize(npts);
		for (int i = 0; i<npts; i++)
		{
			fin >> pts[i][0] >> pts[i][1] >> pts[i][2];
		}
		getline(fin, stmp);
		fin >> stmp >> neles >> itmp;
		cube.resize(neles);
		for (int i = 0; i<neles; i++)
		{
			fin >> itmp >> cube[i][0] >> cube[i][1] >> cube[i][2] >> cube[i][3] >>
				cube[i][4] >> cube[i][5] >> cube[i][6] >> cube[i][7];
		}
		for (int i = 0; i < 3; i++)
		{
			getline(fin, stmp);//skip lines
			//cout << stmp << "\n";
			//getchar();
		}
		for (int i = 0; i<neles; i++)//skip cell types
		{
			fin >> itmp;
		}
		for (int i = 0; i<4; i++) getline(fin, stmp);//skip lines
		for (int i = 0; i<npts; i++)
		{
			fin >> val[i];
			//cout << val[i] << "\n";
			//getchar();
		}
		fin.close();
	}
	else
	{
		cerr << "Cannot open " << fname << "!\n";
	}
	string fn1(fn_in + "-lines.vtk");
	fin.open(fn1);
	if (fin.is_open())
	{
		for (int i = 0; i<4; i++) getline(fin, stmp);//skip lines
		fin >> stmp >> npts >> stmp;
		lpt.resize(npts);
		for (int i = 0; i<npts; i++)
		{
			fin >> lpt[i][0] >> lpt[i][1] >> lpt[i][2];
		}
		getline(fin, stmp);
		fin >> stmp >> neles >> itmp;
		line.resize(neles);
		for (int i = 0; i<neles; i++)
		{
			fin >> itmp >> line[i][0] >> line[i][1];
		}
		fin.close();
	}
	else
	{
		cerr << "Cannot open " << fn1 << "!\n";
	}

	double tmp(1.e6);
	double x_range[3][2] = { { tmp, -tmp }, { tmp, -tmp }, { tmp, -tmp } };
	uint i, j;
	for (i = 0; i <lpt.size(); i++)
	{
		for (j = 0; j < 3; j++)
		{
			if (lpt[i][j] < x_range[j][0]) x_range[j][0] = lpt[i][j];
			if (lpt[i][j] > x_range[j][1]) x_range[j][1] = lpt[i][j];
		}
	}
	double orig[3] = { (x_range[0][0] + x_range[0][1]) / 2., (x_range[1][0] + x_range[1][1]) / 2., (x_range[2][0] + x_range[2][1]) / 2. };
	double xh[3] = { x_range[0][1] - x_range[0][0], x_range[1][1] - x_range[1][0], x_range[2][1] - x_range[2][0] };
	int dirlg(0);
	double hmax(0.), dis;
	for (i = 0; i < 3; i++)
	{
		if (xh[i]>hmax)
		{
			hmax = xh[i];
			dirlg = i;
		}
	}
	double hmin = 1.e6;
	for (i = 0; i < line.size(); i++)
	{
		dis = (lpt[line[i][0]][0] - lpt[line[i][1]][0])*(lpt[line[i][0]][0] - lpt[line[i][1]][0]) +
			(lpt[line[i][0]][1] - lpt[line[i][1]][0])*(lpt[line[i][0]][1] - lpt[line[i][1]][1]) +
			(lpt[line[i][0]][2] - lpt[line[i][1]][0])*(lpt[line[i][0]][2] - lpt[line[i][1]][2]);
		if (dis < hmin) hmin = dis;
	}
	hmin = sqrt(hmin);
	double rmv[3][2], rmv1[3][2];
	//rod
	rmv[0][0] = x_range[0][0]; rmv[0][1] = x_range[0][1];
	rmv[1][0] = orig[1]; rmv[1][1] = x_range[1][1];
	rmv[2][0] = orig[2]; rmv[2][1] = x_range[2][1];

	rmv1[0][0] = x_range[0][0]; rmv1[0][1] = x_range[0][1];
	rmv1[1][0] = orig[1]+2.*hmin; rmv1[1][1] = x_range[1][1];
	rmv1[2][0] = orig[2] + 2.5*hmin; rmv1[2][1] = x_range[2][1];
	//hook
	//rmv[0][0] = x_range[0][0]; rmv[0][1] = (x_range[0][0] + orig[0]) / 2.;
	//rmv[1][0] = x_range[1][0]; rmv[1][1] = x_range[1][1];
	//rmv[2][0] = x_range[2][0]; rmv[2][1] = x_range[2][1];

	vector<int> ptsflag(pts.size(), 0);
	vector<int> ptsloc(pts.size(), -1);
	vector<double> val1;
	vector<array<int, 8>> cube1;
	vector<int> lptflag(lpt.size(), 0);
	vector<int> lptloc(lpt.size(), -1);
	vector<array<int, 2>> line1;
	for (i = 0; i < cube.size(); i++)
	{
		double ctp[3] = { 0., 0., 0. };
		for (j = 0; j < 8; j++)
		{
			ctp[0] += pts[cube[i][j]][0];
			ctp[1] += pts[cube[i][j]][1];
			ctp[2] += pts[cube[i][j]][2];
		}
		ctp[0] /= 8.; ctp[1] /= 8.; ctp[2] /= 8.;
		if (ctp[0] > rmv[0][0] && ctp[0] < rmv[0][1] && ctp[1] > rmv[1][0] && ctp[1] < rmv[1][1] && ctp[2] > rmv[2][0] && ctp[2] < rmv[2][1])
		{
			continue;
		}
		else
		{
			for (j = 0; j < 8; j++)
			{
				ptsflag[cube[i][j]] = 1;
			}
			cube1.push_back(cube[i]);
		}
	}
	int loc(0);
	for (i = 0; i < ptsflag.size(); i++)
	{
		if (ptsflag[i] == 1)
		{
			ptsloc[i] = loc++;
			val1.push_back(val[i]);
		}
	}
	for (i = 0; i < cube1.size(); i++)
	{
		for (j = 0; j < 8; j++) cube1[i][j] = ptsloc[cube1[i][j]];
	}

	for (i = 0; i < line.size(); i++)
	{
		double ctp[3] = { (lpt[line[i][0]][0] + lpt[line[i][1]][0]) / 2., (lpt[line[i][0]][1] + lpt[line[i][1]][1]) / 2., (lpt[line[i][0]][2] + lpt[line[i][1]][2]) / 2.};
		if (ctp[0] > rmv[0][0] && ctp[0] < rmv[0][1] && ctp[1] > rmv[1][0] && ctp[1] < rmv[1][1] && ctp[2] > rmv[2][0] && ctp[2] < rmv[2][1])
		{
			continue;
		}
		else
		{
			lptflag[line[i][0]] = 1; lptflag[line[i][1]] = 1;
			line1.push_back(line[i]);
		}
	}
	int loc1(0);
	for (i = 0; i < lptflag.size(); i++)
	{
		if (lptflag[i] == 1)
		{
			lptloc[i] = loc1++;
		}
	}
	for (i = 0; i < line1.size(); i++)
	{
		for (j = 0; j < 2; j++) line1[i][j] = lptloc[line1[i][j]];
	}
	
	string fname1 = fn_out + "_rmv_disp.vtk";
	ofstream fout;
	fout.open(fname1.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nHex test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << val1.size() << " float\n";
		for (i = 0; i<pts.size(); i++)
		{
			if (ptsflag[i] == 1)
			{
				fout << pts[i][0] << " " << pts[i][1] << " " << pts[i][2] << "\n";
			}
		}
		fout << "\nCELLS " << cube1.size() << " " << 9 * cube1.size() << '\n';
		for (i = 0; i<cube1.size(); i++)
		{
			fout << "8 " << cube1[i][0] << " " << cube1[i][1] << " " << cube1[i][2] << " " << cube1[i][3]
				<< " " << cube1[i][4] << " " << cube1[i][5] << " " << cube1[i][6] << " " << cube1[i][7] << '\n';
		}
		fout << "\nCELL_TYPES " << cube1.size() << '\n';
		for (i = 0; i<cube1.size(); i++)
		{
			fout << "12\n";
		}
		//fout<<"\nPOINT_DATA "<<sdisp.size()<<"\nVECTORS disp float\n";
		//for(i=0;i<sdisp.size();i++)
		//{
		//	fout << sdisp[i][0] << " " << sdisp[i][1] << " " << sdisp[i][2] << "\n";
		//}
		//fout << "\nPOINT_DATA " << sse.size() << "\nVECTORS strain float\n";
		//for (i = 0; i<sse.size(); i++)
		//{
		//	fout << sse[i][0] << " " << sse[i][1] << " " << sse[i][2] << "\n";
		//}
		//fout<<"POINT_DATA "<<sss.size()<<"\nVECTORS stress float\n";
		//for(i=0;i<sss.size();i++)
		//{
		//	fout<<sss[i][0]<<" "<<sss[i][1]<<" "<<sss[i][2]<<"\n";
		//}
		//fout<<"POINT_DATA "<<sdisp_err.size()<<"\nVECTORS disp_err float\n";
		//for(i=0;i<sdisp_err.size();i++)
		//{
		//	fout<<sdisp_err[i][0]<<" "<<sdisp_err[i][1]<<" 0\n";
		//}

		fout << "\nPOINT_DATA " << val1.size() << "\nSCALARS err float 1\nLOOKUP_TABLE default\n";
		for (uint i = 0; i<val1.size(); i++)
		{
			fout << val1[i] << "\n";
		}

		//fout<<"\nCELL_DATA "<<errL2.size()<<"\nSCALARS Error float 1\nLOOKUP_TABLE default\n";
		//for(i=0;i<errL2.size();i++)
		//{
		//	fout<<errL2[i]<<"\n";
		//	//fout<<eles[i].type<<"\n";
		//}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname1 << "!\n";
	}

	string fname2(fn_out + "_rmv-lines.vtk");
	ofstream fout1;
	fout1.open(fname2.c_str());
	if (fout1.is_open())
	{
		fout1 << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout1 << "POINTS " << loc1 << " float\n";
		for (i = 0; i<lpt.size(); i++)
		{
			if (lptflag[i] == 1)
			{
				fout1 << lpt[i][0] << " " << lpt[i][1] << " " << lpt[i][2] << "\n";
			}
		}
		fout1 << "\nCELLS " << line1.size() << " " << 3 * line1.size() << '\n';
		for (i = 0; i<line1.size(); i++)
		{
			fout1 << "2 " << line1[i][0] << " " << line1[i][1] << '\n';
		}
		fout1 << "\nCELL_TYPES " << line1.size() << '\n';
		for (i = 0; i<line1.size(); i++)
		{
			fout1 << "3\n";
		}
		fout1.close();
	}
	else
	{
		cout << "Cannot open " << fname2 << "!\n";
	}
}

void TruncatedTspline_3D::GlobalRefine(int niter)
{
	for (int it = 0; it < niter; it++)
	{
		vector<array<int, 2>> rfid, gst;
		for (uint i = 0; i < hmesh.size(); i++)
		{
			for (uint j = 0; j < hmesh[i].size(); j++)
			{
				if (hmesh[i][j].act == 1)
				{
					array<int, 2> tmp = { i, j };
					rfid.push_back(tmp);
				}
			}
		}
		Refine(rfid, gst);
		//stringstream ss;
		//ss << it + 1;
		//OutputCM(hmesh.size()-1, "../io/hex_input/cube_coarse_"+ss.str());
	}
	cout << "Global refinement done!\n";
	//getchar();
}

double TruncatedTspline_3D::MaxElementSize(const vector<BezierElement3D>& bzmesh)
{
	int ids[4][2] = { { 0, 63 }, { 3, 60 }, { 15, 48 }, { 12, 51 } };
	double max(0.), tmp;
	for (uint i = 0; i < bzmesh.size(); i++)
	{
		for (int j = 0; j < 4; j++)
		{
			tmp = (bzmesh[i].pts[ids[j][0]][0] - bzmesh[i].pts[ids[j][1]][0])*(bzmesh[i].pts[ids[j][0]][0] - bzmesh[i].pts[ids[j][1]][0])
				+ (bzmesh[i].pts[ids[j][0]][1] - bzmesh[i].pts[ids[j][1]][1])*(bzmesh[i].pts[ids[j][0]][1] - bzmesh[i].pts[ids[j][1]][1])
				+ (bzmesh[i].pts[ids[j][0]][2] - bzmesh[i].pts[ids[j][1]][2])*(bzmesh[i].pts[ids[j][0]][2] - bzmesh[i].pts[ids[j][1]][2]);
			max = tmp>max ? tmp : max;
		}
	}
	return sqrt(max);
}

void TruncatedTspline_3D::InitializeMesh(string fn)
{
	//read hex vtk
	string fname(fn + ".vtk"), stmp;
	int npts, neles, itmp;
	ifstream fin;
	fin.open(fname);
	if (fin.is_open())
	{
		for (int i = 0; i<4; i++) getline(fin, stmp);//skip lines
		fin >> stmp >> npts >> stmp;
		cp.resize(npts);
		for (int i = 0; i<npts; i++)
		{
			cp[i].act = 1;
			fin >> cp[i].coor[0] >> cp[i].coor[1] >> cp[i].coor[2];
			cp[i].coortmp[0] = cp[i].coor[0];
			cp[i].coortmp[1] = cp[i].coor[1];
			cp[i].coortmp[2] = cp[i].coor[2];
		}
		getline(fin, stmp);
		fin >> stmp >> neles >> itmp;
		tmesh.resize(neles);
		for (int i = 0; i<neles; i++)
		{
			tmesh[i].act = 1;
			fin >> itmp >> tmesh[i].cnct[0] >> tmesh[i].cnct[1] >> tmesh[i].cnct[2] >> tmesh[i].cnct[3] >>
				tmesh[i].cnct[4] >> tmesh[i].cnct[5] >> tmesh[i].cnct[6] >> tmesh[i].cnct[7];
		}
		fin.close();
	}
	else
	{
		cerr << "Cannot open " << fname << "!\n";
	}

	////heli_loc manual smooth
	//int pid[3][5] = { {24191,24188,23456,23453,23449},{3690,24187,2968,23452,2156},{3684,24180,2967,23442,2155} };
	//for (int i = 0; i < 5; i++)
	//{
	//	for (int j = 0; j < 3; j++)
	//	{
	//		cp[pid[0][i]].coor[j] = (cp[pid[1][i]].coor[j] + cp[pid[2][i]].coor[j]) / 2.;
	//	}
	//}

	//SetDomain();//normalize coordinates in [0,1]^3, for the cube poisson

	//RescaleDomain();

	InitialConnect();
	//SetSharpFeature_1();

	hmesh.push_back(tmesh);
	hcp.push_back(cp);
	hface.push_back(tmface);
	hedge.push_back(tmedge);

	ReportXP();

	////string fn1("../io/le_adapt/navair/navair");
	//string fn1("../io/NAVAIR_GEM/output/sharp/navair");
	//OutputEdge(fn1);
	//OutputCM(fn1);
	//cout << "done setting sharp feature\n";
	//getchar();

	//double tol(1.e-4);
	//for (uint i = 0; i < cp.size(); i++)
	//{
	//	if (cp[i].type == 1 && fabs(cp[i].coor[0]) < tol && fabs(cp[i].coor[1]) < tol &&fabs(cp[i].coor[2]) < tol)
	//	{
	//		cp[i].type = 0;
	//		for (uint j = 0; j < cp[i].edge.size(); j++)
	//		{
	//			if (tmedge[cp[i].edge[j]].type == 2)
	//			{
	//				cp[i].type = 3; break;
	//			}
	//		}
	//	}
	//}
}

void TruncatedTspline_3D::SetSharpFeature_1(double tol)
{
	//sharp edge and sharp corner, indicated by control point
	//sharp edge
	//double tol(.3);
	//double tol(.57);//rod, base
	//double tol(.8);//hook
	//double tol(.4);//heli, navair
	//double tol(.65);//heli_coarse, heli_coarse_loc
	//double tol(.6);//heli_loc
	//double tol(.4);//navair coarse
	//double tol(.6);//heli_dense_loc

	int fc_dir[6][3] = { { 0, 3, 2 }, { 0, 1, 5 }, { 1, 2, 6 }, { 3, 7, 6 }, { 0, 4, 7 }, { 4, 5, 6 } };
	uint i, j, k;
	for (i = 0; i < tmedge.size(); i++)
	{
		if (tmedge[i].type == 1)
		{
			vector<array<double, 3>> vec;
			for (j = 0; j < tmedge[i].hex.size(); j++)
			{
				if (tmesh[tmedge[i].hex[j]].type == 1)
				{
					int hxid(tmedge[i].hex[j]);
					for (k = 0; k < 6; k++)
					{
						if (tmface[tmesh[hxid].face[k]].type == 1)
						{
							vector<int>::iterator it = find(tmedge[i].face.begin(), tmedge[i].face.end(), tmesh[hxid].face[k]);
							if (it != tmedge[i].face.end())
							{
								array<double, 3> tmp1, tmp2;
								for (int dof = 0; dof < 3; dof++)
								{
									tmp1[dof] = cp[tmesh[hxid].cnct[fc_dir[k][1]]].coor[dof] - cp[tmesh[hxid].cnct[fc_dir[k][0]]].coor[dof];
									tmp2[dof] = cp[tmesh[hxid].cnct[fc_dir[k][2]]].coor[dof] - cp[tmesh[hxid].cnct[fc_dir[k][1]]].coor[dof];
								}
								array<double, 3> tmp3 = { tmp1[1] * tmp2[2] - tmp1[2] * tmp2[1], -tmp1[0] * tmp2[2] + tmp1[2] * tmp2[0], tmp1[0] * tmp2[1] - tmp1[1] * tmp2[0] };
								double dis = sqrt(tmp3[0] * tmp3[0] + tmp3[1] * tmp3[1] + tmp3[2] * tmp3[2]);
								tmp3[0] /= dis; tmp3[1] /= dis; tmp3[2] /= dis;
								vec.push_back(tmp3);
							}
						}
					}
				}
			}
			if (vec.size() == 2)
			{
				double ang(vec[0][0] * vec[1][0] + vec[0][1] * vec[1][1] + vec[0][2] * vec[1][2]);
				if (ang < tol)
				{
					tmedge[i].sharp = 1;
					cp[tmedge[i].pt[0]].sharp = 1;
					cp[tmedge[i].pt[1]].sharp = 1;
				}
			}
			else
			{
				cerr << "Something wrong in determining sharp edge!\n";
				getchar();
			}
		}
	}

	//int cp_sharp[] = { 1179 };//manual control, heli and heli coarse
	////int cp_sharp[] = { 1543 };//manual control, heli dense loc1
	//int ncpshp(1);
	//for (int i = 0; i < ncpshp; i++)
	//{
	//	cp[cp_sharp[i]].sharp = 1;
	//}
	//for (i = 0; i < tmedge.size(); i++)
	//{
	//	if (tmedge[i].type == 1 && tmedge[i].sharp == 0)
	//	{
	//		if (cp[tmedge[i].pt[0]].sharp == 1 && cp[tmedge[i].pt[1]].sharp == 1 &&
	//			(tmedge[i].pt[0] == cp_sharp[0] || tmedge[i].pt[1] == cp_sharp[0]))//heli coarse
	//		{
	//			tmedge[i].sharp = 1;
	//		}
	//	}
	//}

	////int cp_desharp[] = { 1216 };//muanlly remove certain sharp, heli coarse
	//int cp_desharp[] = { 1580 };//muanlly remove certain sharp, heli coarse loc
	////int cp_desharp[] = { 12003,12022,12016 };//muanlly remove certain sharp, heli loc
	//int ndeshp(1);
	//for (int i = 0; i < ndeshp; i++)
	//{
	//	cp[cp_desharp[i]].sharp = 0;
	//	for (uint j = 0; j < cp[cp_desharp[i]].edge.size(); j++)
	//	{
	//		tmedge[cp[cp_desharp[i]].edge[j]].sharp = 0;
	//	}
	//}

	////int cp_desharp[] = { 7418,7419 };//muanlly remove certain sharp, navair coarse, no pillow
	//int cp_desharp[] = { 13109,13110 };//muanlly remove certain sharp, navair coarse
	////int cp_desharp[] = { 30994,36209 };//muanlly remove certain sharp, navair
	//int ndeshp(2);
	//for (int i = 0; i < ndeshp; i++)
	//{
	//	cp[cp_desharp[i]].sharp = 0;
	//	for (uint j = 0; j < cp[cp_desharp[i]].edge.size(); j++)
	//	{
	//		tmedge[cp[cp_desharp[i]].edge[j]].sharp = 0;
	//	}
	//}

	for (i = 0; i < cp.size(); i++)
	{
		if (cp[i].sharp == 1)
		{
			int nshp(0);
			for (j = 0; j < cp[i].edge.size(); j++)
			{
				if (tmedge[cp[i].edge[j]].sharp == 1)
				{
					nshp++;
				}
			}
			if (nshp >= 3) cp[i].sharp = 2;//sharp corner
			if (nshp == 1) cp[i].sharp = 2;//
		}
	}
	//for (i = 0; i < tmedge.size(); i++)
	//{
	//	if (tmedge[i].sharp == 1)
	//	{
	//		if (cp[tmedge[i].pt[0]].sharp == 0 || cp[tmedge[i].pt[1]].sharp == 0)
	//		{
	//			tmedge[i].sharp = 0;
	//		}
	//	}
	//}
}

void TruncatedTspline_3D::SetSharpFeature_localrefine(double tol)
{

	int fc_dir[6][3] = { { 0, 3, 2 }, { 0, 1, 5 }, { 1, 2, 6 }, { 3, 7, 6 }, { 0, 4, 7 }, { 4, 5, 6 } };
	uint i, j, k;
	for (i = 0; i < hedge[0].size(); i++)
	{
		if (hedge[0][i].type == 1)
		{
			vector<array<double, 3>> vec;
			for (j = 0; j < hedge[0][i].hex.size(); j++)
			{
				if (hmesh[0][hedge[0][i].hex[j]].type == 1)
				{
					int hxid(hedge[0][i].hex[j]);
					for (k = 0; k < 6; k++)
					{
						if (hface[0][hmesh[0][hxid].face[k]].type == 1)
						{
							vector<int>::iterator it = find(hedge[0][i].face.begin(), hedge[0][i].face.end(), hmesh[0][hxid].face[k]);
							if (it != hedge[0][i].face.end())
							{
								array<double, 3> tmp1, tmp2;
								for (int dof = 0; dof < 3; dof++)
								{
									tmp1[dof] = hcp[0][hmesh[0][hxid].cnct[fc_dir[k][1]]].coor[dof] - hcp[0][hmesh[0][hxid].cnct[fc_dir[k][0]]].coor[dof];
									tmp2[dof] = hcp[0][hmesh[0][hxid].cnct[fc_dir[k][2]]].coor[dof] - hcp[0][hmesh[0][hxid].cnct[fc_dir[k][1]]].coor[dof];
								}
								array<double, 3> tmp3 = { tmp1[1] * tmp2[2] - tmp1[2] * tmp2[1], -tmp1[0] * tmp2[2] + tmp1[2] * tmp2[0], tmp1[0] * tmp2[1] - tmp1[1] * tmp2[0] };
								double dis = sqrt(tmp3[0] * tmp3[0] + tmp3[1] * tmp3[1] + tmp3[2] * tmp3[2]);
								tmp3[0] /= dis; tmp3[1] /= dis; tmp3[2] /= dis;
								vec.push_back(tmp3);
							}
						}
					}
				}
			}
			if (vec.size() == 2)
			{
				double ang(vec[0][0] * vec[1][0] + vec[0][1] * vec[1][1] + vec[0][2] * vec[1][2]);
				if (ang < tol)
				{
					hedge[0][i].sharp = 1;
					hcp[0][hedge[0][i].pt[0]].sharp = 1;
					hcp[0][hedge[0][i].pt[1]].sharp = 1;
				}
			}
			else
			{
				cerr << "Something wrong in determining sharp edge!\n";
				getchar();
			}
		}
	}

	//int hcp[0]_sharp[] = { 1179 };//manual control, heli and heli coarse
	////int hcp[0]_sharp[] = { 1543 };//manual control, heli dense loc1
	//int nhcp[0]shp(1);
	//for (int i = 0; i < nhcp[0]shp; i++)
	//{
	//	hcp[0][hcp[0]_sharp[i]].sharp = 1;
	//}
	//for (i = 0; i < hedge[0].size(); i++)
	//{
	//	if (hedge[0][i].type == 1 && hedge[0][i].sharp == 0)
	//	{
	//		if (hcp[0][hedge[0][i].pt[0]].sharp == 1 && hcp[0][hedge[0][i].pt[1]].sharp == 1 &&
	//			(hedge[0][i].pt[0] == hcp[0]_sharp[0] || hedge[0][i].pt[1] == hcp[0]_sharp[0]))//heli coarse
	//		{
	//			hedge[0][i].sharp = 1;
	//		}
	//	}
	//}

	////int hcp[0]_desharp[] = { 1216 };//muanlly remove certain sharp, heli coarse
	//int hcp[0]_desharp[] = { 1580 };//muanlly remove certain sharp, heli coarse loc
	////int hcp[0]_desharp[] = { 12003,12022,12016 };//muanlly remove certain sharp, heli loc
	//int ndeshp(1);
	//for (int i = 0; i < ndeshp; i++)
	//{
	//	hcp[0][hcp[0]_desharp[i]].sharp = 0;
	//	for (uint j = 0; j < hcp[0][hcp[0]_desharp[i]].edge.size(); j++)
	//	{
	//		hedge[0][hcp[0][hcp[0]_desharp[i]].edge[j]].sharp = 0;
	//	}
	//}

	////int hcp[0]_desharp[] = { 7418,7419 };//muanlly remove certain sharp, navair coarse, no pillow
	//int hcp[0]_desharp[] = { 13109,13110 };//muanlly remove certain sharp, navair coarse
	////int hcp[0]_desharp[] = { 30994,36209 };//muanlly remove certain sharp, navair
	//int ndeshp(2);
	//for (int i = 0; i < ndeshp; i++)
	//{
	//	hcp[0][hcp[0]_desharp[i]].sharp = 0;
	//	for (uint j = 0; j < hcp[0][hcp[0]_desharp[i]].edge.size(); j++)
	//	{
	//		hedge[0][hcp[0][hcp[0]_desharp[i]].edge[j]].sharp = 0;
	//	}
	//}

	for (i = 0; i < hcp[0].size(); i++)
	{
		if (hcp[0][i].sharp == 1)
		{
			int nshp(0);
			for (j = 0; j < hcp[0][i].edge.size(); j++)
			{
				if (hedge[0][hcp[0][i].edge[j]].sharp == 1)
				{
					nshp++;
				}
			}
			if (nshp >= 3) hcp[0][i].sharp = 2;//sharp corner
			if (nshp == 1) hcp[0][i].sharp = 2;//
		}
	}
	//for (i = 0; i < tmedge.size(); i++)
	//{
	//	if (tmedge[i].sharp == 1)
	//	{
	//		if (cp[tmedge[i].pt[0]].sharp == 0 || cp[tmedge[i].pt[1]].sharp == 0)
	//		{
	//			tmedge[i].sharp = 0;
	//		}
	//	}
	//}
}

void TruncatedTspline_3D::BuildInitialEdges()
{
	int edloc[12][2] = { {0,1},{1,2},{2,3},{3,0},{0,4},{1,5},{2,6},{3,7},{4,5},{5,6},{6,7},{7,4} };
	int fcloc[6][4] = { {0,3,2,1},{0,1,5,4},{1,2,6,5},{2,3,7,6},{0,4,7,3},{4,5,6,7} };
	int fced[6][4] = { {3,2,1,0},{0,5,8,4},{1,6,9,5},{2,7,10,6},{4,11,7,3},{8,9,10,11} };

	uint i, j, k;
	tmedge.clear();
	tmface.clear();
	//point-hex relation
	for (i = 0; i < tmesh.size(); i++)
	{
		for (j = 0; j < 8; j++)
		{
			cp[tmesh[i].cnct[j]].hex.push_back(i);
		}
	}
	//construct edges
	for (i = 0; i<tmesh.size(); i++)
	{
		vector<int> nb;
		for (j = 0; j < 8; j++)
		{
			for (k = 0; k < cp[tmesh[i].cnct[j]].hex.size(); k++)
			{
				int eid(cp[tmesh[i].cnct[j]].hex[k]);
				if (eid < i)
				{
					vector<int>::iterator it = find(nb.begin(), nb.end(), eid);
					if (it == nb.end())
					{
						nb.push_back(eid);
					}
				}
			}
		}
		for (j = 0; j < 12; j++)//edge
		{
			Edge3D edtmp;
			edtmp.pt[0] = tmesh[i].cnct[edloc[j][0]];
			edtmp.pt[1] = tmesh[i].cnct[edloc[j][1]];
			int flag(-1);
			for (k = 0; k < nb.size(); k++)
			{
				for (int k0 = 0; k0 < 12; k0++)
				{
					if (edtmp == tmedge[tmesh[nb[k]].edge[k0]])
					{
						flag = tmesh[nb[k]].edge[k0]; break;
					}
				}
				if (flag != -1) break;
			}
			if (flag != -1)
			{
				tmesh[i].edge[j] = flag;
			}
			else
			{
				tmedge.push_back(edtmp);
				tmesh[i].edge[j] = tmedge.size() - 1;
			}
		}
		for (j = 0; j < 6; j++)//face
		{
			Face3D fctmp;
			for (k = 0; k < 4; k++)
			{
				fctmp.cnct[k] = tmesh[i].cnct[fcloc[j][k]];
				fctmp.edge[k] = tmesh[i].edge[fced[j][k]];
			}
			int flag(-1);
			for (k = 0; k < nb.size(); k++)
			{
				for (int k0 = 0; k0 < 6; k0++)
				{
					if (fctmp == tmface[tmesh[nb[k]].face[k0]])
					{
						flag = tmesh[nb[k]].face[k0]; break;
					}
				}
				if (flag != -1) break;
			}
			if (flag != -1)
			{
				tmesh[i].face[j] = flag;
			}
			else
			{
				tmface.push_back(fctmp);
				tmesh[i].face[j] = tmface.size() - 1;
			}
		}
	}

	for (i = 0; i<tmesh.size(); i++)
	{
		for (j = 0; j<12; j++)
		{
			tmedge[tmesh[i].edge[j]].hex.push_back(i);
		}
		for (j = 0; j<6; j++)
		{
			tmface[tmesh[i].face[j]].hex.push_back(i);
		}
	}
	for (i = 0; i<tmface.size(); i++)
	{
		for (j = 0; j<4; j++)
		{
			cp[tmface[i].cnct[j]].face.push_back(i);
			tmedge[tmface[i].edge[j]].face.push_back(i);
		}
	}
	for (i = 0; i<tmedge.size(); i++)
	{
		for (j = 0; j<2; j++)
		{
			cp[tmedge[i].pt[j]].edge.push_back(i);
		}
	}
}

void TruncatedTspline_3D::Global_Subdivide()
{
	//body points
	vector<array<double, 3>> pts_bd(tmesh.size());
	for (int i = 0; i < tmesh.size(); i++)
	{
		pts_bd[i][0] = 0.; pts_bd[i][1] = 0.; pts_bd[i][2] = 0.;
		for (int j = 0; j < 8; j++)
		{
			pts_bd[i][0] += cp[tmesh[i].cnct[j]].coor[0];
			pts_bd[i][1] += cp[tmesh[i].cnct[j]].coor[1];
			pts_bd[i][2] += cp[tmesh[i].cnct[j]].coor[2];
		}
		pts_bd[i][0] /= 8.; pts_bd[i][1] /= 8.; pts_bd[i][2] /= 8.;
	}
	//face points
	vector<array<double, 3>> pts_fc0(tmface.size());//simply average
	vector<array<double, 3>> pts_fc(tmface.size());//desired
	for (int i = 0; i < tmface.size(); i++)
	{
		pts_fc0[i][0] = 0.; pts_fc0[i][1] = 0.; pts_fc0[i][2] = 0.;
		for (int j = 0; j < 4; j++)
		{
			pts_fc0[i][0] += cp[tmface[i].cnct[j]].coor[0];
			pts_fc0[i][1] += cp[tmface[i].cnct[j]].coor[1];
			pts_fc0[i][2] += cp[tmface[i].cnct[j]].coor[2];
		}
		pts_fc0[i][0] /= 4.; pts_fc0[i][1] /= 4.; pts_fc0[i][2] /= 4.;
		if (tmface[i].hex.size() == 2)//interior face points
		{
			int hxid[2] = { tmface[i].hex[0], tmface[i].hex[1] };
			pts_fc[i][0] = (pts_bd[hxid[0]][0] + pts_bd[hxid[1]][0] + 2.*pts_fc0[i][0]) / 4.;
			pts_fc[i][1] = (pts_bd[hxid[0]][1] + pts_bd[hxid[1]][1] + 2.*pts_fc0[i][1]) / 4.;
			pts_fc[i][2] = (pts_bd[hxid[0]][2] + pts_bd[hxid[1]][2] + 2.*pts_fc0[i][2]) / 4.;
		}
		else
		{
			pts_fc[i][0] = pts_fc0[i][0]; pts_fc[i][1] = pts_fc0[i][1]; pts_fc[i][2] = pts_fc0[i][2];
		}
	}
	//edge points
	vector<array<double, 3>> pts_ed0(tmedge.size());//simply average
	vector<array<double, 3>> pts_ed(tmedge.size());//desired
	for (int i = 0; i < tmedge.size(); i++)
	{
		pts_ed0[i][0] = (cp[tmedge[i].pt[0]].coor[0] + cp[tmedge[i].pt[1]].coor[0]) / 2.;
		pts_ed0[i][1] = (cp[tmedge[i].pt[0]].coor[1] + cp[tmedge[i].pt[1]].coor[1]) / 2.;
		pts_ed0[i][2] = (cp[tmedge[i].pt[0]].coor[2] + cp[tmedge[i].pt[1]].coor[2]) / 2.;
		if (tmedge[i].type != 1)//non-boundary, i.e. interior
		{
			double cavg[3] = { 0., 0., 0. };
			for (uint j = 0; j < tmedge[i].hex.size(); j++)
			{
				cavg[0] += pts_bd[tmedge[i].hex[j]][0];
				cavg[1] += pts_bd[tmedge[i].hex[j]][1];
				cavg[2] += pts_bd[tmedge[i].hex[j]][2];
			}
			cavg[0] /= double(tmedge[i].hex.size());
			cavg[1] /= double(tmedge[i].hex.size());
			cavg[2] /= double(tmedge[i].hex.size());
			double aavg[3] = { 0., 0., 0. };
			for (uint j = 0; j < tmedge[i].face.size(); j++)
			{
				aavg[0] += pts_fc0[tmedge[i].face[j]][0];
				aavg[1] += pts_fc0[tmedge[i].face[j]][1];
				aavg[2] += pts_fc0[tmedge[i].face[j]][2];
			}
			aavg[0] /= double(tmedge[i].face.size());
			aavg[1] /= double(tmedge[i].face.size());
			aavg[2] /= double(tmedge[i].face.size());
			pts_ed[i][0] = (cavg[0] + 2.*aavg[0] + double(tmedge[i].face.size() - 3)*pts_ed0[i][0]) / double(tmedge[i].face.size());
			pts_ed[i][1] = (cavg[1] + 2.*aavg[1] + double(tmedge[i].face.size() - 3)*pts_ed0[i][1]) / double(tmedge[i].face.size());
			pts_ed[i][2] = (cavg[2] + 2.*aavg[2] + double(tmedge[i].face.size() - 3)*pts_ed0[i][2]) / double(tmedge[i].face.size());
		}
		else
		{
			if (tmedge[i].sharp == 0)//boundary non-sharp edge
			{
				double aavg[3] = { 0., 0., 0. };
				for (uint j = 0; j < tmedge[i].face.size(); j++)
				{
					if (tmface[tmedge[i].face[j]].type == 1)
					{
						aavg[0] += pts_fc0[tmedge[i].face[j]][0];
						aavg[1] += pts_fc0[tmedge[i].face[j]][1];
						aavg[2] += pts_fc0[tmedge[i].face[j]][2];
					}
				}
				pts_ed[i][0] = (aavg[0] + 2.*pts_ed0[i][0]) / 4.;
				pts_ed[i][1] = (aavg[1] + 2.*pts_ed0[i][1]) / 4.;
				pts_ed[i][2] = (aavg[2] + 2.*pts_ed0[i][2]) / 4.;
			}
			else//sharp edge
			{
				pts_ed[i][0] = pts_ed0[i][0];
				pts_ed[i][1] = pts_ed0[i][1];
				pts_ed[i][2] = pts_ed0[i][2];
			}
		}
	}
	//vertex points
#pragma omp parallel for
	for (int i = 0; i < cp.size(); i++)
	{
		if (cp[i].type != 1)//interior
		{
			double cavg[3] = { 0., 0., 0. };
			for (uint j = 0; j < cp[i].hex.size(); j++)
			{
				cavg[0] += pts_bd[cp[i].hex[j]][0];
				cavg[1] += pts_bd[cp[i].hex[j]][1];
				cavg[2] += pts_bd[cp[i].hex[j]][2];
			}
			cavg[0] /= double(cp[i].hex.size());
			cavg[1] /= double(cp[i].hex.size());
			cavg[2] /= double(cp[i].hex.size());
			double aavg[3] = { 0., 0., 0. };
			for (uint j = 0; j < cp[i].face.size(); j++)
			{
				aavg[0] += pts_fc0[cp[i].face[j]][0];
				aavg[1] += pts_fc0[cp[i].face[j]][1];
				aavg[2] += pts_fc0[cp[i].face[j]][2];
			}
			aavg[0] /= double(cp[i].face.size());
			aavg[1] /= double(cp[i].face.size());
			aavg[2] /= double(cp[i].face.size());
			double mavg[3] = { 0., 0., 0. };
			for (uint j = 0; j < cp[i].edge.size(); j++)
			{
				mavg[0] += pts_ed0[cp[i].edge[j]][0];
				mavg[1] += pts_ed0[cp[i].edge[j]][1];
				mavg[2] += pts_ed0[cp[i].edge[j]][2];
			}
			mavg[0] /= double(cp[i].edge.size());
			mavg[1] /= double(cp[i].edge.size());
			mavg[2] /= double(cp[i].edge.size());
			cp[i].coor[0] = (cavg[0] + 3.*aavg[0] + 3.*mavg[0] + cp[i].coor[0]) / 8.;
			cp[i].coor[1] = (cavg[1] + 3.*aavg[1] + 3.*mavg[1] + cp[i].coor[1]) / 8.;
			cp[i].coor[2] = (cavg[2] + 3.*aavg[2] + 3.*mavg[2] + cp[i].coor[2]) / 8.;
		}
		else
		{
			if (cp[i].sharp == 0)
			{
				double aavg[3] = { 0., 0., 0. };
				int nfc(0);
				for (uint j = 0; j < cp[i].face.size(); j++)
				{
					if (tmface[cp[i].face[j]].type == 1)
					{
						aavg[0] += pts_fc0[cp[i].face[j]][0];
						aavg[1] += pts_fc0[cp[i].face[j]][1];
						aavg[2] += pts_fc0[cp[i].face[j]][2];
						nfc++;
					}
				}
				aavg[0] /= double(nfc); aavg[1] /= double(nfc); aavg[2] /= double(nfc);
				double mavg[3] = { 0., 0., 0. };
				int ned(0);
				for (uint j = 0; j < cp[i].edge.size(); j++)
				{
					if (tmedge[cp[i].edge[j]].type == 1)
					{
						mavg[0] += pts_ed0[cp[i].edge[j]][0];
						mavg[1] += pts_ed0[cp[i].edge[j]][1];
						mavg[2] += pts_ed0[cp[i].edge[j]][2];
						ned++;
					}
				}
				mavg[0] /= double(ned); mavg[1] /= double(ned); mavg[2] /= double(ned);
				cp[i].coor[0] = (aavg[0] + 2.*mavg[0] + double(nfc - 3)*cp[i].coor[0]) / double(nfc);
				cp[i].coor[1] = (aavg[1] + 2.*mavg[1] + double(nfc - 3)*cp[i].coor[1]) / double(nfc);
				cp[i].coor[2] = (aavg[2] + 2.*mavg[2] + double(nfc - 3)*cp[i].coor[2]) / double(nfc);
			}
			else if (cp[i].sharp == 1)//associated with sharp edge
			{
				double mavg[3] = { 0., 0., 0. };
				for (uint j = 0; j < cp[i].edge.size(); j++)
				{
					if (tmedge[cp[i].edge[j]].sharp == 1)
					{
						mavg[0] += pts_ed0[cp[i].edge[j]][0];
						mavg[1] += pts_ed0[cp[i].edge[j]][1];
						mavg[2] += pts_ed0[cp[i].edge[j]][2];
					}
				}
				cp[i].coor[0] = (mavg[0] + 2.*cp[i].coor[0]) / 4.;
				cp[i].coor[1] = (mavg[1] + 2.*cp[i].coor[1]) / 4.;
				cp[i].coor[2] = (mavg[2] + 2.*cp[i].coor[2]) / 4.;
			}
			else//sharp corner
			{
				cp[i].coor[0] = cp[i].coor[0]; cp[i].coor[1] = cp[i].coor[1]; cp[i].coor[2] = cp[i].coor[2];
			}
		}
	}
#pragma omp barrier
	//update cp
	vector<int> pid_vt(cp.size());
	vector<int> pid_ed(tmedge.size());
	vector<int> pid_fc(tmface.size());
	vector<int> pid_bd(tmesh.size());
	int count(0);
	for (int i = 0; i < cp.size(); i++)
	{
		pid_vt[i] = count++;
	}
	for (int i = 0; i < tmedge.size(); i++)
	{
		pid_ed[i] = count++;
		Vertex3D ptmp;
		ptmp.act = 1;
		if (tmedge[i].type == 1) ptmp.type = 1;//default 0
		if (tmedge[i].sharp == 1) ptmp.sharp = 1;//default 0
		ptmp.coor[0] = pts_ed[i][0]; ptmp.coor[1] = pts_ed[i][1]; ptmp.coor[2] = pts_ed[i][2];
		cp.push_back(ptmp);
	}
	for (int i = 0; i < tmface.size(); i++)
	{
		pid_fc[i] = count++;
		Vertex3D ptmp;
		ptmp.act = 1;
		if (tmface[i].type == 1) ptmp.type = 1;//default 0
		ptmp.coor[0] = pts_fc[i][0]; ptmp.coor[1] = pts_fc[i][1]; ptmp.coor[2] = pts_fc[i][2];
		cp.push_back(ptmp);
	}
	for (int i = 0; i < tmesh.size(); i++)
	{
		pid_bd[i] = count++;
		Vertex3D ptmp;
		ptmp.act = 1;
		ptmp.coor[0] = pts_bd[i][0]; ptmp.coor[1] = pts_bd[i][1]; ptmp.coor[2] = pts_bd[i][2];
		cp.push_back(ptmp);
	}
	//update edge
	vector<Edge3D> ednew(2 * tmedge.size() + 4 * tmface.size() + 6 * tmesh.size());
	int edloc(0);
	for (int i = 0; i < tmedge.size(); i++)
	{
		ednew[edloc].pt[0] = tmedge[i].pt[0];
		ednew[edloc].pt[1] = pid_ed[i];
		ednew[edloc].type = tmedge[i].type;
		ednew[edloc].sharp = tmedge[i].sharp;
		edloc++;
		ednew[edloc].pt[0] = pid_ed[i];
		ednew[edloc].pt[1] = tmedge[i].pt[1];
		ednew[edloc].type = tmedge[i].type;
		ednew[edloc].sharp = tmedge[i].sharp;
		edloc++;
	}
	//update face
	vector<Face3D> fcnew(4 * tmface.size() + 12 * tmesh.size());
	int fcloc(0);
	for (int i = 0; i < tmface.size(); i++)
	{
		int fcnct[4][4] = { { tmface[i].cnct[0], pid_ed[tmface[i].edge[0]], pid_fc[i], pid_ed[tmface[i].edge[3]] },
		{ pid_ed[tmface[i].edge[0]], tmface[i].cnct[1], pid_ed[tmface[i].edge[1]], pid_fc[i] },
		{ pid_fc[i], pid_ed[tmface[i].edge[1]], tmface[i].cnct[2], pid_ed[tmface[i].edge[2]] },
		{ pid_ed[tmface[i].edge[3]], pid_fc[i], pid_ed[tmface[i].edge[2]], tmface[i].cnct[3] } };
		int edid[12];
		for (int j = 0; j < 4; j++)
		{
			edid[2 * j] = 2 * tmface[i].edge[j]; edid[2 * j + 1] = 2 * tmface[i].edge[j] + 1;
			if (tmedge[tmface[i].edge[j]].pt[0] != tmface[i].cnct[j])
			{
				edid[2 * j] = 2 * tmface[i].edge[j] + 1; edid[2 * j + 1] = 2 * tmface[i].edge[j];
			}
		}
		//construct 4 new edges
		for (int j = 0; j < 4; j++)
		{
			ednew[edloc].pt[0] = pid_fc[i];
			ednew[edloc].pt[1] = pid_ed[tmface[i].edge[j]];
			if (tmface[i].type == 1) ednew[edloc].type = 1;
			edid[8 + j] = edloc;
			edloc++;
		}
		int fedge[4][4] = { { edid[0], edid[8], edid[11], edid[7] }, { edid[1], edid[2], edid[9], edid[8] },
		{ edid[9], edid[3], edid[4], edid[10] }, { edid[11], edid[10], edid[5], edid[6] } };
		for (int j = 0; j < 4; j++)
		{
			fcnew[fcloc].type = tmface[i].type;
			for (int k = 0; k < 4; k++)
			{
				fcnew[fcloc].cnct[k] = fcnct[j][k];
				fcnew[fcloc].edge[k] = fedge[j][k];
			}
			fcloc++;
		}
	}
	//update hex
	vector<Element3D> hxnew(8 * tmesh.size());
	int hxloc(0);
	for (int i = 0; i < tmesh.size(); i++)
	{
		//construct new edges
		for (int j = 0; j < 6; j++)
		{
			ednew[edloc].pt[0] = pid_bd[i];
			ednew[edloc].pt[1] = pid_fc[tmesh[i].face[j]];
			edloc++;
		}
		//construct new faces
		int fcnct[12][4] = { { pid_ed[tmesh[i].edge[0]], pid_fc[tmesh[i].face[0]], pid_bd[i], pid_fc[tmesh[i].face[1]] },
		{ pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[2]], pid_fc[tmesh[i].face[3]], pid_bd[i] },
		{ pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[10]], pid_fc[tmesh[i].face[5]] },
		{ pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[8]] },
		{ pid_ed[tmesh[i].edge[3]], pid_fc[tmesh[i].face[0]], pid_bd[i], pid_fc[tmesh[i].face[4]] },
		{ pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[1]], pid_fc[tmesh[i].face[2]], pid_bd[i] },
		{ pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[9]], pid_fc[tmesh[i].face[5]] },
		{ pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[11]] },
		{ pid_ed[tmesh[i].edge[4]], pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[4]] },
		{ pid_fc[tmesh[i].face[1]], pid_ed[tmesh[i].edge[5]], pid_fc[tmesh[i].face[2]], pid_bd[i] },
		{ pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[6]], pid_fc[tmesh[i].face[3]] },
		{ pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[7]] } };
		//collect all edges and faces in this element
		int edids[12 * 2 + 6 * 4 + 6], fcids[6 * 4 + 12];
		for (int j = 0; j < 12; j++)
		{
			edids[2 * j] = 2 * tmesh[i].edge[j];
			edids[2 * j + 1] = 2 * tmesh[i].edge[j] + 1;
			fcids[24 + j] = 4 * tmface.size() + 12 * i + j;
		}
		for (int j = 0; j < 6; j++)
		{
			edids[24 + 4 * j] = 2 * tmedge.size() + 4 * tmesh[i].face[j];
			edids[24 + 4 * j + 1] = 2 * tmedge.size() + 4 * tmesh[i].face[j] + 1;
			edids[24 + 4 * j + 2] = 2 * tmedge.size() + 4 * tmesh[i].face[j] + 2;
			edids[24 + 4 * j + 3] = 2 * tmedge.size() + 4 * tmesh[i].face[j] + 3;
			edids[48 + j] = 2 * tmedge.size() + 4 * tmface.size() + 6 * i + j;
			fcids[4 * j] = 4 * tmesh[i].face[j];
			fcids[4 * j + 1] = 4 * tmesh[i].face[j] + 1;
			fcids[4 * j + 2] = 4 * tmesh[i].face[j] + 2;
			fcids[4 * j + 3] = 4 * tmesh[i].face[j] + 3;
		}
		for (int j = 0; j < 12; j++)
		{
			for (int k = 0; k < 4; k++)
			{
				fcnew[fcloc].cnct[k] = fcnct[j][k];
				for (int k0 = 24; k0 < 54; k0++)
				{
					if ((fcnct[j][k] == ednew[edids[k0]].pt[0] && fcnct[j][(k + 1) % 4] == ednew[edids[k0]].pt[1]) || 
						(fcnct[j][k] == ednew[edids[k0]].pt[1] && fcnct[j][(k + 1) % 4] == ednew[edids[k0]].pt[0]))
					{
						fcnew[fcloc].edge[k] = edids[k0]; break;
					}
				}
			}
			fcloc++;
		}
		//construct new hex
		int ecnct[8][8] = { { tmesh[i].cnct[0], pid_ed[tmesh[i].edge[0]], pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[3]], pid_ed[tmesh[i].edge[4]], pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[4]] },
		{ pid_ed[tmesh[i].edge[0]], tmesh[i].cnct[1], pid_ed[tmesh[i].edge[1]], pid_fc[tmesh[i].face[0]], pid_fc[tmesh[i].face[1]], pid_ed[tmesh[i].edge[5]], pid_fc[tmesh[i].face[2]], pid_bd[i] },
		{ pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[1]], tmesh[i].cnct[2], pid_ed[tmesh[i].edge[2]], pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[6]], pid_fc[tmesh[i].face[3]] },
		{ pid_ed[tmesh[i].edge[3]], pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[2]], tmesh[i].cnct[3], pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[7]] },
		{ pid_ed[tmesh[i].edge[4]], pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[4]], tmesh[i].cnct[4], pid_ed[tmesh[i].edge[8]], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[11]] },
		{ pid_fc[tmesh[i].face[1]], pid_ed[tmesh[i].edge[5]], pid_fc[tmesh[i].face[2]], pid_bd[i], pid_ed[tmesh[i].edge[8]], tmesh[i].cnct[5], pid_ed[tmesh[i].edge[9]], pid_fc[tmesh[i].face[5]] },
		{ pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[6]], pid_fc[tmesh[i].face[3]], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[9]], tmesh[i].cnct[6], pid_ed[tmesh[i].edge[10]] },
		{ pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[7]], pid_ed[tmesh[i].edge[11]], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[10]], tmesh[i].cnct[7] } };
		for (int j = 0; j < 8; j++)
		{
			for (int k = 0; k < 8; k++)
			{
				hxnew[hxloc].cnct[k] = ecnct[j][k];
			}
			//find face connectivity
			for (int k = 0; k < 6; k++)
			{
				array<int, 4> tmp1 = { ecnct[j][solid_fc[k][0]], ecnct[j][solid_fc[k][1]], ecnct[j][solid_fc[k][2]], ecnct[j][solid_fc[k][3]] };
				sort(tmp1.begin(), tmp1.end());
				for (int k0 = 0; k0 < 36; k0++)
				{
					array<int, 4> tmp2 = { fcnew[fcids[k0]].cnct[0], fcnew[fcids[k0]].cnct[1], fcnew[fcids[k0]].cnct[2], fcnew[fcids[k0]].cnct[3] };
					sort(tmp2.begin(), tmp2.end());
					if (tmp1 == tmp2)
					{
						hxnew[hxloc].face[k] = fcids[k0]; break;
					}
				}
			}
			//find edge connectivity
			for (int k = 0; k < 12; k++)
			{
				array<int, 2> tmp1 = { ecnct[j][solid_ed[k][0]], ecnct[j][solid_ed[k][1]] };
				for (int k0 = 0; k0 < 54; k0++)
				{
					if ((tmp1[0] == ednew[edids[k0]].pt[0] && tmp1[1] == ednew[edids[k0]].pt[1]) ||
						(tmp1[0] == ednew[edids[k0]].pt[1] && tmp1[1] == ednew[edids[k0]].pt[0]))
					{
						hxnew[hxloc].edge[k] = edids[k0]; break;
					}
				}
			}
			hxloc++;
		}
	}
	//update connectivity
	tmedge.resize(ednew.size());
	tmface.resize(fcnew.size());
	tmesh.resize(hxnew.size());
	for (int i = 0; i < cp.size(); i++)
	{
		cp[i].edge.clear();
		cp[i].face.clear();
		cp[i].hex.clear();
	}
	for (int i = 0; i < ednew.size(); i++)
	{
		tmedge[i].act = 1;
		tmedge[i].type = ednew[i].type;
		tmedge[i].sharp = ednew[i].sharp;
		tmedge[i].pt[0] = ednew[i].pt[0]; tmedge[i].pt[1] = ednew[i].pt[1];
		tmedge[i].face.clear();
		tmedge[i].hex.clear();
	}
	for (int i = 0; i < fcnew.size(); i++)
	{
		tmface[i].act = 1;
		tmface[i].type = fcnew[i].type;
		for (int j = 0; j < 4; j++)
		{
			tmface[i].cnct[j] = fcnew[i].cnct[j];
			tmface[i].edge[j] = fcnew[i].edge[j];
		}
		tmface[i].hex.clear();
	}
	for (int i = 0; i < hxnew.size(); i++)
	{
		tmesh[i].act = 1;
		tmesh[i].type = hxnew[i].type;
		for (int j = 0; j < 8; j++)
		{
			tmesh[i].cnct[j] = hxnew[i].cnct[j];
		}
		for (int j = 0; j < 12; j++)
		{
			tmesh[i].edge[j] = hxnew[i].edge[j];
		}
		for (int j = 0; j < 6; j++)
		{
			tmesh[i].face[j] = hxnew[i].face[j];
		}
	}
	//vertex-to-hex, edge-to-hex, face-to-hex
	for (int i = 0; i<tmesh.size(); i++)
	{
		for (int j = 0; j<8; j++)
		{
			cp[tmesh[i].cnct[j]].hex.push_back(i);
		}
		for (int j = 0; j<12; j++)
		{
			tmedge[tmesh[i].edge[j]].hex.push_back(i);
		}
		for (int j = 0; j<6; j++)
		{
			tmface[tmesh[i].face[j]].hex.push_back(i);
		}
	}
	//vertex-to-face, edge-to-face
	for (int i = 0; i<tmface.size(); i++)
	{
		for (int j = 0; j<4; j++)
		{
			cp[tmface[i].cnct[j]].face.push_back(i);
			tmedge[tmface[i].edge[j]].face.push_back(i);
		}
	}
	//vertex-to-edge
	for (int i = 0; i<tmedge.size(); i++)
	{
		for (int j = 0; j<2; j++)
		{
			cp[tmedge[i].pt[j]].edge.push_back(i);
		}
	}
	//find extraordinary edges and vertices
	for (int i = 0; i<tmedge.size(); i++)
	{
		if (tmedge[i].type != 1 && tmedge[i].hex.size() != 4)
		{
			tmedge[i].type = 2;
			if (cp[tmedge[i].pt[0]].type != 1)
				cp[tmedge[i].pt[0]].type = 3;
			if (cp[tmedge[i].pt[1]].type != 1)
				cp[tmedge[i].pt[1]].type = 3;
		}
	}
	//
	//find boundary and irregular elements
	for (int i = 0; i<tmesh.size(); i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (cp[tmesh[i].cnct[j]].type == 1)
			{
				tmesh[i].type = 1; break;
			}
		}
		if (tmesh[i].type != 1)
		{
			for (int j = 0; j<12; j++)
			{
				if (tmedge[tmesh[i].edge[j]].type == 2)
				{
					tmesh[i].type = 2;
					break;
				}
			}
		}
	}

	//boundry extraordinary points
	//for (int i = 0; i<cp.size(); i++)
	//{
	//	if (cp[i].type == 1)
	//	{
	//		int count(0);
	//		for (j = 0; j < cp[i].edge.size(); j++)
	//		{
	//			if (tmedge[cp[i].edge[j]].type == 2) count++;
	//		}
	//		if (count == 1) cp[i].bcxp = 1;
	//		else if (count>1) cp[i].bcxp = 2;
	//	}
	//}
}

void TruncatedTspline_3D::Global_Subdivide_Simple()
{
	//body points
	vector<array<double, 3>> pts_bd(tmesh.size());
	for (int i = 0; i < tmesh.size(); i++)
	{
		pts_bd[i][0] = 0.; pts_bd[i][1] = 0.; pts_bd[i][2] = 0.;
		for (int j = 0; j < 8; j++)
		{
			pts_bd[i][0] += cp[tmesh[i].cnct[j]].coor[0];
			pts_bd[i][1] += cp[tmesh[i].cnct[j]].coor[1];
			pts_bd[i][2] += cp[tmesh[i].cnct[j]].coor[2];
		}
		pts_bd[i][0] /= 8.; pts_bd[i][1] /= 8.; pts_bd[i][2] /= 8.;
	}
	//face points
	vector<array<double, 3>> pts_fc0(tmface.size());//simply average
	vector<array<double, 3>> pts_fc(tmface.size());//desired
	for (int i = 0; i < tmface.size(); i++)
	{
		pts_fc0[i][0] = 0.; pts_fc0[i][1] = 0.; pts_fc0[i][2] = 0.;
		for (int j = 0; j < 4; j++)
		{
			pts_fc0[i][0] += cp[tmface[i].cnct[j]].coor[0];
			pts_fc0[i][1] += cp[tmface[i].cnct[j]].coor[1];
			pts_fc0[i][2] += cp[tmface[i].cnct[j]].coor[2];
		}
		pts_fc0[i][0] /= 4.; pts_fc0[i][1] /= 4.; pts_fc0[i][2] /= 4.;
		pts_fc[i][0] = pts_fc0[i][0]; pts_fc[i][1] = pts_fc0[i][1]; pts_fc[i][2] = pts_fc0[i][2];
		//if (tmface[i].hex.size() == 2)//interior face points
		//{
		//	int hxid[2] = { tmface[i].hex[0], tmface[i].hex[1] };
		//	pts_fc[i][0] = (pts_bd[hxid[0]][0] + pts_bd[hxid[1]][0] + 2.*pts_fc0[i][0]) / 4.;
		//	pts_fc[i][1] = (pts_bd[hxid[0]][1] + pts_bd[hxid[1]][1] + 2.*pts_fc0[i][1]) / 4.;
		//	pts_fc[i][2] = (pts_bd[hxid[0]][2] + pts_bd[hxid[1]][2] + 2.*pts_fc0[i][2]) / 4.;
		//	
		//}
		//else
		//{
		//	pts_fc[i][0] = pts_fc0[i][0]; pts_fc[i][1] = pts_fc0[i][1]; pts_fc[i][2] = pts_fc0[i][2];
		//}
	}
	//edge points
	vector<array<double, 3>> pts_ed0(tmedge.size());//simply average
	vector<array<double, 3>> pts_ed(tmedge.size());//desired
	for (int i = 0; i < tmedge.size(); i++)
	{
		pts_ed0[i][0] = (cp[tmedge[i].pt[0]].coor[0] + cp[tmedge[i].pt[1]].coor[0]) / 2.;
		pts_ed0[i][1] = (cp[tmedge[i].pt[0]].coor[1] + cp[tmedge[i].pt[1]].coor[1]) / 2.;
		pts_ed0[i][2] = (cp[tmedge[i].pt[0]].coor[2] + cp[tmedge[i].pt[1]].coor[2]) / 2.;
		pts_ed[i][0] = pts_ed0[i][0];
		pts_ed[i][1] = pts_ed0[i][1];
		pts_ed[i][2] = pts_ed0[i][2];
		//if (tmedge[i].type != 1)//non-boundary, i.e. interior
		//{
		//	double cavg[3] = { 0., 0., 0. };
		//	for (uint j = 0; j < tmedge[i].hex.size(); j++)
		//	{
		//		cavg[0] += pts_bd[tmedge[i].hex[j]][0];
		//		cavg[1] += pts_bd[tmedge[i].hex[j]][1];
		//		cavg[2] += pts_bd[tmedge[i].hex[j]][2];
		//	}
		//	cavg[0] /= double(tmedge[i].hex.size());
		//	cavg[1] /= double(tmedge[i].hex.size());
		//	cavg[2] /= double(tmedge[i].hex.size());
		//	double aavg[3] = { 0., 0., 0. };
		//	for (uint j = 0; j < tmedge[i].face.size(); j++)
		//	{
		//		aavg[0] += pts_fc0[tmedge[i].face[j]][0];
		//		aavg[1] += pts_fc0[tmedge[i].face[j]][1];
		//		aavg[2] += pts_fc0[tmedge[i].face[j]][2];
		//	}
		//	aavg[0] /= double(tmedge[i].face.size());
		//	aavg[1] /= double(tmedge[i].face.size());
		//	aavg[2] /= double(tmedge[i].face.size());
		//	pts_ed[i][0] = (cavg[0] + 2.*aavg[0] + double(tmedge[i].face.size() - 3)*pts_ed0[i][0]) / double(tmedge[i].face.size());
		//	pts_ed[i][1] = (cavg[1] + 2.*aavg[1] + double(tmedge[i].face.size() - 3)*pts_ed0[i][1]) / double(tmedge[i].face.size());
		//	pts_ed[i][2] = (cavg[2] + 2.*aavg[2] + double(tmedge[i].face.size() - 3)*pts_ed0[i][2]) / double(tmedge[i].face.size());
		//}
		//else
		//{
		//	if (tmedge[i].sharp == 0)//boundary non-sharp edge
		//	{
		//		double aavg[3] = { 0., 0., 0. };
		//		for (uint j = 0; j < tmedge[i].face.size(); j++)
		//		{
		//			if (tmface[tmedge[i].face[j]].type == 1)
		//			{
		//				aavg[0] += pts_fc0[tmedge[i].face[j]][0];
		//				aavg[1] += pts_fc0[tmedge[i].face[j]][1];
		//				aavg[2] += pts_fc0[tmedge[i].face[j]][2];
		//			}
		//		}
		//		pts_ed[i][0] = (aavg[0] + 2.*pts_ed0[i][0]) / 4.;
		//		pts_ed[i][1] = (aavg[1] + 2.*pts_ed0[i][1]) / 4.;
		//		pts_ed[i][2] = (aavg[2] + 2.*pts_ed0[i][2]) / 4.;
		//	}
		//	else//sharp edge
		//	{
		//		pts_ed[i][0] = pts_ed0[i][0];
		//		pts_ed[i][1] = pts_ed0[i][1];
		//		pts_ed[i][2] = pts_ed0[i][2];
		//	}
		//}
	}
	//vertex points
	//for (int i = 0; i < cp.size(); i++)
	//{
	//	if (cp[i].type != 1)//interior
	//	{
	//		double cavg[3] = { 0., 0., 0. };
	//		for (uint j = 0; j < cp[i].hex.size(); j++)
	//		{
	//			cavg[0] += pts_bd[cp[i].hex[j]][0];
	//			cavg[1] += pts_bd[cp[i].hex[j]][1];
	//			cavg[2] += pts_bd[cp[i].hex[j]][2];
	//		}
	//		cavg[0] /= double(cp[i].hex.size());
	//		cavg[1] /= double(cp[i].hex.size());
	//		cavg[2] /= double(cp[i].hex.size());
	//		double aavg[3] = { 0., 0., 0. };
	//		for (uint j = 0; j < cp[i].face.size(); j++)
	//		{
	//			aavg[0] += pts_fc0[cp[i].face[j]][0];
	//			aavg[1] += pts_fc0[cp[i].face[j]][1];
	//			aavg[2] += pts_fc0[cp[i].face[j]][2];
	//		}
	//		aavg[0] /= double(cp[i].face.size());
	//		aavg[1] /= double(cp[i].face.size());
	//		aavg[2] /= double(cp[i].face.size());
	//		double mavg[3] = { 0., 0., 0. };
	//		for (uint j = 0; j < cp[i].edge.size(); j++)
	//		{
	//			mavg[0] += pts_ed0[cp[i].edge[j]][0];
	//			mavg[1] += pts_ed0[cp[i].edge[j]][1];
	//			mavg[2] += pts_ed0[cp[i].edge[j]][2];
	//		}
	//		mavg[0] /= double(cp[i].edge.size());
	//		mavg[1] /= double(cp[i].edge.size());
	//		mavg[2] /= double(cp[i].edge.size());
	//		cp[i].coor[0] = (cavg[0] + 3.*aavg[0] + 3.*mavg[0] + cp[i].coor[0]) / 8.;
	//		cp[i].coor[1] = (cavg[1] + 3.*aavg[1] + 3.*mavg[1] + cp[i].coor[1]) / 8.;
	//		cp[i].coor[2] = (cavg[2] + 3.*aavg[2] + 3.*mavg[2] + cp[i].coor[2]) / 8.;
	//	}
	//	else
	//	{
	//		if (cp[i].sharp == 0)
	//		{
	//			double aavg[3] = { 0., 0., 0. };
	//			int nfc(0);
	//			for (uint j = 0; j < cp[i].face.size(); j++)
	//			{
	//				if (tmface[cp[i].face[j]].type == 1)
	//				{
	//					aavg[0] += pts_fc0[cp[i].face[j]][0];
	//					aavg[1] += pts_fc0[cp[i].face[j]][1];
	//					aavg[2] += pts_fc0[cp[i].face[j]][2];
	//					nfc++;
	//				}
	//			}
	//			aavg[0] /= double(nfc); aavg[1] /= double(nfc); aavg[2] /= double(nfc);
	//			double mavg[3] = { 0., 0., 0. };
	//			int ned(0);
	//			for (uint j = 0; j < cp[i].edge.size(); j++)
	//			{
	//				if (tmedge[cp[i].edge[j]].type == 1)
	//				{
	//					mavg[0] += pts_ed0[cp[i].edge[j]][0];
	//					mavg[1] += pts_ed0[cp[i].edge[j]][1];
	//					mavg[2] += pts_ed0[cp[i].edge[j]][2];
	//					ned++;
	//				}
	//			}
	//			mavg[0] /= double(ned); mavg[1] /= double(ned); mavg[2] /= double(ned);
	//			cp[i].coor[0] = (aavg[0] + 2.*mavg[0] + double(nfc - 3)*cp[i].coor[0]) / double(nfc);
	//			cp[i].coor[1] = (aavg[1] + 2.*mavg[1] + double(nfc - 3)*cp[i].coor[1]) / double(nfc);
	//			cp[i].coor[2] = (aavg[2] + 2.*mavg[2] + double(nfc - 3)*cp[i].coor[2]) / double(nfc);
	//		}
	//		else if (cp[i].sharp == 1)//associated with sharp edge
	//		{
	//			double mavg[3] = { 0., 0., 0. };
	//			for (uint j = 0; j < cp[i].edge.size(); j++)
	//			{
	//				if (tmedge[cp[i].edge[j]].sharp == 1)
	//				{
	//					mavg[0] += pts_ed0[cp[i].edge[j]][0];
	//					mavg[1] += pts_ed0[cp[i].edge[j]][1];
	//					mavg[2] += pts_ed0[cp[i].edge[j]][2];
	//				}
	//			}
	//			cp[i].coor[0] = (mavg[0] + 2.*cp[i].coor[0]) / 4.;
	//			cp[i].coor[1] = (mavg[1] + 2.*cp[i].coor[1]) / 4.;
	//			cp[i].coor[2] = (mavg[2] + 2.*cp[i].coor[2]) / 4.;
	//		}
	//		else//sharp corner
	//		{
	//			cp[i].coor[0] = cp[i].coor[0]; cp[i].coor[1] = cp[i].coor[1]; cp[i].coor[2] = cp[i].coor[2];
	//		}
	//	}
	//}
	//update cp
	vector<int> pid_vt(cp.size());
	vector<int> pid_ed(tmedge.size());
	vector<int> pid_fc(tmface.size());
	vector<int> pid_bd(tmesh.size());
	int count(0);
	for (int i = 0; i < cp.size(); i++)
	{
		pid_vt[i] = count++;
	}
	for (int i = 0; i < tmedge.size(); i++)
	{
		pid_ed[i] = count++;
		Vertex3D ptmp;
		ptmp.act = 1;
		if (tmedge[i].type == 1) ptmp.type = 1;//default 0
		if (tmedge[i].sharp == 1) ptmp.sharp = 1;//default 0
		ptmp.coor[0] = pts_ed[i][0]; ptmp.coor[1] = pts_ed[i][1]; ptmp.coor[2] = pts_ed[i][2];
		cp.push_back(ptmp);
	}
	for (int i = 0; i < tmface.size(); i++)
	{
		pid_fc[i] = count++;
		Vertex3D ptmp;
		ptmp.act = 1;
		if (tmface[i].type == 1) ptmp.type = 1;//default 0
		ptmp.coor[0] = pts_fc[i][0]; ptmp.coor[1] = pts_fc[i][1]; ptmp.coor[2] = pts_fc[i][2];
		cp.push_back(ptmp);
	}
	for (int i = 0; i < tmesh.size(); i++)
	{
		pid_bd[i] = count++;
		Vertex3D ptmp;
		ptmp.act = 1;
		ptmp.coor[0] = pts_bd[i][0]; ptmp.coor[1] = pts_bd[i][1]; ptmp.coor[2] = pts_bd[i][2];
		cp.push_back(ptmp);
	}
	//update edge
	vector<Edge3D> ednew(2 * tmedge.size() + 4 * tmface.size() + 6 * tmesh.size());
	int edloc(0);
	for (int i = 0; i < tmedge.size(); i++)
	{
		ednew[edloc].pt[0] = tmedge[i].pt[0];
		ednew[edloc].pt[1] = pid_ed[i];
		ednew[edloc].type = tmedge[i].type;
		ednew[edloc].sharp = tmedge[i].sharp;
		edloc++;
		ednew[edloc].pt[0] = pid_ed[i];
		ednew[edloc].pt[1] = tmedge[i].pt[1];
		ednew[edloc].type = tmedge[i].type;
		ednew[edloc].sharp = tmedge[i].sharp;
		edloc++;
	}
	//update face
	vector<Face3D> fcnew(4 * tmface.size() + 12 * tmesh.size());
	int fcloc(0);
	for (int i = 0; i < tmface.size(); i++)
	{
		int fcnct[4][4] = { { tmface[i].cnct[0], pid_ed[tmface[i].edge[0]], pid_fc[i], pid_ed[tmface[i].edge[3]] },
		{ pid_ed[tmface[i].edge[0]], tmface[i].cnct[1], pid_ed[tmface[i].edge[1]], pid_fc[i] },
		{ pid_fc[i], pid_ed[tmface[i].edge[1]], tmface[i].cnct[2], pid_ed[tmface[i].edge[2]] },
		{ pid_ed[tmface[i].edge[3]], pid_fc[i], pid_ed[tmface[i].edge[2]], tmface[i].cnct[3] } };
		int edid[12];
		for (int j = 0; j < 4; j++)
		{
			edid[2 * j] = 2 * tmface[i].edge[j]; edid[2 * j + 1] = 2 * tmface[i].edge[j] + 1;
			if (tmedge[tmface[i].edge[j]].pt[0] != tmface[i].cnct[j])
			{
				edid[2 * j] = 2 * tmface[i].edge[j] + 1; edid[2 * j + 1] = 2 * tmface[i].edge[j];
			}
		}
		//construct 4 new edges
		for (int j = 0; j < 4; j++)
		{
			ednew[edloc].pt[0] = pid_fc[i];
			ednew[edloc].pt[1] = pid_ed[tmface[i].edge[j]];
			if (tmface[i].type == 1) ednew[edloc].type = 1;
			edid[8 + j] = edloc;
			edloc++;
		}
		int fedge[4][4] = { { edid[0], edid[8], edid[11], edid[7] }, { edid[1], edid[2], edid[9], edid[8] },
		{ edid[9], edid[3], edid[4], edid[10] }, { edid[11], edid[10], edid[5], edid[6] } };
		for (int j = 0; j < 4; j++)
		{
			fcnew[fcloc].type = tmface[i].type;
			for (int k = 0; k < 4; k++)
			{
				fcnew[fcloc].cnct[k] = fcnct[j][k];
				fcnew[fcloc].edge[k] = fedge[j][k];
			}
			fcloc++;
		}
	}
	//update hex
	vector<Element3D> hxnew(8 * tmesh.size());
	int hxloc(0);
	for (int i = 0; i < tmesh.size(); i++)
	{
		//construct new edges
		for (int j = 0; j < 6; j++)
		{
			ednew[edloc].pt[0] = pid_bd[i];
			ednew[edloc].pt[1] = pid_fc[tmesh[i].face[j]];
			edloc++;
		}
		//construct new faces
		int fcnct[12][4] = { { pid_ed[tmesh[i].edge[0]], pid_fc[tmesh[i].face[0]], pid_bd[i], pid_fc[tmesh[i].face[1]] },
		{ pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[2]], pid_fc[tmesh[i].face[3]], pid_bd[i] },
		{ pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[10]], pid_fc[tmesh[i].face[5]] },
		{ pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[8]] },
		{ pid_ed[tmesh[i].edge[3]], pid_fc[tmesh[i].face[0]], pid_bd[i], pid_fc[tmesh[i].face[4]] },
		{ pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[1]], pid_fc[tmesh[i].face[2]], pid_bd[i] },
		{ pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[9]], pid_fc[tmesh[i].face[5]] },
		{ pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[11]] },
		{ pid_ed[tmesh[i].edge[4]], pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[4]] },
		{ pid_fc[tmesh[i].face[1]], pid_ed[tmesh[i].edge[5]], pid_fc[tmesh[i].face[2]], pid_bd[i] },
		{ pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[6]], pid_fc[tmesh[i].face[3]] },
		{ pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[7]] } };
		//collect all edges and faces in this element
		int edids[12 * 2 + 6 * 4 + 6], fcids[6 * 4 + 12];
		for (int j = 0; j < 12; j++)
		{
			edids[2 * j] = 2 * tmesh[i].edge[j];
			edids[2 * j + 1] = 2 * tmesh[i].edge[j] + 1;
			fcids[24 + j] = 4 * tmface.size() + 12 * i + j;
		}
		for (int j = 0; j < 6; j++)
		{
			edids[24 + 4 * j] = 2 * tmedge.size() + 4 * tmesh[i].face[j];
			edids[24 + 4 * j + 1] = 2 * tmedge.size() + 4 * tmesh[i].face[j] + 1;
			edids[24 + 4 * j + 2] = 2 * tmedge.size() + 4 * tmesh[i].face[j] + 2;
			edids[24 + 4 * j + 3] = 2 * tmedge.size() + 4 * tmesh[i].face[j] + 3;
			edids[48 + j] = 2 * tmedge.size() + 4 * tmface.size() + 6 * i + j;
			fcids[4 * j] = 4 * tmesh[i].face[j];
			fcids[4 * j + 1] = 4 * tmesh[i].face[j] + 1;
			fcids[4 * j + 2] = 4 * tmesh[i].face[j] + 2;
			fcids[4 * j + 3] = 4 * tmesh[i].face[j] + 3;
		}
		for (int j = 0; j < 12; j++)
		{
			for (int k = 0; k < 4; k++)
			{
				fcnew[fcloc].cnct[k] = fcnct[j][k];
				for (int k0 = 24; k0 < 54; k0++)
				{
					if ((fcnct[j][k] == ednew[edids[k0]].pt[0] && fcnct[j][(k + 1) % 4] == ednew[edids[k0]].pt[1]) ||
						(fcnct[j][k] == ednew[edids[k0]].pt[1] && fcnct[j][(k + 1) % 4] == ednew[edids[k0]].pt[0]))
					{
						fcnew[fcloc].edge[k] = edids[k0]; break;
					}
				}
			}
			fcloc++;
		}
		//construct new hex
		int ecnct[8][8] = { { tmesh[i].cnct[0], pid_ed[tmesh[i].edge[0]], pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[3]], pid_ed[tmesh[i].edge[4]], pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[4]] },
		{ pid_ed[tmesh[i].edge[0]], tmesh[i].cnct[1], pid_ed[tmesh[i].edge[1]], pid_fc[tmesh[i].face[0]], pid_fc[tmesh[i].face[1]], pid_ed[tmesh[i].edge[5]], pid_fc[tmesh[i].face[2]], pid_bd[i] },
		{ pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[1]], tmesh[i].cnct[2], pid_ed[tmesh[i].edge[2]], pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[6]], pid_fc[tmesh[i].face[3]] },
		{ pid_ed[tmesh[i].edge[3]], pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[2]], tmesh[i].cnct[3], pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[7]] },
		{ pid_ed[tmesh[i].edge[4]], pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[4]], tmesh[i].cnct[4], pid_ed[tmesh[i].edge[8]], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[11]] },
		{ pid_fc[tmesh[i].face[1]], pid_ed[tmesh[i].edge[5]], pid_fc[tmesh[i].face[2]], pid_bd[i], pid_ed[tmesh[i].edge[8]], tmesh[i].cnct[5], pid_ed[tmesh[i].edge[9]], pid_fc[tmesh[i].face[5]] },
		{ pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[6]], pid_fc[tmesh[i].face[3]], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[9]], tmesh[i].cnct[6], pid_ed[tmesh[i].edge[10]] },
		{ pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[7]], pid_ed[tmesh[i].edge[11]], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[10]], tmesh[i].cnct[7] } };
		for (int j = 0; j < 8; j++)
		{
			for (int k = 0; k < 8; k++)
			{
				hxnew[hxloc].cnct[k] = ecnct[j][k];
			}
			//find face connectivity
			for (int k = 0; k < 6; k++)
			{
				array<int, 4> tmp1 = { ecnct[j][solid_fc[k][0]], ecnct[j][solid_fc[k][1]], ecnct[j][solid_fc[k][2]], ecnct[j][solid_fc[k][3]] };
				sort(tmp1.begin(), tmp1.end());
				for (int k0 = 0; k0 < 36; k0++)
				{
					array<int, 4> tmp2 = { fcnew[fcids[k0]].cnct[0], fcnew[fcids[k0]].cnct[1], fcnew[fcids[k0]].cnct[2], fcnew[fcids[k0]].cnct[3] };
					sort(tmp2.begin(), tmp2.end());
					if (tmp1 == tmp2)
					{
						hxnew[hxloc].face[k] = fcids[k0]; break;
					}
				}
			}
			//find edge connectivity
			for (int k = 0; k < 12; k++)
			{
				array<int, 2> tmp1 = { ecnct[j][solid_ed[k][0]], ecnct[j][solid_ed[k][1]] };
				for (int k0 = 0; k0 < 54; k0++)
				{
					if ((tmp1[0] == ednew[edids[k0]].pt[0] && tmp1[1] == ednew[edids[k0]].pt[1]) ||
						(tmp1[0] == ednew[edids[k0]].pt[1] && tmp1[1] == ednew[edids[k0]].pt[0]))
					{
						hxnew[hxloc].edge[k] = edids[k0]; break;
					}
				}
			}
			hxloc++;
		}
	}
	//update connectivity
	tmedge.resize(ednew.size());
	tmface.resize(fcnew.size());
	tmesh.resize(hxnew.size());
	for (int i = 0; i < cp.size(); i++)
	{
		cp[i].edge.clear();
		cp[i].face.clear();
		cp[i].hex.clear();
	}
	for (int i = 0; i < ednew.size(); i++)
	{
		tmedge[i].act = 1;
		tmedge[i].type = ednew[i].type;
		tmedge[i].sharp = ednew[i].sharp;
		tmedge[i].pt[0] = ednew[i].pt[0]; tmedge[i].pt[1] = ednew[i].pt[1];
		tmedge[i].face.clear();
		tmedge[i].hex.clear();
	}
	for (int i = 0; i < fcnew.size(); i++)
	{
		tmface[i].act = 1;
		tmface[i].type = fcnew[i].type;
		for (int j = 0; j < 4; j++)
		{
			tmface[i].cnct[j] = fcnew[i].cnct[j];
			tmface[i].edge[j] = fcnew[i].edge[j];
		}
		tmface[i].hex.clear();
	}
	for (int i = 0; i < hxnew.size(); i++)
	{
		tmesh[i].act = 1;
		tmesh[i].type = hxnew[i].type;
		for (int j = 0; j < 8; j++)
		{
			tmesh[i].cnct[j] = hxnew[i].cnct[j];
		}
		for (int j = 0; j < 12; j++)
		{
			tmesh[i].edge[j] = hxnew[i].edge[j];
		}
		for (int j = 0; j < 6; j++)
		{
			tmesh[i].face[j] = hxnew[i].face[j];
		}
	}
	//vertex-to-hex, edge-to-hex, face-to-hex
	for (int i = 0; i<tmesh.size(); i++)
	{
		for (int j = 0; j<8; j++)
		{
			cp[tmesh[i].cnct[j]].hex.push_back(i);
		}
		for (int j = 0; j<12; j++)
		{
			tmedge[tmesh[i].edge[j]].hex.push_back(i);
		}
		for (int j = 0; j<6; j++)
		{
			tmface[tmesh[i].face[j]].hex.push_back(i);
		}
	}
	//vertex-to-face, edge-to-face
	for (int i = 0; i<tmface.size(); i++)
	{
		for (int j = 0; j<4; j++)
		{
			cp[tmface[i].cnct[j]].face.push_back(i);
			tmedge[tmface[i].edge[j]].face.push_back(i);
		}
	}
	//vertex-to-edge
	for (int i = 0; i<tmedge.size(); i++)
	{
		for (int j = 0; j<2; j++)
		{
			cp[tmedge[i].pt[j]].edge.push_back(i);
		}
	}
	//find extraordinary edges and vertices
	for (int i = 0; i<tmedge.size(); i++)
	{
		if (tmedge[i].type != 1 && tmedge[i].hex.size() != 4)
		{
			tmedge[i].type = 2;
			if (cp[tmedge[i].pt[0]].type != 1)
				cp[tmedge[i].pt[0]].type = 3;
			if (cp[tmedge[i].pt[1]].type != 1)
				cp[tmedge[i].pt[1]].type = 3;
		}
	}
	//
	//find boundary and irregular elements
	for (int i = 0; i<tmesh.size(); i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (cp[tmesh[i].cnct[j]].type == 1)
			{
				tmesh[i].type = 1; break;
			}
		}
		if (tmesh[i].type != 1)
		{
			for (int j = 0; j<12; j++)
			{
				if (tmedge[tmesh[i].edge[j]].type == 2)
				{
					tmesh[i].type = 2;
					break;
				}
			}
		}
	}
}

void TruncatedTspline_3D::BuildBasisFunction()
{
	hmesh.push_back(tmesh);
	hcp.push_back(cp);
	hface.push_back(tmface);
	hedge.push_back(tmedge);

	vector<Vertex3D>().swap(cp);
	vector<Edge3D>().swap(tmedge);
	vector<Face3D>().swap(tmface);
	vector<Element3D>().swap(tmesh);

	//ReportXP();

	AllBezierLev(0);
	//for (uint i = 0; i < hmesh[0].size(); i++)
	//{
	//	if (hmesh[0][i].type == 1)
	//	{
	//		ConstructBezierBasis_Boundary(0, i);
	//	}
	//}
}

void TruncatedTspline_3D::OutputCM(string fn)
{
	//string fname(fn + "_CM.vtk");
	string fname(fn + ".vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << cp.size() << " float\n";
		for (uint i = 0; i<cp.size(); i++)
		{
			fout << cp[i].coor[0] << " " << cp[i].coor[1] << " " << cp[i].coor[2] << "\n";
		}
		/*fout << "\nCELLS " << tmesh.size() << " " << 9 * tmesh.size() << '\n';
		for (uint i = 0; i<tmesh.size(); i++)
		{
			fout << "8 ";
			for (int j = 0; j<8; j++)
			{
				fout << tmesh[i].cnct[j] << ' ';
			}
			fout << '\n';
		}
		fout << "\nCELL_TYPES " << tmesh.size() << '\n';
		for (uint i = 0; i<tmesh.size(); i++)
		{
			fout << "12\n";
		}*/
		int neles(0);
		for (uint i = 0; i < tmesh.size(); i++)
		{
			//if (tmesh[i].type == 1) neles++;
			if (tmesh[i].act == 1) neles++;
		}
		fout << "\nCELLS " << neles << " " << 9 * neles << '\n';
		for (uint i = 0; i<tmesh.size(); i++)
		{
			//if (tmesh[i].type == 1)
			if (tmesh[i].act == 1)
			{
				fout << "8 ";
				for (int j = 0; j<8; j++)
				{
					fout << tmesh[i].cnct[j] << ' ';
				}
				fout << '\n';
			}
		}
		fout << "\nCELL_TYPES " << neles << '\n';
		for (uint i = 0; i<neles; i++)
		{
			fout << "12\n";
		}

		//fout << "POINT_DATA " << cp.size() << "\nVECTORS type float\n";
		//for (uint i = 0; i<cp.size(); i++)
		//{
		//	fout << cp[i].type << " " << cp[i].sharp << " 0\n";
		//}

		//fout << "POINT_DATA " << cp.size() << "\nSCALARS type float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<cp.size(); i++)
		//{
		//	fout << cp[i].type << "\n";
		//}

		//fout << "\nCELL_DATA " << tmesh.size() << "\nSCALARS eact float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i < tmesh.size(); i++)
		//{
		//	fout << tmesh[i].trun << "\n";
		//	//fout << hmesh[lev][i].type << "\n";
		//}

		/*vector<int> ebad;
		for (uint i = 0; i < tmesh.size(); i++)
		{
			if (tmesh[i].trun == 1)
			{
				ebad.push_back(i);
			}
		}
		fout << "\nCELLS " << ebad.size() << " " << 9 * ebad.size() << '\n';
		for (uint i = 0; i<ebad.size(); i++)
		{
			fout << "8 ";
			for (int j = 0; j<8; j++)
			{
				fout << tmesh[ebad[i]].cnct[j] << ' ';
			}
			fout << '\n';
		}
		fout << "\nCELL_TYPES " << ebad.size() << '\n';
		for (uint i = 0; i<ebad.size(); i++)
		{
			fout << "12\n";
		}
		fout << "\nCELL_DATA " << ebad.size() << "\nSCALARS eact float 1\nLOOKUP_TABLE default\n";
		for (uint i = 0; i < ebad.size(); i++)
		{
			fout << tmesh[ebad[i]].trun << "\n";
		}	*/	

		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}

	//int eid(4292);
	//cout << "element type: " << eid << "\n";
	//for (int i = 0; i < 8; i++)
	//{
	//	cout << tmesh[eid].cnct[i] << "(" << cp[tmesh[eid].cnct[i]].type << ") ";
	//}
	////for (int i = 0; i < 6; i++)
	////{
	////	cout << tmface[tmesh[eid].face[i]].type << " ";
	////}
	//cout << "\n";
	//getchar();

	cout << "Done output control mesh!\n"; //getchar();
}

void TruncatedTspline_3D::OutputFace(string fn)
{
	string fname(fn + "_face.vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << cp.size() << " float\n";
		for (uint i = 0; i<cp.size(); i++)
		{
			fout << cp[i].coor[0] << " " << cp[i].coor[1] << " " << cp[i].coor[2] << "\n";
		}
		fout << "\nCELLS " << tmface.size() << " " << 5 * tmface.size() << '\n';
		for (uint i = 0; i<tmface.size(); i++)
		{
			fout << "4 ";
			for (int j = 0; j<4; j++)
			{
				fout << tmface[i].cnct[j] << ' ';
			}
			fout << '\n';
		}
		fout << "\nCELL_TYPES " << tmface.size() << '\n';
		for (uint i = 0; i<tmface.size(); i++)
		{
			fout << "9\n";
		}

		//fout << "POINT_DATA " << hcp[lev].size() << "\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<hcp[lev].size(); i++)
		//{
		//	fout << hcp[lev][i].act << "\n";
		//}

		fout << "\nCELL_DATA " << tmface.size() << "\nSCALARS type float 1\nLOOKUP_TABLE default\n";
		for (uint i = 0; i<tmface.size(); i++)
		{
			fout << tmface[i].type << "\n";
		}

		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::OutputFace_Boundary(string fn)
{
	string fname(fn + "_faceb.vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << cp.size() << " float\n";
		for (uint i = 0; i<cp.size(); i++)
		{
			fout << cp[i].coor[0] << " " << cp[i].coor[1] << " " << cp[i].coor[2] << "\n";
		}
		int nfcb(0);
		for (uint i = 0; i < tmface.size(); i++)
		{
			if (tmface[i].type == 1)
				nfcb++;
		}
		fout << "\nCELLS " << nfcb << " " << 5 * nfcb << '\n';
		for (uint i = 0; i<tmface.size(); i++)
		{
			if (tmface[i].type == 1)
			{
				fout << "4 ";
				for (int j = 0; j<4; j++)
				{
					fout << tmface[i].cnct[j] << ' ';
				}
				fout << '\n';
			}
		}
		fout << "\nCELL_TYPES " << nfcb << '\n';
		for (uint i = 0; i<nfcb; i++)
		{
			fout << "9\n";
		}

		//fout << "POINT_DATA " << hcp[lev].size() << "\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<hcp[lev].size(); i++)
		//{
		//	fout << hcp[lev][i].act << "\n";
		//}

		//fout << "\nCELL_DATA " << tmface.size() << "\nSCALARS type float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<tmface.size(); i++)
		//{
		//	fout << tmface[i].type << "\n";
		//}

		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::OutputEdge(string fn)
{
	string fname(fn + "_edge.vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << cp.size() << " float\n";
		for (uint i = 0; i<cp.size(); i++)
		{
			fout << cp[i].coor[0] << " " << cp[i].coor[1] << " " << cp[i].coor[2] << "\n";
		}
		fout << "\nCELLS " << tmedge.size() << " " << 3 * tmedge.size() << '\n';
		for (uint i = 0; i<tmedge.size(); i++)
		{
			fout << "2 ";
			for (int j = 0; j<2; j++)
			{
				fout << tmedge[i].pt[j] << ' ';
			}
			fout << '\n';
		}
		fout << "\nCELL_TYPES " << tmedge.size() << '\n';
		for (uint i = 0; i<tmedge.size(); i++)
		{
			fout << "3\n";
		}

		fout << "POINT_DATA " << cp.size() << "\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
		for (uint i = 0; i<cp.size(); i++)
		{
			fout << cp[i].sharp << "\n";
			//fout << hcp[lev][i].bcxp << "\n";
		}
		fout << "\nCELL_DATA " << tmedge.size() << "\nSCALARS type float 1\nLOOKUP_TABLE default\n";
		for (uint i = 0; i<tmedge.size(); i++)
		{
			fout << tmedge[i].sharp << "\n";
		}
		//fout << "\nCELL_DATA " << tmedge.size() << "\nVECTORS type float\n";
		//for (uint i = 0; i<tmedge.size(); i++)
		//{
		//	fout << tmedge[i].type << " " << tmedge[i].sharp << " 0\n";
		//}

		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::run_Global(int nref, string fn)
{
	for (int i = 0; i < nref; i++)
	{
		cout << "Refine step: " << i << "\n";
		Global_Subdivide();
		//Global_Subdivide_Simple();

		stringstream ss;
		ss << (i + 1);
		//OutputCM(fn + ss.str());
		//OutputFace(fn + ss.str());
		//OutputEdge(fn + ss.str());
	}
	cout << "Building basis function...\n";
	BuildBasisFunction();
}

void TruncatedTspline_3D::SetDomainRange(double xy[3][2], double nm[3], double& a)
{
	double tmp(1.e6);
	double x_range[3][2] = { { tmp, -tmp }, { tmp, -tmp }, { tmp, -tmp } };
	uint i, j;
	for (i = 0; i <hcp[0].size(); i++)
	{
		for (j = 0; j < 3; j++)
		{
			if (hcp[0][i].coor[j] < x_range[j][0]) x_range[j][0] = hcp[0][i].coor[j];
			if (hcp[0][i].coor[j] > x_range[j][1]) x_range[j][1] = hcp[0][i].coor[j];
		}
	}
	double xh[3] = { x_range[0][1] - x_range[0][0], x_range[1][1] - x_range[1][0], x_range[2][1] - x_range[2][0] };

	double nmtmp[3] = { -xh[1] * xh[2], -xh[0] * xh[2], 2.*xh[0] * xh[1] };
	tmp = sqrt(nmtmp[0] * nmtmp[0] + nmtmp[1] * nmtmp[1] + nmtmp[2] * nmtmp[2]);
	//nm[0] = nmtmp[0] / tmp; nm[1] = nmtmp[1] / tmp; nm[2] = nmtmp[2] / tmp;
	//nm[0] = 1.; nm[1] = 0.; nm[2] = 0.;//rod
	nm[0] = 0.; nm[1] = 0.; nm[2] = 1.;//rockerarm

	//nm[0] = .5; nm[1] = .5; nm[2] = .5;//cube

	xy[0][0] = x_range[0][0]; xy[1][0] = x_range[1][0]; xy[2][0] = x_range[2][0];
	xy[0][1] = x_range[0][1]; xy[1][1] = x_range[1][1]; xy[2][1] = x_range[2][1];

	dmrg[0][0] = xy[0][0]; dmrg[0][1] = xy[0][1];
	dmrg[1][0] = xy[1][0]; dmrg[1][1] = xy[1][1];
	dmrg[2][0] = xy[2][0]; dmrg[2][1] = xy[2][1];
	nmpl[0] = nm[0]; nmpl[1] = nm[1]; nmpl[2] = nm[2];
	acoef = a / sqrt(xh[0] * xh[0] + xh[1] * xh[1] + xh[2] * xh[2]);//regulation
	a = acoef;
	dmlen[0] = dmrg[0][1] - dmrg[0][0];
	dmlen[1] = dmrg[1][1] - dmrg[1][0];
	dmlen[2] = dmrg[2][1] - dmrg[2][0];
}

void TruncatedTspline_3D::PipelineDataProcess(string fn_in, string fn_out)
{
	//read hex vtk
	vector<double> disp;
	string fname(fn_in + ".vtk"), stmp;
	int npts, neles, itmp;
	ifstream fin;
	fin.open(fname);
	if (fin.is_open())
	{
		for (int i = 0; i<4; i++) getline(fin, stmp);//skip lines
		fin >> stmp >> npts >> stmp;
		cp.resize(npts);
		for (int i = 0; i<npts; i++)
		{
			//cp[i].act = 1;
			fin >> cp[i].coor[0] >> cp[i].coor[1] >> cp[i].coor[2];
		}
		getline(fin, stmp);
		fin >> stmp >> neles >> itmp;
		tmesh.resize(neles);
		for (int i = 0; i<neles; i++)
		{
			//tmesh[i].act = 1;
			fin >> itmp >> tmesh[i].cnct[0] >> tmesh[i].cnct[1] >> tmesh[i].cnct[2] >> tmesh[i].cnct[3] >>
				tmesh[i].cnct[4] >> tmesh[i].cnct[5] >> tmesh[i].cnct[6] >> tmesh[i].cnct[7];
		}
		for (int i = 0; i<neles+5; i++) getline(fin, stmp);
		disp.resize(npts);
		for (int i = 0; i < npts; i++) fin >> disp[i];
		fin.close();
	}
	else
	{
		cerr << "Cannot open " << fname << "!\n";
	}

	//remove redundant points
	vector<int> flag(cp.size(), 0);
	for (uint i = 0; i < tmesh.size(); i++)
	{
		for (int j = 0; j < 8; j++) flag[tmesh[i].cnct[j]] = 1;
	}
	vector<int> pid_new(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (flag[i] == 1)
		{
			pid_new[i] = count++;
		}
	}
	for (uint i = 0; i < tmesh.size(); i++)
	{
		for (int j = 0; j < 8; j++) tmesh[i].cnct[j] = pid_new[tmesh[i].cnct[j]];
	}

	//output
	string fn1(fn_out + ".vtk");
	ofstream fout;
	fout.open(fn1.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << count << " float\n";
		for (uint i = 0; i<cp.size(); i++)
		{
			if (flag[i] == 1)
			{
				fout << cp[i].coor[0] << " " << cp[i].coor[1] << " " << cp[i].coor[2] << "\n";
			}
		}
		fout << "\nCELLS " << tmesh.size() << " " << 9 * tmesh.size() << '\n';
		for (uint i = 0; i<tmesh.size(); i++)
		{
			fout << "8 ";
			for (int j = 0; j<8; j++)
			{
				fout << tmesh[i].cnct[j] << ' ';
			}
			fout << '\n';
		}
		fout << "\nCELL_TYPES " << tmesh.size() << '\n';
		for (uint i = 0; i<tmesh.size(); i++)
		{
			fout << "12\n";
		}
		fout << "POINT_DATA " << count << "\nSCALARS pact float 1\nLOOKUP_TABLE default\n";
		for (uint i = 0; i<cp.size(); i++)
		{
			if (flag[i] == 1)
			{
				fout << disp[i] << "\n";
			}
		}
		//fout << "\nCELL_DATA " << hmesh[lev].size() << "\nSCALARS eact float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<hmesh[lev].size(); i++)
		//{
		//	//fout<<hmesh[lev][i].act<<"\n";
		//	fout << hmesh[lev][i].type << "\n";
		//}

		fout.close();
	}
	else
	{
		cout << "Cannot open " << fn1 << "!\n";
	}
}

void TruncatedTspline_3D::PipelineBezierExtract(vector<BezierElement3D>& bzmesh)
{
	bzmesh.clear();
	uint i, j, k, k1, k2;
	int loc(0);
	vector<vector<int>> aloc(hcp.size());
	for (i = 0; i < hcp.size(); i++)
	{
		aloc[i].resize(hcp[i].size(), -1);
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				aloc[i][j] = loc++;
			}
		}
	}
	for (i = 0; i < hmesh.size(); i++)
	{
		for (j = 0; j < hmesh[i].size(); j++)
		{
			if (hmesh[i][j].act == 1 /*&& hmesh[i][j].type!=1*/)
			{
				BezierElement3D bztmp;
				bztmp.prt[0] = i; bztmp.prt[1] = j;
				bztmp.trun = hmesh[i][j].trun;
				if (hmesh[i][j].type == 1) bztmp.type = 1;
				if (hmesh[i][j].trun == 0)
				{
					bztmp.IEN.resize(hmesh[i][j].IEN.size());
					bztmp.cmat.resize(hmesh[i][j].IEN.size(), vector<double>(64));
					for (k = 0; k < hmesh[i][j].IEN.size(); k++)
					{
						bztmp.IEN[k] = aloc[i][hmesh[i][j].IEN[k]];
						for (k1 = 0; k1 < 64; k1++)
						{
							bztmp.cmat[k][k1] = hmesh[i][j].bemat[k][k1];
							bztmp.pts[k1][0] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[0];
							bztmp.pts[k1][1] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[1];
							bztmp.pts[k1][2] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[2];
						}
					}
				}
				else
				{
					bztmp.IEN.resize(hmesh[i][j].IEN_act.size());
					bztmp.cmat.resize(hmesh[i][j].IEN_act.size(), vector<double>(64));
					for (k = 0; k < hmesh[i][j].IEN_act.size(); k++)
					{
						int lev(hmesh[i][j].IEN_act[k][0]);
						int pid(hmesh[i][j].IEN_act[k][1]);
						if (aloc[lev][pid] == -1)
						{
							cout << "wrong aloc!\n";
							getchar();
						}
						bztmp.IEN[k] = aloc[lev][pid];
						for (k1 = 0; k1 < 64; k1++)
						{
							bztmp.cmat[k][k1] = 0.;
							for (k2 = 0; k2 < hmesh[i][j].IEN.size(); k2++)
							{
								bztmp.cmat[k][k1] += hmesh[i][j].tmat[k][k2] * hmesh[i][j].bemat[k2][k1];
							}
						}
					}
					for (k = 0; k < hmesh[i][j].IEN.size(); k++)
					{
						for (k1 = 0; k1 < 64; k1++)
						{
							bztmp.pts[k1][0] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[0];
							bztmp.pts[k1][1] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[1];
							bztmp.pts[k1][2] += hmesh[i][j].bemat[k][k1] * hcp[i][hmesh[i][j].IEN[k]].coor[2];
						}
					}
				}
				bzmesh.push_back(bztmp);
			}
		}
	}
}

void TruncatedTspline_3D::CreateBsplines(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	int nsp(3);
	nsp *= 2;
	nsp *= 2;
	int nex[3] = { nsp, nsp, nsp };//3 by 3 by 3 cube
	int npx[3] = { nex[0] + 3, nex[1] + 3, nex[2] + 3 };
	int ncp(npx[0] * npx[1] * npx[2]), nel(nex[0] * nex[1] * nex[2]);
	double dmx[3][2] = { { 0., 1. }, { 0., 1. }, { 0., 1. } };
	double lenx[3] = { (dmx[0][1] - dmx[0][0])/double(npx[0]-1), (dmx[1][1] - dmx[1][0])/double(npx[1]-1), (dmx[2][1] - dmx[2][0])/double(npx[2]-1) };
	vector<vector<double>> ku(3);
	cp.resize(ncp);
	IDBC.resize(ncp, -1);
	gh.resize(ncp, 0.);
	bzmesh.resize(nel);
	uint i, j, k, loc(0), i0, j0, k0;
	for (i = 0; i < 4; i++)
	{
		ku[0].push_back(0.);
		ku[1].push_back(0.);
		ku[2].push_back(0.);
	}
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < nex[i]; j++) ku[i].push_back(double(j + 1));
	}
	for (i = 0; i < 3; i++)
	{
		ku[0].push_back(double(nex[0]));
		ku[1].push_back(double(nex[1]));
		ku[2].push_back(double(nex[2]));
	}
	loc = 0;
	int count(0);
	for (k = 0; k < npx[2]; k++)
	{
		for (j = 0; j < npx[1]; j++)
		{
			for (i = 0; i < npx[0]; i++)
			{
				//cp[loc].act = 1;
				cp[loc].coor[0] = dmx[0][0] + double(i) * lenx[0];
				cp[loc].coor[1] = dmx[1][0] + double(j) * lenx[1];
				cp[loc].coor[2] = dmx[2][0] + double(k) * lenx[2];
				if (i == 0 || i == npx[0] - 1 || j == 0 || j == npx[1] - 1 || k == 0 || k == npx[2] - 1)
				{
					IDBC[loc] = -1;
					gh[loc] = SpecifyDirichBC(cp[loc].coor);
				}
				else
				{
					IDBC[loc] = count++;
				}
				loc++;
			}
		}
	}
	loc = 0;
	for (k = 0; k < nex[2]; k++)
	{
		for (j = 0; j < nex[1]; j++)
		{
			for (i = 0; i < nex[0]; i++)
			{
				bzmesh[loc].IEN.resize(64);
				int loc0(0);
				for (k0 = 0; k0 < 4; k0++)
				{
					for (j0 = 0; j0 < 4; j0++)
					{
						for (i0 = 0; i0 < 4; i0++)
						{
							bzmesh[loc].IEN[loc0] = (k + k0)*npx[0] * npx[1] + (j + j0)*npx[0] + i + i0;
							loc0++;
						}
					}
				}
				bzmesh[loc].cmat.resize(64, vector<double>(64, 0.));
				vector<double> ku0(ku[0].begin() + i, ku[0].begin() + i + 8);
				vector<double> kv0(ku[1].begin() + j, ku[1].begin() + j + 8);
				vector<double> kw0(ku[2].begin() + k, ku[2].begin() + k + 8);
				vector<double> ku1, kv1, kw1;
				array<double, 2> ktu = { double(i), double(i + 1) };
				array<double, 2> ktv = { double(j), double(j + 1) };
				array<double, 2> ktw = { double(k), double(k + 1) };
				vector<vector<double>> Tu, Tv, Tw;
				int iloc[3];
				BezierInsertKnots(ku0, ktu, ku1);
				BezierInsertKnots(kv0, ktv, kv1);
				BezierInsertKnots(kw0, ktw, kw1);
				TMatrix(ku0, ku1, 3, Tu);
				TMatrix(kv0, kv1, 3, Tv);
				TMatrix(kw0, kw1, 3, Tw);
				for (i0 = 0; i0 < ku1.size() - 1; i0++)
				{
					if (ku1[i0] == double(i) && ku1[i0 + 1] == double(i + 1))
					{
						iloc[0] = i0 - 3; break;
					}
				}
				for (i0 = 0; i0 < kv1.size() - 1; i0++)
				{
					if (kv1[i0] == double(j) && kv1[i0 + 1] == double(j + 1))
					{
						iloc[1] = i0 - 3; break;
					}
				}
				for (i0 = 0; i0 < kw1.size() - 1; i0++)
				{
					if (kw1[i0] == double(k) && kw1[i0 + 1] == double(k + 1))
					{
						iloc[2] = i0 - 3; break;
					}
				}
				loc0 = 0;//Bspline
				for (k0 = 0; k0 < 4; k0++)
				{
					for (j0 = 0; j0 < 4; j0++)
					{
						for (i0 = 0; i0 < 4; i0++)
						{
							int loc1(0);//Bezier
							for (int k1 = 0; k1 < 4; k1++)
							{
								for (int j1 = 0; j1 < 4; j1++)
								{
									for (int i1 = 0; i1 < 4; i1++)
									{
										bzmesh[loc].cmat[loc0][loc1] = Tu[iloc[0] + i1][i0] * Tv[iloc[1] + j1][j0] * Tw[iloc[2] + k1][k0];
										bzmesh[loc].pts[loc1][0] += bzmesh[loc].cmat[loc0][loc1] * cp[bzmesh[loc].IEN[loc0]].coor[0];
										bzmesh[loc].pts[loc1][1] += bzmesh[loc].cmat[loc0][loc1] * cp[bzmesh[loc].IEN[loc0]].coor[1];
										bzmesh[loc].pts[loc1][2] += bzmesh[loc].cmat[loc0][loc1] * cp[bzmesh[loc].IEN[loc0]].coor[2];
										loc1++;
									}
								}
							}
							loc0++;
						}
					}
				}
				//cout << loc << "\n";
				//for (int pid = 0; pid < bzmesh[loc].pts.size(); pid++)
				//{
				//	cout << bzmesh[loc].pts[pid][0] << " " << bzmesh[loc].pts[pid][1] << " " << bzmesh[loc].pts[pid][2] << "\n";
				//	getchar();
				//}
				//cout << "done " << loc << "\n";
				loc++;
			}
		}
	}
}

void TruncatedTspline_3D::CreateBsplines(int nex[3])
{
	int npx[3] = { nex[0] + 3, nex[1] + 3, nex[2] + 3 };
	int ncp(npx[0] * npx[1] * npx[2]);
	int nel(nex[0] * nex[1] * nex[2]);
	double dmx[3][2] = { { 0., 1. }, { 0., 1. }, { 0., 1. } };
	double lenx[3] = { (dmx[0][1] - dmx[0][0]) / double(npx[0] - 1), (dmx[1][1] - dmx[1][0]) / double(npx[1] - 1), (dmx[2][1] - dmx[2][0]) / double(npx[2] - 1) };
	kvec.resize(3);
	cp.resize(ncp);
	tmesh.resize(nel);
	uint i, j, k, loc(0);
	for (i = 0; i < 4; i++)
	{
		kvec[0].push_back(0.);
		kvec[1].push_back(0.);
		kvec[2].push_back(0.);
	}
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < nex[i]; j++) kvec[i].push_back(double(j + 1));
	}
	for (i = 0; i < 3; i++)
	{
		kvec[0].push_back(double(nex[0]));
		kvec[1].push_back(double(nex[1]));
		kvec[2].push_back(double(nex[2]));
	}
	loc = 0;
	int count(0);
	for (k = 0; k < npx[2]; k++)
	{
		for (j = 0; j < npx[1]; j++)
		{
			for (i = 0; i < npx[0]; i++)
			{
				cp[loc].act = 1;
				if (i == 0 || i == npx[0] - 1 || j == 0 || j == npx[1] - 1 || k == 0 || k == npx[2] - 1)
				{
					cp[loc].type = 1;
				}
				cp[loc].coor[0] = dmx[0][0] + double(i) * lenx[0];
				cp[loc].coor[1] = dmx[1][0] + double(j) * lenx[1];
				cp[loc].coor[2] = dmx[2][0] + double(k) * lenx[2];
				loc++;
			}
		}
	}
}

void TruncatedTspline_3D::Bsplines_Refine()
{
	int nex0[3] = { kvec[0].size() - 7, kvec[1].size() - 7, kvec[2].size() - 7 };//# elements after refinement
	int npx0[3] = { nex0[0] + 3, nex0[1] + 3, nex0[2] + 3 };
	int nex[3] = { 2*(kvec[0].size() - 7), 2*(kvec[1].size() - 7), 2*(kvec[2].size() - 7) };//# elements after refinement
	int npx[3] = { nex[0] + 3, nex[1] + 3, nex[2] + 3 };
	int ncp0(npx0[0] * npx0[1] * npx0[2]), ncp(npx[0] * npx[1] * npx[2]);
	int nel0(nex0[0] * nex0[1] * nex0[2]), nel(nex[0] * nex[1] * nex[2]);
	uint i, j, k, i0, j0, k0, loc(0);
	vector<vector<double>> ku(3);//knot vectors after refinement
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < kvec[i].size() - 1; j++)
		{
			ku[i].push_back(kvec[i][j]);
			if (kvec[i][j] < kvec[i][j + 1])
			{
				ku[i].push_back((kvec[i][j] + kvec[i][j + 1]) / 2.);
			}
		}
		ku[i].push_back(kvec[i].back());
	}
	vector<vector<double>> Tu, Tv, Tw;
	TMatrix(kvec[0], ku[0], 3, Tu);
	TMatrix(kvec[1], ku[1], 3, Tv);
	TMatrix(kvec[2], ku[2], 3, Tw);
	vector<array<double, 3>> pts(ncp);//new points

	loc = 0;//new id
	for (k = 0; k < npx[2]; k++)
	{
		for (j = 0; j < npx[1]; j++)
		{
			for (i = 0; i < npx[0]; i++)
			{
				int loc0(0);//old id
				for (k0 = 0; k0 < npx0[2]; k0++)
				{
					for (j0 = 0; j0 < npx0[1]; j0++)
					{
						for (i0 = 0; i0 < npx0[0]; i0++)
						{
							if (Tu[i][i0] != 0. && Tv[j][j0] != 0. && Tw[k][k0]!=0.)
							{
								double ctmp = Tu[i][i0] * Tv[j][j0] * Tw[k][k0];
								pts[loc][0] += ctmp*cp[loc0].coor[0];
								pts[loc][1] += ctmp*cp[loc0].coor[1];
								pts[loc][2] += ctmp*cp[loc0].coor[2];
							}
							loc0++;
						}
					}
				}
				loc++;
			}
		}
	}

	for (i = 0; i < 3; i++)
	{
		kvec[i].clear();
	}
	for (i = 0; i < 4; i++)
	{
		kvec[0].push_back(0.);
		kvec[1].push_back(0.);
		kvec[2].push_back(0.);
	}
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < nex[i]; j++) kvec[i].push_back(double(j + 1));
	}
	for (i = 0; i < 3; i++)
	{
		kvec[0].push_back(double(nex[0]));
		kvec[1].push_back(double(nex[1]));
		kvec[2].push_back(double(nex[2]));
	}
	cp.clear();
	cp.resize(ncp);
	loc = 0;
	for (k = 0; k < npx[2]; k++)
	{
		for (j = 0; j < npx[1]; j++)
		{
			for (i = 0; i < npx[0]; i++)
			{
				cp[loc].act = 1;
				cp[loc].type = 0;
				if (i == 0 || i == npx[0] - 1 || j == 0 || j == npx[1] - 1 || k == 0 || k == npx[2] - 1)
				{
					cp[loc].type = 1;
				}
				cp[loc].coor[0] = pts[loc][0];
				cp[loc].coor[1] = pts[loc][1];
				cp[loc].coor[2] = pts[loc][2];
				loc++;
			}
		}
	}
	//for (i = 0; i < pts.size(); i++)
	//{
	//	cp[i].coor[0] = pts[i][0];
	//	cp[i].coor[1] = pts[i][1];
	//	cp[i].coor[2] = pts[i][2];
	//}
}

void TruncatedTspline_3D::Bspline_BezierExtract(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	int nex[3] = { kvec[0].size() - 7, kvec[1].size() - 7, kvec[2].size() - 7 };//# elements after refinement
	int npx[3] = { nex[0] + 3, nex[1] + 3, nex[2] + 3 };
	int ncp(npx[0] * npx[1] * npx[2]);
	int nel(nex[0] * nex[1] * nex[2]);
	vector<vector<double>> ku(3);
	IDBC.resize(ncp, -1);
	gh.resize(ncp, 0.);
	bzmesh.resize(nel);
	uint i, j, k, loc(0), i0, j0, k0;
	for (i = 0; i < 3; i++)
	{
		ku[i].resize(kvec[i].size());
		for (j = 0; j < kvec[i].size(); j++)
		{
			ku[i][j] = kvec[i][j];
		}
	}
	loc = 0;
	int count(0);
	for (k = 0; k < npx[2]; k++)
	{
		for (j = 0; j < npx[1]; j++)
		{
			for (i = 0; i < npx[0]; i++)
			{
				if (i == 0 || i == npx[0] - 1 || j == 0 || j == npx[1] - 1 || k == 0 || k == npx[2] - 1)
				{
					IDBC[loc] = -1;
					gh[loc] = SpecifyDirichBC(cp[loc].coor);
				}
				else
				{
					IDBC[loc] = count++;
				}
				loc++;
			}
		}
	}

	cpa.resize(cp.size());
	for (i = 0; i < cp.size(); i++)
	{
		cpa[i][0] = cp[i].coor[0];
		cpa[i][1] = cp[i].coor[1];
		cpa[i][2] = cp[i].coor[2];
	}

	loc = 0;
	for (k = 0; k < nex[2]; k++)
	{
		for (j = 0; j < nex[1]; j++)
		{
			for (i = 0; i < nex[0]; i++)
			{
				bzmesh[loc].IEN.resize(64);
				int loc0(0);
				for (k0 = 0; k0 < 4; k0++)
				{
					for (j0 = 0; j0 < 4; j0++)
					{
						for (i0 = 0; i0 < 4; i0++)
						{
							bzmesh[loc].IEN[loc0] = (k + k0)*npx[0] * npx[1] + (j + j0)*npx[0] + i + i0;
							loc0++;
						}
					}
				}
				bzmesh[loc].cmat.resize(64, vector<double>(64, 0.));
				vector<double> ku0(ku[0].begin() + i, ku[0].begin() + i + 8);
				vector<double> kv0(ku[1].begin() + j, ku[1].begin() + j + 8);
				vector<double> kw0(ku[2].begin() + k, ku[2].begin() + k + 8);
				vector<double> ku1, kv1, kw1;
				array<double, 2> ktu = { double(i), double(i + 1) };
				array<double, 2> ktv = { double(j), double(j + 1) };
				array<double, 2> ktw = { double(k), double(k + 1) };
				vector<vector<double>> Tu, Tv, Tw;
				int iloc[3];
				BezierInsertKnots(ku0, ktu, ku1);
				BezierInsertKnots(kv0, ktv, kv1);
				BezierInsertKnots(kw0, ktw, kw1);
				TMatrix(ku0, ku1, 3, Tu);
				TMatrix(kv0, kv1, 3, Tv);
				TMatrix(kw0, kw1, 3, Tw);
				for (i0 = 0; i0 < ku1.size() - 1; i0++)
				{
					if (ku1[i0] == double(i) && ku1[i0 + 1] == double(i + 1))
					{
						iloc[0] = i0 - 3; break;
					}
				}
				for (i0 = 0; i0 < kv1.size() - 1; i0++)
				{
					if (kv1[i0] == double(j) && kv1[i0 + 1] == double(j + 1))
					{
						iloc[1] = i0 - 3; break;
					}
				}
				for (i0 = 0; i0 < kw1.size() - 1; i0++)
				{
					if (kw1[i0] == double(k) && kw1[i0 + 1] == double(k + 1))
					{
						iloc[2] = i0 - 3; break;
					}
				}
				loc0 = 0;//Bspline
				for (k0 = 0; k0 < 4; k0++)
				{
					for (j0 = 0; j0 < 4; j0++)
					{
						for (i0 = 0; i0 < 4; i0++)
						{
							int loc1(0);//Bezier
							for (int k1 = 0; k1 < 4; k1++)
							{
								for (int j1 = 0; j1 < 4; j1++)
								{
									for (int i1 = 0; i1 < 4; i1++)
									{
										bzmesh[loc].cmat[loc0][loc1] = Tu[iloc[0] + i1][i0] * Tv[iloc[1] + j1][j0] * Tw[iloc[2] + k1][k0];
										bzmesh[loc].pts[loc1][0] += bzmesh[loc].cmat[loc0][loc1] * cp[bzmesh[loc].IEN[loc0]].coor[0];
										bzmesh[loc].pts[loc1][1] += bzmesh[loc].cmat[loc0][loc1] * cp[bzmesh[loc].IEN[loc0]].coor[1];
										bzmesh[loc].pts[loc1][2] += bzmesh[loc].cmat[loc0][loc1] * cp[bzmesh[loc].IEN[loc0]].coor[2];
										loc1++;
									}
								}
							}
							loc0++;
						}
					}
				}
				loc++;
			}
		}
	}
}

void TruncatedTspline_3D::Bspline_BezierExtract_fit(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	int nex[3] = { kvec[0].size() - 7, kvec[1].size() - 7, kvec[2].size() - 7 };//# elements after refinement
	int npx[3] = { nex[0] + 3, nex[1] + 3, nex[2] + 3 };
	int ncp(npx[0] * npx[1] * npx[2]);
	int nel(nex[0] * nex[1] * nex[2]);
	vector<vector<double>> ku(3);
	//IDBC.resize(ncp, -1);
	//gh.resize(ncp, 0.);
	bzmesh.resize(nel);
	uint i, j, k, loc(0), i0, j0, k0;
	for (i = 0; i < 3; i++)
	{
		ku[i].resize(kvec[i].size());
		for (j = 0; j < kvec[i].size(); j++)
		{
			ku[i][j] = kvec[i][j];
		}
	}
	/*loc = 0;
	int count(0);
	for (k = 0; k < npx[2]; k++)
	{
		for (j = 0; j < npx[1]; j++)
		{
			for (i = 0; i < npx[0]; i++)
			{
				if (i == 0 || i == npx[0] - 1 || j == 0 || j == npx[1] - 1 || k == 0 || k == npx[2] - 1)
				{
					IDBC[loc] = -1;
					gh[loc] = SpecifyDirichBC(cp[loc].coor);
				}
				else
				{
					IDBC[loc] = count++;
				}
				loc++;
			}
		}
	}*/
	loc = 0;
	for (k = 0; k < nex[2]; k++)
	{
		for (j = 0; j < nex[1]; j++)
		{
			for (i = 0; i < nex[0]; i++)
			{
				if (i == 0 || i == nex[0] - 1 || j == 0 || j == nex[1] - 1 || k == 0 || k == nex[2] - 1)
				{
					bzmesh[loc].type = 1;
				}
				bzmesh[loc].IEN.resize(64);
				int loc0(0);
				for (k0 = 0; k0 < 4; k0++)
				{
					for (j0 = 0; j0 < 4; j0++)
					{
						for (i0 = 0; i0 < 4; i0++)
						{
							bzmesh[loc].IEN[loc0] = (k + k0)*npx[0] * npx[1] + (j + j0)*npx[0] + i + i0;
							loc0++;
						}
					}
				}
				bzmesh[loc].cmat.resize(64, vector<double>(64, 0.));
				vector<double> ku0(ku[0].begin() + i, ku[0].begin() + i + 8);
				vector<double> kv0(ku[1].begin() + j, ku[1].begin() + j + 8);
				vector<double> kw0(ku[2].begin() + k, ku[2].begin() + k + 8);
				vector<double> ku1, kv1, kw1;
				array<double, 2> ktu = { double(i), double(i + 1) };
				array<double, 2> ktv = { double(j), double(j + 1) };
				array<double, 2> ktw = { double(k), double(k + 1) };
				vector<vector<double>> Tu, Tv, Tw;
				int iloc[3];
				BezierInsertKnots(ku0, ktu, ku1);
				BezierInsertKnots(kv0, ktv, kv1);
				BezierInsertKnots(kw0, ktw, kw1);
				TMatrix(ku0, ku1, 3, Tu);
				TMatrix(kv0, kv1, 3, Tv);
				TMatrix(kw0, kw1, 3, Tw);
				for (i0 = 0; i0 < ku1.size() - 1; i0++)
				{
					if (ku1[i0] == double(i) && ku1[i0 + 1] == double(i + 1))
					{
						iloc[0] = i0 - 3; break;
					}
				}
				for (i0 = 0; i0 < kv1.size() - 1; i0++)
				{
					if (kv1[i0] == double(j) && kv1[i0 + 1] == double(j + 1))
					{
						iloc[1] = i0 - 3; break;
					}
				}
				for (i0 = 0; i0 < kw1.size() - 1; i0++)
				{
					if (kw1[i0] == double(k) && kw1[i0 + 1] == double(k + 1))
					{
						iloc[2] = i0 - 3; break;
					}
				}
				loc0 = 0;//Bspline
				for (k0 = 0; k0 < 4; k0++)
				{
					for (j0 = 0; j0 < 4; j0++)
					{
						for (i0 = 0; i0 < 4; i0++)
						{
							int loc1(0);//Bezier
							for (int k1 = 0; k1 < 4; k1++)
							{
								for (int j1 = 0; j1 < 4; j1++)
								{
									for (int i1 = 0; i1 < 4; i1++)
									{
										bzmesh[loc].cmat[loc0][loc1] = Tu[iloc[0] + i1][i0] * Tv[iloc[1] + j1][j0] * Tw[iloc[2] + k1][k0];
										bzmesh[loc].pts[loc1][0] += bzmesh[loc].cmat[loc0][loc1] * cp[bzmesh[loc].IEN[loc0]].coor[0];
										bzmesh[loc].pts[loc1][1] += bzmesh[loc].cmat[loc0][loc1] * cp[bzmesh[loc].IEN[loc0]].coor[1];
										bzmesh[loc].pts[loc1][2] += bzmesh[loc].cmat[loc0][loc1] * cp[bzmesh[loc].IEN[loc0]].coor[2];
										loc1++;
									}
								}
							}
							loc0++;
						}
					}
				}
				loc++;
			}
		}
	}
}

void TruncatedTspline_3D::FittingBC_Bsplines(const vector<BezierElement3D>& bzall, vector<int>& IDBC1, vector<double>& gh1)
{
	uint i, j, k, k1, k2;
	int nex[3] = { kvec[0].size() - 7, kvec[1].size() - 7, kvec[2].size() - 7 };
	//boundary points
	vector<int> flag(cp.size(), 0);
	for (i = 0; i < bzall.size(); i++)
	{
		if (bzall[i].type == 1)
		{
			for (j = 0; j < bzall[i].IEN.size(); j++)
			{
				flag[bzall[i].IEN[j]] = 1;
			}
		}
	}
	vector<int> aloc(cp.size(), -1);
	int loc = 0;
	for (i = 0; i < aloc.size(); i++)
	{
		if (flag[i] == 1)
		{
			aloc[i] = loc++;
		}
	}
	vector<int> IDBC(loc, -1);
	vector<double> gh(loc, 0.);
	loc = 0;
	int count(0);
	for (i = 0; i < cp.size(); i++)
	{
		if (flag[i] == 1)
		{
			if (cp[i].type == 1)
			{
				IDBC[loc] = count++;
			}
			loc++;
		}
	}
	vector<BezierElement3D> bzmesh;
	loc = 0;
	for (k = 0; k < nex[2]; k++)
	{
		for (j = 0; j < nex[1]; j++)
		{
			for (i = 0; i < nex[0]; i++)
			{
				if (bzall[loc].type == 1)
				{
					BezierElement3D bztmp;
					bztmp.type = 1;
					bool fbc[6] = { k == 0, j == 0, i == nex[0] - 1, j == nex[1] - 1, i == 0, k == nex[2] - 1 };
					for (k1 = 0; k1 < 6; k1++)
					{
						if (fbc[k1])
						{
							bztmp.bfc.push_back(k1);
						}
					}
					bztmp.IEN.resize(bzall[loc].IEN.size());
					bztmp.cmat.resize(bzall[loc].IEN.size(), vector<double>(64));
					for (k1 = 0; k1 < bzall[loc].IEN.size(); k1++)
					{
						bztmp.IEN[k1] = aloc[bzall[loc].IEN[k1]];
						for (k2 = 0; k2 < 64; k2++)
						{
							bztmp.cmat[k1][k2] = bzall[loc].cmat[k1][k2];
						}
					}
					for (k2 = 0; k2 < 64; k2++)
					{
						bztmp.pts[k2][0] = bzall[loc].pts[k2][0];
						bztmp.pts[k2][1] = bzall[loc].pts[k2][1];
						bztmp.pts[k2][2] = bzall[loc].pts[k2][2];
					}
					bzmesh.push_back(bztmp);
				}
				loc++;
			}
		}
	}

	LeastSquare ls;
	vector<double> sol;
	ls.SetProblem(IDBC, gh);
	ls.GetEqParameter(dmrg, nmpl, acoef);
	//ls.VisualizeBoundarySurface(bzmesh, cpts, "../io/complex2/rod2");
	//cout << "done output boundary surface!\n";
	//getchar();
	ls.Run_Fitting(bzmesh, "", sol);
	//ls.VisualizeBoundarySurface(bzmesh, cpts, "../io/complex2/rod2");
	//cout << "done output boundary surface!\n";
	//getchar();

	IDBC1.clear();
	gh1.clear();
	IDBC1.resize(cp.size(), -1);
	gh1.resize(cp.size(), 0.);
	loc = 0;
	count = 0;
	for (i = 0; i < cp.size(); i++)
	{
		if (flag[i] == 1)
		{
			if (cp[i].type == 1)
			{
				IDBC1[i] = -1;
				gh1[i] = sol[loc];
			}
			else
			{
				IDBC1[i] = count++;
			}
			loc++;
		}
		else
		{
			IDBC1[i] = count++;
		}
	}
}

void TruncatedTspline_3D::SetDomainRange_Bsplines(double xy[3][2], double nm[3], double& a)
{
	double tmp(1.e6);
	double x_range[3][2] = { { tmp, -tmp }, { tmp, -tmp }, { tmp, -tmp } };
	uint i, j;
	for (i = 0; i <cp.size(); i++)
	{
		for (j = 0; j < 3; j++)
		{
			if (cp[i].coor[j] < x_range[j][0]) x_range[j][0] = cp[i].coor[j];
			if (cp[i].coor[j] > x_range[j][1]) x_range[j][1] = cp[i].coor[j];
		}
	}
	double xh[3] = { x_range[0][1] - x_range[0][0], x_range[1][1] - x_range[1][0], x_range[2][1] - x_range[2][0] };

	double nmtmp[3] = { -xh[1] * xh[2], -xh[0] * xh[2], 2.*xh[0] * xh[1] };
	tmp = sqrt(nmtmp[0] * nmtmp[0] + nmtmp[1] * nmtmp[1] + nmtmp[2] * nmtmp[2]);
	nm[0] = nmtmp[0] / tmp; nm[1] = nmtmp[1] / tmp; nm[2] = nmtmp[2] / tmp;

	//nm[0] = .5; nm[1] = .5; nm[2] = .5;//cube

	xy[0][0] = x_range[0][0]; xy[1][0] = x_range[1][0]; xy[2][0] = x_range[2][0];
	xy[0][1] = x_range[0][1]; xy[1][1] = x_range[1][1]; xy[2][1] = x_range[2][1];

	dmrg[0][0] = xy[0][0]; dmrg[0][1] = xy[0][1];
	dmrg[1][0] = xy[1][0]; dmrg[1][1] = xy[1][1];
	dmrg[2][0] = xy[2][0]; dmrg[2][1] = xy[2][1];
	nmpl[0] = nm[0]; nmpl[1] = nm[1]; nmpl[2] = nm[2];
	acoef = a / sqrt(xh[0] * xh[0] + xh[1] * xh[1] + xh[2] * xh[2]);//regulation
	a = acoef;
	dmlen[0] = dmrg[0][1] - dmrg[0][0];
	dmlen[1] = dmrg[1][1] - dmrg[1][0];
	dmlen[2] = dmrg[2][1] - dmrg[2][0];
}





void TruncatedTspline_3D::ReadHexMeshVTK(string fn)
{
	string fname(fn + ".vtk"), stmp;
	int npts, neles, itmp;
	ifstream fin;
	fin.open(fname);
	if (fin.is_open())
	{
		for (int i = 0; i<4; i++) getline(fin, stmp);//skip lines
		fin >> stmp >> npts >> stmp;
		cp.resize(npts);
		for (int i = 0; i<npts; i++)
		{
			cp[i].act = 1;//not necessary
			fin >> cp[i].coor[0] >> cp[i].coor[1] >> cp[i].coor[2];
		}
		getline(fin, stmp);
		fin >> stmp >> neles >> itmp;
		tmesh.resize(neles);
		for (int i = 0; i<neles; i++)
		{
			tmesh[i].act = 1;
			fin >> itmp >> tmesh[i].cnct[0] >> tmesh[i].cnct[1] >> tmesh[i].cnct[2] >> tmesh[i].cnct[3] >>
				tmesh[i].cnct[4] >> tmesh[i].cnct[5] >> tmesh[i].cnct[6] >> tmesh[i].cnct[7];
		}
		fin.close();
	}
	else
	{
		cerr << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::DeleteDuplicatePoint(string fn)
{
	vector<int> flag(cp.size(), -1);
	double dst, tol(1.e-6);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (flag[i] == -1)
		{
			for (uint j = i + 1; j < cp.size(); j++)
			{
				dst = (cp[i].coor[0] - cp[j].coor[0])*(cp[i].coor[0] - cp[j].coor[0]) + (cp[i].coor[1] - cp[j].coor[1])*(cp[i].coor[1] - cp[j].coor[1]) +
					(cp[i].coor[2] - cp[j].coor[2])*(cp[i].coor[2] - cp[j].coor[2]);
				if (dst < tol)
				{
					flag[j] = i;
				}
			}
		}
	}
	int count(0);
	vector<int> pid(cp.size());
	for (uint i = 0; i < cp.size(); i++)
	{
		if (flag[i] == -1)
		{
			pid[i] = count++;
		}
		else
		{
			pid[i] = pid[flag[i]];
		}
	}

	string fname(fn + ".vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nHex test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << count << " float\n";
		for (uint i = 0; i<cp.size(); i++)
		{
			if (flag[i] == -1)
			{
				fout << cp[i].coor[0] << " " << cp[i].coor[1] << " " << cp[i].coor[2] << "\n";
			}
		}
		fout << "\nCELLS " << tmesh.size() << " " << 9 * tmesh.size() << '\n';
		for (uint i = 0; i<tmesh.size(); i++)
		{
			fout << "8 ";
			for (int j = 0; j<8; j++)
			{
				fout << pid[tmesh[i].cnct[j]] << ' ';
			}
			fout << '\n';
		}
		fout << "\nCELL_TYPES " << tmesh.size() << '\n';
		for (uint i = 0; i<tmesh.size(); i++)
		{
			fout << "12\n";
		}

		//fout << "POINT_DATA " << cp.size() << "\nVECTORS type float\n";
		//for (uint i = 0; i<cp.size(); i++)
		//{
		//	fout << cp[i].type << " " << cp[i].sharp << " 0\n";
		//}
		//fout << "POINT_DATA " << cp.size() << "\nSCALARS type float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<cp.size(); i++)
		//{
		//	fout << cp[i].type << "\n";
		//}
		//fout << "\nCELL_DATA " << hmesh[lev].size() << "\nSCALARS eact float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<hmesh[lev].size(); i++)
		//{
		//	//fout<<hmesh[lev][i].act<<"\n";
		//	fout << hmesh[lev][i].type << "\n";
		//}

		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::BuildSolidTspline()
{
	SetDomain();//normalize coordinates in [0,1]^3, for the cube poisson

	Build_Edge_Face();
	MeshTopology();
	BuildElementBasis();
}

void TruncatedTspline_3D::Build_Edge_Face()
{
	uint i, j;
	tmedge.clear();
	tmface.clear();
	//construct edges
	for (i = 0; i<tmesh.size(); i++)
	{
		for (j = 0; j<4; j++)
		{
			Edge3D edtmp;
			edtmp.pt[0] = tmesh[i].cnct[j];
			edtmp.pt[1] = tmesh[i].cnct[(j + 1) % 4];
			vector<Edge3D>::iterator it = find(tmedge.begin(), tmedge.end(), edtmp);
			int edid(it - tmedge.begin());
			if (it == tmedge.end())
			{
				tmedge.push_back(edtmp);
			}
			tmesh[i].edge[j] = edid;
		}
		for (j = 0; j<4; j++)
		{
			Edge3D edtmp;
			edtmp.pt[0] = tmesh[i].cnct[j];
			edtmp.pt[1] = tmesh[i].cnct[j + 4];
			vector<Edge3D>::iterator it = find(tmedge.begin(), tmedge.end(), edtmp);
			int edid(it - tmedge.begin());
			if (it == tmedge.end())
			{
				tmedge.push_back(edtmp);
			}
			tmesh[i].edge[j + 4] = edid;
		}
		for (j = 0; j<4; j++)
		{
			Edge3D edtmp;
			edtmp.pt[0] = tmesh[i].cnct[j + 4];
			edtmp.pt[1] = tmesh[i].cnct[(j + 1) % 4 + 4];
			vector<Edge3D>::iterator it = find(tmedge.begin(), tmedge.end(), edtmp);
			int edid(it - tmedge.begin());
			if (it == tmedge.end())
			{
				tmedge.push_back(edtmp);
			}
			tmesh[i].edge[j + 8] = edid;
		}
	}
	//construct faces
	for (i = 0; i<tmesh.size(); i++)
	{
		//one bottom face
		Face3D fc1;
		for (j = 0; j<4; j++)
		{
			fc1.cnct[j] = tmesh[i].cnct[j];
			fc1.edge[j] = tmesh[i].edge[j];
		}
		vector<Face3D>::iterator it1 = find(tmface.begin(), tmface.end(), fc1);
		int fc1id(it1 - tmface.begin());
		if (it1 == tmface.end())
		{
			tmface.push_back(fc1);
		}
		tmesh[i].face[0] = fc1id;
		//4 side faces
		for (j = 0; j<4; j++)
		{
			Face3D fc;
			for (int k = 0; k<4; k++)
			{
				fc.cnct[k] = tmesh[i].cnct[fc_cnct[j][k]];
				fc.edge[k] = tmesh[i].edge[ed_cnct[j][k]];
			}
			vector<Face3D>::iterator it = find(tmface.begin(), tmface.end(), fc);
			int fcid(it - tmface.begin());
			if (it == tmface.end())
			{
				tmface.push_back(fc);
			}
			tmesh[i].face[j + 1] = fcid;
		}
		//one top face
		Face3D fc2;
		for (j = 0; j<4; j++)
		{
			fc2.cnct[j] = tmesh[i].cnct[j + 4];
			fc2.edge[j] = tmesh[i].edge[j + 8];
		}
		vector<Face3D>::iterator it2 = find(tmface.begin(), tmface.end(), fc2);
		int fc2id(it2 - tmface.begin());
		if (it2 == tmface.end())
		{
			tmface.push_back(fc2);
		}
		tmesh[i].face[5] = fc2id;
	}
}

void TruncatedTspline_3D::MeshTopology()
{
	uint i, j;
	//vertex-to-hex, edge-to-hex, face-to-hex
	for (i = 0; i<tmesh.size(); i++)
	{
		for (j = 0; j<8; j++)
		{
			cp[tmesh[i].cnct[j]].hex.push_back(i);
		}
		for (j = 0; j<12; j++)
		{
			tmedge[tmesh[i].edge[j]].hex.push_back(i);
		}
		for (j = 0; j<6; j++)
		{
			tmface[tmesh[i].face[j]].hex.push_back(i);
		}
	}
	//vertex-to-face, edge-to-face
	for (i = 0; i<tmface.size(); i++)
	{
		for (j = 0; j<4; j++)
		{
			cp[tmface[i].cnct[j]].face.push_back(i);
			tmedge[tmface[i].edge[j]].face.push_back(i);
		}
	}
	//vertex-to-edge
	for (i = 0; i<tmedge.size(); i++)
	{
		for (j = 0; j<2; j++)
		{
			cp[tmedge[i].pt[j]].edge.push_back(i);
		}
	}

	//find BC face, edge, vertex
	//int ed0[6][4] = { { 4, 5, 6, 7 }, { 1, 3, 9, 11 }, { 0, 2, 8, 10 }, { 1, 3, 9, 11 }, { 0, 2, 8, 10 }, { 4, 5, 6, 7 } };//order could be wrong, but doesn't matter
	int fc0[6] = { 2, 1, 0, 1, 0, 2 };
	for (i = 0; i<tmface.size(); i++)
	{
		if (tmface[i].hex.size() == 1)
		{
			tmface[i].type = 1;
			tmesh[tmface[i].hex[0]].type = 1;
			for (j = 0; j<4; j++)
			{
				cp[tmface[i].cnct[j]].type = 1;
				tmedge[tmface[i].edge[j]].type = 1;
			}
			//set zero length edges
			int hexid(tmface[i].hex[0]);
			int* it = find(tmesh[hexid].face, tmesh[hexid].face + 6, i);
			int fc_loc(it - tmesh[hexid].face);
			tmesh[hexid].kvlen[fc0[fc_loc]] = 0.;//not useful
			//for (j = 0; j<4; j++)
			//{
			//	tmedge[tmesh[hexid].edge[ed0[fc_loc][j]]].len = 0.;
			//}
		}
	}
	//find extraordinary edges and vertices
	for (i = 0; i<tmedge.size(); i++)
	{
		if (tmedge[i].type != 1 && tmedge[i].hex.size() != 4)
		{
			tmedge[i].type = 2;
			if (cp[tmedge[i].pt[0]].type != 1)
				cp[tmedge[i].pt[0]].type = 3;
			if (cp[tmedge[i].pt[1]].type != 1)
				cp[tmedge[i].pt[1]].type = 3;
		}
	}
	////boundary
	//for (i = 0; i<cp.size(); i++)
	//{
	//	if (cp[i].type == 1)//not consider surface extraordinary points yet
	//	{
	//		//int val(0);
	//		//for(j=0; j<cp[i].face.size(); j++)
	//		//{
	//		//	if(tmface[cp[i].face[j]].type==1) val++;
	//		//}
	//		//if(val==3 || val>4) cp[i].type=13;
	//	}
	//}

	//find irregular elements
	for (i = 0; i<tmesh.size(); i++)
	{
		if (tmesh[i].type != 1)
		{
			for (j = 0; j < 8; j++)
			{
				if (cp[tmesh[i].cnct[j]].type==3)
				{
					tmesh[i].type = 2;
					break;
				}
			}
			for (j = 0; j<12; j++)
			{
				if (tmedge[tmesh[i].edge[j]].type == 2)
				{
					tmesh[i].type = 2;
					break;
				}
			}
		}
	}

	//additional boundary elements
	for (i = 0; i<tmesh.size(); i++)
	{
		if (tmesh[i].type != 1)
		{
			for (j = 0; j<8; j++)
			{
				if (cp[tmesh[i].cnct[j]].type == 1)
				{
					tmesh[i].type = 1;
					break;
				}
			}
		}
	}

	//neighbor information
	for (i = 0; i < tmesh.size(); i++)
	{
		if (tmesh[i].type == 0)
		{
			vector<int> nb(6);
			for (j = 0; j < 6; j++)
			{
				nb[j] = tmface[tmesh[i].face[j]].hex[0];
				if (nb[j] == i) nb[j] = tmface[tmesh[i].face[j]].hex[1];
				tmesh[i].fcnb[j][0] = nb[j];
				int* it = find(tmesh[nb[j]].face, tmesh[nb[j]].face + 6, tmesh[i].face[j]);
				tmesh[i].fcnb[j][1] = it - tmesh[nb[j]].face;
				if (tmesh[i].fcnb[j][1] == 6)
				{
					cerr << "Can't find face in face neighbor!\n"; getchar();
				}
			}
			nb.push_back(i);
			for (j = 0; j < 12; j++)
			{
				for (int k = 0; k < tmedge[tmesh[i].edge[j]].hex.size(); k++)
				{
					int ednb(tmedge[tmesh[i].edge[j]].hex[k]);
					vector<int>::iterator it = find(nb.begin(), nb.end(), ednb);
					if (it == nb.end())
					{
						tmesh[i].ednb[j][0] = ednb;
						int* it1 = find(tmesh[ednb].edge, tmesh[ednb].edge + 12, tmesh[i].edge[j]);
						tmesh[i].ednb[j][1] = it1 - tmesh[ednb].edge;
						if (tmesh[i].ednb[j][1] == 12)
						{
							cerr << "Can't find edge in edge neighbor!\n"; getchar();
						}
						nb.push_back(ednb);
						break;
					}
				}
				if (tmesh[i].ednb[j][0] == -1)
				{
					cerr << "Can't find edge neighbor!\n"; getchar();
				}
			}
			for (j = 0; j < 8; j++)
			{
				for (int k = 0; k < cp[tmesh[i].cnct[j]].hex.size(); k++)
				{
					int vtnb(cp[tmesh[i].cnct[j]].hex[k]);
					vector<int>::iterator it = find(nb.begin(), nb.end(), vtnb);
					if (it == nb.end())
					{
						tmesh[i].vtnb[j][0] = vtnb;
						int* it1 = find(tmesh[vtnb].cnct, tmesh[vtnb].cnct + 8, tmesh[i].cnct[j]);
						tmesh[i].vtnb[j][1] = it1 - tmesh[vtnb].cnct;
						if (tmesh[i].vtnb[j][1] == 8)
						{
							cerr << "Can't find edge in edge neighbor!\n"; getchar();
						}
						nb.push_back(vtnb);
						break;
					}
				}
				if (tmesh[i].vtnb[j][0] == -1)
				{
					cerr << "Can't find vertex neighbor!\n"; getchar();
				}
			}
		}
	}

	//boundry extraordinary points
	//for (i = 0; i<cp.size(); i++)
	//{
	//	if (cp[i].type == 1)
	//	{
	//		int count(0);
	//		for (j = 0; j < cp[i].edge.size(); j++)
	//		{
	//			if (tmedge[cp[i].edge[j]].type == 2) count++;
	//		}
	//		if (count == 1) cp[i].bcxp = 1;
	//		else if (count>1) cp[i].bcxp = 2;
	//	}
	//}
}

void TruncatedTspline_3D::BuildElementBasis()
{
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].type == 0)
		{
			SetRegularPatch(eid);
		}
		else if (tmesh[eid].type == 2)
		{
			SetBezierMatIrrPatch(eid);
			UpdateIEN_Irr(eid);
		}
	}
}

void TruncatedTspline_3D::SetRegularPatch(int eid)
{
	int fcop[6] = { 5, 3, 4, 1, 2, 0 };
	int edop[12] = { 10, 11, 8, 9, 6, 7, 4, 5, 2, 3, 0, 1 };
	int vtop[8] = { 6, 7, 4, 5, 2, 3, 0, 1 };

	int fcdir[3][2] = { { 4, 2 }, { 1, 3 }, { 0, 5 } };
	//int fcppd[6] = { 2, 1, 0, 1, 0, 2 };
	tmesh[eid].patch_ku.clear();
	tmesh[eid].patch_kv.clear();
	tmesh[eid].patch_kw.clear();
	tmesh[eid].patch_ku.resize(64);
	tmesh[eid].patch_kv.resize(64);
	tmesh[eid].patch_kw.resize(64);
	double pklen[3][7];
	double pkv[3][8];

	for (int idr = 0; idr < 3; idr++)
	{
		//pklen[idr][3] = tmesh[eid].kvlen[idr];
		for (int i = 0; i < 7; i++) pklen[idr][i] = 1.;//initialize to unit intervals
		//negative direction
		int hx_next(tmesh[eid].fcnb[fcdir[idr][0]][0]);
		int fcloc_next(tmesh[eid].fcnb[fcdir[idr][0]][1]);
		if (tmesh[hx_next].type == 1)
		{
			pklen[idr][2] = 0.; pklen[idr][1] = 0.;
		}
		else if (tmesh[hx_next].type == 0)
		{
			int fcoploc_next(fcop[fcloc_next]);
			int hx_next2(tmesh[hx_next].fcnb[fcoploc_next][0]);
			if (tmesh[hx_next2].type == 1)
			{
				pklen[idr][1] = 0.;
			}
		}
		//positive direction
		hx_next = tmesh[eid].fcnb[fcdir[idr][1]][0];
		fcloc_next = tmesh[eid].fcnb[fcdir[idr][1]][1];
		if (tmesh[hx_next].type == 1)
		{
			pklen[idr][4] = 0.; pklen[idr][5] = 0.;
		}
		else if (tmesh[hx_next].type == 0)
		{
			int fcoploc_next(fcop[fcloc_next]);
			int hx_next2(tmesh[hx_next].fcnb[fcoploc_next][0]);
			if (tmesh[hx_next2].type == 1)
			{
				pklen[idr][5] = 0.;
			}
		}

		pklen[idr][0] = pklen[idr][1];
		pklen[idr][6] = pklen[idr][5];

		pkv[idr][3] = 0.; pkv[idr][4] = pklen[idr][3];
		for (int i = 0; i < 3; i++)
		{
			pkv[idr][5 + i] = pkv[idr][4 + i] + pklen[idr][4 + i];
			pkv[idr][2 - i] = pkv[idr][3 - i] - pklen[idr][2 - i];
		}

		for (int i = 0; i < 8; i++)
		{
			tmesh[eid].pkv[idr][i] = pkv[idr][i];
		}
	}

	int count(0);
	for (int k = 0; k < 4; k++)
	{
		for (int j = 0; j < 4; j++)
		{
			for (int i = 0; i < 4; i++)
			{
				for (int ikv = 0; ikv < 5; ikv++)
				{
					tmesh[eid].patch_ku[count][ikv] = pkv[0][ikv + i];
					tmesh[eid].patch_kv[count][ikv] = pkv[1][ikv + j];
					tmesh[eid].patch_kw[count][ikv] = pkv[2][ikv + k];
				}
				count++;
			}
		}
	}

	//find IEN
	tmesh[eid].IEN.clear();
	tmesh[eid].IEN.resize(64);

	int vcn_loc[8] = { 21, 22, 26, 25, 37, 38, 42, 41 };
	int fcnb_loc[6][4] = { { 5, 6, 10, 9 }, { 17, 18, 34, 33 }, { 23, 27, 43, 39 }, { 29, 30, 46, 45 }, { 20, 24, 40, 36 }, { 53, 54, 58, 57 } };
	int ednb_loc[12][2] = { { 1, 2 }, { 7, 11 }, { 14, 13 }, { 8, 4 }, { 16, 32 }, { 19, 35 }, { 31, 47 }, { 28, 44 }, { 49, 50 }, { 55, 59 }, { 62, 61 }, { 56, 52 } };
	int vtnb_loc[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };

	int fcs[6][4] = { { 0, 1, 2, 3 }, { 0, 1, 5, 4 }, { 1, 2, 6, 5 }, { 3, 2, 6, 7 }, { 0, 3, 7, 4 }, { 4, 5, 6, 7 } };
	int eds[12][2] = { { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 0 }, { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 4 } };
	int fcped[6][4] = { { 4, 5, 6, 7 }, { 3, 1, 9, 11 }, { 0, 2, 10, 8 }, { 3, 1, 9, 11 }, { 0, 2, 10, 8 }, { 4, 5, 6, 7 } };

	for (int i = 0; i < 8; i++)
	{
		tmesh[eid].IEN[vcn_loc[i]] = tmesh[eid].cnct[i];
		int hxid(tmesh[eid].vtnb[i][0]);
		int ploc = vtop[tmesh[eid].vtnb[i][1]];
		tmesh[eid].IEN[vtnb_loc[i]] = tmesh[hxid].cnct[ploc];
	}
	for (int i = 0; i < 12; i++)
	{
		int hxid(tmesh[eid].ednb[i][0]);//edge neighbor
		//int edloc(tmesh[eid].ednb[i][1]);//edge id in the edge neighbor
		//int ploc[2] = { eds[edloc][0], eds[edloc][1] };//need to know start
		int pid[2] = { tmesh[eid].cnct[eds[i][0]], tmesh[eid].cnct[eds[i][1]] };//ordered two end points
		int fcloc[2] = { -1, -1 };
		int plocop[2] = { -1, -1 };
		for (int j = 0; j < 6; j++)//loop through the 6 faces of the edge neighbor
		{
			int num[2] = { 0, 0 };
			int tmp[2] = { -1, -1 };
			for (int k = 0; k < 4; k++)
			{
				if (tmface[tmesh[hxid].face[j]].cnct[k] == pid[0])
				{
					num[0]++; tmp[0] = k;
				}
				if (tmface[tmesh[hxid].face[j]].cnct[k] == pid[1])
				{
					num[1]++; tmp[1] = k;
				}
			}
			if (num[0] == 1 && num[1] == 0)
			{
				fcloc[0] = j; plocop[0] = (tmp[0] + 2) % 4;
			}
			if (num[1] == 1 && num[0] == 0)
			{
				fcloc[1] = j; plocop[1] = (tmp[1] + 2) % 4;
			}
		}
		if (fcloc[0] == -1 || fcloc[1] == -1)
		{
			cerr << "Can't find face with one edge point!\n"; getchar();
		}
		
		tmesh[eid].IEN[ednb_loc[i][0]] = tmface[tmesh[hxid].face[fcloc[0]]].cnct[plocop[0]];
		tmesh[eid].IEN[ednb_loc[i][1]] = tmface[tmesh[hxid].face[fcloc[1]]].cnct[plocop[1]];
	}
	for (int i = 0; i < 6; i++)
	{
		int hxid(tmesh[eid].fcnb[i][0]);
		int fcloc(tmesh[eid].fcnb[i][1]);
		//int ploc[4] = { fcs[fcloc][0], fcs[fcloc][1], fcs[fcloc][2], fcs[fcloc][3] };//need to know which is the start
		int pid0[4] = { tmesh[eid].cnct[fcs[i][0]], tmesh[eid].cnct[fcs[i][1]], tmesh[eid].cnct[fcs[i][2]], tmesh[eid].cnct[fcs[i][3]] };
		int edloc[4] = { fcped[fcloc][0], fcped[fcloc][1], fcped[fcloc][2], fcped[fcloc][3] };
		int pid[4] = { -1, -1, -1, -1 };
		for (int j = 0; j < 4; j++)
		{
			for (int k = 0; k < 4; k++)
			{
				if (tmedge[tmesh[hxid].edge[edloc[k]]].pt[0] == pid0[j])
				{
					pid[j] = tmedge[tmesh[hxid].edge[edloc[k]]].pt[1];
				}
				else if (tmedge[tmesh[hxid].edge[edloc[k]]].pt[1] == pid0[j])
				{
					pid[j] = tmedge[tmesh[hxid].edge[edloc[k]]].pt[0];
				}
			}
			//if (tmedge[tmesh[hxid].edge[edloc[j]]].pt[0] == pid0[j])
			//{
			//	pid[j] = tmedge[tmesh[hxid].edge[edloc[j]]].pt[1];
			//}
			//else if (tmedge[tmesh[hxid].edge[edloc[j]]].pt[1] == pid0[j])
			//{
			//	pid[j] = tmedge[tmesh[hxid].edge[edloc[j]]].pt[0];
			//}
			//else
			//{
			//	cerr << "face edge cnct wrong!\n"; getchar();
			//}

			if (pid[j] == -1)
			{
				cerr << "Can't find face point in the perpendicular edges!\n";
				getchar();
			}
			tmesh[eid].IEN[fcnb_loc[i][j]] = pid[j];
		}
	}

	//cout << "eid: " << eid << " IEN:\n";
	//for (uint i = 0; i < tmesh[eid].IEN.size(); i++)
	//{
	//	cout << tmesh[eid].IEN[i] << " ";
	//}
	//cout << "\n";
	//cout << "patch knot vectors:\n";
	//cout << "ku: ";
	//for (int i = 0; i < 8; i++) cout << pkv[0][i] << " ";
	//cout << "\n";
	//cout << "kv: ";
	//for (int i = 0; i < 8; i++) cout << pkv[1][i] << " ";
	//cout << "\n";
	//cout << "kw: ";
	//for (int i = 0; i < 8; i++) cout << pkv[2][i] << " ";
	//cout << "\n";
	//getchar();
}

void TruncatedTspline_3D::UpdateIEN_Irr(int eid)
{
	vector<int>().swap(tmesh[eid].IEN);
	tmesh[eid].IEN = tmesh[eid].IENtmp;
	vector<int>().swap(tmesh[eid].IENtmp);
}

void TruncatedTspline_3D::Refine_Global()
{
	RecordTmeshInfo();
	for (uint e = 0; e < tmesh.size(); e++)
	{
		if (tmesh[e].type == 0)
		{
			Refine_Element_Reg(e);
		}
		if (tmesh[e].type == 1)//be careful with zero-area ones
		{
			//Refine_Element_Bnd(e);
		}
		else if (tmesh[e].type == 2)
		{
			//Refine_Element_Irr(e);
		}
		else
		{
			cerr << "Not supported type for refinement!\n"; getchar();
		}
	}
}

void TruncatedTspline_3D::RecordTmeshInfo()
{
	npt_old = cp.size();
	nel_old = tmesh.size();
	nfc_old = tmface.size();
	ned_old = tmedge.size();

	for (uint i = 0; i < cp.size(); i++)
	{
		cp[i].coortmp[0] = 0.; cp[i].coortmp[1] = 0.; cp[i].coortmp[2] = 0.;
		cp[i].update = 0;
	}
}

void TruncatedTspline_3D::Refine_Element_Reg(int eid)
{
	vector<vector<double>> pkv1(3);
	vector<vector<double>> pkv2(3);
	vector<vector<double>> Tu, Tv, Tw;
	for (int i = 0; i < 3; i++)
	{
		pkv1[i].resize(8);
		for (int j = 0; j < 8; j++)
		{
			pkv1[i][j] = tmesh[eid].pkv[i][j];
		}
		KnotVectorSubdiv(pkv1[i], pkv2[i]);
	}
	TMatrix(pkv1[0], pkv2[0], 3, Tu);
	TMatrix(pkv1[1], pkv2[1], 3, Tv);
	TMatrix(pkv1[2], pkv2[2], 3, Tw);
	int ist[3] = { 0, 0, 0 };
	for (int i = 0; i < 3; i++)
	{
		for (uint j = 0; j < pkv2.size() - 1; j++)
		{
			if (pkv2[i][j] == 0. && pkv2[i][j] < pkv2[i][j + 1])
			{
				ist[i] = j - 2; break;
			}
		}
	}

	int i1, i2, j1, j2, k1, k2;
	int loc1(0), loc2(0);
	double coef;
	vector<Vertex3D> pnew(27);
	for (k2 = 0; k2 < 3; k2++)
	{
		for (j2 = 0; j2 < 3; j2++)
		{
			for (i2 = 0; i2 < 3; i2++)
			{
				loc1 = 0;
				for (k1 = 0; k1 < 4; k1++)
				{
					for (j1 = 0; j1 < 4; j1++)
					{
						for (i1 = 0; i1 < 4; i1++)
						{
							coef = Tu[ist[0] + i2][i1] * Tu[ist[1] + j2][j1] * Tw[ist[2] + k2][k1];
							if (coef != 0.)
							{
								pnew[loc2].coortmp[0] += coef*cp[tmesh[eid].IEN[loc1]].coor[0];
								pnew[loc2].coortmp[1] += coef*cp[tmesh[eid].IEN[loc1]].coor[1];
								pnew[loc2].coortmp[2] += coef*cp[tmesh[eid].IEN[loc1]].coor[2];
							}
							loc1++;
						}
					}
				}
				loc2++;
			}
		}
	}

	int pvt_loc[8] = { 0, 2, 8, 6, 18, 20, 26, 24 };
	int ped_loc[12] = { 1, 5, 7, 3, 9, 11, 17, 15, 19, 23, 25, 21 };
	int pfc_loc[6] = { 4, 10, 14, 16, 12, 22 };
	int pnid[27];
	cp.push_back(pnew[13]);//body point
	pnid[13] = cp.size() - 1;
	for (int i = 0; i < 8; i++)
	{
		if (cp[tmesh[eid].cnct[i]].update == 0)
		{
			cp[tmesh[eid].cnct[i]].coortmp[0] = pnew[pvt_loc[i]].coortmp[0];
			cp[tmesh[eid].cnct[i]].coortmp[1] = pnew[pvt_loc[i]].coortmp[1];
			cp[tmesh[eid].cnct[i]].coortmp[2] = pnew[pvt_loc[i]].coortmp[2];
			cp[tmesh[eid].cnct[i]].update = 1;
		}
		pnid[pvt_loc[i]] = tmesh[eid].cnct[i];
	}
	for (int i = 0; i < 12; i++)
	{
		if (tmedge[tmesh[eid].edge[i]].act == 1)
		{
			cp.push_back(pnew[ped_loc[i]]);
			tmedge[tmesh[eid].edge[i]].midpt = cp.size() - 1;
			//tmedge[tmesh[eid].edge[i]].act = 0;
		}
		pnid[ped_loc[i]] = tmedge[tmesh[eid].edge[i]].midpt;
	}
	for (int i = 0; i < 6; i++)
	{
		if (tmface[tmesh[eid].face[i]].act == 1)
		{
			cp.push_back(pnew[pfc_loc[i]]);
			tmface[tmesh[eid].face[i]].ctpt = cp.size() - 1;
			//tmface[tmesh[eid].face[i]].act = 0;
		}
		pnid[pfc_loc[i]] = tmface[tmesh[eid].face[i]].ctpt;
	}

	//int fcs[6][4] = { { 0, 1, 2, 3 }, { 0, 1, 5, 4 }, { 1, 2, 6, 5 }, { 3, 2, 6, 7 }, { 0, 3, 7, 4 }, { 4, 5, 6, 7 } };
	//int eds[12][2] = { { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 0 }, { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 4 } };
	//construct edges
	int ednid[54];
	for (int i = 0; i < 12; i++)
	{
		if (tmedge[tmesh[eid].edge[i]].act == 1)
		{
			Edge3D edtmp[2];
			edtmp[0].pt[0] = tmedge[tmesh[eid].edge[i]].pt[0];
			edtmp[0].pt[1] = tmedge[tmesh[eid].edge[i]].midpt;
			edtmp[1].pt[0] = tmedge[tmesh[eid].edge[i]].midpt;
			edtmp[1].pt[1] = tmedge[tmesh[eid].edge[i]].pt[1];
			tmedtmp.push_back(edtmp[0]);
			tmedge[tmesh[eid].edge[i]].chd[0] = tmedtmp.size() - 1;
			tmedtmp.push_back(edtmp[1]);
			tmedge[tmesh[eid].edge[i]].chd[1] = tmedtmp.size() - 1;
			tmedge[tmesh[eid].edge[i]].act = 0;
		}
		ednid[2 * i] = tmedge[tmesh[eid].edge[i]].chd[0];
		ednid[2 * i + 1] = tmedge[tmesh[eid].edge[i]].chd[1];
	}
	for (int i = 0; i < 6; i++)
	{
		if (tmface[tmesh[eid].face[i]].act == 1)
		{
			Edge3D edtmp[4];
			tmface[tmesh[eid].face[i]].Tedge.resize(4);
			for (int j = 0; j < 4; j++)
			{
				edtmp[j].pt[0] = tmface[tmesh[eid].face[i]].ctpt;
				edtmp[j].pt[1] = tmedge[tmface[tmesh[eid].face[i]].edge[j]].midpt;
				tmedtmp.push_back(edtmp[j]);
				tmface[tmesh[eid].face[i]].Tedge[j] = tmedtmp.size() - 1;
			}
		}
		for (int j = 0; j < 4; j++)
		{
			ednid[24 + 6 * i + j] = tmface[tmesh[eid].face[i]].Tedge[j];
		}
	}
	for (int i = 0; i < 6; i++)
	{
		Edge3D edtmp;
		edtmp.pt[0] = pnid[13];
		edtmp.pt[1] = tmface[tmesh[eid].face[i]].ctpt;
		tmedtmp.push_back(edtmp);
		ednid[48 + i] = tmedtmp.size() - 1;

	}

	//construct faces
	int fcnid[36];
	int fcold[6][4][4] = { { { 0, 1, 4, 3 }, { 1, 2, 5, 4 }, { 3, 4, 7, 6 }, { 4, 5, 8, 7 } }, 
	{ { 0, 1, 10, 9 }, { 1, 2, 11, 10 }, { 9, 10, 19, 18 }, { 10, 11, 20, 19 } },
	{ { 2, 5, 14, 11 }, { 5, 8, 17, 14 }, { 11, 14, 23, 20 }, { 14, 17, 26, 23 } },
	{ { 6, 7, 16, 15 }, { 7, 8, 17, 16 }, { 15, 16, 25, 24 }, { 16, 17, 26, 25 } },
	{ { 0, 3, 12, 9 }, { 3, 6, 15, 12 }, { 9, 12, 21, 18 }, { 12, 15, 24, 21 } },
	{ { 18, 19, 22, 21 }, { 19, 20, 23, 22 }, { 21, 22, 25, 24 }, { 22, 23, 26, 25 } } };
	int fcnew[12][4] = { { 9, 10, 13, 12 }, { 10, 11, 14, 13 }, { 12, 13, 16, 15 }, { 13, 14, 17, 16 },
	{ 1, 4, 13, 10 }, { 4, 7, 16, 13 }, { 10, 13, 22, 19 }, { 13, 16, 25, 22 },
	{ 3, 4, 13, 12 }, { 4, 5, 14, 13 }, { 12, 13, 22, 21 }, { 13, 14, 23, 22 } };
	for (int i = 0; i < 6; i++)
	{
		if (tmface[tmesh[eid].face[i]].act == 1)
		{
			Face3D fctmp[4];
			tmface[tmesh[eid].face[i]].chd.resize(4);
			for (int j = 0; j < 4; j++)
			{
				for (int k = 0; k < 4; k++)
				{
					fctmp[j].cnct[k] = pnid[fcold[i][j][k]];
				}
				tmfctmp.push_back(fctmp[j]);
				tmface[tmesh[eid].face[i]].chd[j] = tmfctmp.size() - 1;
			}
			tmface[tmesh[eid].face[i]].act = 0;
		}
		for (int j = 0; j < 4; j++)
		{
			fcnid[4 * i + j] = tmface[tmesh[eid].face[i]].chd[j];
		}
	}
	for (int i = 0; i < 12; i++)
	{
		Face3D fctmp;
		for (int j = 0; j < 4; j++)
		{
			fctmp.cnct[j] = pnid[fcnew[i][j]];
		}
		tmfctmp.push_back(fctmp);
		fcnid[24 + i] = tmfctmp.size() - 1;
	}

	//construct hex
	int hxnid[8];
	int hxnew[8][8] = { { 0, 1, 4, 3, 9, 10, 13, 12 }, { 1, 2, 5, 4, 10, 11, 14, 13 }, { 3, 4, 7, 6, 12, 13, 16, 15 }, {4,5,8,7,13,14,17,16},
	{ 9, 10, 13, 12, 18, 19, 22, 21 }, { 10, 11, 14, 13, 19, 20, 23, 22 }, { 12, 13, 16, 15, 21, 22, 25, 24 }, { 13, 14, 17, 16, 22, 23, 26, 25 } };
	for (int i = 0; i < 8; i++)
	{
		Element3D etmp;
		for (int j = 0; j < 8; j++)
		{
			etmp.cnct[j] = pnid[hxnew[i][j]];
		}
		tmtmp.push_back(etmp);
		hxnid[i] = tmtmp.size() - 1;
	}
	Find_FaceEdge_Index(hxnid, fcnid, ednid);

	//boundary neighbor elements
	//int bflag[6] = { 0, 0, 0, 0, 0, 0 };
	//for (int i = 0; i < 6; i++)
	//{
	//	if (tmesh[tmesh[eid].fcnb[i][0]].type == 1)//face neighbor is boundary element
	//	{
	//		bflag[i] = 1;
	//	}
	//}
}

void TruncatedTspline_3D::Find_FaceEdge_Index(int hxid[8], int fcid[36], int edid[54])
{
	int i, j, k, edpid[2];
	//find edge index in faces
	for (i = 0; i < 36; i++)
	{
		for (j = 0; j < 4; j++)
		{
			edpid[0] = tmfctmp[fcid[i]].cnct[j];
			edpid[1] = tmfctmp[fcid[i]].cnct[(j + 1) % 4];
			int flag(0);
			for (k = 0; k < 54; k++)
			{
				if ((tmedtmp[edid[k]].pt[0] == edpid[0] && tmedtmp[edid[k]].pt[1] == edpid[1]) || 
					(tmedtmp[edid[k]].pt[1] == edpid[0] && tmedtmp[edid[k]].pt[0] == edpid[1]))
				{
					flag = 1;
					tmfctmp[fcid[i]].edge[j] = edid[k]; break;
				}
			}
			if (flag == 0)
			{
				cerr << "Can't find edge index in a face!\n"; getchar();
			}
		}
	}
	//find face and edge index in hex
	int fcs[6][4] = { { 0, 1, 2, 3 }, { 0, 1, 5, 4 }, { 1, 2, 6, 5 }, { 3, 2, 6, 7 }, { 0, 3, 7, 4 }, { 4, 5, 6, 7 } };
	int eds[12][2] = { { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 0 }, { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 4 } };
	vector<array<int, 4>> fcsort(36);
	for (i = 0; i < 36; i++)
	{
		for (j = 0; j < 4; j++)
		{
			fcsort[i][j] = tmfctmp[fcid[i]].cnct[j];
		}
		sort(fcsort[i].begin(), fcsort[i].end());
	}
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 6; j++)
		{
			array<int, 4> fctmp;
			for (k = 0; k < 4; k++)
			{
				fctmp[k] = tmtmp[hxid[i]].cnct[fcs[j][k]];
			}
			sort(fctmp.begin(), fctmp.end());
			vector<array<int, 4>>::iterator it = find(fcsort.begin(), fcsort.end(), fctmp);
			if (it != fcsort.end())
			{
				tmtmp[hxid[i]].face[j] = fcid[it - fcsort.begin()];
			}
			else
			{
				cerr << "Can'f find face in a hex!\n"; getchar();
			}
		}
		for (j = 0; j < 12; j++)
		{
			edpid[0] = tmtmp[hxid[i]].cnct[eds[j][0]];
			edpid[1] = tmtmp[hxid[i]].cnct[eds[j][1]];
			int flag(0);
			for (k = 0; k < 54; k++)
			{
				if ((tmedtmp[edid[k]].pt[0] == edpid[0] && tmedtmp[edid[k]].pt[1] == edpid[1]) ||
					(tmedtmp[edid[k]].pt[1] == edpid[0] && tmedtmp[edid[k]].pt[0] == edpid[1]))
				{
					flag = 1;
					tmtmp[hxid[i]].edge[j] = edid[k]; break;
				}
			}
			if (flag == 0)
			{
				cerr << "Can't find edge index in a face!\n"; getchar();
			}
		}
	}
}

void TruncatedTspline_3D::Refine_Element_Int_Topology(int eid)
{
	//find points
	vector<Vertex3D> pnew(27);
	int pvt_loc[8] = { 0, 2, 8, 6, 18, 20, 26, 24 };
	int ped_loc[12] = { 1, 5, 7, 3, 9, 11, 17, 15, 19, 23, 25, 21 };
	int pfc_loc[6] = { 4, 10, 14, 16, 12, 22 };
	int pnid[27];
	cp.push_back(pnew[13]);//body point
	pnid[13] = cp.size() - 1;
	for (int i = 0; i < 8; i++)
	{
		pnid[pvt_loc[i]] = tmesh[eid].cnct[i];
	}
	for (int i = 0; i < 12; i++)
	{
		if (tmedge[tmesh[eid].edge[i]].act == 1)
		{
			cp.push_back(pnew[ped_loc[i]]);
			tmedge[tmesh[eid].edge[i]].midpt = cp.size() - 1;
		}
		pnid[ped_loc[i]] = tmedge[tmesh[eid].edge[i]].midpt;
	}
	for (int i = 0; i < 6; i++)
	{
		if (tmface[tmesh[eid].face[i]].act == 1)
		{
			cp.push_back(pnew[pfc_loc[i]]);
			tmface[tmesh[eid].face[i]].ctpt = cp.size() - 1;
		}
		pnid[pfc_loc[i]] = tmface[tmesh[eid].face[i]].ctpt;
	}

	//construct edges
	int ednid[54];
	for (int i = 0; i < 12; i++)
	{
		if (tmedge[tmesh[eid].edge[i]].act == 1)
		{
			Edge3D edtmp[2];
			edtmp[0].pt[0] = tmedge[tmesh[eid].edge[i]].pt[0];
			edtmp[0].pt[1] = tmedge[tmesh[eid].edge[i]].midpt;
			edtmp[1].pt[0] = tmedge[tmesh[eid].edge[i]].midpt;
			edtmp[1].pt[1] = tmedge[tmesh[eid].edge[i]].pt[1];
			tmedtmp.push_back(edtmp[0]);
			tmedge[tmesh[eid].edge[i]].chd[0] = tmedtmp.size() - 1;
			tmedtmp.push_back(edtmp[1]);
			tmedge[tmesh[eid].edge[i]].chd[1] = tmedtmp.size() - 1;
			tmedge[tmesh[eid].edge[i]].act = 0;
		}
		ednid[2 * i] = tmedge[tmesh[eid].edge[i]].chd[0];
		ednid[2 * i + 1] = tmedge[tmesh[eid].edge[i]].chd[1];
	}
	for (int i = 0; i < 6; i++)
	{
		if (tmface[tmesh[eid].face[i]].act == 1)
		{
			Edge3D edtmp[4];
			tmface[tmesh[eid].face[i]].Tedge.resize(4);
			for (int j = 0; j < 4; j++)
			{
				edtmp[j].pt[0] = tmface[tmesh[eid].face[i]].ctpt;
				edtmp[j].pt[1] = tmedge[tmface[tmesh[eid].face[i]].edge[j]].midpt;
				tmedtmp.push_back(edtmp[j]);
				tmface[tmesh[eid].face[i]].Tedge[j] = tmedtmp.size() - 1;
			}
		}
		for (int j = 0; j < 4; j++)
		{
			ednid[24 + 6 * i + j] = tmface[tmesh[eid].face[i]].Tedge[j];
		}
	}
	for (int i = 0; i < 6; i++)
	{
		Edge3D edtmp;
		edtmp.pt[0] = pnid[13];
		edtmp.pt[1] = tmface[tmesh[eid].face[i]].ctpt;
		tmedtmp.push_back(edtmp);
		ednid[48 + i] = tmedtmp.size() - 1;

	}

	//construct faces
	int fcnid[36];
	int fcold[6][4][4] = { { { 0, 1, 4, 3 }, { 1, 2, 5, 4 }, { 3, 4, 7, 6 }, { 4, 5, 8, 7 } },
	{ { 0, 1, 10, 9 }, { 1, 2, 11, 10 }, { 9, 10, 19, 18 }, { 10, 11, 20, 19 } },
	{ { 2, 5, 14, 11 }, { 5, 8, 17, 14 }, { 11, 14, 23, 20 }, { 14, 17, 26, 23 } },
	{ { 6, 7, 16, 15 }, { 7, 8, 17, 16 }, { 15, 16, 25, 24 }, { 16, 17, 26, 25 } },
	{ { 0, 3, 12, 9 }, { 3, 6, 15, 12 }, { 9, 12, 21, 18 }, { 12, 15, 24, 21 } },
	{ { 18, 19, 22, 21 }, { 19, 20, 23, 22 }, { 21, 22, 25, 24 }, { 22, 23, 26, 25 } } };
	int fcnew[12][4] = { { 9, 10, 13, 12 }, { 10, 11, 14, 13 }, { 12, 13, 16, 15 }, { 13, 14, 17, 16 },
	{ 1, 4, 13, 10 }, { 4, 7, 16, 13 }, { 10, 13, 22, 19 }, { 13, 16, 25, 22 },
	{ 3, 4, 13, 12 }, { 4, 5, 14, 13 }, { 12, 13, 22, 21 }, { 13, 14, 23, 22 } };
	for (int i = 0; i < 6; i++)
	{
		if (tmface[tmesh[eid].face[i]].act == 1)
		{
			Face3D fctmp[4];
			tmface[tmesh[eid].face[i]].chd.resize(4);
			for (int j = 0; j < 4; j++)
			{
				for (int k = 0; k < 4; k++)
				{
					fctmp[j].cnct[k] = pnid[fcold[i][j][k]];
				}
				tmfctmp.push_back(fctmp[j]);
				tmface[tmesh[eid].face[i]].chd[j] = tmfctmp.size() - 1;
			}
			tmface[tmesh[eid].face[i]].act = 0;
		}
		for (int j = 0; j < 4; j++)
		{
			fcnid[4 * i + j] = tmface[tmesh[eid].face[i]].chd[j];
		}
	}
	for (int i = 0; i < 12; i++)
	{
		Face3D fctmp;
		for (int j = 0; j < 4; j++)
		{
			fctmp.cnct[j] = pnid[fcnew[i][j]];
		}
		tmfctmp.push_back(fctmp);
		fcnid[24 + i] = tmfctmp.size() - 1;
	}

	//construct hex
	int hxnid[8];
	int hxnew[8][8] = { { 0, 1, 4, 3, 9, 10, 13, 12 }, { 1, 2, 5, 4, 10, 11, 14, 13 }, { 3, 4, 7, 6, 12, 13, 16, 15 }, { 4, 5, 8, 7, 13, 14, 17, 16 },
	{ 9, 10, 13, 12, 18, 19, 22, 21 }, { 10, 11, 14, 13, 19, 20, 23, 22 }, { 12, 13, 16, 15, 21, 22, 25, 24 }, { 13, 14, 17, 16, 22, 23, 26, 25 } };
	for (int i = 0; i < 8; i++)
	{
		Element3D etmp;
		for (int j = 0; j < 8; j++)
		{
			etmp.cnct[j] = pnid[hxnew[i][j]];
		}
		tmtmp.push_back(etmp);
		hxnid[i] = tmtmp.size() - 1;
	}
	Find_FaceEdge_Index(hxnid, fcnid, ednid);
}

void TruncatedTspline_3D::Refine_Element_Bnd4_Topology(int eid, int dir)
{
	//find points
	vector<Vertex3D> pnew(18);
	//int fcbt[3][2] = { { 4, 2 }, { 1, 3 }, { 0, 5 } };//bottom and top faces of eid
	//int fcsd[3][4] = { { 1, 0, 3, 5 }, { 5, 2, 0, 4 }, { 1, 2, 3, 4 } };//side faces of eid
	int pvt_loc[3][8] = { { 2, 11, 7, 8, 0, 9, 15, 6 }, { 6, 8, 17, 15, 0, 2, 11, 9 }, { 0, 2, 8, 6, 9, 11, 17, 15 } };
	int ped_loc[8] = { 1, 5, 7, 3, 10, 14, 16, 12 };//
	int pfc_loc[2] = { 4, 13 };
	//int edsub[3][8] = { { 4, 3, 7, 11, 5, 1, 6, 9 }, { 8, 5, 0, 4, 10, 6, 2, 7 }, { 0, 1, 2, 3, 8, 9, 10, 11 } };//edges of eid to be split
	int edflag[3][12] = { { 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1 }, { 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0 }, { 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1 } };
	int fcflag[3][6] = { { 2, 2, 4, 2, 4, 2 }, { 2, 4, 2, 4, 2, 2 }, { 4, 2, 2, 2, 2, 4 } };
	int pnid[18];
	for (int i = 0; i < 8; i++)
	{
		pnid[pvt_loc[dir][i]] = tmesh[eid].cnct[i];
	}
	//for (int i = 0; i < 12; i++)
	//{
	//	if (edflag[dir][i] == 1)
	//	{
	//	}
	//	if (tmedge[tmesh[eid].edge[edsub[dir][i]]].act == 1)
	//	{
	//		cp.push_back(pnew[ped_loc[i]]);
	//		tmedge[tmesh[eid].edge[edsub[dir][i]]].midpt = cp.size() - 1;
	//	}
	//	pnid[ped_loc[i]] = tmedge[tmesh[eid].edge[edsub[dir][i]]].midpt;
	//}
	//for (int i = 0; i < 2; i++)
	//{
	//	if (tmface[tmesh[eid].face[fcbt[dir][i]]].act == 1)
	//	{
	//		cp.push_back(pnew[pfc_loc[i]]);
	//		tmface[tmesh[eid].face[fcbt[dir][i]]].ctpt = cp.size() - 1;
	//	}
	//	pnid[pfc_loc[i]] = tmface[tmesh[eid].face[fcbt[dir][i]]].ctpt;
	//}

	////construct edges
	//int ednid[13];
	//for (int i = 0; i < 8; i++)
	//{
	//	if (tmedge[tmesh[eid].edge[i]].act == 1)
	//	{
	//		Edge3D edtmp[2];
	//		edtmp[0].pt[0] = tmedge[tmesh[eid].edge[i]].pt[0];
	//		edtmp[0].pt[1] = tmedge[tmesh[eid].edge[i]].midpt;
	//		edtmp[1].pt[0] = tmedge[tmesh[eid].edge[i]].midpt;
	//		edtmp[1].pt[1] = tmedge[tmesh[eid].edge[i]].pt[1];
	//		tmedtmp.push_back(edtmp[0]);
	//		tmedge[tmesh[eid].edge[i]].chd[0] = tmedtmp.size() - 1;
	//		tmedtmp.push_back(edtmp[1]);
	//		tmedge[tmesh[eid].edge[i]].chd[1] = tmedtmp.size() - 1;
	//		tmedge[tmesh[eid].edge[i]].act = 0;
	//	}
	//	ednid[2 * i] = tmedge[tmesh[eid].edge[i]].chd[0];
	//	ednid[2 * i + 1] = tmedge[tmesh[eid].edge[i]].chd[1];
	//}
	//for (int i = 0; i < 6; i++)
	//{
	//	if (tmface[tmesh[eid].face[i]].act == 1)
	//	{
	//		Edge3D edtmp[4];
	//		tmface[tmesh[eid].face[i]].Tedge.resize(4);
	//		for (int j = 0; j < 4; j++)
	//		{
	//			edtmp[j].pt[0] = tmface[tmesh[eid].face[i]].ctpt;
	//			edtmp[j].pt[1] = tmedge[tmface[tmesh[eid].face[i]].edge[j]].midpt;
	//			tmedtmp.push_back(edtmp[j]);
	//			tmface[tmesh[eid].face[i]].Tedge[j] = tmedtmp.size() - 1;
	//		}
	//	}
	//	for (int j = 0; j < 4; j++)
	//	{
	//		ednid[24 + 6 * i + j] = tmface[tmesh[eid].face[i]].Tedge[j];
	//	}
	//}
	//for (int i = 0; i < 6; i++)
	//{
	//	Edge3D edtmp;
	//	edtmp.pt[0] = pnid[13];
	//	edtmp.pt[1] = tmface[tmesh[eid].face[i]].ctpt;
	//	tmedtmp.push_back(edtmp);
	//	ednid[48 + i] = tmedtmp.size() - 1;

	//}

	////construct faces
	//int fcnid[36];
	//int fcold[6][4][4] = { { { 0, 1, 4, 3 }, { 1, 2, 5, 4 }, { 3, 4, 7, 6 }, { 4, 5, 8, 7 } },
	//{ { 0, 1, 10, 9 }, { 1, 2, 11, 10 }, { 9, 10, 19, 18 }, { 10, 11, 20, 19 } },
	//{ { 2, 5, 14, 11 }, { 5, 8, 17, 14 }, { 11, 14, 23, 20 }, { 14, 17, 26, 23 } },
	//{ { 6, 7, 16, 15 }, { 7, 8, 17, 16 }, { 15, 16, 25, 24 }, { 16, 17, 26, 25 } },
	//{ { 0, 3, 12, 9 }, { 3, 6, 15, 12 }, { 9, 12, 21, 18 }, { 12, 15, 24, 21 } },
	//{ { 18, 19, 22, 21 }, { 19, 20, 23, 22 }, { 21, 22, 25, 24 }, { 22, 23, 26, 25 } } };
	//int fcnew[12][4] = { { 9, 10, 13, 12 }, { 10, 11, 14, 13 }, { 12, 13, 16, 15 }, { 13, 14, 17, 16 },
	//{ 1, 4, 13, 10 }, { 4, 7, 16, 13 }, { 10, 13, 22, 19 }, { 13, 16, 25, 22 },
	//{ 3, 4, 13, 12 }, { 4, 5, 14, 13 }, { 12, 13, 22, 21 }, { 13, 14, 23, 22 } };
	//for (int i = 0; i < 6; i++)
	//{
	//	if (tmface[tmesh[eid].face[i]].act == 1)
	//	{
	//		Face3D fctmp[4];
	//		tmface[tmesh[eid].face[i]].chd.resize(4);
	//		for (int j = 0; j < 4; j++)
	//		{
	//			for (int k = 0; k < 4; k++)
	//			{
	//				fctmp[j].cnct[k] = pnid[fcold[i][j][k]];
	//			}
	//			tmfctmp.push_back(fctmp[j]);
	//			tmface[tmesh[eid].face[i]].chd[j] = tmfctmp.size() - 1;
	//		}
	//		tmface[tmesh[eid].face[i]].act = 0;
	//	}
	//	for (int j = 0; j < 4; j++)
	//	{
	//		fcnid[4 * i + j] = tmface[tmesh[eid].face[i]].chd[j];
	//	}
	//}
	//for (int i = 0; i < 12; i++)
	//{
	//	Face3D fctmp;
	//	for (int j = 0; j < 4; j++)
	//	{
	//		fctmp.cnct[j] = pnid[fcnew[i][j]];
	//	}
	//	tmfctmp.push_back(fctmp);
	//	fcnid[24 + i] = tmfctmp.size() - 1;
	//}

	////construct hex
	//int hxnid[8];
	//int hxnew[8][8] = { { 0, 1, 4, 3, 9, 10, 13, 12 }, { 1, 2, 5, 4, 10, 11, 14, 13 }, { 3, 4, 7, 6, 12, 13, 16, 15 }, { 4, 5, 8, 7, 13, 14, 17, 16 },
	//{ 9, 10, 13, 12, 18, 19, 22, 21 }, { 10, 11, 14, 13, 19, 20, 23, 22 }, { 12, 13, 16, 15, 21, 22, 25, 24 }, { 13, 14, 17, 16, 22, 23, 26, 25 } };
	//for (int i = 0; i < 8; i++)
	//{
	//	Element3D etmp;
	//	for (int j = 0; j < 8; j++)
	//	{
	//		etmp.cnct[j] = pnid[hxnew[i][j]];
	//	}
	//	tmtmp.push_back(etmp);
	//	hxnid[i] = tmtmp.size() - 1;
	//}
	//Find_FaceEdge_Index(hxnid, fcnid, ednid);
}





void TruncatedTspline_3D::Run_Coupling(string fn, int nrf, vector<BezierElement3D>& bzmesh, vector<int>& IDBC)
{
	InitializeMesh(fn);
	for (int i = 0; i < nrf; i++)
	{
		Global_Subdivide();
	}
	BuildSplines_Unstruct();
	BezierExtract3D_Unstruct(bzmesh);
	Set_RKPM(bzmesh);
	Find_IDBC(IDBC);
}

void TruncatedTspline_3D::BezierExtract3D_Unstruct(vector<BezierElement3D>& bzmesh)
{
	cout << "Bezier extracting...\n";
	cout << "# Bezier: " << tmesh.size() << "\n";
	bzmesh.resize(tmesh.size());
#pragma omp parallel for
	for (int eid = 0; eid < tmesh.size(); eid++)
	{
		//int i(eact[eid][0]), j(eact[eid][1]);
		if (eid != 0 && eid % 500 == 0)
		{
			cout << eid << " ";
		}
		double tmp;
		if (tmesh[eid].type == 0) tmesh[eid].type = 2;//test for pure RKPM
		bzmesh[eid].type = tmesh[eid].type;
		bzmesh[eid].IEN.resize(tmesh[eid].IEN.size());
		bzmesh[eid].cmat.resize(tmesh[eid].IEN.size(), vector<double>(64));
		for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
		{
			bzmesh[eid].IEN[k] = tmesh[eid].IEN[k];
			for (int k1 = 0; k1 < 64; k1++)
			{
				tmp = tmesh[eid].bemat[k][k1];
				bzmesh[eid].cmat[k][k1] = tmp;
				bzmesh[eid].pts[k1][0] += tmp * cp[tmesh[eid].IEN[k]].coor[0];
				bzmesh[eid].pts[k1][1] += tmp * cp[tmesh[eid].IEN[k]].coor[1];
				bzmesh[eid].pts[k1][2] += tmp * cp[tmesh[eid].IEN[k]].coor[2];
			}
		}

		//find types of interfaces
		for (int k = 0; k < 6; k++)
		{
			if (tmface[tmesh[eid].face[k]].hex.size() == 1)
			{
				bzmesh[eid].bc[k] = 1;//boundary face
			}
			else if (tmface[tmesh[eid].face[k]].hex.size() == 2)
			{
				int hxid[2] = { tmface[tmesh[eid].face[k]].hex[0], tmface[tmesh[eid].face[k]].hex[1] };
				if ((tmesh[hxid[0]].type != 0 && tmesh[hxid[1]].type == 0) || (tmesh[hxid[1]].type != 0 && tmesh[hxid[0]].type == 0))//problematic
				{
					bzmesh[eid].bc[k] = 2;//coupling interface
				}
			}
		}
	}
}

void TruncatedTspline_3D::AddMeshfreeNodes(vector<BezierElement3D>& bzmesh)
{
	int nnodes(3);//# nodes per direction
	int nni(nnodes - 2);//exclude two ends
	double coef(3.5);
	vector<array<double, 3>> sp_bd(nni*nni*nni);//sampling body points
	vector<array<double, 3>> sp_fc(6 * nni*nni);//sampling face points
	vector<array<double, 3>> sp_ed(12 * nni);//sampling edge points
	vector<array<double, 3>> sp_vt(8);//sampling edge points
	double slen(1. / double(nnodes - 1));
	int i, j, k, loc(0);
	for (i = 1; i < nnodes-1; i++)//w
	{
		for (j = 1; j < nnodes-1; j++)//v
		{
			for (k = 1; k < nnodes-1; k++)//u
			{
				sp_bd[loc][0] = double(k)*slen;
				sp_bd[loc][1] = double(j)*slen;
				sp_bd[loc][2] = double(i)*slen;
				loc++;
			}
		}
	}
	loc = 0;
	for (i = 1; i < nnodes - 1; i++)
	{
		for (j = 1; j < nnodes - 1; j++)
		{
			//face 0
			sp_fc[loc][0] = double(j)*slen;
			sp_fc[loc][1] = double(i)*slen;
			sp_fc[loc][2] = 0.;
			//face 1
			sp_fc[nni*nni + loc][0] = double(j)*slen;
			sp_fc[nni*nni + loc][1] = 0.;
			sp_fc[nni*nni + loc][2] = double(i)*slen;
			//face 2
			sp_fc[2 * nni*nni + loc][0] = 1.;
			sp_fc[2 * nni*nni + loc][1] = double(j)*slen;
			sp_fc[2 * nni*nni + loc][2] = double(i)*slen;
			//face 3
			sp_fc[3 * nni*nni + loc][0] = double(j)*slen;
			sp_fc[3 * nni*nni + loc][1] = 1.;
			sp_fc[3 * nni*nni + loc][2] = double(i)*slen;
			//face 4
			sp_fc[4 * nni*nni + loc][0] = 0.;
			sp_fc[4 * nni*nni + loc][1] = double(j)*slen;
			sp_fc[4 * nni*nni + loc][2] = double(i)*slen;
			//face 5
			sp_fc[5 * nni*nni + loc][0] = double(j)*slen;
			sp_fc[5 * nni*nni + loc][1] = double(i)*slen;
			sp_fc[5 * nni*nni + loc][2] = 1.;

			loc++;
		}
	}
	loc = 0;
	for (i = 1; i < nnodes - 1; i++)
	{
		sp_ed[loc][0] = double(i)*slen; sp_ed[loc][1] = 0.; sp_ed[loc][2] = 0.;//edge 0
		sp_ed[nni + loc][0] = 1.; sp_ed[nni + loc][1] = double(i)*slen; sp_ed[nni + loc][2] = 0.;//edge 1
		sp_ed[2 * nni + loc][0] = double(i)*slen; sp_ed[2 * nni + loc][1] = 1.; sp_ed[2 * nni + loc][2] = 0.;//edge 2
		sp_ed[3 * nni + loc][0] = 0.; sp_ed[3 * nni + loc][1] = double(i)*slen; sp_ed[3 * nni + loc][2] = 0.;//edge 3
		sp_ed[4 * nni + loc][0] = 0.; sp_ed[4 * nni + loc][1] = 0.; sp_ed[4 * nni + loc][2] = double(i)*slen;//edge 4
		sp_ed[5 * nni + loc][0] = 1.; sp_ed[5 * nni + loc][1] = 0.; sp_ed[5 * nni + loc][2] = double(i)*slen;//edge 5
		sp_ed[6 * nni + loc][0] = 1.; sp_ed[6 * nni + loc][1] = 1.; sp_ed[6 * nni + loc][2] = double(i)*slen;//edge 6
		sp_ed[7 * nni + loc][0] = 0.; sp_ed[7 * nni + loc][1] = 1.; sp_ed[7 * nni + loc][2] = double(i)*slen;//edge 7
		sp_ed[8 * nni + loc][0] = double(i)*slen; sp_ed[8 * nni + loc][1] = 0.; sp_ed[8 * nni + loc][2] = 1.;//edge 8
		sp_ed[9 * nni + loc][0] = 1.; sp_ed[9 * nni + loc][1] = double(i)*slen; sp_ed[9 * nni + loc][2] = 1.;//edge 9
		sp_ed[10 * nni + loc][0] = double(i)*slen; sp_ed[10 * nni + loc][1] = 1.; sp_ed[10 * nni + loc][2] = 1.;//edge 10
		sp_ed[11 * nni + loc][0] = 0.; sp_ed[11 * nni + loc][1] = double(i)*slen; sp_ed[11 * nni + loc][2] = 1.;//edge 11

		loc++;
	}
	double vtpar[8][3] = { { 0., 0., 0. }, { 1., 0., 0. }, { 1., 1., 0. }, { 0., 1., 0. }, { 0., 0., 1. }, { 1., 0., 1. }, { 1., 1., 1. }, { 0., 1., 1. } };
	for (i = 0; i < 8; i++)
	{
		sp_vt[i][0] = vtpar[i][0]; sp_vt[i][1] = vtpar[i][1]; sp_vt[i][2] = vtpar[i][2];
	}

	//sampling points
	int bzop[4][2] = { { 0, 63 }, { 3, 60 }, { 15, 48 }, { 12, 51 } };
	double hmax(0.), dst;
	for (uint eid = 0; eid < tmesh.size(); eid++)//tmesh.size()==bzmesh.size()
	{
		if (tmesh[eid].type == 1 || tmesh[eid].type == 2)//boundary and irregular
		{
			//find max node spacing
			double hmax(0.), dst;
			for (k = 0; k < 8; k++)
			{
				for (j = 0; j < cp[tmesh[eid].cnct[k]].hex.size(); j++)
				{
					int hxid(cp[tmesh[eid].cnct[k]].hex[j]);
					for (i = 0; i < 4; i++)
					{
						dst = (bzmesh[hxid].pts[bzop[i][0]][0] - bzmesh[hxid].pts[bzop[i][1]][0])*(bzmesh[hxid].pts[bzop[i][0]][0] - bzmesh[hxid].pts[bzop[i][1]][0]) +
							(bzmesh[hxid].pts[bzop[i][0]][1] - bzmesh[hxid].pts[bzop[i][1]][1])*(bzmesh[hxid].pts[bzop[i][0]][1] - bzmesh[hxid].pts[bzop[i][1]][1]) +
							(bzmesh[hxid].pts[bzop[i][0]][2] - bzmesh[hxid].pts[bzop[i][1]][2])*(bzmesh[hxid].pts[bzop[i][0]][2] - bzmesh[hxid].pts[bzop[i][1]][2]);
						if (dst>hmax) hmax = dst;
					}
				}
			}
			hmax = coef*sqrt(hmax) / double(nnodes - 1);
			//add new meshfree nodes
			for (i = 0; i < sp_bd.size(); i++)
			{
				MFNode mptmp;
				bzmesh[eid].GeomMap(sp_bd[i], mptmp.coor);
				mptmp.a = hmax;
				mp.push_back(mptmp);
			}
			for (i = 0; i < 6; i++)
			{
				if (tmface[tmesh[eid].face[i]].mpflag == 0)
				{
					for (j = 0; j < nni*nni; j++)
					{
						MFNode mptmp;
						bzmesh[eid].GeomMap(sp_fc[i*nni*nni + j], mptmp.coor);
						mptmp.a = hmax;
						mp.push_back(mptmp);
						tmface[tmesh[eid].face[i]].mpid.push_back(mp.size() - 1);
					}
					tmface[tmesh[eid].face[i]].mpflag = 1;
				}
			}
			for (i = 0; i < 12; i++)
			{
				if (tmedge[tmesh[eid].edge[i]].mpflag == 0)
				{
					for (j = 0; j < nni; j++)
					{
						MFNode mptmp;
						bzmesh[eid].GeomMap(sp_ed[i*nni + j], mptmp.coor);
						mptmp.a = hmax;
						mp.push_back(mptmp);
						tmedge[tmesh[eid].edge[i]].mpid.push_back(mp.size() - 1);
					}
					tmedge[tmesh[eid].edge[i]].mpflag = 1;
				}
			}
			for (i = 0; i < 8; i++)
			{
				if (cp[tmesh[eid].cnct[i]].mpflag == 0)
				{
					MFNode mptmp;
					bzmesh[eid].GeomMap(sp_vt[i], mptmp.coor);
					mptmp.a = hmax;
					mp.push_back(mptmp);
					cp[tmesh[eid].cnct[i]].mpid = mp.size() - 1;
					cp[tmesh[eid].cnct[i]].mpflag = 1;
				}
			}
		}
	}
}

void TruncatedTspline_3D::Set_RKPM(vector<BezierElement3D>& bzmesh)
{
	AddMeshfreeNodes(bzmesh);
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].type != 0)
		{
			FindMeshfreeNodes_glb(bzmesh[eid]);
		}
	}
}

void TruncatedTspline_3D::FindNeighbor_2r(int eid, vector<int>& hx2r)
{
	hx2r.clear();
	hx2r.push_back(eid);
	vector<int> cp1r;
	//1st ring
	for (int i = 0; i < 8; i++)
	{
		for (uint j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
		{
			int hxid(cp[tmesh[eid].cnct[i]].hex[j]);
			if (hxid != eid)
			{
				vector<int>::iterator it = find(hx2r.begin(), hx2r.end(), hxid);
				if (it == hx2r.end())
				{
					hx2r.push_back(hxid);
					for (int k = 0; k < 8; k++)
					{
						vector<int>::iterator it1 = find(cp1r.begin(), cp1r.end(), tmesh[hxid].cnct[k]);
						int* it2 = find(tmesh[eid].cnct, tmesh[eid].cnct + 8, tmesh[hxid].cnct[k]);
						if (it1 == cp1r.end() && it2 == tmesh[eid].cnct + 8)
						{
							cp1r.push_back(tmesh[hxid].cnct[k]);
						}
					}
				}
			}
		}
	}
	//2nd ring
	for (uint i = 0; i < cp1r.size(); i++)
	{
		for (uint j = 0; j < cp[cp1r[i]].hex.size(); j++)
		{
			int hxid(cp[cp1r[i]].hex[j]);
			vector<int>::iterator it = find(hx2r.begin(), hx2r.end(), hxid);
			if (it == hx2r.end())
			{
				hx2r.push_back(hxid);
			}
		}
	}
}

void TruncatedTspline_3D::FindMeshfreeNodes_glb(BezierElement3D& bzel)
{
	int bzcn[8] = { 0, 3, 12, 15, 48, 51, 60, 63 };
	for (uint i = 0; i < mp.size(); i++)
	{
		int flag(0);
		double dst;
		for (int j = 0; j < 8; j++)
		{
			double len[3] = { mp[i].coor[0] - bzel.pts[bzcn[j]][0], mp[i].coor[1] - bzel.pts[bzcn[j]][1], mp[i].coor[2] - bzel.pts[bzcn[j]][2] };
			dst = sqrt(len[0] * len[0] + len[1] * len[1] + len[2] * len[2]);
			if (dst < mp[i].a)
			{
				flag = 1; break;
			}
		}
		if (flag == 1)
		{
			//add RKPM info to Bezier element
			bzel.rkpm = 1;
			bzel.mid.push_back(cp.size() + i);
			bzel.IEN.push_back(cp.size() + i);
			array<double, 3> tmp = { mp[i].coor[0], mp[i].coor[1], mp[i].coor[2] };
			bzel.mp.push_back(tmp);
			bzel.ra.push_back(mp[i].a);
		}
	}
}

void TruncatedTspline_3D::Find_IDBC(vector<int>& IDBC)
{
	IDBC.clear();
	IDBC.resize(cp.size() + mp.size(), -1);
	vector<int> flag(cp.size(), 0);
	for (uint i = 0; i < tmesh.size(); i++)
	{
		if (tmesh[i].type == 0)//regular element, IGA only used for it
		{
			for (uint j = 0; j < tmesh[i].IEN.size(); j++)
			{
				flag[tmesh[i].IEN[j]] = 1;
			}
		}
	}
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (flag[i] == 1)
		{
			IDBC[i] = count++;
		}
		else
		{
			IDBC[i] = -1;
		}
	}
	for (uint i = 0; i < mp.size(); i++)
	{
		IDBC[cp.size() + i] = count + i;
	}
}

void TruncatedTspline_3D::BuildSplines_Unstruct()
{
	cout << "# elements: " << tmesh.size() << "\n";
#pragma omp parallel for
	for (int i = 0; i < tmesh.size(); i++)
	{
		if (i != 0 && i % 500 == 0)
		{
			cout << i << " ";
		}
		if (tmesh[i].type != 1)
		{
			BuildElementSplines_Interior(i);
		}
		else
		{
			BuildElementSplines_Boundary(i);
		}
	}
}

void TruncatedTspline_3D::BuildSplines_Unstruct_Open()
{
	cout << "# elements: " << tmesh.size() << "\n";
#pragma omp parallel for
	for (int i = 0; i < tmesh.size(); i++)
	{
		if (i != 0 && i % 500 == 0)
		{
			cout << i << " ";
		}
		if (tmesh[i].type != 1)
		{
			BuildElementSplines_Interior_Open(i);
		}
		else
		{
			BuildElementSplines_Boundary_Open(i);
		}
	}
}

void TruncatedTspline_3D::BuildElementSplines_Interior(int eid)
{
	//find IENtmp first
	tmesh[eid].IEN.clear();
	uint i, j, k, hxid;
	vector<int> loc(cp.size(), -1);
	vector<int> hx1r(1, eid);
	for (i = 0; i < 8; i++)
	{
		loc[tmesh[eid].cnct[i]] = tmesh[eid].IEN.size();
		tmesh[eid].IEN.push_back(tmesh[eid].cnct[i]);
	}
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
		{
			hxid = cp[tmesh[eid].cnct[i]].hex[j];
			vector<int>::iterator it1 = find(hx1r.begin(), hx1r.end(), hxid);
			if (it1 == hx1r.end())
			{
				hx1r.push_back(hxid);
				for (k = 0; k < 8; k++)
				{
					vector<int>::iterator it = find(tmesh[eid].IEN.begin(), tmesh[eid].IEN.end(), tmesh[hxid].cnct[k]);
					if (it == tmesh[eid].IEN.end())
					{
						loc[tmesh[hxid].cnct[k]] = tmesh[eid].IEN.size();
						tmesh[eid].IEN.push_back(tmesh[hxid].cnct[k]);
					}
				}
			}
		}
	}
	for (i = 0; i < tmesh[eid].bemat.size(); i++)
	{
		tmesh[eid].bemat[i].clear();
	}
	tmesh[eid].bemat.clear();
	tmesh[eid].bemat.resize(tmesh[eid].IEN.size(), vector<double>(64, 0.));
	//8 body points, not consider boundary yet
	double w[2] = { 2. / 3., 1. / 3. };
	double a[8] = { w[0] * w[0] * w[0], w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[0] * w[0],
		w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[1] * w[1], w[1] * w[1] * w[0] };
	int bpi[8][8] = { { 0, 1, 2, 3, 4, 5, 6, 7 }, { 1, 2, 3, 0, 5, 6, 7, 4 }, { 2, 3, 0, 1, 6, 7, 4, 5 }, { 3, 0, 1, 2, 7, 4, 5, 6 },
	{ 4, 5, 6, 7, 0, 1, 2, 3 }, { 5, 6, 7, 4, 1, 2, 3, 0 }, { 6, 7, 4, 5, 2, 3, 0, 1 }, { 7, 4, 5, 6, 3, 0, 1, 2 } };
	vector<array<array<double, 8>, 8>> bpm(hx1r.size());
	vector<array<array<int, 8>, 8>> bpmap(hx1r.size());
	for (i = 0; i < hx1r.size(); i++)//which element
	{
		for (j = 0; j < 8; j++)//which body point, bezier
		{
			for (k = 0; k < 8; k++)//which local corner point, b-splines
			{
				bpm[i][j][k] = a[k];
				bpmap[i][j][k] = loc[tmesh[hx1r[i]].cnct[bpi[j][k]]];
			}
		}
	}
	int layer[4] = { 0, 16, 32, 48 };
	int bpbz[8] = { 5 + layer[1], 6 + layer[1], 10 + layer[1], 9 + layer[1], 5 + layer[2], 6 + layer[2], 10 + layer[2], 9 + layer[2] };
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			tmesh[eid].bemat[bpmap[0][i][j]][bpbz[i]] = bpm[0][i][j];
		}
	}
	//2*12 edge points
	int edi[12][2] = { { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 0 }, { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 4 } };
	int edbz[12][2] = { { 1, 2 }, { 7, 11 }, { 14, 13 }, { 8, 4 }, { 0 + layer[1], 0 + layer[2] }, { 3 + layer[1], 3 + layer[2] },
	{ 15 + layer[1], 15 + layer[2] }, { 12 + layer[1], 12 + layer[2] }, { 1 + layer[3], 2 + layer[3] }, { 7 + layer[3], 11 + layer[3] }, { 14 + layer[3], 13 + layer[3] }, { 8 + layer[3], 4 + layer[3] } };
	int pos1, pos2;
	for (i = 0; i < 12; i++)
	{
		uint nhex = tmedge[tmesh[eid].edge[i]].hex.size();
		for (j = 0; j<tmedge[tmesh[eid].edge[i]].hex.size(); j++)
		{
			hxid = tmedge[tmesh[eid].edge[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			pos1 = it - hx1r.begin();
			int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[edi[i][0]]);
			pos2 = it1 - tmesh[hxid].cnct;
			for (k = 0; k < 8; k++)
			{
				tmesh[eid].bemat[bpmap[pos1][pos2][k]][edbz[i][0]] += bpm[pos1][pos2][k] / nhex;
			}
			int* it2 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[edi[i][1]]);
			pos2 = it2 - tmesh[hxid].cnct;
			for (k = 0; k < 8; k++)
			{
				tmesh[eid].bemat[bpmap[pos1][pos2][k]][edbz[i][1]] += bpm[pos1][pos2][k] / nhex;
			}
		}
	}
	//8 corner points
	int cnbz[8] = { 0, 3, 15, 12, 0 + layer[3], 3 + layer[3], 15 + layer[3], 12 + layer[3] };
	for (i = 0; i < 8; i++)
	{
		uint nhex = cp[tmesh[eid].cnct[i]].hex.size();
		for (j = 0; j<nhex; j++)
		{
			hxid = cp[tmesh[eid].cnct[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			pos1 = it - hx1r.begin();
			int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[i]);
			pos2 = it1 - tmesh[hxid].cnct;
			for (k = 0; k < 8; k++)
			{
				tmesh[eid].bemat[bpmap[pos1][pos2][k]][cnbz[i]] += bpm[pos1][pos2][k] / nhex;
			}
		}
	}
	//4*6 face points
	int fci[6][4] = { { 0, 1, 3, 2 }, { 0, 1, 4, 5 }, { 1, 2, 5, 6 }, { 3, 2, 7, 6 }, { 0, 3, 4, 7 }, { 4, 5, 7, 6 } };
	int fcbz[6][4] = { { 5, 6, 9, 10 }, { 1 + layer[1], 2 + layer[1], 1 + layer[2], 2 + layer[2] }, { 7 + layer[1], 11 + layer[1], 7 + layer[2], 11 + layer[2] },
	{ 13 + layer[1], 14 + layer[1], 13 + layer[2], 14 + layer[2] }, { 4 + layer[1], 8 + layer[1], 4 + layer[2], 8 + layer[2] }, { 5 + layer[3], 6 + layer[3], 9 + layer[3], 10 + layer[3] } };
	for (i = 0; i < 6; i++)
	{
		uint nhex = tmface[tmesh[eid].face[i]].hex.size();
		for (j = 0; j < nhex; j++)
		{
			hxid = tmface[tmesh[eid].face[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			pos1 = it - hx1r.begin();
			for (int j1 = 0; j1 < 4; j1++)
			{
				int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[fci[i][j1]]);
				pos2 = it1 - tmesh[hxid].cnct;
				for (k = 0; k < 8; k++)
				{
					tmesh[eid].bemat[bpmap[pos1][pos2][k]][fcbz[i][j1]] += bpm[pos1][pos2][k] / nhex;
				}
			}
		}
	}
}

void TruncatedTspline_3D::BuildElementSplines_Boundary(int eid)
{
	//find IEN first
	tmesh[eid].IEN.clear();
	uint i, j, k, hxid;
	vector<int> loc(cp.size(), -1);
	vector<int> hx1r(1, eid);
	for (i = 0; i < 8; i++)
	{
		loc[tmesh[eid].cnct[i]] = tmesh[eid].IEN.size();
		tmesh[eid].IEN.push_back(tmesh[eid].cnct[i]);
	}
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
		{
			hxid = cp[tmesh[eid].cnct[i]].hex[j];
			vector<int>::iterator it1 = find(hx1r.begin(), hx1r.end(), hxid);
			if (it1 == hx1r.end())
			{
				hx1r.push_back(hxid);
				for (k = 0; k < 8; k++)
				{
					vector<int>::iterator it = find(tmesh[eid].IEN.begin(), tmesh[eid].IEN.end(), tmesh[hxid].cnct[k]);
					if (it == tmesh[eid].IEN.end())
					{
						loc[tmesh[hxid].cnct[k]] = tmesh[eid].IEN.size();
						tmesh[eid].IEN.push_back(tmesh[hxid].cnct[k]);
					}
				}
			}
		}
	}
	for (i = 0; i < tmesh[eid].bemat.size(); i++)
	{
		tmesh[eid].bemat[i].clear();
	}
	tmesh[eid].bemat.clear();
	tmesh[eid].bemat.resize(tmesh[eid].IEN.size(), vector<double>(64, 0.));
	//8 body points
	double w[2] = { 2. / 3., 1. / 3. };
	double a[8] = { w[0] * w[0] * w[0], w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[0] * w[0],
		w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[1] * w[1], w[1] * w[1] * w[0] };
	int bpi[8][8] = { { 0, 1, 2, 3, 4, 5, 6, 7 }, { 1, 2, 3, 0, 5, 6, 7, 4 }, { 2, 3, 0, 1, 6, 7, 4, 5 }, { 3, 0, 1, 2, 7, 4, 5, 6 },
	{ 4, 5, 6, 7, 0, 1, 2, 3 }, { 5, 6, 7, 4, 1, 2, 3, 0 }, { 6, 7, 4, 5, 2, 3, 0, 1 }, { 7, 4, 5, 6, 3, 0, 1, 2 } };
	vector<array<array<double, 8>, 8>> bpm(hx1r.size());
	vector<array<array<int, 8>, 8>> bpmap(hx1r.size());
	for (i = 0; i < hx1r.size(); i++)//which element
	{
		for (j = 0; j < 8; j++)//which body point, bezier
		{
			for (k = 0; k < 8; k++)//which local corner point, b-splines
			{
				bpm[i][j][k] = a[k];
				bpmap[i][j][k] = loc[tmesh[hx1r[i]].cnct[bpi[j][k]]];
			}
		}
	}
	int layer[4] = { 0, 16, 32, 48 };
	int bpbz[8] = { 5 + layer[1], 6 + layer[1], 10 + layer[1], 9 + layer[1], 5 + layer[2], 6 + layer[2], 10 + layer[2], 9 + layer[2] };
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			tmesh[eid].bemat[bpmap[0][i][j]][bpbz[i]] = bpm[0][i][j];
		}
	}
	int pos1, pos2;
	//4*6 face points
	//double af[4][4] = { { w[0] * w[0], w[1] * w[0], w[1] * w[0], w[1] * w[1] }, { w[1] * w[0], w[0] * w[0], w[1] * w[1], w[1] * w[0] },
	//{ w[1] * w[0], w[1] * w[1], w[0] * w[0], w[1] * w[0] }, { w[1] * w[1], w[1] * w[0], w[1] * w[0], w[0] * w[0] } };
	double af[4] = { w[0] * w[0], w[1] * w[0], w[1] * w[1], w[1] * w[0] };
	int f_cnct[4][4] = { { 0, 1, 2, 3 }, { 1, 2, 3, 0 }, { 2, 3, 0, 1 }, { 3, 0, 1, 2 } };
	int fci[6][4] = { { 0, 1, 3, 2 }, { 0, 1, 4, 5 }, { 1, 2, 5, 6 }, { 3, 2, 7, 6 }, { 0, 3, 4, 7 }, { 4, 5, 7, 6 } };
	int fcbz[6][4] = { { 5, 6, 9, 10 }, { 1 + layer[1], 2 + layer[1], 1 + layer[2], 2 + layer[2] }, { 7 + layer[1], 11 + layer[1], 7 + layer[2], 11 + layer[2] },
	{ 13 + layer[1], 14 + layer[1], 13 + layer[2], 14 + layer[2] }, { 4 + layer[1], 8 + layer[1], 4 + layer[2], 8 + layer[2] }, { 5 + layer[3], 6 + layer[3], 9 + layer[3], 10 + layer[3] } };
	//find all boundary faces
	vector<int> fc_b;
	vector<array<array<double, 4>, 4>> fpm;
	vector<array<array<int, 4>, 4>> fpmap;//reference is face, note that reference is not solid
	for (i = 0; i < hx1r.size(); i++)
	{
		for (j = 0; j < 6; j++)
		{
			if (tmface[tmesh[hx1r[i]].face[j]].hex.size() == 1)
			{
				int fcid(tmesh[hx1r[i]].face[j]);
				fc_b.push_back(fcid);
				array<array<double, 4>, 4> fpm_tmp;
				array<array<int, 4>, 4> fpmap_tmp;
				for (int j1 = 0; j1 < 4; j1++)//Bezier
				{
					for (k = 0; k < 4; k++)//B-splines
					{
						fpm_tmp[j1][k] = af[k];
						fpmap_tmp[j1][k] = loc[tmface[fcid].cnct[f_cnct[j1][k]]];
					}
				}
				fpm.push_back(fpm_tmp);
				fpmap.push_back(fpmap_tmp);
			}
		}
	}
	//determine coefs
	for (i = 0; i < 6; i++)
	{
		uint nhex = tmface[tmesh[eid].face[i]].hex.size();
		if (nhex == 2)
		{
			for (j = 0; j < nhex; j++)
			{
				hxid = tmface[tmesh[eid].face[i]].hex[j];
				vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
				pos1 = it - hx1r.begin();
				for (int j1 = 0; j1 < 4; j1++)
				{
					int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[fci[i][j1]]);
					pos2 = it1 - tmesh[hxid].cnct;
					for (k = 0; k < 8; k++)
					{
						tmesh[eid].bemat[bpmap[pos1][pos2][k]][fcbz[i][j1]] += bpm[pos1][pos2][k] / nhex;
					}
				}
			}
		}
		else if (nhex == 1)//new, for boundary face
		{
			int fcid = tmesh[eid].face[i];
			vector<int>::iterator it = find(fc_b.begin(), fc_b.end(), fcid);
			pos1 = it - fc_b.begin();
			for (int j1 = 0; j1 < 4; j1++)
			{
				int* it1 = find(tmface[fcid].cnct, tmface[fcid].cnct + 4, tmesh[eid].cnct[fci[i][j1]]);
				pos2 = it1 - tmface[fcid].cnct;
				for (k = 0; k < 4; k++)
				{
					tmesh[eid].bemat[fpmap[pos1][pos2][k]][fcbz[i][j1]] = fpm[pos1][pos2][k];
				}
			}
		}
	}
	//2*12 edge points
	int edi[12][2] = { { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 0 }, { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 4 } };
	int edbz[12][2] = { { 1, 2 }, { 7, 11 }, { 14, 13 }, { 8, 4 }, { 0 + layer[1], 0 + layer[2] }, { 3 + layer[1], 3 + layer[2] },
	{ 15 + layer[1], 15 + layer[2] }, { 12 + layer[1], 12 + layer[2] }, { 1 + layer[3], 2 + layer[3] }, { 7 + layer[3], 11 + layer[3] }, { 14 + layer[3], 13 + layer[3] }, { 8 + layer[3], 4 + layer[3] } };
	for (i = 0; i < 12; i++)
	{
		if (tmedge[tmesh[eid].edge[i]].type != 1)//non-boundary
		{
			uint nhex = tmedge[tmesh[eid].edge[i]].hex.size();
			for (j = 0; j<tmedge[tmesh[eid].edge[i]].hex.size(); j++)
			{
				hxid = tmedge[tmesh[eid].edge[i]].hex[j];
				vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
				pos1 = it - hx1r.begin();
				int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[edi[i][0]]);
				pos2 = it1 - tmesh[hxid].cnct;
				for (k = 0; k < 8; k++)
				{
					tmesh[eid].bemat[bpmap[pos1][pos2][k]][edbz[i][0]] += bpm[pos1][pos2][k] / nhex;
				}
				int* it2 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[edi[i][1]]);
				pos2 = it2 - tmesh[hxid].cnct;
				for (k = 0; k < 8; k++)
				{
					tmesh[eid].bemat[bpmap[pos1][pos2][k]][edbz[i][1]] += bpm[pos1][pos2][k] / nhex;
				}
			}
		}
		else if (tmedge[tmesh[eid].edge[i]].type == 1 && tmedge[tmesh[eid].edge[i]].sharp == 0)//boundary, non-sharp
		{
			int nfc_b(0);
			for (j = 0; j < tmedge[tmesh[eid].edge[i]].face.size(); j++)
			{
				if (tmface[tmedge[tmesh[eid].edge[i]].face[j]].type == 1) nfc_b++;
			}
			for (j = 0; j<tmedge[tmesh[eid].edge[i]].face.size(); j++)
			{
				int fcid(tmedge[tmesh[eid].edge[i]].face[j]);
				if (tmface[fcid].type == 1)//boundary face
				{
					vector<int>::iterator it = find(fc_b.begin(), fc_b.end(), fcid);
					pos1 = it - fc_b.begin();
					for (int j1 = 0; j1 < 2; j1++)
					{
						int* it1 = find(tmface[fcid].cnct, tmface[fcid].cnct + 4, tmesh[eid].cnct[edi[i][j1]]);
						pos2 = it1 - tmface[fcid].cnct;
						for (k = 0; k < 4; k++)
						{
							tmesh[eid].bemat[fpmap[pos1][pos2][k]][edbz[i][j1]] += fpm[pos1][pos2][k] / nfc_b;
						}
					}
				}
			}
		}
		else if (tmedge[tmesh[eid].edge[i]].type == 1 && tmedge[tmesh[eid].edge[i]].sharp == 1)//boundary, sharp edge
		{
			int bid[2] = { loc[tmesh[eid].cnct[edi[i][0]]], loc[tmesh[eid].cnct[edi[i][1]]] };
			tmesh[eid].bemat[bid[0]][edbz[i][0]] = w[0];
			tmesh[eid].bemat[bid[0]][edbz[i][1]] = w[1];
			tmesh[eid].bemat[bid[1]][edbz[i][0]] = w[1];
			tmesh[eid].bemat[bid[1]][edbz[i][1]] = w[0];
		}
	}
	//8 corner points
	int cnbz[8] = { 0, 3, 15, 12, 0 + layer[3], 3 + layer[3], 15 + layer[3], 12 + layer[3] };
	for (i = 0; i < 8; i++)
	{
		if (cp[tmesh[eid].cnct[i]].type != 1)//non-boundary vertex points
		{
			uint nhex = cp[tmesh[eid].cnct[i]].hex.size();
			for (j = 0; j<nhex; j++)
			{
				hxid = cp[tmesh[eid].cnct[i]].hex[j];
				vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
				pos1 = it - hx1r.begin();
				int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[i]);
				pos2 = it1 - tmesh[hxid].cnct;
				for (k = 0; k < 8; k++)
				{
					tmesh[eid].bemat[bpmap[pos1][pos2][k]][cnbz[i]] += bpm[pos1][pos2][k] / nhex;
				}
			}
		}
		else if (cp[tmesh[eid].cnct[i]].type == 1 && cp[tmesh[eid].cnct[i]].sharp == 0)//boundary vertex points, non-sharp
		{
			int nfc_b(0);
			for (j = 0; j < cp[tmesh[eid].cnct[i]].face.size(); j++)
			{
				if (tmface[cp[tmesh[eid].cnct[i]].face[j]].type == 1) nfc_b++;
			}
			for (j = 0; j<cp[tmesh[eid].cnct[i]].face.size(); j++)
			{
				int fcid(cp[tmesh[eid].cnct[i]].face[j]);
				if (tmface[fcid].type == 1)//boundary face
				{
					vector<int>::iterator it = find(fc_b.begin(), fc_b.end(), fcid);
					pos1 = it - fc_b.begin();
					int* it1 = find(tmface[fcid].cnct, tmface[fcid].cnct + 4, tmesh[eid].cnct[i]);
					pos2 = it1 - tmface[fcid].cnct;
					for (k = 0; k < 4; k++)
					{
						tmesh[eid].bemat[fpmap[pos1][pos2][k]][cnbz[i]] += fpm[pos1][pos2][k] / nfc_b;
					}
				}
			}
		}
		else if (cp[tmesh[eid].cnct[i]].type == 1 && cp[tmesh[eid].cnct[i]].sharp == 1)//boundary vertex points, sharp edge
		{
			//tmesh[eid].bemat[loc[tmesh[eid].cnct[i]]][cnbz[i]] = 1.;
			vector<int> shp_ed;
			for (j = 0; j < cp[tmesh[eid].cnct[i]].edge.size(); j++)
			{
				if (tmedge[cp[tmesh[eid].cnct[i]].edge[j]].sharp == 1)
				{
					shp_ed.push_back(cp[tmesh[eid].cnct[i]].edge[j]);
				}
			}
			if (shp_ed.size() == 2)
			{
				for (j = 0; j < shp_ed.size(); j++)
				{
					if (tmedge[shp_ed[j]].pt[0] == tmesh[eid].cnct[i])
					{
						tmesh[eid].bemat[loc[tmedge[shp_ed[j]].pt[0]]][cnbz[i]] = 2. / 3.;
						tmesh[eid].bemat[loc[tmedge[shp_ed[j]].pt[1]]][cnbz[i]] = 1. / 6.;
					}
					else
					{
						tmesh[eid].bemat[loc[tmedge[shp_ed[j]].pt[1]]][cnbz[i]] = 2. / 3.;
						tmesh[eid].bemat[loc[tmedge[shp_ed[j]].pt[0]]][cnbz[i]] = 1. / 6.;
					}
				}
			}
			else
			{
				cerr << "# of sharp edges of the point is wrong!\n";
				cout << shp_ed.size() << "\n";
				getchar();
			}
		}
		else if (cp[tmesh[eid].cnct[i]].type == 1 && cp[tmesh[eid].cnct[i]].sharp == 2)//boundary vertex points, sharp corner
		{
			tmesh[eid].bemat[loc[tmesh[eid].cnct[i]]][cnbz[i]] = 1.;
		}
	}
}

void TruncatedTspline_3D::BuildElementSplines_Interior_Open(int eid)
{
	//find IENtmp first
	tmesh[eid].IEN.clear();
	uint i, j, k, hxid;
	vector<int> loc(cp.size(), -1);
	vector<int> hx1r(1, eid);
	for (i = 0; i < 8; i++)
	{
		loc[tmesh[eid].cnct[i]] = tmesh[eid].IEN.size();
		tmesh[eid].IEN.push_back(tmesh[eid].cnct[i]);
	}
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
		{
			hxid = cp[tmesh[eid].cnct[i]].hex[j];
			vector<int>::iterator it1 = find(hx1r.begin(), hx1r.end(), hxid);
			if (it1 == hx1r.end())
			{
				hx1r.push_back(hxid);
				for (k = 0; k < 8; k++)
				{
					vector<int>::iterator it = find(tmesh[eid].IEN.begin(), tmesh[eid].IEN.end(), tmesh[hxid].cnct[k]);
					if (it == tmesh[eid].IEN.end())
					{
						loc[tmesh[hxid].cnct[k]] = tmesh[eid].IEN.size();
						tmesh[eid].IEN.push_back(tmesh[hxid].cnct[k]);
					}
				}
			}
		}
	}
	for (i = 0; i < tmesh[eid].bemat.size(); i++)
	{
		tmesh[eid].bemat[i].clear();
	}
	tmesh[eid].bemat.clear();
	tmesh[eid].bemat.resize(tmesh[eid].IEN.size(), vector<double>(64, 0.));
	//8 body points, not consider boundary yet
	double w[2] = { 2. / 3., 1. / 3. };
	double a[8] = { w[0] * w[0] * w[0], w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[0] * w[0],
		w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[1] * w[1], w[1] * w[1] * w[0] };
	int bpi[8][8] = { { 0, 1, 2, 3, 4, 5, 6, 7 },{ 1, 2, 3, 0, 5, 6, 7, 4 },{ 2, 3, 0, 1, 6, 7, 4, 5 },{ 3, 0, 1, 2, 7, 4, 5, 6 },
	{ 4, 5, 6, 7, 0, 1, 2, 3 },{ 5, 6, 7, 4, 1, 2, 3, 0 },{ 6, 7, 4, 5, 2, 3, 0, 1 },{ 7, 4, 5, 6, 3, 0, 1, 2 } };
	vector<array<array<double, 8>, 8>> bpm(hx1r.size());
	vector<array<array<int, 8>, 8>> bpmap(hx1r.size());
	for (i = 0; i < hx1r.size(); i++)//which element
	{
		for (j = 0; j < 8; j++)//which body point, bezier
		{
			for (k = 0; k < 8; k++)//which local corner point, b-splines
			{
				bpm[i][j][k] = a[k];
				bpmap[i][j][k] = loc[tmesh[hx1r[i]].cnct[bpi[j][k]]];
			}
		}
	}
	int layer[4] = { 0, 16, 32, 48 };
	int bpbz[8] = { 5 + layer[1], 6 + layer[1], 10 + layer[1], 9 + layer[1], 5 + layer[2], 6 + layer[2], 10 + layer[2], 9 + layer[2] };
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			tmesh[eid].bemat[bpmap[0][i][j]][bpbz[i]] = bpm[0][i][j];
		}
	}
	//2*12 edge points
	int edi[12][2] = { { 0, 1 },{ 1, 2 },{ 2, 3 },{ 3, 0 },{ 0, 4 },{ 1, 5 },{ 2, 6 },{ 3, 7 },{ 4, 5 },{ 5, 6 },{ 6, 7 },{ 7, 4 } };
	int edbz[12][2] = { { 1, 2 },{ 7, 11 },{ 14, 13 },{ 8, 4 },{ 0 + layer[1], 0 + layer[2] },{ 3 + layer[1], 3 + layer[2] },
	{ 15 + layer[1], 15 + layer[2] },{ 12 + layer[1], 12 + layer[2] },{ 1 + layer[3], 2 + layer[3] },{ 7 + layer[3], 11 + layer[3] },{ 14 + layer[3], 13 + layer[3] },{ 8 + layer[3], 4 + layer[3] } };
	int pos1, pos2;
	for (i = 0; i < 12; i++)
	{
		uint nhex = tmedge[tmesh[eid].edge[i]].hex.size();
		for (j = 0; j<tmedge[tmesh[eid].edge[i]].hex.size(); j++)
		{
			hxid = tmedge[tmesh[eid].edge[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			pos1 = it - hx1r.begin();
			int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[edi[i][0]]);
			pos2 = it1 - tmesh[hxid].cnct;
			for (k = 0; k < 8; k++)
			{
				tmesh[eid].bemat[bpmap[pos1][pos2][k]][edbz[i][0]] += bpm[pos1][pos2][k] / nhex;
			}
			int* it2 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[edi[i][1]]);
			pos2 = it2 - tmesh[hxid].cnct;
			for (k = 0; k < 8; k++)
			{
				tmesh[eid].bemat[bpmap[pos1][pos2][k]][edbz[i][1]] += bpm[pos1][pos2][k] / nhex;
			}
		}
	}
	//8 corner points
	int cnbz[8] = { 0, 3, 15, 12, 0 + layer[3], 3 + layer[3], 15 + layer[3], 12 + layer[3] };
	for (i = 0; i < 8; i++)
	{
		uint nhex = cp[tmesh[eid].cnct[i]].hex.size();
		for (j = 0; j<nhex; j++)
		{
			hxid = cp[tmesh[eid].cnct[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			pos1 = it - hx1r.begin();
			int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[i]);
			pos2 = it1 - tmesh[hxid].cnct;
			for (k = 0; k < 8; k++)
			{
				tmesh[eid].bemat[bpmap[pos1][pos2][k]][cnbz[i]] += bpm[pos1][pos2][k] / nhex;
			}
		}
	}
	//4*6 face points
	int fci[6][4] = { { 0, 1, 3, 2 },{ 0, 1, 4, 5 },{ 1, 2, 5, 6 },{ 3, 2, 7, 6 },{ 0, 3, 4, 7 },{ 4, 5, 7, 6 } };
	int fcbz[6][4] = { { 5, 6, 9, 10 },{ 1 + layer[1], 2 + layer[1], 1 + layer[2], 2 + layer[2] },{ 7 + layer[1], 11 + layer[1], 7 + layer[2], 11 + layer[2] },
	{ 13 + layer[1], 14 + layer[1], 13 + layer[2], 14 + layer[2] },{ 4 + layer[1], 8 + layer[1], 4 + layer[2], 8 + layer[2] },{ 5 + layer[3], 6 + layer[3], 9 + layer[3], 10 + layer[3] } };
	for (i = 0; i < 6; i++)
	{
		uint nhex = tmface[tmesh[eid].face[i]].hex.size();
		for (j = 0; j < nhex; j++)
		{
			hxid = tmface[tmesh[eid].face[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			pos1 = it - hx1r.begin();
			for (int j1 = 0; j1 < 4; j1++)
			{
				int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[fci[i][j1]]);
				pos2 = it1 - tmesh[hxid].cnct;
				for (k = 0; k < 8; k++)
				{
					tmesh[eid].bemat[bpmap[pos1][pos2][k]][fcbz[i][j1]] += bpm[pos1][pos2][k] / nhex;
				}
			}
		}
	}
}

void TruncatedTspline_3D::BuildElementSplines_Boundary_Open(int eid)
{
	//find IEN first
	tmesh[eid].IEN.clear();
	uint i, j, k, hxid;
	vector<int> loc(cp.size(), -1);
	vector<int> hx1r(1, eid);
	for (i = 0; i < 8; i++)
	{
		loc[tmesh[eid].cnct[i]] = tmesh[eid].IEN.size();
		tmesh[eid].IEN.push_back(tmesh[eid].cnct[i]);
	}
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
		{
			hxid = cp[tmesh[eid].cnct[i]].hex[j];
			vector<int>::iterator it1 = find(hx1r.begin(), hx1r.end(), hxid);
			if (it1 == hx1r.end())
			{
				hx1r.push_back(hxid);
				for (k = 0; k < 8; k++)
				{
					vector<int>::iterator it = find(tmesh[eid].IEN.begin(), tmesh[eid].IEN.end(), tmesh[hxid].cnct[k]);
					if (it == tmesh[eid].IEN.end())
					{
						loc[tmesh[hxid].cnct[k]] = tmesh[eid].IEN.size();
						tmesh[eid].IEN.push_back(tmesh[hxid].cnct[k]);
					}
				}
			}
		}
	}
	for (i = 0; i < tmesh[eid].bemat.size(); i++)
	{
		tmesh[eid].bemat[i].clear();
	}
	tmesh[eid].bemat.clear();
	tmesh[eid].bemat.resize(tmesh[eid].IEN.size(), vector<double>(64, 0.));
	//8 body points
	double w[2] = { 2. / 3., 1. / 3. };
	double a[8] = { w[0] * w[0] * w[0], w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[0] * w[0],
		w[1] * w[0] * w[0], w[1] * w[1] * w[0], w[1] * w[1] * w[1], w[1] * w[1] * w[0] };
	int bpi[8][8] = { { 0, 1, 2, 3, 4, 5, 6, 7 },{ 1, 2, 3, 0, 5, 6, 7, 4 },{ 2, 3, 0, 1, 6, 7, 4, 5 },{ 3, 0, 1, 2, 7, 4, 5, 6 },
	{ 4, 5, 6, 7, 0, 1, 2, 3 },{ 5, 6, 7, 4, 1, 2, 3, 0 },{ 6, 7, 4, 5, 2, 3, 0, 1 },{ 7, 4, 5, 6, 3, 0, 1, 2 } };
	vector<array<array<double, 8>, 8>> bpm(hx1r.size());
	vector<array<array<int, 8>, 8>> bpmap(hx1r.size());
	for (i = 0; i < hx1r.size(); i++)//which element
	{
		for (j = 0; j < 8; j++)//which body point, bezier
		{
			for (k = 0; k < 8; k++)//which local corner point, b-splines
			{
				bpm[i][j][k] = a[k];
				bpmap[i][j][k] = loc[tmesh[hx1r[i]].cnct[bpi[j][k]]];
			}
		}
	}
	int layer[4] = { 0, 16, 32, 48 };
	int bpbz[8] = { 5 + layer[1], 6 + layer[1], 10 + layer[1], 9 + layer[1], 5 + layer[2], 6 + layer[2], 10 + layer[2], 9 + layer[2] };
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			tmesh[eid].bemat[bpmap[0][i][j]][bpbz[i]] = bpm[0][i][j];
		}
	}
	int pos1, pos2;
	//4*6 face points
	//double af[4][4] = { { w[0] * w[0], w[1] * w[0], w[1] * w[0], w[1] * w[1] }, { w[1] * w[0], w[0] * w[0], w[1] * w[1], w[1] * w[0] },
	//{ w[1] * w[0], w[1] * w[1], w[0] * w[0], w[1] * w[0] }, { w[1] * w[1], w[1] * w[0], w[1] * w[0], w[0] * w[0] } };
	double af[4] = { w[0] * w[0], w[1] * w[0], w[1] * w[1], w[1] * w[0] };
	int f_cnct[4][4] = { { 0, 1, 2, 3 },{ 1, 2, 3, 0 },{ 2, 3, 0, 1 },{ 3, 0, 1, 2 } };
	int fci[6][4] = { { 0, 1, 3, 2 },{ 0, 1, 4, 5 },{ 1, 2, 5, 6 },{ 3, 2, 7, 6 },{ 0, 3, 4, 7 },{ 4, 5, 7, 6 } };
	int fcbz[6][4] = { { 5, 6, 9, 10 },{ 1 + layer[1], 2 + layer[1], 1 + layer[2], 2 + layer[2] },{ 7 + layer[1], 11 + layer[1], 7 + layer[2], 11 + layer[2] },
	{ 13 + layer[1], 14 + layer[1], 13 + layer[2], 14 + layer[2] },{ 4 + layer[1], 8 + layer[1], 4 + layer[2], 8 + layer[2] },{ 5 + layer[3], 6 + layer[3], 9 + layer[3], 10 + layer[3] } };
	//find all boundary faces
	vector<int> fc_b;
	vector<array<array<double, 4>, 4>> fpm;
	vector<array<array<int, 4>, 4>> fpmap;//reference is face, note that reference is not solid
	for (i = 0; i < hx1r.size(); i++)
	{
		for (j = 0; j < 6; j++)
		{
			if (tmface[tmesh[hx1r[i]].face[j]].hex.size() == 1)
			{
				int fcid(tmesh[hx1r[i]].face[j]);
				fc_b.push_back(fcid);
				array<array<double, 4>, 4> fpm_tmp;
				array<array<int, 4>, 4> fpmap_tmp;
				for (int j1 = 0; j1 < 4; j1++)//Bezier
				{
					for (k = 0; k < 4; k++)//B-splines
					{
						fpm_tmp[j1][k] = af[k];
						fpmap_tmp[j1][k] = loc[tmface[fcid].cnct[f_cnct[j1][k]]];
					}
				}
				fpm.push_back(fpm_tmp);
				fpmap.push_back(fpmap_tmp);
			}
		}
	}
	//determine coefs
	for (i = 0; i < 6; i++)
	{
		uint nhex = tmface[tmesh[eid].face[i]].hex.size();
		if (nhex == 2)
		{
			for (j = 0; j < nhex; j++)
			{
				hxid = tmface[tmesh[eid].face[i]].hex[j];
				vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
				pos1 = it - hx1r.begin();
				for (int j1 = 0; j1 < 4; j1++)
				{
					int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[fci[i][j1]]);
					pos2 = it1 - tmesh[hxid].cnct;
					for (k = 0; k < 8; k++)
					{
						tmesh[eid].bemat[bpmap[pos1][pos2][k]][fcbz[i][j1]] += bpm[pos1][pos2][k] / nhex;
					}
				}
			}
		}
		else if (nhex == 1)//new, for boundary face
		{
			int fcid = tmesh[eid].face[i];
			vector<int>::iterator it = find(fc_b.begin(), fc_b.end(), fcid);
			pos1 = it - fc_b.begin();
			for (int j1 = 0; j1 < 4; j1++)
			{
				int* it1 = find(tmface[fcid].cnct, tmface[fcid].cnct + 4, tmesh[eid].cnct[fci[i][j1]]);
				pos2 = it1 - tmface[fcid].cnct;
				for (k = 0; k < 4; k++)
				{
					tmesh[eid].bemat[fpmap[pos1][pos2][k]][fcbz[i][j1]] = fpm[pos1][pos2][k];
				}
			}
		}
	}
	//2*12 edge points
	int edi[12][2] = { { 0, 1 },{ 1, 2 },{ 2, 3 },{ 3, 0 },{ 0, 4 },{ 1, 5 },{ 2, 6 },{ 3, 7 },{ 4, 5 },{ 5, 6 },{ 6, 7 },{ 7, 4 } };
	int edbz[12][2] = { { 1, 2 },{ 7, 11 },{ 14, 13 },{ 8, 4 },{ 0 + layer[1], 0 + layer[2] },{ 3 + layer[1], 3 + layer[2] },
	{ 15 + layer[1], 15 + layer[2] },{ 12 + layer[1], 12 + layer[2] },{ 1 + layer[3], 2 + layer[3] },{ 7 + layer[3], 11 + layer[3] },{ 14 + layer[3], 13 + layer[3] },{ 8 + layer[3], 4 + layer[3] } };
	for (i = 0; i < 12; i++)
	{
		if (tmedge[tmesh[eid].edge[i]].type != 1)//non-boundary
		{
			uint nhex = tmedge[tmesh[eid].edge[i]].hex.size();
			for (j = 0; j<tmedge[tmesh[eid].edge[i]].hex.size(); j++)
			{
				hxid = tmedge[tmesh[eid].edge[i]].hex[j];
				vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
				pos1 = it - hx1r.begin();
				int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[edi[i][0]]);
				pos2 = it1 - tmesh[hxid].cnct;
				for (k = 0; k < 8; k++)
				{
					tmesh[eid].bemat[bpmap[pos1][pos2][k]][edbz[i][0]] += bpm[pos1][pos2][k] / nhex;
				}
				int* it2 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[edi[i][1]]);
				pos2 = it2 - tmesh[hxid].cnct;
				for (k = 0; k < 8; k++)
				{
					tmesh[eid].bemat[bpmap[pos1][pos2][k]][edbz[i][1]] += bpm[pos1][pos2][k] / nhex;
				}
			}
		}
		else if (tmedge[tmesh[eid].edge[i]].type == 1 && tmedge[tmesh[eid].edge[i]].sharp == 0)//boundary, non-sharp
		{
			int nfc_b(0);
			for (j = 0; j < tmedge[tmesh[eid].edge[i]].face.size(); j++)
			{
				if (tmface[tmedge[tmesh[eid].edge[i]].face[j]].type == 1) nfc_b++;
			}
			for (j = 0; j<tmedge[tmesh[eid].edge[i]].face.size(); j++)
			{
				int fcid(tmedge[tmesh[eid].edge[i]].face[j]);
				if (tmface[fcid].type == 1)//boundary face
				{
					vector<int>::iterator it = find(fc_b.begin(), fc_b.end(), fcid);
					pos1 = it - fc_b.begin();
					for (int j1 = 0; j1 < 2; j1++)
					{
						int* it1 = find(tmface[fcid].cnct, tmface[fcid].cnct + 4, tmesh[eid].cnct[edi[i][j1]]);
						pos2 = it1 - tmface[fcid].cnct;
						for (k = 0; k < 4; k++)
						{
							tmesh[eid].bemat[fpmap[pos1][pos2][k]][edbz[i][j1]] += fpm[pos1][pos2][k] / nfc_b;
						}
					}
				}
			}
		}
		else if (tmedge[tmesh[eid].edge[i]].type == 1 && tmedge[tmesh[eid].edge[i]].sharp == 1)//boundary, sharp edge
		{
			int bid[2] = { loc[tmesh[eid].cnct[edi[i][0]]], loc[tmesh[eid].cnct[edi[i][1]]] };
			tmesh[eid].bemat[bid[0]][edbz[i][0]] = w[0];
			tmesh[eid].bemat[bid[0]][edbz[i][1]] = w[1];
			tmesh[eid].bemat[bid[1]][edbz[i][0]] = w[1];
			tmesh[eid].bemat[bid[1]][edbz[i][1]] = w[0];
		}
	}
	//8 corner points
	int cnbz[8] = { 0, 3, 15, 12, 0 + layer[3], 3 + layer[3], 15 + layer[3], 12 + layer[3] };
	for (i = 0; i < 8; i++)
	{
		if (cp[tmesh[eid].cnct[i]].type != 1)//non-boundary vertex points
		{
			uint nhex = cp[tmesh[eid].cnct[i]].hex.size();
			for (j = 0; j<nhex; j++)
			{
				hxid = cp[tmesh[eid].cnct[i]].hex[j];
				vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
				pos1 = it - hx1r.begin();
				int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[i]);
				pos2 = it1 - tmesh[hxid].cnct;
				for (k = 0; k < 8; k++)
				{
					tmesh[eid].bemat[bpmap[pos1][pos2][k]][cnbz[i]] += bpm[pos1][pos2][k] / nhex;
				}
			}
		}
		else if (cp[tmesh[eid].cnct[i]].type == 1 && cp[tmesh[eid].cnct[i]].sharp == 0)//boundary vertex points, non-sharp
		{
			int nfc_b(0);
			for (j = 0; j < cp[tmesh[eid].cnct[i]].face.size(); j++)
			{
				if (tmface[cp[tmesh[eid].cnct[i]].face[j]].type == 1) nfc_b++;
			}
			for (j = 0; j<cp[tmesh[eid].cnct[i]].face.size(); j++)
			{
				int fcid(cp[tmesh[eid].cnct[i]].face[j]);
				if (tmface[fcid].type == 1)//boundary face
				{
					vector<int>::iterator it = find(fc_b.begin(), fc_b.end(), fcid);
					pos1 = it - fc_b.begin();
					int* it1 = find(tmface[fcid].cnct, tmface[fcid].cnct + 4, tmesh[eid].cnct[i]);
					pos2 = it1 - tmface[fcid].cnct;
					for (k = 0; k < 4; k++)
					{
						tmesh[eid].bemat[fpmap[pos1][pos2][k]][cnbz[i]] += fpm[pos1][pos2][k] / nfc_b;
					}
				}
			}
		}
		else if (cp[tmesh[eid].cnct[i]].type == 1 && cp[tmesh[eid].cnct[i]].sharp == 1)//boundary vertex points, sharp edge
		{
			//tmesh[eid].bemat[loc[tmesh[eid].cnct[i]]][cnbz[i]] = 1.;
			vector<int> shp_ed;
			for (j = 0; j < cp[tmesh[eid].cnct[i]].edge.size(); j++)
			{
				if (tmedge[cp[tmesh[eid].cnct[i]].edge[j]].sharp == 1)
				{
					shp_ed.push_back(cp[tmesh[eid].cnct[i]].edge[j]);
				}
			}
			if (shp_ed.size() == 2)
			{
				for (j = 0; j < shp_ed.size(); j++)
				{
					if (tmedge[shp_ed[j]].pt[0] == tmesh[eid].cnct[i])
					{
						tmesh[eid].bemat[loc[tmedge[shp_ed[j]].pt[0]]][cnbz[i]] = 2. / 3.;
						tmesh[eid].bemat[loc[tmedge[shp_ed[j]].pt[1]]][cnbz[i]] = 1. / 6.;
					}
					else
					{
						tmesh[eid].bemat[loc[tmedge[shp_ed[j]].pt[1]]][cnbz[i]] = 2. / 3.;
						tmesh[eid].bemat[loc[tmedge[shp_ed[j]].pt[0]]][cnbz[i]] = 1. / 6.;
					}
				}
			}
			else
			{
				cerr << "# of sharp edges of the point is wrong!\n";
				cout << shp_ed.size() << "\n";
				getchar();
			}
		}
		else if (cp[tmesh[eid].cnct[i]].type == 1 && cp[tmesh[eid].cnct[i]].sharp == 2)//boundary vertex points, sharp corner
		{
			tmesh[eid].bemat[loc[tmesh[eid].cnct[i]]][cnbz[i]] = 1.;
		}
	}
}

void TruncatedTspline_3D::OutputMesh_Coupling(const vector<BezierElement3D>& bzmesh, string fn)
{
	int cn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };
	string fname = fn + "_bzmesh.vtk";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nBezier mesh\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << 8 * bzmesh.size() << " float\n";
		for (uint i = 0; i<bzmesh.size(); i++)
		{
			for (int j = 0; j < 8; j++)
			{
				fout << bzmesh[i].pts[cn[j]][0] << " " << bzmesh[i].pts[cn[j]][1] << " " << bzmesh[i].pts[cn[j]][2] << "\n";
			}
		}
		fout << "\nCELLS " << bzmesh.size() << " " << 9 * bzmesh.size() << '\n';
		for (uint i = 0; i<bzmesh.size(); i++)
		{
			fout << "8 " << 8 * i << " " << 8 * i + 1 << " " << 8 * i + 2 << " " << 8 * i + 3
				<< " " << 8 * i + 4 << " " << 8 * i + 5 << " " << 8 * i + 6 << " " << 8 * i + 7 << '\n';
		}
		fout << "\nCELL_TYPES " << bzmesh.size() << '\n';
		for (uint i = 0; i<bzmesh.size(); i++)
		{
			fout << "12\n";
		}
		//fout << "POINT_DATA " << sdisp.size() << "\nSCALARS err float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<sdisp.size(); i++)
		//{
		//	fout << sdisp[i] << "\n";
		//}
		fout << "\nCELL_DATA " << bzmesh.size() << "\nSCALARS Error float 1\nLOOKUP_TABLE default\n";
		for (uint i = 0; i < bzmesh.size(); i++)
		{
			fout << bzmesh[i].type << "\n";
		}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}

	//string fname1(fn + "_mp.vtk");
	////ofstream fout;
	//fout.open(fname1.c_str());
	//if (fout.is_open())
	//{
	//	fout << "# vtk DataFile Version 2.0\nMeshfree nodes\nASCII\nDATASET UNSTRUCTURED_GRID\n";
	//	fout << "POINTS " << mp.size() << " float\n";
	//	for (uint i = 0; i<mp.size(); i++)
	//	{
	//		fout << mp[i].coor[0] << " " << mp[i].coor[1] << " " << mp[i].coor[2] << "\n";
	//	}
	//	fout << "\nCELLS " << mp.size() << " " << 2 * mp.size() << '\n';
	//	for (uint i = 0; i<mp.size(); i++)
	//	{
	//		fout << "1 " << i << "\n";
	//	}
	//	fout << "\nCELL_TYPES " << mp.size() << '\n';
	//	for (uint i = 0; i < mp.size(); i++)
	//	{
	//		fout << "1\n";
	//	}
	//	fout.close();
	//}
	//else
	//{
	//	cerr << "Can't open " << fname1 << '\n';
	//}
}






void TruncatedTspline_3D::Run_Coupling_Bezier(string fn, int nrf, vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	InitializeMesh(fn);
	//OutputCM(fn);
	ReportDiffEleNumber();
	BuildSplines_Unstruct();
	Convert2Bezier();
	for (int i = 0; i < nrf; i++)
	{
		Global_Subdivide_wBezier();
	}
	BuildSplines_Unstruct();
	BezierExtract_BezierCoupling(bzmesh, IDBC, gh);
}

void TruncatedTspline_3D::Convert2Bezier()
{
	int bzbd[8] = { 21, 22, 26, 25, 37, 38, 42, 41 };
	int bzfc[6][4] = { { 5, 6, 10, 9 }, { 17, 18, 34, 33 }, { 23, 27, 43, 39 }, { 29, 30, 46, 45 }, { 20, 24, 40, 36 }, { 53, 54, 58, 57 } };
	int bzed[12][2] = { { 1, 2 }, { 7, 11 }, { 13, 14 }, { 4, 8 }, { 16, 32 }, { 19, 35 }, { 31, 47 }, { 28, 44 }, { 49, 50 }, { 55, 59 }, { 61, 62 }, { 52, 56 } };
	int bzcn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };

	for (int eid = 0; eid < tmesh.size(); eid++)
	{
		tmesh[eid].IENb.clear();
		if (tmesh[eid].type != 0)//irregular or boundary
		{
			tmesh[eid].bzflag = 1;
			tmesh[eid].IENb.resize(64);
			vector<array<double, 3>> bzcpe(64);
			double tmp;
			for (int i = 0; i < 64; i++)
			{
				bzcpe[i][0] = 0.; bzcpe[i][1] = 0.; bzcpe[i][2] = 0.;
				for (int j = 0; j < tmesh[eid].IEN.size(); j++)
				{
					tmp = tmesh[eid].bemat[j][i];
					bzcpe[i][0] += tmp*cp[tmesh[eid].IEN[j]].coor[0];
					bzcpe[i][1] += tmp*cp[tmesh[eid].IEN[j]].coor[1];
					bzcpe[i][2] += tmp*cp[tmesh[eid].IEN[j]].coor[2];
				}
			}
			for (int i = 0; i < 8; i++)//body points
			{
				bzcp.push_back(bzcpe[bzbd[i]]);
				tmesh[eid].IENb[bzbd[i]] = bzcp.size() - 1;
			}
			for (int i = 0; i < 6; i++)//face points
			{
				if (tmface[tmesh[eid].face[i]].bzid.size() == 0)
				{
					for (int j = 0; j < 4; j++)
					{
						bzcp.push_back(bzcpe[bzfc[i][j]]);
						tmesh[eid].IENb[bzfc[i][j]] = bzcp.size() - 1;
						tmface[tmesh[eid].face[i]].bzid.push_back(tmesh[eid].IENb[bzfc[i][j]]);
					}
				}
				else
				{
					int fcid(tmesh[eid].face[i]);
					for (int j = 0; j < 4; j++)
					{
						int loc(-1), pfid;
						for (int k = 0; k < 4; k++)
						{
							pfid = tmface[fcid].bzid[k];
							tmp = (bzcpe[bzfc[i][j]][0] - bzcp[pfid][0])*(bzcpe[bzfc[i][j]][0] - bzcp[pfid][0]) +
								(bzcpe[bzfc[i][j]][1] - bzcp[pfid][1])*(bzcpe[bzfc[i][j]][1] - bzcp[pfid][1]) +
								(bzcpe[bzfc[i][j]][2] - bzcp[pfid][2])*(bzcpe[bzfc[i][j]][2] - bzcp[pfid][2]);
							tmp = sqrt(tmp);
							if (tmp < 1.e-8)
							{
								loc = pfid; break;
							}
						}
						if (loc == -1)
						{
							cerr << "Can't find existing face points in a face!\n"; getchar();
						}
						tmesh[eid].IENb[bzfc[i][j]] = loc;
					}
				}
			}
			for (int i = 0; i < 12; i++)//edge points
			{
				if (tmedge[tmesh[eid].edge[i]].bzid.size() == 0)
				{
					for (int j = 0; j < 2; j++)
					{
						bzcp.push_back(bzcpe[bzed[i][j]]);
						tmesh[eid].IENb[bzed[i][j]] = bzcp.size() - 1;
						tmedge[tmesh[eid].edge[i]].bzid.push_back(tmesh[eid].IENb[bzed[i][j]]);
					}
				}
				else
				{
					int edid(tmesh[eid].edge[i]);
					for (int j = 0; j < 2; j++)
					{
						int loc(-1), peid;
						for (int k = 0; k < 2; k++)
						{
							peid = tmedge[edid].bzid[k];
							tmp = (bzcpe[bzed[i][j]][0] - bzcp[peid][0])*(bzcpe[bzed[i][j]][0] - bzcp[peid][0]) +
								(bzcpe[bzed[i][j]][1] - bzcp[peid][1])*(bzcpe[bzed[i][j]][1] - bzcp[peid][1]) +
								(bzcpe[bzed[i][j]][2] - bzcp[peid][2])*(bzcpe[bzed[i][j]][2] - bzcp[peid][2]);
							tmp = sqrt(tmp);
							if (tmp < 1.e-8)
							{
								loc = peid; break;
							}
						}
						if (loc == -1)
						{
							cerr << "Can't find existing edge points in an edge!\n"; getchar();
						}
						tmesh[eid].IENb[bzed[i][j]] = loc;
					}
				}
			}
			for (int i = 0; i < 8; i++)//corner points
			{
				if (cp[tmesh[eid].cnct[i]].bzid == -1)
				{
					bzcp.push_back(bzcpe[bzcn[i]]);
					tmesh[eid].IENb[bzcn[i]] = bzcp.size() - 1;
					cp[tmesh[eid].cnct[i]].bzid = tmesh[eid].IENb[bzcn[i]];
				}
				else
				{
					tmesh[eid].IENb[bzcn[i]] = cp[tmesh[eid].cnct[i]].bzid;
				}
			}
		}
	}
}

void TruncatedTspline_3D::Global_Subdivide_wBezier()
{
	//body points
	vector<array<double, 3>> pts_bd(tmesh.size());
	for (int i = 0; i < tmesh.size(); i++)
	{
		pts_bd[i][0] = 0.; pts_bd[i][1] = 0.; pts_bd[i][2] = 0.;
		for (int j = 0; j < 8; j++)
		{
			pts_bd[i][0] += cp[tmesh[i].cnct[j]].coor[0];
			pts_bd[i][1] += cp[tmesh[i].cnct[j]].coor[1];
			pts_bd[i][2] += cp[tmesh[i].cnct[j]].coor[2];
		}
		pts_bd[i][0] /= 8.; pts_bd[i][1] /= 8.; pts_bd[i][2] /= 8.;
	}
	//face points
	vector<array<double, 3>> pts_fc0(tmface.size());//simply average
	vector<array<double, 3>> pts_fc(tmface.size());//desired
	for (int i = 0; i < tmface.size(); i++)
	{
		pts_fc0[i][0] = 0.; pts_fc0[i][1] = 0.; pts_fc0[i][2] = 0.;
		for (int j = 0; j < 4; j++)
		{
			pts_fc0[i][0] += cp[tmface[i].cnct[j]].coor[0];
			pts_fc0[i][1] += cp[tmface[i].cnct[j]].coor[1];
			pts_fc0[i][2] += cp[tmface[i].cnct[j]].coor[2];
		}
		pts_fc0[i][0] /= 4.; pts_fc0[i][1] /= 4.; pts_fc0[i][2] /= 4.;
		if (tmface[i].hex.size() == 2)//interior face points
		{
			int hxid[2] = { tmface[i].hex[0], tmface[i].hex[1] };
			pts_fc[i][0] = (pts_bd[hxid[0]][0] + pts_bd[hxid[1]][0] + 2.*pts_fc0[i][0]) / 4.;
			pts_fc[i][1] = (pts_bd[hxid[0]][1] + pts_bd[hxid[1]][1] + 2.*pts_fc0[i][1]) / 4.;
			pts_fc[i][2] = (pts_bd[hxid[0]][2] + pts_bd[hxid[1]][2] + 2.*pts_fc0[i][2]) / 4.;
		}
		else
		{
			pts_fc[i][0] = pts_fc0[i][0]; pts_fc[i][1] = pts_fc0[i][1]; pts_fc[i][2] = pts_fc0[i][2];
		}
	}
	//edge points
	vector<array<double, 3>> pts_ed0(tmedge.size());//simply average
	vector<array<double, 3>> pts_ed(tmedge.size());//desired
	for (int i = 0; i < tmedge.size(); i++)
	{
		pts_ed0[i][0] = (cp[tmedge[i].pt[0]].coor[0] + cp[tmedge[i].pt[1]].coor[0]) / 2.;
		pts_ed0[i][1] = (cp[tmedge[i].pt[0]].coor[1] + cp[tmedge[i].pt[1]].coor[1]) / 2.;
		pts_ed0[i][2] = (cp[tmedge[i].pt[0]].coor[2] + cp[tmedge[i].pt[1]].coor[2]) / 2.;
		if (tmedge[i].type != 1)//non-boundary, i.e. interior
		{
			double cavg[3] = { 0., 0., 0. };
			for (uint j = 0; j < tmedge[i].hex.size(); j++)
			{
				cavg[0] += pts_bd[tmedge[i].hex[j]][0];
				cavg[1] += pts_bd[tmedge[i].hex[j]][1];
				cavg[2] += pts_bd[tmedge[i].hex[j]][2];
			}
			cavg[0] /= double(tmedge[i].hex.size());
			cavg[1] /= double(tmedge[i].hex.size());
			cavg[2] /= double(tmedge[i].hex.size());
			double aavg[3] = { 0., 0., 0. };
			for (uint j = 0; j < tmedge[i].face.size(); j++)
			{
				aavg[0] += pts_fc0[tmedge[i].face[j]][0];
				aavg[1] += pts_fc0[tmedge[i].face[j]][1];
				aavg[2] += pts_fc0[tmedge[i].face[j]][2];
			}
			aavg[0] /= double(tmedge[i].face.size());
			aavg[1] /= double(tmedge[i].face.size());
			aavg[2] /= double(tmedge[i].face.size());
			pts_ed[i][0] = (cavg[0] + 2.*aavg[0] + double(tmedge[i].face.size() - 3)*pts_ed0[i][0]) / double(tmedge[i].face.size());
			pts_ed[i][1] = (cavg[1] + 2.*aavg[1] + double(tmedge[i].face.size() - 3)*pts_ed0[i][1]) / double(tmedge[i].face.size());
			pts_ed[i][2] = (cavg[2] + 2.*aavg[2] + double(tmedge[i].face.size() - 3)*pts_ed0[i][2]) / double(tmedge[i].face.size());
		}
		else
		{
			if (tmedge[i].sharp == 0)//boundary non-sharp edge
			{
				double aavg[3] = { 0., 0., 0. };
				for (uint j = 0; j < tmedge[i].face.size(); j++)
				{
					if (tmface[tmedge[i].face[j]].type == 1)
					{
						aavg[0] += pts_fc0[tmedge[i].face[j]][0];
						aavg[1] += pts_fc0[tmedge[i].face[j]][1];
						aavg[2] += pts_fc0[tmedge[i].face[j]][2];
					}
				}
				pts_ed[i][0] = (aavg[0] + 2.*pts_ed0[i][0]) / 4.;
				pts_ed[i][1] = (aavg[1] + 2.*pts_ed0[i][1]) / 4.;
				pts_ed[i][2] = (aavg[2] + 2.*pts_ed0[i][2]) / 4.;
			}
			else//sharp edge
			{
				pts_ed[i][0] = pts_ed0[i][0];
				pts_ed[i][1] = pts_ed0[i][1];
				pts_ed[i][2] = pts_ed0[i][2];
			}
		}
	}
	//vertex points
#pragma omp parallel for
	for (int i = 0; i < cp.size(); i++)
	{
		if (cp[i].type != 1)//interior, careful
		{
			double cavg[3] = { 0., 0., 0. };
			for (uint j = 0; j < cp[i].hex.size(); j++)
			{
				cavg[0] += pts_bd[cp[i].hex[j]][0];
				cavg[1] += pts_bd[cp[i].hex[j]][1];
				cavg[2] += pts_bd[cp[i].hex[j]][2];
			}
			cavg[0] /= double(cp[i].hex.size());
			cavg[1] /= double(cp[i].hex.size());
			cavg[2] /= double(cp[i].hex.size());
			double aavg[3] = { 0., 0., 0. };
			for (uint j = 0; j < cp[i].face.size(); j++)
			{
				aavg[0] += pts_fc0[cp[i].face[j]][0];
				aavg[1] += pts_fc0[cp[i].face[j]][1];
				aavg[2] += pts_fc0[cp[i].face[j]][2];
			}
			aavg[0] /= double(cp[i].face.size());
			aavg[1] /= double(cp[i].face.size());
			aavg[2] /= double(cp[i].face.size());
			double mavg[3] = { 0., 0., 0. };
			for (uint j = 0; j < cp[i].edge.size(); j++)
			{
				mavg[0] += pts_ed0[cp[i].edge[j]][0];
				mavg[1] += pts_ed0[cp[i].edge[j]][1];
				mavg[2] += pts_ed0[cp[i].edge[j]][2];
			}
			mavg[0] /= double(cp[i].edge.size());
			mavg[1] /= double(cp[i].edge.size());
			mavg[2] /= double(cp[i].edge.size());
			cp[i].coor[0] = (cavg[0] + 3.*aavg[0] + 3.*mavg[0] + cp[i].coor[0]) / 8.;
			cp[i].coor[1] = (cavg[1] + 3.*aavg[1] + 3.*mavg[1] + cp[i].coor[1]) / 8.;
			cp[i].coor[2] = (cavg[2] + 3.*aavg[2] + 3.*mavg[2] + cp[i].coor[2]) / 8.;
		}
		else
		{
			if (cp[i].sharp == 0)
			{
				double aavg[3] = { 0., 0., 0. };
				int nfc(0);
				for (uint j = 0; j < cp[i].face.size(); j++)
				{
					if (tmface[cp[i].face[j]].type == 1)
					{
						aavg[0] += pts_fc0[cp[i].face[j]][0];
						aavg[1] += pts_fc0[cp[i].face[j]][1];
						aavg[2] += pts_fc0[cp[i].face[j]][2];
						nfc++;
					}
				}
				aavg[0] /= double(nfc); aavg[1] /= double(nfc); aavg[2] /= double(nfc);//nfc==2
				double mavg[3] = { 0., 0., 0. };
				int ned(0);
				for (uint j = 0; j < cp[i].edge.size(); j++)
				{
					if (tmedge[cp[i].edge[j]].type == 1)
					{
						mavg[0] += pts_ed0[cp[i].edge[j]][0];
						mavg[1] += pts_ed0[cp[i].edge[j]][1];
						mavg[2] += pts_ed0[cp[i].edge[j]][2];
						ned++;
					}
				}
				mavg[0] /= double(ned); mavg[1] /= double(ned); mavg[2] /= double(ned);
				cp[i].coor[0] = (aavg[0] + 2.*mavg[0] + double(nfc - 3)*cp[i].coor[0]) / double(nfc);
				cp[i].coor[1] = (aavg[1] + 2.*mavg[1] + double(nfc - 3)*cp[i].coor[1]) / double(nfc);
				cp[i].coor[2] = (aavg[2] + 2.*mavg[2] + double(nfc - 3)*cp[i].coor[2]) / double(nfc);
			}
			else if (cp[i].sharp == 1)//associated with sharp edge
			{
				double mavg[3] = { 0., 0., 0. };
				for (uint j = 0; j < cp[i].edge.size(); j++)
				{
					if (tmedge[cp[i].edge[j]].sharp == 1)
					{
						mavg[0] += pts_ed0[cp[i].edge[j]][0];
						mavg[1] += pts_ed0[cp[i].edge[j]][1];
						mavg[2] += pts_ed0[cp[i].edge[j]][2];
					}
				}
				cp[i].coor[0] = (mavg[0] + 2.*cp[i].coor[0]) / 4.;
				cp[i].coor[1] = (mavg[1] + 2.*cp[i].coor[1]) / 4.;
				cp[i].coor[2] = (mavg[2] + 2.*cp[i].coor[2]) / 4.;
			}
			else//sharp corner
			{
				cp[i].coor[0] = cp[i].coor[0]; cp[i].coor[1] = cp[i].coor[1]; cp[i].coor[2] = cp[i].coor[2];
			}
		}
	}
#pragma omp barrier
	//update cp
	vector<int> pid_vt(cp.size());
	vector<int> pid_ed(tmedge.size());
	vector<int> pid_fc(tmface.size());
	vector<int> pid_bd(tmesh.size());
	int count(0);
	for (int i = 0; i < cp.size(); i++)
	{
		pid_vt[i] = count++;
	}
	for (int i = 0; i < tmedge.size(); i++)
	{
		pid_ed[i] = count++;
		Vertex3D ptmp;
		ptmp.act = 1;
		if (tmedge[i].type == 1) ptmp.type = 1;//default 0
		if (tmedge[i].sharp == 1) ptmp.sharp = 1;//default 0
		ptmp.coor[0] = pts_ed[i][0]; ptmp.coor[1] = pts_ed[i][1]; ptmp.coor[2] = pts_ed[i][2];
		cp.push_back(ptmp);
	}
	for (int i = 0; i < tmface.size(); i++)
	{
		pid_fc[i] = count++;
		Vertex3D ptmp;
		ptmp.act = 1;
		if (tmface[i].type == 1) ptmp.type = 1;//default 0
		ptmp.coor[0] = pts_fc[i][0]; ptmp.coor[1] = pts_fc[i][1]; ptmp.coor[2] = pts_fc[i][2];
		cp.push_back(ptmp);
	}
	for (int i = 0; i < tmesh.size(); i++)
	{
		pid_bd[i] = count++;
		Vertex3D ptmp;
		ptmp.act = 1;
		ptmp.coor[0] = pts_bd[i][0]; ptmp.coor[1] = pts_bd[i][1]; ptmp.coor[2] = pts_bd[i][2];
		cp.push_back(ptmp);
	}
	//update edge
	vector<Edge3D> ednew(2 * tmedge.size() + 4 * tmface.size() + 6 * tmesh.size());
	int edloc(0);
	for (int i = 0; i < tmedge.size(); i++)
	{
		ednew[edloc].pt[0] = tmedge[i].pt[0];
		ednew[edloc].pt[1] = pid_ed[i];
		ednew[edloc].type = tmedge[i].type;//
		ednew[edloc].sharp = tmedge[i].sharp;//
		edloc++;
		ednew[edloc].pt[0] = pid_ed[i];
		ednew[edloc].pt[1] = tmedge[i].pt[1];
		ednew[edloc].type = tmedge[i].type;//
		ednew[edloc].sharp = tmedge[i].sharp;//
		edloc++;
	}
	//update face
	vector<Face3D> fcnew(4 * tmface.size() + 12 * tmesh.size());
	int fcloc(0);
	for (int i = 0; i < tmface.size(); i++)
	{
		int fcnct[4][4] = { { tmface[i].cnct[0], pid_ed[tmface[i].edge[0]], pid_fc[i], pid_ed[tmface[i].edge[3]] },
		{ pid_ed[tmface[i].edge[0]], tmface[i].cnct[1], pid_ed[tmface[i].edge[1]], pid_fc[i] },
		{ pid_fc[i], pid_ed[tmface[i].edge[1]], tmface[i].cnct[2], pid_ed[tmface[i].edge[2]] },
		{ pid_ed[tmface[i].edge[3]], pid_fc[i], pid_ed[tmface[i].edge[2]], tmface[i].cnct[3] } };
		int edid[12];
		for (int j = 0; j < 4; j++)
		{
			edid[2 * j] = 2 * tmface[i].edge[j]; edid[2 * j + 1] = 2 * tmface[i].edge[j] + 1;
			if (tmedge[tmface[i].edge[j]].pt[0] != tmface[i].cnct[j])
			{
				edid[2 * j] = 2 * tmface[i].edge[j] + 1; edid[2 * j + 1] = 2 * tmface[i].edge[j];
			}
		}
		//construct 4 new edges
		for (int j = 0; j < 4; j++)
		{
			ednew[edloc].pt[0] = pid_fc[i];
			ednew[edloc].pt[1] = pid_ed[tmface[i].edge[j]];
			if (tmface[i].type == 1) ednew[edloc].type = 1;//boundary
			edid[8 + j] = edloc;
			edloc++;
		}
		int fedge[4][4] = { { edid[0], edid[8], edid[11], edid[7] }, { edid[1], edid[2], edid[9], edid[8] },
		{ edid[9], edid[3], edid[4], edid[10] }, { edid[11], edid[10], edid[5], edid[6] } };
		for (int j = 0; j < 4; j++)
		{
			fcnew[fcloc].type = tmface[i].type;//
			for (int k = 0; k < 4; k++)
			{
				fcnew[fcloc].cnct[k] = fcnct[j][k];
				fcnew[fcloc].edge[k] = fedge[j][k];
			}
			fcloc++;
		}
	}
	//update hex
	vector<Element3D> hxnew(8 * tmesh.size());
	int hxloc(0);
	for (int i = 0; i < tmesh.size(); i++)
	{
		//construct new edges
		for (int j = 0; j < 6; j++)
		{
			ednew[edloc].pt[0] = pid_bd[i];
			ednew[edloc].pt[1] = pid_fc[tmesh[i].face[j]];
			edloc++;
		}
		//construct new faces
		int fcnct[12][4] = { { pid_ed[tmesh[i].edge[0]], pid_fc[tmesh[i].face[0]], pid_bd[i], pid_fc[tmesh[i].face[1]] },
		{ pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[2]], pid_fc[tmesh[i].face[3]], pid_bd[i] },
		{ pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[10]], pid_fc[tmesh[i].face[5]] },
		{ pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[8]] },
		{ pid_ed[tmesh[i].edge[3]], pid_fc[tmesh[i].face[0]], pid_bd[i], pid_fc[tmesh[i].face[4]] },
		{ pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[1]], pid_fc[tmesh[i].face[2]], pid_bd[i] },
		{ pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[9]], pid_fc[tmesh[i].face[5]] },
		{ pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[11]] },
		{ pid_ed[tmesh[i].edge[4]], pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[4]] },
		{ pid_fc[tmesh[i].face[1]], pid_ed[tmesh[i].edge[5]], pid_fc[tmesh[i].face[2]], pid_bd[i] },
		{ pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[6]], pid_fc[tmesh[i].face[3]] },
		{ pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[7]] } };
		//collect all edges and faces in this element
		int edids[12 * 2 + 6 * 4 + 6], fcids[6 * 4 + 12];
		for (int j = 0; j < 12; j++)
		{
			edids[2 * j] = 2 * tmesh[i].edge[j];
			edids[2 * j + 1] = 2 * tmesh[i].edge[j] + 1;
			fcids[24 + j] = 4 * tmface.size() + 12 * i + j;
		}
		for (int j = 0; j < 6; j++)
		{
			edids[24 + 4 * j] = 2 * tmedge.size() + 4 * tmesh[i].face[j];
			edids[24 + 4 * j + 1] = 2 * tmedge.size() + 4 * tmesh[i].face[j] + 1;
			edids[24 + 4 * j + 2] = 2 * tmedge.size() + 4 * tmesh[i].face[j] + 2;
			edids[24 + 4 * j + 3] = 2 * tmedge.size() + 4 * tmesh[i].face[j] + 3;
			edids[48 + j] = 2 * tmedge.size() + 4 * tmface.size() + 6 * i + j;
			fcids[4 * j] = 4 * tmesh[i].face[j];
			fcids[4 * j + 1] = 4 * tmesh[i].face[j] + 1;
			fcids[4 * j + 2] = 4 * tmesh[i].face[j] + 2;
			fcids[4 * j + 3] = 4 * tmesh[i].face[j] + 3;
		}
		for (int j = 0; j < 12; j++)
		{
			for (int k = 0; k < 4; k++)
			{
				fcnew[fcloc].cnct[k] = fcnct[j][k];
				for (int k0 = 24; k0 < 54; k0++)
				{
					if ((fcnct[j][k] == ednew[edids[k0]].pt[0] && fcnct[j][(k + 1) % 4] == ednew[edids[k0]].pt[1]) ||
						(fcnct[j][k] == ednew[edids[k0]].pt[1] && fcnct[j][(k + 1) % 4] == ednew[edids[k0]].pt[0]))
					{
						fcnew[fcloc].edge[k] = edids[k0]; break;
					}
				}
			}
			fcloc++;
		}
		//construct new hex
		int ecnct[8][8] = { { tmesh[i].cnct[0], pid_ed[tmesh[i].edge[0]], pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[3]], pid_ed[tmesh[i].edge[4]], pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[4]] },
		{ pid_ed[tmesh[i].edge[0]], tmesh[i].cnct[1], pid_ed[tmesh[i].edge[1]], pid_fc[tmesh[i].face[0]], pid_fc[tmesh[i].face[1]], pid_ed[tmesh[i].edge[5]], pid_fc[tmesh[i].face[2]], pid_bd[i] },
		{ pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[1]], tmesh[i].cnct[2], pid_ed[tmesh[i].edge[2]], pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[6]], pid_fc[tmesh[i].face[3]] },
		{ pid_ed[tmesh[i].edge[3]], pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[2]], tmesh[i].cnct[3], pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[7]] },
		{ pid_ed[tmesh[i].edge[4]], pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[4]], tmesh[i].cnct[4], pid_ed[tmesh[i].edge[8]], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[11]] },
		{ pid_fc[tmesh[i].face[1]], pid_ed[tmesh[i].edge[5]], pid_fc[tmesh[i].face[2]], pid_bd[i], pid_ed[tmesh[i].edge[8]], tmesh[i].cnct[5], pid_ed[tmesh[i].edge[9]], pid_fc[tmesh[i].face[5]] },
		{ pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[6]], pid_fc[tmesh[i].face[3]], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[9]], tmesh[i].cnct[6], pid_ed[tmesh[i].edge[10]] },
		{ pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[7]], pid_ed[tmesh[i].edge[11]], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[10]], tmesh[i].cnct[7] } };
		for (int j = 0; j < 8; j++)
		{
			for (int k = 0; k < 8; k++)
			{
				hxnew[hxloc].cnct[k] = ecnct[j][k];
			}
			//find face connectivity
			for (int k = 0; k < 6; k++)
			{
				array<int, 4> tmp1 = { ecnct[j][solid_fc[k][0]], ecnct[j][solid_fc[k][1]], ecnct[j][solid_fc[k][2]], ecnct[j][solid_fc[k][3]] };
				sort(tmp1.begin(), tmp1.end());
				for (int k0 = 0; k0 < 36; k0++)
				{
					array<int, 4> tmp2 = { fcnew[fcids[k0]].cnct[0], fcnew[fcids[k0]].cnct[1], fcnew[fcids[k0]].cnct[2], fcnew[fcids[k0]].cnct[3] };
					sort(tmp2.begin(), tmp2.end());
					if (tmp1 == tmp2)
					{
						hxnew[hxloc].face[k] = fcids[k0]; break;
					}
				}
			}
			//find edge connectivity
			for (int k = 0; k < 12; k++)
			{
				array<int, 2> tmp1 = { ecnct[j][solid_ed[k][0]], ecnct[j][solid_ed[k][1]] };
				for (int k0 = 0; k0 < 54; k0++)
				{
					if ((tmp1[0] == ednew[edids[k0]].pt[0] && tmp1[1] == ednew[edids[k0]].pt[1]) ||
						(tmp1[0] == ednew[edids[k0]].pt[1] && tmp1[1] == ednew[edids[k0]].pt[0]))
					{
						hxnew[hxloc].edge[k] = edids[k0]; break;
					}
				}
			}
			hxloc++;
		}
	}//type of hex not assigned yet

	//refinement of Bezier patch
	BezierPatch_Refine(hxnew);

	//update connectivity
	tmedge.resize(ednew.size());
	tmface.resize(fcnew.size());
	tmesh.resize(hxnew.size());
	for (int i = 0; i < cp.size(); i++)
	{
		cp[i].edge.clear();
		cp[i].face.clear();
		cp[i].hex.clear();
	}
	for (int i = 0; i < ednew.size(); i++)
	{
		tmedge[i].act = 1;
		tmedge[i].type = ednew[i].type;
		tmedge[i].sharp = ednew[i].sharp;
		tmedge[i].pt[0] = ednew[i].pt[0]; tmedge[i].pt[1] = ednew[i].pt[1];
		tmedge[i].face.clear();
		tmedge[i].hex.clear();
	}
	for (int i = 0; i < fcnew.size(); i++)
	{
		tmface[i].act = 1;
		tmface[i].type = fcnew[i].type;
		for (int j = 0; j < 4; j++)
		{
			tmface[i].cnct[j] = fcnew[i].cnct[j];
			tmface[i].edge[j] = fcnew[i].edge[j];
		}
		tmface[i].hex.clear();
	}
	for (int i = 0; i < hxnew.size(); i++)
	{
		tmesh[i].act = 1;
		//tmesh[i].type = hxnew[i].type;//problem
		tmesh[i].type = 0;
		for (int j = 0; j < 8; j++)
		{
			tmesh[i].cnct[j] = hxnew[i].cnct[j];
		}
		for (int j = 0; j < 12; j++)
		{
			tmesh[i].edge[j] = hxnew[i].edge[j];
		}
		for (int j = 0; j < 6; j++)
		{
			tmesh[i].face[j] = hxnew[i].face[j];
		}
	}

	//further treatment of Bezier patches
	FindBezierIEN(hxnew);

	//deconstruct hxnew, fcnew, ednew
	ClearRefineMemory(hxnew, fcnew, ednew);

	//vertex-to-hex, edge-to-hex, face-to-hex
	for (int i = 0; i<tmesh.size(); i++)
	{
		for (int j = 0; j<8; j++)
		{
			cp[tmesh[i].cnct[j]].hex.push_back(i);
		}
		for (int j = 0; j<12; j++)
		{
			tmedge[tmesh[i].edge[j]].hex.push_back(i);
		}
		for (int j = 0; j<6; j++)
		{
			tmface[tmesh[i].face[j]].hex.push_back(i);
		}
	}
	//vertex-to-face, edge-to-face
	for (int i = 0; i<tmface.size(); i++)
	{
		for (int j = 0; j<4; j++)
		{
			cp[tmface[i].cnct[j]].face.push_back(i);
			tmedge[tmface[i].edge[j]].face.push_back(i);
		}
	}
	//vertex-to-edge
	for (int i = 0; i<tmedge.size(); i++)
	{
		for (int j = 0; j<2; j++)
		{
			cp[tmedge[i].pt[j]].edge.push_back(i);
		}
	}
	//find extraordinary edges and vertices
	for (int i = 0; i<tmedge.size(); i++)
	{
		if (tmedge[i].type != 1 && tmedge[i].hex.size() != 4)
		{
			tmedge[i].type = 2;
			if (cp[tmedge[i].pt[0]].type != 1)
				cp[tmedge[i].pt[0]].type = 3;
			if (cp[tmedge[i].pt[1]].type != 1)
				cp[tmedge[i].pt[1]].type = 3;
		}
	}
	//find boundary and irregular elements
	for (int i = 0; i<tmesh.size(); i++)
	{
		tmesh[i].type = 0;
		for (int j = 0; j < 8; j++)
		{
			if (cp[tmesh[i].cnct[j]].type == 1)
			{
				tmesh[i].type = 1; break;
			}
		}
		if (tmesh[i].type != 1)
		{
			for (int j = 0; j<12; j++)
			{
				if (tmedge[tmesh[i].edge[j]].type == 2)
				{
					tmesh[i].type = 2;
					break;
				}
			}
			//additional
			for (int j = 0; j<8; j++)
			{
				if (cp[tmesh[i].cnct[j]].type == 3)
				{
					tmesh[i].type = 2;
					break;
				}
			}
		}
	}

	//boundry extraordinary points
	//for (int i = 0; i<cp.size(); i++)
	//{
	//	if (cp[i].type == 1)
	//	{
	//		int count(0);
	//		for (j = 0; j < cp[i].edge.size(); j++)
	//		{
	//			if (tmedge[cp[i].edge[j]].type == 2) count++;
	//		}
	//		if (count == 1) cp[i].bcxp = 1;
	//		else if (count>1) cp[i].bcxp = 2;
	//	}
	//}
}

void TruncatedTspline_3D::BezierPatch_Refine(vector<Element3D>& hxnew)
{
	double kv1_tmp[8] = { 0., 0., 0., 0., 1., 1., 1., 1. };
	double kv2_tmp[11] = { 0., 0., 0., 0., .5, .5, .5, 1., 1., 1., 1. };
	vector<double> kv1(kv1_tmp, kv1_tmp + 8);
	vector<double> kv2(kv2_tmp, kv2_tmp + 11);
	vector<vector<double>> cmat;
	TMatrix(kv1,kv2,3,cmat);

	//initialize, clear bzid
	//for (uint i = 0; i < tmface.size(); i++)
	//{
	//	tmface[i].bzid.clear();
	//}
	//for (uint i = 0; i < tmedge.size(); i++)
	//{
	//	tmedge[i].bzid.clear();
	//}
	//for (uint i = 0; i < cp.size(); i++)
	//{
	//	cp[i].bzid = -1;
	//}

	int stt[8][3] = { { 0, 0, 0 }, { 3, 0, 0 }, { 3, 3, 0 }, { 0, 3, 0 }, { 0, 0, 3 }, { 3, 0, 3 }, { 3, 3, 3 }, { 0, 3, 3 } };
	int npn(7), npo(4), i, j, k, i0, j0, k0, loc(0), loc0(0);
	//int bnfc[6][25];
	//int bned[12][5];
	//int bncn[8] = { 0, 6, 48, 42, 294, 300, 342, 336 };

	vector<array<double, 3>> bpenew(npn * npn * npn);//element Bezier points
	vector<array<double, 3>> bzcpn;//all Bezier points
	double tmp;
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].bzflag == 1)
		{
			loc = 0;
			//vector<int> bpeid(npn*npn*npn);
			for (k = 0; k < npn; k++)
			{
				for (j = 0; j < npn; j++)
				{
					for (i = 0; i < npn; i++)
					{
						loc0 = 0;
						bpenew[loc][0] = 0.; bpenew[loc][1] = 0.; bpenew[loc][2] = 0.;
						for (k0 = 0; k0 < npo; k0++)
						{
							for (j0 = 0; j0 < npo; j0++)
							{
								for (i0 = 0; i0 < npo; i0++)
								{
									tmp = cmat[i][i0] * cmat[j][j0] * cmat[k][k0];
									if (tmp != 0.)
									{
										bpenew[loc][0] += tmp*bzcp[tmesh[eid].IENb[loc0]][0];
										bpenew[loc][1] += tmp*bzcp[tmesh[eid].IENb[loc0]][1];
										bpenew[loc][2] += tmp*bzcp[tmesh[eid].IENb[loc0]][2];
									}
									loc0++;
								}
							}
						}
						loc++;
					}
				}
			}
			for (int eid1 = 0; eid1 < 8; eid1++)
			{
				int hxid(8 * eid + eid1);
				hxnew[hxid].bzflag = 1;
				//hxnew[hxid].IENb.resize(64);//not here
				hxnew[hxid].bzpt.resize(64);//need to remove repeated later
				loc = 0;
				for (k = 0; k < 4; k++)
				{
					for (j = 0; j < 4; j++)
					{
						for (i = 0; i < 4; i++)
						{
							loc0 = (stt[eid1][2] + k)*npn*npn + (stt[eid1][1] + j)*npn + (stt[eid1][0] + i);
							hxnew[hxid].bzpt[loc] = bpenew[loc0];
							loc++;
						}
					}
				}
			}
		}
	}

	//clear
	//for (uint i = 0; i < tmface.size(); i++)
	//{
	//	tmface[i].bzid.clear();
	//}
	//for (uint i = 0; i < tmedge.size(); i++)
	//{
	//	tmedge[i].bzid.clear();
	//}
	//for (uint i = 0; i < cp.size(); i++)
	//{
	//	cp[i].bzid = -1;
	//}
}

void TruncatedTspline_3D::FindBezierIEN(const vector<Element3D>& hxnew)
{
	int bzbd[8] = { 21, 22, 26, 25, 37, 38, 42, 41 };
	int bzfc[6][4] = { { 5, 6, 10, 9 }, { 17, 18, 34, 33 }, { 23, 27, 43, 39 }, { 29, 30, 46, 45 }, { 20, 24, 40, 36 }, { 53, 54, 58, 57 } };
	int bzed[12][2] = { { 1, 2 }, { 7, 11 }, { 13, 14 }, { 4, 8 }, { 16, 32 }, { 19, 35 }, { 31, 47 }, { 28, 44 }, { 49, 50 }, { 55, 59 }, { 61, 62 }, { 52, 56 } };
	int bzcn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };

	//initialize, clear bzid
	for (uint i = 0; i < tmface.size(); i++)
	{
		tmface[i].bzid.clear();
	}
	for (uint i = 0; i < tmedge.size(); i++)
	{
		tmedge[i].bzid.clear();
	}
	for (uint i = 0; i < cp.size(); i++)
	{
		cp[i].bzid = -1;
	}
	bzcp.clear();

	for (uint eid = 0; eid < hxnew.size(); eid++)
	{
		tmesh[eid].bzflag = 0;
		tmesh[eid].IENb.clear();
		if (hxnew[eid].bzflag == 1)
		{
			tmesh[eid].bzflag = 1;
			tmesh[eid].IENb.resize(64);
			for (int i = 0; i < 8; i++)//body points
			{
				bzcp.push_back(hxnew[eid].bzpt[bzbd[i]]);
				tmesh[eid].IENb[bzbd[i]] = bzcp.size() - 1;
			}
			for (int i = 0; i < 6; i++)//face points
			{
				if (tmface[tmesh[eid].face[i]].bzid.size() == 0)
				{
					for (int j = 0; j < 4; j++)
					{
						bzcp.push_back(hxnew[eid].bzpt[bzfc[i][j]]);
						tmesh[eid].IENb[bzfc[i][j]] = bzcp.size() - 1;
						tmface[tmesh[eid].face[i]].bzid.push_back(tmesh[eid].IENb[bzfc[i][j]]);
					}
				}
				else
				{
					int fcid(tmesh[eid].face[i]);
					for (int j = 0; j < 4; j++)
					{
						int loc(-1), pfid;
						double tmp;
						for (int k = 0; k < 4; k++)
						{
							pfid = tmface[fcid].bzid[k];
							tmp = (hxnew[eid].bzpt[bzfc[i][j]][0] - bzcp[pfid][0])*(hxnew[eid].bzpt[bzfc[i][j]][0] - bzcp[pfid][0]) +
								(hxnew[eid].bzpt[bzfc[i][j]][1] - bzcp[pfid][1])*(hxnew[eid].bzpt[bzfc[i][j]][1] - bzcp[pfid][1]) +
								(hxnew[eid].bzpt[bzfc[i][j]][2] - bzcp[pfid][2])*(hxnew[eid].bzpt[bzfc[i][j]][2] - bzcp[pfid][2]);
							tmp = sqrt(tmp);
							if (tmp < 1.e-12)
							{
								loc = pfid; break;
							}
						}
						if (loc == -1)
						{
							cerr << "Can't find existing face points in a face!\n"; getchar();
						}
						tmesh[eid].IENb[bzfc[i][j]] = loc;
					}
				}
			}
			for (int i = 0; i < 12; i++)//edge points
			{
				if (tmedge[tmesh[eid].edge[i]].bzid.size() == 0)
				{
					for (int j = 0; j < 2; j++)
					{
						bzcp.push_back(hxnew[eid].bzpt[bzed[i][j]]);
						tmesh[eid].IENb[bzed[i][j]] = bzcp.size() - 1;
						tmedge[tmesh[eid].edge[i]].bzid.push_back(tmesh[eid].IENb[bzed[i][j]]);
					}
				}
				else
				{
					int edid(tmesh[eid].edge[i]);
					for (int j = 0; j < 2; j++)
					{
						int loc(-1), peid;
						double tmp;
						for (int k = 0; k < 2; k++)
						{
							peid = tmedge[edid].bzid[k];
							tmp = (hxnew[eid].bzpt[bzed[i][j]][0] - bzcp[peid][0])*(hxnew[eid].bzpt[bzed[i][j]][0] - bzcp[peid][0]) +
								(hxnew[eid].bzpt[bzed[i][j]][1] - bzcp[peid][1])*(hxnew[eid].bzpt[bzed[i][j]][1] - bzcp[peid][1]) +
								(hxnew[eid].bzpt[bzed[i][j]][2] - bzcp[peid][2])*(hxnew[eid].bzpt[bzed[i][j]][2] - bzcp[peid][2]);
							tmp = sqrt(tmp);
							if (tmp < 1.e-12)
							{
								loc = peid; break;
							}
						}
						if (loc == -1)
						{
							cerr << "Can't find existing edge points in an edge!\n"; getchar();
						}
						tmesh[eid].IENb[bzed[i][j]] = loc;
					}
				}
			}
			for (int i = 0; i < 8; i++)//corner points
			{
				if (cp[tmesh[eid].cnct[i]].bzid == -1)
				{
					bzcp.push_back(hxnew[eid].bzpt[bzcn[i]]);
					tmesh[eid].IENb[bzcn[i]] = bzcp.size() - 1;
					cp[tmesh[eid].cnct[i]].bzid = tmesh[eid].IENb[bzcn[i]];
				}
				else
				{
					tmesh[eid].IENb[bzcn[i]] = cp[tmesh[eid].cnct[i]].bzid;
				}
			}
		}
	}
}

void TruncatedTspline_3D::ClearRefineMemory(vector<Element3D>& hxnew, vector<Face3D>& fcnew, vector<Edge3D>& ednew)
{
	for (uint eid = 0; eid < hxnew.size(); eid++)
	{
		vector<array<double, 3>>().swap(hxnew[eid].bzpt);
	}
}

void TruncatedTspline_3D::BezierExtract_BezierCoupling(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	vector<int> aflag(cp.size(), 0);
	vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < tmesh.size(); i++)
	{
		if (tmesh[i].bzflag == 0)
		{
			for (uint j = 0; j < tmesh[i].IEN.size(); j++)
			{
				aflag[tmesh[i].IEN[j]] = 1;
			}
		}
	}
	for (uint i = 0; i < cp.size(); i++)
	{
		if (aflag[i] == 1)
		{
			aloc[i] = count++;
		}
	}
	IDBC.clear();
	IDBC.resize(count + bzcp.size());
	for (uint i = 0; i < IDBC.size(); i++)
	{
		IDBC[i] = i;//boundary weakly imposed
	}
	gh.clear();
	gh.resize(IDBC.size());//initial guess for iterative solvers
	count = 0;
	//double xcoor[3];
	array<double, 3> xcoor;
	for (uint i = 0; i < cp.size(); i++)
	{
		if (aflag[i] == 1)
		{
			xcoor[0] = cp[i].coor[0];
			xcoor[1] = cp[i].coor[1];
			xcoor[2] = cp[i].coor[2];
			//gh[count] = SpecifyDirichBC(xcoor);
			gh[count] = exact_sol(xcoor);
			count++;
		}
	}
	for (uint i = 0; i < bzcp.size(); i++)
	{
		gh[count + i] = SpecifyDirichBC(bzcp[i].data());
	}

	cout << "Bezier extracting...\n";
	cout << "# Bezier: " << tmesh.size() << "\n";
	bzmesh.resize(tmesh.size());
#pragma omp parallel for
	for (int eid = 0; eid < tmesh.size(); eid++)
	{
		if (eid != 0 && eid % 500 == 0)
		{
			cout << eid << " ";
		}
		//find types of interfaces
		if (tmesh[eid].bzflag == 1)
		{
			for (int k = 0; k < 6; k++)
			{
				if (tmface[tmesh[eid].face[k]].hex.size() == 1)//must be a boundary element
				{
					bzmesh[eid].bc[k] = 1;//boundary face for boundary condition
					bzmesh[eid].bcflag = 1;
				}
				else if (tmface[tmesh[eid].face[k]].hex.size() == 2)
				{
					int hxnb(tmface[tmesh[eid].face[k]].hex[0]);
					if (hxnb == eid) hxnb = tmface[tmesh[eid].face[k]].hex[1];
					if (tmesh[hxnb].bzflag == 0)
					{
						bzmesh[eid].bc[k] = 2;//coupling interface
						bzmesh[eid].bzcouple = 1;
					}
				}
			}
		}
		
		double tmp;
		bzmesh[eid].type = tmesh[eid].type;//used for visualization
		bzmesh[eid].bzflag = tmesh[eid].bzflag;
		if (bzmesh[eid].bzcouple == 0)
		{
			if (tmesh[eid].bzflag == 0)
			{
				bzmesh[eid].IEN.resize(tmesh[eid].IEN.size());
				bzmesh[eid].cmat.resize(tmesh[eid].IEN.size(), vector<double>(64));
				for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
				{
					bzmesh[eid].IEN[k] = aloc[tmesh[eid].IEN[k]];//some IEN may be -1
					for (int k1 = 0; k1 < 64; k1++)
					{
						tmp = tmesh[eid].bemat[k][k1];
						bzmesh[eid].cmat[k][k1] = tmp;
						bzmesh[eid].pts[k1][0] += tmp * cp[tmesh[eid].IEN[k]].coor[0];
						bzmesh[eid].pts[k1][1] += tmp * cp[tmesh[eid].IEN[k]].coor[1];
						bzmesh[eid].pts[k1][2] += tmp * cp[tmesh[eid].IEN[k]].coor[2];
					}
				}
			}
			else
			{
				bzmesh[eid].IENb.resize(tmesh[eid].IENb.size());//64
				for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
				{
					bzmesh[eid].IENb[k] = tmesh[eid].IENb[k] + count;
					bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
					bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
					bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
				}
			}
		}
		else//bzflag must be 1
		{
			bzmesh[eid].IEN.resize(tmesh[eid].IEN.size());
			bzmesh[eid].cmat.resize(tmesh[eid].IEN.size(), vector<double>(64));			
			for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
			{
				bzmesh[eid].IEN[k] = aloc[tmesh[eid].IEN[k]];
				for (int k1 = 0; k1 < 64; k1++)
				{
					bzmesh[eid].cmat[k][k1] = tmesh[eid].bemat[k][k1];
				}
			}
			bzmesh[eid].IENb.resize(tmesh[eid].IENb.size());
			for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
			{
				bzmesh[eid].IENb[k] = tmesh[eid].IENb[k] + count;
				bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
				bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
				bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
			}
		}
	}
}

void TruncatedTspline_3D::RescaleDomain()
{
	double tmp(1.e6);
	double x_range[3][2] = { { tmp, -tmp }, { tmp, -tmp }, { tmp, -tmp } };
	uint i, j;
	for (i = 0; i <cp.size(); i++)
	{
		for (j = 0; j < 3; j++)
		{
			if (cp[i].coor[j] < x_range[j][0]) x_range[j][0] = cp[i].coor[j];
			if (cp[i].coor[j] > x_range[j][1]) x_range[j][1] = cp[i].coor[j];
		}
	}
	double xh[3] = { x_range[0][1] - x_range[0][0], x_range[1][1] - x_range[1][0], x_range[2][1] - x_range[2][0] };
	double dim_min(1.e6);
	for (i = 0; i < 3; i++)
	{
		if (xh[i] < dim_min) dim_min = xh[i];
	}
	//xh[0] /= dim_min; xh[1] /= dim_min; xh[2] /= dim_min;

	for (i = 0; i <cp.size(); i++)
	{
		for (j = 0; j < 3; j++)
		{
			//cp[i].coor[j] = (cp[i].coor[j] - x_range[j][0]) / xh[j];
			cp[i].coor[j] = (cp[i].coor[j] - x_range[j][0]) / dim_min;
		}
	}
}

void TruncatedTspline_3D::ReportDiffEleNumber()
{
	uint n0(0), n1(0);
	for (uint i = 0; i < tmesh.size(); i++)
	{
		if (tmesh[i].type == 0)
		{
			n0++;
			//tmesh[i].type = 2;//for test
		}
		else
		{
			n1++;
		}
	}
	cout << "# regular eles: " << n0 << " " << double(n0) / double(n0 + n1) << "\n";
	cout << "# irregular el: " << n1 << " " << double(n1) / double(n0 + n1) << "\n";
	//getchar();

	//int pid(903);
	//cout << "type: " << cp[pid].type << "\n";
	//cout << "# neighbor edges: " << cp[pid].edge.size() << "\n";
	//for (uint i = 0; i < cp[pid].edge.size(); i++)
	//{
	//	cout << "edge id: " << i << "  # nhex: " << tmedge[cp[pid].edge[i]].hex.size() << "\n";
	//}
	//cout << "# neighbor hexes: " << cp[pid].hex.size() << "\n";
	//for (uint i = 0; i < cp[pid].hex.size(); i++)
	//{
	//	cout << "hex id: " << i << "  hex type: " << tmesh[cp[pid].hex[i]].type << "\n";
	//}
	//getchar();
}






void TruncatedTspline_3D::Run_Coupling_Comp(string fn, int ngrf, int nlrf, vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	//InitializeMesh(fn);
	//SetSharpFeature_1(0.7);

	char *buffer = strdup(fn.c_str());
	char *fn_wo_filespec_char = buffer;
	PathRemoveFileSpecA(fn_wo_filespec_char);
	stringstream ss_in, ss_out;
	string fld;
	ss_in << fn_wo_filespec_char;
	ss_in >> fld;

	string fn_out;
	ss_out << fn << "_gref_lev" << ngrf << "_lref_lev" << nlrf;
	ss_out >> fn_out;

	
	for (int i = 0; i < ngrf; i++)
	{
		//Global_Subdivide_wBezier();
		Global_Subdivide();
		//Global_Subdivide_Simple();
		//ProjectBoundary();//not available
	}

	if (nlrf == 0)
	{
		BuildSplines_Unstruct();
		BezierExtract_Comp(bzmesh, IDBC, gh);
	}
	else
	{
		for (int i = 0; i < nlrf; i++)
		{

			stringstream ss;
			ss << i + 1;
			cout << bzmesh.size() << endl;
			//if (i < nlrf)
			{
				cout << i << " refining...\n";
				vector<array<int, 2>> rfid, gst;


				//cout << fld<<endl;
				InputRefineID_Manual(fld + "\\lev" + ss.str(), rfid, gst);
				Refine(rfid, gst);

				cout << "Refining done\n";

				cout << "hmesh size: " << hmesh.size() << endl;
				for (int j = 0; j < hmesh.size(); j++)
				{
					stringstream ss_meshlev;
					ss_meshlev << j;
					OutputCM(j, fn_out + "_hmesh" + ss_meshlev.str());
				}
			}		
		}
		AnalysisInterface_Poisson_1(bzmesh, IDBC, gh);
	}
	
	

	//PatchTest_BC(IDBC, gh);
	//UserDefineIDBC(IDBC, gh);//fertility

	//StrongDirichletBC_Elasticity(bzmesh, IDBC, gh);
	//StrongDirichletBC_Elasticity_FromFile(bzmesh, IDBC, gh);
	//StrongDirichletBC_Elasticity_PID(bzmesh, IDBC, gh);
	//StrongDirichletBC_Elasticity_EID(bzmesh, IDBC, gh);
	//StrongDirichletBC_Elasticity_Coor(bzmesh, IDBC, gh);
}

void TruncatedTspline_3D::BezierExtract_Comp(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	vector<int> aflag(cp.size(), 0);
	vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < tmesh.size(); i++)
	{
		if (tmesh[i].bzflag == 0)
		{
			for (uint j = 0; j < tmesh[i].IEN.size(); j++)
			{
				aflag[tmesh[i].IEN[j]] = 1;
			}
		}
		else
		{
			cerr << "Wrong: bzflag is 1 in the comparison case!\n"; getchar();
		}
	}
	for (uint i = 0; i < cp.size(); i++)
	{
		if (aflag[i] == 1)
		{
			aloc[i] = count++;
		}
	}
	cpa.clear();
	cpa.resize(count);
	count = 0;
	for (uint i = 0; i < cp.size(); i++)
	{
		if (aflag[i] == 1)
		{
			cpa[count][0] = cp[i].coor[0];
			cpa[count][1] = cp[i].coor[1];
			cpa[count][2] = cp[i].coor[2];
			count++;
		}
	}

	IDBC.clear();
	IDBC.resize(count + bzcp.size());//bzcp.size()==0
	for (uint i = 0; i < IDBC.size(); i++)
	{
		IDBC[i] = i;//boundary weakly imposed
	}
	gh.clear();
	gh.resize(IDBC.size());//initial guess for iterative solvers
	count = 0;
	//double xcoor[3];
	array<double, 3> xcoor;
	for (uint i = 0; i < cp.size(); i++)
	{
		if (aflag[i] == 1)
		{
			xcoor[0] = cp[i].coor[0];
			xcoor[1] = cp[i].coor[1];
			xcoor[2] = cp[i].coor[2];
			//gh[count] = SpecifyDirichBC(xcoor);
			gh[count] = exact_sol(xcoor);
			count++;
		}
	}
	for (uint i = 0; i < bzcp.size(); i++)
	{
		//gh[count + i] = SpecifyDirichBC(bzcp[i].data());
		gh[count + i] = exact_sol(bzcp[i]);
	}

	cout << "Bezier extracting...\n";
	cout << "# Bezier: " << tmesh.size() << "\n";
	bzmesh.resize(tmesh.size());
#pragma omp parallel for
	for (int eid = 0; eid < tmesh.size(); eid++)
	{
		if (eid != 0 && eid % 500 == 0)
		{
			cout << eid << " ";
		}
		//find types of interfaces
		//if (tmesh[eid].bzflag == 1)
		if (tmesh[eid].bzflag == 0)
		{
			for (int k = 0; k < 6; k++)
			{
				if (tmface[tmesh[eid].face[k]].hex.size() == 1)//must be a boundary element
				{
					bzmesh[eid].bc[k] = 1;//boundary face for boundary condition
					//bzmesh[eid].bcflag = 1;
				}
				//else if (tmface[tmesh[eid].face[k]].hex.size() == 2)
				//{
				//	int hxnb(tmface[tmesh[eid].face[k]].hex[0]);
				//	if (hxnb == eid) hxnb = tmface[tmesh[eid].face[k]].hex[1];
				//	if (tmesh[hxnb].bzflag == 0)
				//	{
				//		bzmesh[eid].bc[k] = 2;//coupling interface
				//		bzmesh[eid].bzcouple = 1;
				//	}
				//}
			}
		}

		double tmp;
		bzmesh[eid].type = tmesh[eid].type;//used for visualization
		bzmesh[eid].bzflag = tmesh[eid].bzflag;
		if (bzmesh[eid].bzcouple == 0)
		{
			if (tmesh[eid].bzflag == 0)
			{
				bzmesh[eid].IEN.resize(tmesh[eid].IEN.size());
				bzmesh[eid].cmat.resize(tmesh[eid].IEN.size(), vector<double>(64));
				for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
				{
					bzmesh[eid].IEN[k] = aloc[tmesh[eid].IEN[k]];//some IEN may be -1
					for (int k1 = 0; k1 < 64; k1++)
					{
						tmp = tmesh[eid].bemat[k][k1];
						bzmesh[eid].cmat[k][k1] = tmp;
						bzmesh[eid].pts[k1][0] += tmp * cp[tmesh[eid].IEN[k]].coor[0];
						bzmesh[eid].pts[k1][1] += tmp * cp[tmesh[eid].IEN[k]].coor[1];
						bzmesh[eid].pts[k1][2] += tmp * cp[tmesh[eid].IEN[k]].coor[2];
					}
				}
			}
			else
			{
				bzmesh[eid].IENb.resize(tmesh[eid].IENb.size());//64
				for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
				{
					bzmesh[eid].IENb[k] = tmesh[eid].IENb[k] + count;
					bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
					bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
					bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
				}
			}
		}
		else//bzflag must be 1
		{
			bzmesh[eid].IEN.resize(tmesh[eid].IEN.size());
			bzmesh[eid].cmat.resize(tmesh[eid].IEN.size(), vector<double>(64));
			for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
			{
				bzmesh[eid].IEN[k] = aloc[tmesh[eid].IEN[k]];
				for (int k1 = 0; k1 < 64; k1++)
				{
					bzmesh[eid].cmat[k][k1] = tmesh[eid].bemat[k][k1];
				}
			}
			bzmesh[eid].IENb.resize(tmesh[eid].IENb.size());
			for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
			{
				bzmesh[eid].IENb[k] = tmesh[eid].IENb[k] + count;
				bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
				bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
				bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
			}
		}
	}
}

void TruncatedTspline_3D::BezierExtract_Comp_Fitting(vector<BezierElement3D>& bzmesh, vector<int>& IDBC)
{
	//fitting all boundary points
	IDBC.clear();
	IDBC.resize(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].type == 1)//boundary
		{
			IDBC[i] = count++;
		}
	}

	count = 0;
	cout << "Bezier extracting...\n";
	cout << "# Bezier: " << tmesh.size() << "\n";
	bzmesh.resize(tmesh.size());
#pragma omp parallel for
	for (int eid = 0; eid < tmesh.size(); eid++)
	{
		if (eid != 0 && eid % 500 == 0)
		{
			cout << eid << " ";
		}
		if (tmesh[eid].type == 1)//boundary element
		{
			for (int k = 0; k < 6; k++)
			{
				if (tmface[tmesh[eid].face[k]].hex.size() == 1)//must be a boundary element
				{
					bzmesh[eid].bc[k] = 1;//boundary face for boundary condition
				}
			}
		}
		double tmp;
		bzmesh[eid].type = tmesh[eid].type;//used for visualization
		bzmesh[eid].bzflag = tmesh[eid].bzflag;//==0
		//if (bzmesh[eid].bzcouple == 0)
		{
			//if (tmesh[eid].bzflag == 0)
			{
				bzmesh[eid].IEN.resize(tmesh[eid].IEN.size());
				bzmesh[eid].cmat.resize(tmesh[eid].IEN.size(), vector<double>(64));
				for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
				{
					bzmesh[eid].IEN[k] = tmesh[eid].IEN[k];
					for (int k1 = 0; k1 < 64; k1++)
					{
						tmp = tmesh[eid].bemat[k][k1];
						bzmesh[eid].cmat[k][k1] = tmp;
						bzmesh[eid].pts[k1][0] += tmp * cp[tmesh[eid].IEN[k]].coor[0];
						bzmesh[eid].pts[k1][1] += tmp * cp[tmesh[eid].IEN[k]].coor[1];
						bzmesh[eid].pts[k1][2] += tmp * cp[tmesh[eid].IEN[k]].coor[2];
					}
				}
				bzmesh[eid].cnpt.resize(8);
				for (int k = 0; k < 8; k++)
				{
					bzmesh[eid].cnpt[k][0] = cp[tmesh[eid].cnct[k]].coor[0];
					bzmesh[eid].cnpt[k][1] = cp[tmesh[eid].cnct[k]].coor[1];
					bzmesh[eid].cnpt[k][2] = cp[tmesh[eid].cnct[k]].coor[2];
				}
			}
			//else
			//{
			//	bzmesh[eid].IENb.resize(tmesh[eid].IENb.size());//64
			//	for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
			//	{
			//		bzmesh[eid].IENb[k] = tmesh[eid].IENb[k] + count;
			//		bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
			//		bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
			//		bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
			//	}
			//}
		}
		//else//bzflag must be 1
		//{
		//	bzmesh[eid].IEN.resize(tmesh[eid].IEN.size());
		//	bzmesh[eid].cmat.resize(tmesh[eid].IEN.size(), vector<double>(64));
		//	for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
		//	{
		//		bzmesh[eid].IEN[k] = aloc[tmesh[eid].IEN[k]];
		//		for (int k1 = 0; k1 < 64; k1++)
		//		{
		//			bzmesh[eid].cmat[k][k1] = tmesh[eid].bemat[k][k1];
		//		}
		//	}
		//	bzmesh[eid].IENb.resize(tmesh[eid].IENb.size());
		//	for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
		//	{
		//		bzmesh[eid].IENb[k] = tmesh[eid].IENb[k] + count;
		//		bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
		//		bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
		//		bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
		//	}
		//}
	}
}

void TruncatedTspline_3D::Fitting2InptHex(string fn_in, string fn_out)
{
	InitializeMesh(fn_in);
	BuildSplines_Unstruct();
	
	//vector<BezierElement3D> bzmesh;
	//vector<int> IDBC;
	//BezierExtract_Comp_Fitting(bzmesh, IDBC);

	//LeastSquare ls;
	//vector<array<double, 3>> sol;
	//ls.SetProblem_SurfaceFitting(IDBC);
	//ls.Run_SurfaceFitting(bzmesh, "", sol);

	//for (uint i = 0; i < cp.size(); i++)
	//{
	//	if (cp[i].type == 1)
	//	{
	//		cp[i].coor[0] = sol[i][0];
	//		cp[i].coor[1] = sol[i][1];
	//		cp[i].coor[2] = sol[i][2];
	//		//cout << "before: " << cp[i].coor[0] << " " << cp[i].coor[1] << " " << cp[i].coor[2] << "\n";
	//		//cout << "after: " << sol[i][0] << " " << sol[i][1] << " " << sol[i][2] << "\n";
	//		//getchar();
	//	}
	//}

	//OutputCM("../io/hex_out/heli_loc");
	//cout << "Done output CM\n";
	//getchar();
	////OutputGeom_C0C1("../io/geom/heli_coarse");
}

void TruncatedTspline_3D::Run_Coupling_Comp_Fit(string fn, int nrf, vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	Fitting2InptHex(fn, "");
	//Smoothing(100, 0.5);
	//getchar();
	for (int i = 0; i < nrf; i++)
	{
		//Global_Subdivide_wBezier();
		Global_Subdivide();
	}
	BuildSplines_Unstruct();
	BezierExtract_Comp(bzmesh, IDBC, gh);

	//PatchTest_BC(IDBC, gh);
	//UserDefineIDBC(IDBC, gh);//fertility

	//StrongDirichletBC_Elasticity(bzmesh, IDBC, gh);
	//StrongDirichletBC_Elasticity_FromFile(bzmesh, IDBC, gh);
	//StrongDirichletBC_Elasticity_PID(bzmesh, IDBC, gh);
	//StrongDirichletBC_Elasticity_EID(bzmesh, IDBC, gh);
	StrongDirichletBC_Elasticity_Coor(bzmesh, IDBC, gh);
}


//adaptive analysis
void TruncatedTspline_3D::Initialize_AdaptFit(string fn)
{
	//Fitting2InptHex(fn, "");//not good

	InitializeMesh(fn);
	BuildSplines_Unstruct();

	hmesh.push_back(tmesh);
	hcp.push_back(cp);
	hface.push_back(tmface);
	hedge.push_back(tmedge);

	//ReportXP();

	//AllBezierLev(0);

	//BezierPoints_ini();//represent geometry using initial control points and blending functions

	SetSupport(0);
}

void TruncatedTspline_3D::BezierExtract_AdaptFit(vector<BezierElement3D>& bzmesh)
{
	int loc(0);
	vector<vector<int>> aloc(hcp.size());
	for (uint i = 0; i < hcp.size(); i++)
	{
		aloc[i].resize(hcp[i].size(), -1);
		for (uint j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				aloc[i][j] = loc++;
			}
		}
	}

	cout << "Bezier extracting...\n";
	//cout << "# Bezier: " << hmesh[0].size() << "\n";
	vector<array<int, 2>> eact;
	for (uint i = 0; i < hmesh.size(); i++)
	{
		for (uint j = 0; j < hmesh[i].size(); j++)
		{
			if (hmesh[i][j].act == 1)
			{
				array<int, 2> tmp = { i, j };
				eact.push_back(tmp);
			}
		}
	}
	bzmesh.resize(eact.size());

#pragma omp parallel for
	for (int eid = 0; eid < eact.size(); eid++)
	{
		int i(eact[eid][0]), j(eact[eid][1]);
		//if (hmesh[i][j].act == 1)
		{
			if (eid != 0 && eid % 500 == 0)
			{
				cout << eid << " ";
			}
			double tmp;
			bzmesh[eid].prt[0] = i; bzmesh[eid].prt[1] = j;
			bzmesh[eid].trun = hmesh[i][j].trun;//useful when writing Bezier format later
			if (hmesh[i][j].type == 1) bzmesh[eid].type = 1;//visualization
			bzmesh[eid].pts.clear();
			//for (int k1 = 0; k1 < 64; k1++)
			//{
			//	bzmesh[eid].pts[k1][0] = hmesh[i][j].bzpt[k1][0];
			//	bzmesh[eid].pts[k1][1] = hmesh[i][j].bzpt[k1][1];
			//	bzmesh[eid].pts[k1][2] = hmesh[i][j].bzpt[k1][2];
			//}
			if (hmesh[i][j].trun == 0)
			{
				bzmesh[eid].IEN.resize(hmesh[i][j].IEN.size());
				bzmesh[eid].cmat.resize(hmesh[i][j].IEN.size(), vector<double>(64));
				bzmesh[eid].pts.resize(hmesh[i][j].IEN.size());
				for (uint k = 0; k < hmesh[i][j].IEN.size(); k++)
				{
					bzmesh[eid].IEN[k] = aloc[i][hmesh[i][j].IEN[k]];
					bzmesh[eid].pts[k][0] = hcp[i][hmesh[i][j].IEN[k]].coor[0];
					bzmesh[eid].pts[k][1] = hcp[i][hmesh[i][j].IEN[k]].coor[1];
					bzmesh[eid].pts[k][2] = hcp[i][hmesh[i][j].IEN[k]].coor[2];
					for (int k1 = 0; k1 < 64; k1++)
					{
						tmp = hmesh[i][j].bemat[k][k1];
						bzmesh[eid].cmat[k][k1] = tmp;
						//bzmesh[eid].pts[k1][0] += tmp * hcp[i][hmesh[i][j].IEN[k]].coor[0];
						//bzmesh[eid].pts[k1][1] += tmp * hcp[i][hmesh[i][j].IEN[k]].coor[1];
						//bzmesh[eid].pts[k1][2] += tmp * hcp[i][hmesh[i][j].IEN[k]].coor[2];
					}
				}
			}
			else
			{
				bzmesh[eid].IEN.resize(hmesh[i][j].IEN_act.size());
				bzmesh[eid].cmat.resize(hmesh[i][j].IEN_act.size(), vector<double>(64));
				bzmesh[eid].pts.resize(hmesh[i][j].IEN_act.size());
				for (int k = 0; k < hmesh[i][j].IEN_act.size(); k++)
				{
					int lev(hmesh[i][j].IEN_act[k][0]);
					int pid(hmesh[i][j].IEN_act[k][1]);
					if (aloc[lev][pid] == -1)
					{
						cout << "wrong aloc!\n";
						getchar();
					}
					bzmesh[eid].IEN[k] = aloc[lev][pid];
					bzmesh[eid].pts[k][0] = hcp[lev][pid].coor[0];
					bzmesh[eid].pts[k][1] = hcp[lev][pid].coor[1];
					bzmesh[eid].pts[k][2] = hcp[lev][pid].coor[2];
					for (int k1 = 0; k1 < 64; k1++)
					{
						bzmesh[eid].cmat[k][k1] = 0.;
						for (int k2 = 0; k2 < hmesh[i][j].IEN.size(); k2++)
						{
							bzmesh[eid].cmat[k][k1] += hmesh[i][j].tmat[k][k2] * hmesh[i][j].bemat[k2][k1];
						}
					}
				}
				for (int k = 0; k < hmesh[i][j].IEN.size(); k++)
				{
					for (int k1 = 0; k1 < 64; k1++)
					{
						tmp = hmesh[i][j].bemat[k][k1];
						//bzmesh[eid].pts[k1][0] += tmp * hcp[i][hmesh[i][j].IEN[k]].coor[0];
						//bzmesh[eid].pts[k1][1] += tmp * hcp[i][hmesh[i][j].IEN[k]].coor[1];
						//bzmesh[eid].pts[k1][2] += tmp * hcp[i][hmesh[i][j].IEN[k]].coor[2];
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::StrongDirichletBC_Elasticity_AdaptFit(vector<int>& IDBC, vector<double>& gh)
{
	vector<array<int, 2>> pact;
	for (uint i = 0; i < hcp.size(); i++)
	{
		for (uint j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				array<int, 2> itmp = { i,j };
				pact.push_back(itmp);
			}
		}
	}

	//double ux0(2.6388e-5), uy0(2.7166), ux1(5.90525);//heli
	//double tol[3] = { 0.000619612,0.000578553,0.000188722 };
	//double sfac(2.);
	//tol[0] *= sfac; tol[1] *= sfac; tol[2] *= sfac;

	//double ux0(0.), uy0(0.), uz0(0.), ux1(1.);//unit cube
	//double tol[4] = { 1.e-8,1.e-8,1.e-8,1.e-8 };

	//IDBC.clear();
	//IDBC.resize(3 * pact.size(), -1);
	//gh.clear();
	//gh.resize(IDBC.size(), 0.);

	//int count(0);
	//for (uint i = 0; i < pact.size(); i++)
	//{
	//	if (hcp[pact[i][0]][pact[i][1]].type == 1)
	//	{
	//		for (int idof = 0; idof < 3; idof++)
	//		{
	//			if (idof == 0 && fabs(hcp[pact[i][0]][pact[i][1]].coor[idof] - ux0) < tol[0])
	//			{
	//				gh[3 * i + idof] = 0.;
	//			}
	//			else if (idof == 1 && fabs(hcp[pact[i][0]][pact[i][1]].coor[idof] - uy0) < tol[1])
	//			{
	//				gh[3 * i + idof] = 0.;
	//			}
	//			else if (idof == 2 && fabs(hcp[pact[i][0]][pact[i][1]].coor[idof] - uz0) < tol[2])//only for cube
	//			{
	//				gh[3 * i + idof] = 0.;
	//			}
	//			else if (idof == 0 && fabs(hcp[pact[i][0]][pact[i][1]].coor[idof] - ux1) < tol[2])
	//			{
	//				gh[3 * i + idof] = 0.01;
	//			}
	//			else
	//			{
	//				IDBC[3 * i + idof] = count++;
	//			}
	//		}
	//	}
	//	else
	//	{
	//		for (int idof = 0; idof < 3; idof++)
	//		{
	//			IDBC[3 * i + idof] = count++;
	//		}
	//	}
	//}


	double uy0(0.), uy1(-25.4), ux0(0.);//navair coarse
	double tol[2] = { 1.e-6,1.e-6 };
	IDBC.clear();
	IDBC.resize(3 * pact.size(), -1);
	gh.clear();
	gh.resize(IDBC.size(), 0.);

	int count(0);
	for (uint i = 0; i < pact.size(); i++)
	{
		if (hcp[pact[i][0]][pact[i][1]].type == 1)
		{
			for (int idof = 0; idof < 3; idof++)
			{
				if (idof == 0 && fabs(hcp[pact[i][0]][pact[i][1]].coor[idof] - ux0) < tol[0])
				{
					gh[3 * i + idof] = 0.;
				}
				else if (idof == 1 && fabs(hcp[pact[i][0]][pact[i][1]].coor[idof] - uy0) < tol[1])
				{
					gh[3 * i + idof] = 0.;
				}
				else if (idof == 1 && fabs(hcp[pact[i][0]][pact[i][1]].coor[idof] - uy1) < tol[1])
				{
					gh[3 * i + idof] = -0.1;
				}
				else
				{
					IDBC[3 * i + idof] = count++;
				}
			}
		}
		else
		{
			for (int idof = 0; idof < 3; idof++)
			{
				IDBC[3 * i + idof] = count++;
			}
		}
	}
}

void TruncatedTspline_3D::StrongDirichletBC_Elasticity_PID_Adapt(string fn, vector<int>& IDBC, vector<double>& gh)
{
	//string fn("../io/le_adapt/honda1/bc");
	int nbc(2);
	vector<vector<int>> pid;
	vector<array<int, 3>> bc_dof;
	vector<array<double, 3>> bc_disp;
	ReadBC_PID(fn, nbc, pid, bc_dof, bc_disp);

	vector<vector<int>> bcflag(hcp.size());
	for (uint i = 0; i < hcp.size(); i++)
	{
		bcflag[i].resize(3 * hcp[i].size(), 0);
	}
	for (uint i = 0; i < pid.size(); i++)//nbc
	{
		for (int idof = 0; idof < 3; idof++)
		{
			if (bc_dof[i][idof] == 1)
			{
				for (uint j = 0; j < pid[i].size(); j++)
				{
					bcflag[0][3 * pid[i][j] + idof] = i + 1;
				}
			}
		}
	}

	int count(0);
	for (uint i = 0; i < hcp.size(); i++)
	{
		for (uint j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				count++;
			}
		}
	}

	IDBC.clear();
	IDBC.resize(3 * count, -1);
	gh.clear();
	gh.resize(IDBC.size(), 0.);
	int aloc(0);
	count = 0;
	for (uint i = 0; i < hcp.size(); i++)
	{
		for (uint j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				for (int idof = 0; idof < 3; idof++)
				{
					if (bcflag[i][3 * j + idof] == 1)
					{
						gh[3 * aloc + idof] = 0.;
					}
					else if (bcflag[i][3 * j + idof] == 2)
					{
						gh[3 * aloc + idof] = 0.1;
					}
					else
					{
						IDBC[3 * aloc + idof] = count++;
					}
				}
				aloc++;
			}
		}
	}
}


void TruncatedTspline_3D::Identify_Elasticity_AdaptFit(const vector<array<double, 2>>& eh, const vector<double>& vs, 
	vector<array<int, 2>>& rfid, vector<array<int, 2>>& gst)
{
	uint i, j, k;
	double vsmax(0.);
	for (i = 0; i < vs.size(); i++)
	{
		if (vs[i] > vsmax) vsmax = vs[i];
	}

	double eta(0.8);//heli
	double tol(eta*vsmax);
	vector<array<int, 2>> rf_pid;
	for (i = 0; i < vs.size(); i++)
	{
		if (vs[i] > tol)
		{
			for (j = 0; j < 8; j++)
			{
				array<int, 2> rftmp = { eh[i][0],hmesh[eh[i][0]][eh[i][1]].cnct[j] };
				if (hcp[rftmp[0]][rftmp[1]].act == 1)
				{
					rf_pid.push_back(rftmp);
				}
			}
		}
	}

	//for (i = 0; i < hcp.size(); i++)
	//{
	//	for (j = 0; j < hcp[i].size(); j++)
	//	{
	//		if (hcp[i][j].act == 1 && fabs(hcp[i][j].coor[0]) < 1.e-8)
	//		{
	//			array<int, 2> rftmp = { i,j };
	//			rf_pid.push_back(rftmp);
	//		}
	//	}
	//}

	rfid.clear();
	gst.clear();
	for (i = 0; i < rf_pid.size(); i++)
	{
		//check support, refine 1-ring as long as 1-ring elements are at the same level
		int ring1(0);
		for (j = 0; j < hcp[rf_pid[i][0]][rf_pid[i][1]].hex.size(); j++)
		{
			if (hmesh[rf_pid[i][0]][hcp[rf_pid[i][0]][rf_pid[i][1]].hex[j]].act == 1)
			{
				ring1 = 1;
				array<int, 2> tmp = { rf_pid[i][0], hcp[rf_pid[i][0]][rf_pid[i][1]].hex[j] };
				vector<array<int, 2>>::iterator it = find(rfid.begin(), rfid.end(), tmp);
				if (it == rfid.end())
					rfid.push_back(tmp);
			}
		}
		if (ring1 == 0)//new
		{
			for (j = 0; j < hcp[rf_pid[i][0]][rf_pid[i][1]].supp.size(); j++)
			{
				if (hmesh[rf_pid[i][0]][hcp[rf_pid[i][0]][rf_pid[i][1]].supp[j]].act == 1)
				{
					array<int, 2> tmp = { rf_pid[i][0], hcp[rf_pid[i][0]][rf_pid[i][1]].supp[j] };
					vector<array<int, 2>>::iterator it = find(rfid.begin(), rfid.end(), tmp);
					if (it == rfid.end())
						rfid.push_back(tmp);
				}
			}
		}
	}
	//cout << "Max error: "<< err_max << "\n";
	//cout << "# of pid: " << rf_pid.size() << "\n";
	cout << "# of rfid: " << rfid.size() << "\n";
	//getchar();
	for (i = 0; i < rfid.size(); i++)
	{
		int lev(rfid[i][0]);
		for (j = 0; j < 8; j++)
		{
			int pt(hmesh[lev][rfid[i][1]].cnct[j]);
			for (k = 0; k < hcp[lev][pt].hex.size(); k++)
			{
				if (hmesh[lev][hcp[lev][pt].hex[k]].chd.size() == 0)
				{
					array<int, 2> tmp = { lev, hcp[lev][pt].hex[k] };
					vector<array<int, 2>>::iterator it1 = find(gst.begin(), gst.end(), tmp);
					vector<array<int, 2>>::iterator it2 = find(rfid.begin(), rfid.end(), tmp);
					if (it1 == gst.end() && it2 == rfid.end())
					{
						gst.push_back(tmp);
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::Identify_Refine_Test(vector<array<int, 2>>& rfid, vector<array<int, 2>>& gst)
{
	rfid.clear();
	gst.clear();

	uint i, j, k;
	//cube
	for (i = 0; i < hmesh.size(); i++)
	{
		for (j = 0; j < hmesh[i].size(); j++)
		{
			for (k = 0; k < 8; k++)
			{
				if (hcp[i][hmesh[i][j].cnct[k]].coor[0] < 1.e-8)
				{
					array<int, 2> tmp = { i,j };
					rfid.push_back(tmp);
					break;
				}
			}
		}
	}

	for (i = 0; i < rfid.size(); i++)
	{
		int lev(rfid[i][0]);
		for (j = 0; j < 8; j++)
		{
			int pt(hmesh[lev][rfid[i][1]].cnct[j]);
			for (k = 0; k < hcp[lev][pt].hex.size(); k++)
			{
				if (hmesh[lev][hcp[lev][pt].hex[k]].chd.size() == 0)
				{
					array<int, 2> tmp = { lev, hcp[lev][pt].hex[k] };
					vector<array<int, 2>>::iterator it1 = find(gst.begin(), gst.end(), tmp);
					vector<array<int, 2>>::iterator it2 = find(rfid.begin(), rfid.end(), tmp);
					if (it1 == gst.end() && it2 == rfid.end())
					{
						gst.push_back(tmp);
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::Identify_BadElement(vector<array<int, 2>>& rfid, vector<array<int, 2>>& gst)
{
	rfid.clear();
	gst.clear();

	uint i, j, k;
	double minJacob_glb;
	array<int,2> min_pos;
	vector<array<int, 2>> BadEle;
	GlobalMinJacob_Adapt(minJacob_glb, min_pos, BadEle);

	for (i = 0; i < hcp.size(); i++)
	{
		for (j = 0; j < hcp[i].size(); j++)
		{
			hcp[i][j].smth = 0;
		}
	}
	for (i = 0; i < hmesh.size(); i++)
	{
		for (j = 0; j < hmesh[i].size(); j++)
		{
			hmesh[i][j].smth = 0;
		}
	}
	for (i = 0; i < BadEle.size(); i++)
	{
		for (int k = 0; k < 8; k++)
		{
			hcp[BadEle[i][0]][hmesh[BadEle[i][0]][BadEle[i][1]].cnct[k]].smth = 1;
		}
	}
	for (i = 0; i < hcp.size(); i++)
	{
		for (j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].smth == 1)
			{
				for (k = 0; k < hcp[i][j].hex.size(); k++)
				{
					hmesh[i][hcp[i][j].hex[k]].smth = 1;
				}
			}
		}
	}
	for (i = 0; i < hmesh.size(); i++)
	{
		for (j = 0; j < hmesh[i].size(); j++)
		{
			if (hmesh[i][j].smth == 1)
			{
				array<int, 2> itmp = { i,j };
				rfid.push_back(itmp);
			}
		}
	}

	for (i = 0; i < rfid.size(); i++)
	{
		int lev(rfid[i][0]);
		for (j = 0; j < 8; j++)
		{
			int pt(hmesh[lev][rfid[i][1]].cnct[j]);
			for (k = 0; k < hcp[lev][pt].hex.size(); k++)
			{
				if (hmesh[lev][hcp[lev][pt].hex[k]].chd.size() == 0)
				{
					array<int, 2> tmp = { lev, hcp[lev][pt].hex[k] };
					vector<array<int, 2>>::iterator it1 = find(gst.begin(), gst.end(), tmp);
					vector<array<int, 2>>::iterator it2 = find(rfid.begin(), rfid.end(), tmp);
					if (it1 == gst.end() && it2 == rfid.end())
					{
						gst.push_back(tmp);
					}
				}
			}
		}
	}
}


void TruncatedTspline_3D::VisualizeBC(string fn, const vector<int>& IDBC, const vector<double>& gh)
{
	string fname(fn + "_bc.vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		int nact(0);
		for (uint i = 0; i < hcp.size(); i++)
		{
			for (uint j = 0; j < hcp[i].size(); j++)
			{
				if (hcp[i][j].act == 1)
				{
					nact++;
				}
			}
		}
		fout << "# vtk DataFile Version 2.0\nHex test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << nact << " float\n";
		for (uint i = 0; i < hcp.size(); i++)
		{
			for (uint j = 0; j < hcp[i].size(); j++)
			{
				if (hcp[i][j].act == 1)
				{
					fout << hcp[i][j].coor[0] << " " << hcp[i][j].coor[1] << " " << hcp[i][j].coor[2] << "\n";
				}
			}
		}
		fout << "\nCELLS " << nact << " " << 2 * nact << '\n';
		for (int i = 0; i < nact; i++)
		{
			fout << "1 " << i << "\n";
		}
		fout << "\nCELL_TYPES " << nact << '\n';
		for (int i = 0; i < nact; i++)
		{
			fout << "1\n";
		}
		fout << "POINT_DATA " << nact << "\nVECTORS type float\n";
		int loc(0);
		for (uint i = 0; i < hcp.size(); i++)
		{
			for (uint j = 0; j < hcp[i].size(); j++)
			{
				if (hcp[i][j].act == 1)
				{
					for (int k = 0; k < 3; k++)
					{
						if (IDBC[3 * loc + k] != -1)
						{
							fout << "-100 ";
						}
						else
						{
							fout << gh[3 * loc + k] << " ";
						}
					}
					fout << "\n";
					loc++;
				}
			}
		}
	}
	else
	{
		cerr << "Can't open " << fname << "!\n";
	}
}



///////////////////////////////////////////////////////////////////////////////////////
//adatptive with open knot vectors

void TruncatedTspline_3D::Initialize_THS3D(string fn)
{
	//assume input hex has a pillowed layer

	InitializeMesh(fn);
	//SetZeroKnotInterval();
	BuildSplines_Unstruct_Open();

	hmesh.push_back(tmesh);
	hcp.push_back(cp);
	hface.push_back(tmface);
	hedge.push_back(tmedge);

	//ReportXP();

	//BezierPoints_ini();//represent geometry using initial control points and blending functions

	SetSupport(0);
}

void TruncatedTspline_3D::SetZeroKnotInterval()
{
	int ed_ppd[6][4] = { {4,5,6,7},{1,3,9,11},{0,2,8,10},{1,3,9,11},{0,2,8,10},{4,5,6,7} };
	for (uint i = 0; i < tmesh.size(); i++)
	{
		if (tmesh[i].type == 1)
		{
			int count(0);
			for (int j = 0; j < 6; j++)
			{
				if (tmface[tmesh[i].face[j]].type == 1)
				{
					count++;
					for (int k = 0; k < 4; k++)
					{
						tmedge[tmesh[i].edge[ed_ppd[j][k]]].len = 0.;
					}
				}
			}
			if (count > 1)//this won't be the case if mesh is pillowed
			{
				cerr << "More than one boundary face in an element!\n";
				getchar();
			}
		}
	}
}




//////////////////////////////////////////////////////////////////////////////////




void TruncatedTspline_3D::Run_C0C1Bezier(string fn, int nrf, vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	InitializeMesh(fn);
	InitializeC0Component();
	//OutputCM(fn);
	//ReportDiffEleNumber();
	BuildSplines_Unstruct();
	Convert2Bezier();
	for (int i = 0; i < nrf; i++)
	{
		Global_Subdivide_C0C1Bezier();//need modification for c0flags
		//EnlargeRefineRegion();
	}
	BuildSplines_Unstruct();
	AddC0C1Bezier();
	TruncateC0C1();
	//OutputGeom_C0C1("../io/global5/cube2");
	BezierExtract_C0C1Bezier(bzmesh, IDBC, gh);

	//PatchTest_BC(IDBC, gh);//Poisson
	//StrongDirichletBC(bzmesh, IDBC, gh);
	//StrongDirichletBC_Elasticity(bzmesh, IDBC, gh);
	//StrongDirichletBC_Elasticity_FromFile(bzmesh, IDBC, gh);
	//StrongDirichletBC_Elasticity_Manual(bzmesh, IDBC, gh);
}

void TruncatedTspline_3D::InitializeC0Component()
{
	//treat boundary components (i.e. vertices, edges and faces) and interior ones separately
	//C0 interior faces, C0 continuity across such faces that are connected to extraordinary edges
	for (uint i = 0; i < tmedge.size(); i++)
	{
		if (tmedge[i].type == 2)//must be interior
		{
			tmedge[i].c0flag = 1;
			for (uint j = 0; j < tmedge[i].face.size(); j++)
			{
				tmface[tmedge[i].face[j]].c0flag = 1;
			}
			for (int j = 0; j < 2; j++)
			{
				if (cp[tmedge[i].pt[j]].type != 1)
					cp[tmedge[i].pt[j]].c0flag = 1;
				//if (cp[tmedge[i].pt[j]].type == 1)//boundary
				//{
				//	//cp[tmedge[i].pt[j]].c0flag_b = 1;
				//}
			}
		}
		else if (tmedge[i].type == 1)//boundary
		{
			if (tmedge[i].sharp == 1)
			{
				tmedge[i].c0flag_b = 1;
				for (uint j = 0; j < tmedge[i].face.size(); j++)
				{
					if (tmface[tmedge[i].face[j]].type == 0)
					{
						tmface[tmedge[i].face[j]].c0flag = 1;
					}
				}
			}
			else
			{
				if (tmedge[i].face.size() != 3)//boundary extraordinary edges
				{
					tmedge[i].c0flag_b = 1;
					for (uint j = 0; j < tmedge[i].face.size(); j++)
					{
						if (tmface[tmedge[i].face[j]].type == 0)
						{
							tmface[tmedge[i].face[j]].c0flag = 1;
						}
					}
				}
			}
		}
	}

	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].type == 3)
		{
			cp[i].c0flag = 1;
		}
		else if (cp[i].type == 1)
		{
			if (cp[i].sharp != 0)
			{
				cp[i].c0flag_b = 1;
			}
			else
			{
				int nv_b(0), nv_i(0);
				for (uint j = 0; j < cp[i].edge.size(); j++)
				{
					if (tmedge[cp[i].edge[j]].type == 1) nv_b++;
					else nv_i++;
				}
				if (nv_i != 1 || nv_b != 4)
				{
					cp[i].c0flag_b = 1;
					for (uint j = 0; j < cp[i].edge.size(); j++)
					{
						if (tmedge[cp[i].edge[j]].type != 1)
						{
							tmedge[cp[i].edge[j]].c0flag = 1;
						}
						else
						{
							tmedge[cp[i].edge[j]].c0flag_b = 1;
						}
					}
					for (uint j = 0; j < cp[i].face.size(); j++)
					{
						if (tmface[cp[i].face[j]].type != 1)
						{
							tmface[cp[i].face[j]].c0flag = 1;
						}
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::AddC0C1Bezier()
{
	cout << "Adding C0 and C1 functions...\n";

	//all boundary elements have bzflag==1
	//all c0flag assigned only to interior faces, edges and vertices
	//all c0flag_b assigned only to boundary edges and vertices
	//all boundary faces converted to 2D Bezier meshes

	int bzbd[8] = { 21, 22, 26, 25, 37, 38, 42, 41 };
	int cmb_bd2fc[8][3] = { { 5, 17, 20 }, { 6, 18, 23 }, { 10, 27, 30 }, { 9, 29, 24 }, { 33, 36, 53 }, { 34, 39, 54 }, { 43, 46, 58 }, { 45, 40, 57 } };
	int loc_bd2fc[8][3] = { { 0, 1, 4 }, { 0, 1, 2 }, { 0, 2, 3 }, { 0, 3, 4 }, { 1, 4, 5 }, { 1, 2, 5 }, { 2, 3, 5 }, { 3, 4, 5 } };
	int cmb_bd2ed[8][3] = { { 1, 4, 16 }, { 2, 7, 19 }, { 11, 14, 31 }, { 13, 8, 28 }, { 32, 49, 52 }, { 35, 50, 55 }, { 47, 59, 62 }, { 44, 61, 56 } };
	int loc_bd2ed[8][3] = { { 0, 3, 4 }, { 0, 1, 5 }, { 1, 2, 6 }, { 2, 3, 7 }, { 4, 8, 11 }, { 5, 8, 9 }, { 6, 9, 10 }, { 7, 10, 11 } };
	int cmb_bd2cn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };//same as bzcn

	int bzfc[6][4] = { { 5, 6, 10, 9 }, { 17, 18, 34, 33 }, { 23, 27, 43, 39 }, { 29, 30, 46, 45 }, { 20, 24, 40, 36 }, { 53, 54, 58, 57 } };
	int bzed[12][2] = { { 1, 2 }, { 7, 11 }, { 13, 14 }, { 4, 8 }, { 16, 32 }, { 19, 35 }, { 31, 47 }, { 28, 44 }, { 49, 50 }, { 55, 59 }, { 61, 62 }, { 52, 56 } };//
	int bzcn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };

	int fc_cn[6][4] = { { 0, 1, 2, 3 }, { 0, 1, 5, 4 }, { 1, 2, 6, 5 }, { 3, 2, 6, 7 }, { 0, 3, 7, 4 }, { 4, 5, 6, 7 } };//corresponding to bzfc
	int fc_ed[6][4] = { { 0, 1, 2, 3 }, { 0, 5, 8, 4 }, { 1, 6, 9, 5 }, { 2, 6, 10, 7 }, { 3, 7, 11, 4 }, { 8, 9, 10, 11 } };
	int bzfc_ed[6][4][2] = { { { 1, 4 }, { 7, 2 }, { 14, 11 }, { 8, 13 } }, { { 1, 16 }, { 19, 2 }, { 50, 35 }, { 32, 49 } }, { { 7, 19 }, { 31, 11 }, { 59, 47 }, { 35, 55 } },
	{ { 13, 28 }, { 31, 14 }, { 62, 47 }, { 44, 61 } }, { { 4, 16 }, { 28, 8 }, { 56, 44 }, { 32, 52 } }, { { 49, 52 }, { 55, 50 }, { 62, 59 }, { 56, 61 } } };
	int ed_cn[12][2] = { { 0, 1 }, { 1, 2 }, { 3, 2 }, { 0, 3 }, { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 5 }, { 5, 6 }, { 7, 6 }, { 4, 7 } };//corresponding to bzed

	int cmb_fc2ed[6][4][2] = { { { 4, 1 }, { 2, 7 }, { 11, 14 }, { 13, 8 } }, { { 16, 1, }, { 2, 19 }, { 35, 50 }, { 49, 32 } }, { { 19, 7 }, { 11, 31 }, { 47, 59 }, { 55, 35 } },
	{ { 28, 13 }, { 14, 31 }, { 47, 62 }, { 61, 44 } }, { { 16, 4 }, { 8, 28 }, { 44, 56 }, { 52, 32 } }, { { 52, 49 }, { 50, 55 }, { 59, 62 }, { 61, 56 } } };
	int loc_fc2ed[6][4][2] = { { { 3, 0 }, { 0, 1 }, { 1, 2 }, { 2, 3 } }, { { 4, 0 }, { 0, 5 }, { 5, 8 }, { 8, 4 } }, { { 5, 1 }, { 1, 6 }, { 6, 9 }, { 9, 5 } },
	{ { 7, 2 }, { 2, 6 }, { 6, 10 }, { 10, 7 } }, { { 4, 3 }, { 3, 7 }, { 7, 11 }, { 11, 4 } }, { { 11, 8 }, { 8, 9 }, { 9, 10 }, { 10, 11 } } };
	int cmb_fc2cn[6][4] = { { 0, 3, 15, 12 }, { 0, 3, 51, 48 }, { 3, 15, 63, 51 }, { 12, 15, 63, 60 }, { 0, 12, 60, 48 }, { 48, 51, 63, 60 } };
	//int loc_fc2cn[6][4] = {};//same as fc_cn

	for (uint eid = 0; eid < tmesh.size(); eid++)//add C1 splines
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 1)//all boundary elements have bzflag == 1
		{
			uint i, j;
			for (i = 0; i < 8; i++)
			{
				tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzbd[i]]);
				vector<double> coef(64, 0.);
				coef[bzbd[i]] = 1.;
				for (j = 0; j < 3; j++)
				{
					if (tmface[tmesh[eid].face[loc_bd2fc[i][j]]].c0flag == 0 && tmface[tmesh[eid].face[loc_bd2fc[i][j]]].type != 1)
						coef[cmb_bd2fc[i][j]] = 0.5;
					if (tmedge[tmesh[eid].edge[loc_bd2ed[i][j]]].c0flag == 0 && tmedge[tmesh[eid].edge[loc_bd2ed[i][j]]].type != 1)
						coef[cmb_bd2ed[i][j]] = 0.25;
				}
				if (cp[tmesh[eid].cnct[i]].c0flag == 0 && cp[tmesh[eid].cnct[i]].type != 1) coef[cmb_bd2cn[i]] = 0.125;
				tmesh[eid].cmat.push_back(coef);
			}
		}
	}
	for (uint eid = 0; eid < tmesh.size(); eid++)//add C0 Bezier
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 1)//all boundary elements have bzflag == 1
		{
			uint i, j;
			for (i = 0; i < 6; i++)//add face points
			{
				if (tmface[tmesh[eid].face[i]].c0flag == 1 || tmface[tmesh[eid].face[i]].type == 1)//interior face with c0flag==1 or boundary face
				{
					for (j = 0; j < 4; j++)
					{
						tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzfc[i][j]]);
						//tmesh[eid].IENc0_loc.push_back(bzfc[i][j]);
						//if (tmface[tmesh[eid].face[i]].type == 1) tmesh[eid].IENc01_b.push_back(tmesh[eid].IENb[bzfc[i][j]]);
						vector<double> coef(64, 0.);
						coef[bzfc[i][j]] = 1.;//not consider neighboring influence from face first for simplification
						//if (tmedge[tmesh[eid].edge[loc_fc2ed[i][j][0]]].type == 1 && tmedge[tmesh[eid].edge[loc_fc2ed[i][j][0]]].c0flag_b == 0)//boundary
						//	coef[cmb_fc2ed[i][j][0]] = 0.5;
						//if (tmedge[tmesh[eid].edge[loc_fc2ed[i][j][1]]].type == 1 && tmedge[tmesh[eid].edge[loc_fc2ed[i][j][1]]].c0flag_b == 0)//boundary
						//	coef[cmb_fc2ed[i][j][1]] = 0.5;
						//if (cp[tmesh[eid].cnct[fc_cn[i][j]]].type == 1 && cp[tmesh[eid].cnct[fc_cn[i][j]]].c0flag_b == 0)//boundary
						//	coef[cmb_fc2cn[i][j]] = 0.25;
						tmesh[eid].cmat.push_back(coef);
					}
				}
			}
			for (i = 0; i < 12; i++)//add edge points
			{
				if (tmedge[tmesh[eid].edge[i]].c0flag == 1 || tmedge[tmesh[eid].edge[i]].type == 1)
				{
					for (j = 0; j < 2; j++)
					{
						tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzed[i][j]]);
						//tmesh[eid].IENc0_loc.push_back(bzed[i][j]);
						vector<double> coef(64, 0.);
						coef[bzed[i][j]] = 1.;
						tmesh[eid].cmat.push_back(coef);
					}
				}
			}
			for (i = 0; i < 8; i++)//add corner points
			{
				if (cp[tmesh[eid].cnct[i]].c0flag == 1 || cp[tmesh[eid].cnct[i]].type == 1)
				{
					tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzcn[i]]);
					//tmesh[eid].IENc0_loc.push_back(bzcn[i]);
					vector<double> coef(64, 0.);
					coef[bzcn[i]] = 1.;
					tmesh[eid].cmat.push_back(coef);
				}
			}
		}
	}
	
	for (uint eid = 0; eid < tmesh.size(); eid++)//add neighboring influence
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 1)
		{
			uint i, j;
			vector<int> enb;
			for (i = 0; i < 6; i++)//influence from face neighbor
			{
				int fcnb(-1);
				if (tmface[tmesh[eid].face[i]].type == 0)//interior
				{
					fcnb = tmface[tmesh[eid].face[i]].hex[0];
					if (fcnb == eid) fcnb = tmface[tmesh[eid].face[i]].hex[1];
					enb.push_back(fcnb);
				}
				if (fcnb != -1)
				{
					if (tmesh[fcnb].bzflag == 1)
					{
						for (j = 0; j < 4; j++)
						{
							int* it = find(tmesh[fcnb].cnct, tmesh[fcnb].cnct + 8, tmesh[eid].cnct[fc_cn[i][j]]);
							int loc(it - tmesh[fcnb].cnct);
							vector<double> coef(64, 0.);
							int add_flag(0);
							if (tmface[tmesh[eid].face[i]].c0flag == 0 && tmface[tmesh[eid].face[i]].type != 1)
							{
								add_flag = 1;
								coef[bzfc[i][j]] = 0.5;
							}
							if (tmedge[tmesh[eid].edge[fc_ed[i][j]]].c0flag == 0 && tmedge[tmesh[eid].edge[fc_ed[i][j]]].type != 1)
							{
								add_flag = 1;
								coef[bzfc_ed[i][j][0]] = 0.25;
							}
							if (tmedge[tmesh[eid].edge[fc_ed[i][(j + 3) % 4]]].c0flag == 0 && tmedge[tmesh[eid].edge[fc_ed[i][(j + 3) % 4]]].type != 1)
							{
								add_flag = 1;
								coef[bzfc_ed[i][j][1]] = 0.25;
							}
							if (cp[tmesh[eid].cnct[fc_cn[i][j]]].c0flag == 0 && cp[tmesh[eid].cnct[fc_cn[i][j]]].type != 1)
							{
								add_flag = 1;
								coef[bzcn[fc_cn[i][j]]] = 0.125;
							}
							if (add_flag == 1)
							{
								tmesh[eid].IENc01.push_back(tmesh[fcnb].IENc01[loc]);
								tmesh[eid].cmat.push_back(coef);
							}
						}
					}
					//else
					//{
					//	//tmesh[fcnb].bzflag = 2;//transition, later need to add C1 contributions to such elements
					//}
				}
			}
			for (i = 0; i < 12; i++)//influence from edge neighbor
			{
				int ednb(-1);
				for (j = 0; j < tmedge[tmesh[eid].edge[i]].hex.size(); j++)
				{
					int hxid(tmedge[tmesh[eid].edge[i]].hex[j]);
					if (hxid != eid)
					{
						vector<int>::iterator it = find(enb.begin(), enb.end(), hxid);
						if (it == enb.end())
						{
							enb.push_back(hxid);
							if (tmedge[tmesh[eid].edge[i]].type != 1/* && tmedge[tmesh[eid].edge[i]].c0flag == 0*/)
								ednb = hxid;
						}
					}
				}
				if (tmedge[tmesh[eid].edge[i]].type != 1 && ednb != -1)//must be an interior edge
				{
					if (tmesh[ednb].bzflag == 1)
					{
						for (j = 0; j < 2; j++)
						{
							int* it = find(tmesh[ednb].cnct, tmesh[ednb].cnct + 8, tmesh[eid].cnct[ed_cn[i][j]]);
							int loc(it - tmesh[ednb].cnct);
							vector<double> coef(64, 0.);
							int add_flag(0);
							if (tmedge[tmesh[eid].edge[i]].c0flag == 0)//already known as an interior edge
							{
								add_flag = 1;
								coef[bzed[i][j]] = 0.25;
							}
							if (cp[tmesh[eid].cnct[ed_cn[i][j]]].c0flag == 0 && cp[tmesh[eid].cnct[ed_cn[i][j]]].type != 1)
							{
								add_flag = 1;
								coef[bzcn[ed_cn[i][j]]] = 0.125;
							}
							if (add_flag == 1)
							{
								tmesh[eid].IENc01.push_back(tmesh[ednb].IENc01[loc]);
								tmesh[eid].cmat.push_back(coef);
							}
						}
					}
					//else
					//{
					//	//tmesh[ednb].bzflag = 2;
					//}
				}
			}
			for (i = 0; i < 8; i++)//influence from corner neighbor
			{
				if (cp[tmesh[eid].cnct[i]].c0flag == 0 && cp[tmesh[eid].cnct[i]].type != 1)
				{
					int cnnb(-1);
					for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
					{
						int hxid(cp[tmesh[eid].cnct[i]].hex[j]);
						if (hxid != eid)
						{
							vector<int>::iterator it = find(enb.begin(), enb.end(), hxid);
							if (it == enb.end())
							{
								cnnb = hxid; break;
							}
						}
					}
					if (cnnb != -1)
					{
						if (tmesh[cnnb].bzflag == 1)
						{
							int* it = find(tmesh[cnnb].cnct, tmesh[cnnb].cnct + 8, tmesh[eid].cnct[i]);
							int loc(it - tmesh[cnnb].cnct);
							vector<double> coef(64, 0.);
							coef[bzcn[i]] = 0.125;
							tmesh[eid].IENc01.push_back(tmesh[cnnb].IENc01[loc]);
							tmesh[eid].cmat.push_back(coef);
						}
						//else
						//{
						//	//tmesh[cnnb].bzflag = 2;
						//}
					}
					else
					{
						cerr << "Can't find cnnb even though cp.c0flag==0!\n"; getchar();
					}
				}
			}
		}
	}

	//AddC0C1Bezier_Boundary();

	//boundry faces, influence from neighboring faces
	//for (uint eid = 0; eid < tmesh.size(); eid++)
	//{
	//	if (tmesh[eid].act == 1 && tmesh[eid].type == 1)//boundary elements, must have bzflag==1
	//	{
	//		uint i, j, k, k0;
	//		for (i = 0; i < 6; i++)
	//		{
	//			if (tmface[tmesh[eid].face[i]].type == 1)
	//			{
	//				int fcid(tmesh[eid].face[i]);
	//				for (j = 0; j < 4; j++)
	//				{
	//					int hxid[2] = { -1, -1 }, fcnb(-1);
	//					for (k = 0; k < tmedge[tmface[fcid].edge[j]].hex.size(); k++)
	//					{
	//						int hxtmp(tmedge[tmface[fcid].edge[j]].hex[k]);
	//						if (hxtmp != eid)
	//						{
	//							for (k0 = 0; k0 < 6; k0++)
	//							{
	//							}
	//						}
	//					}
	//				}
	//			}
	//		}
	//	}
	//}

	//find transition element
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 0)
		{
			uint i, j, hxid, flag(0);
			for (i = 0; i < 8; i++)
			{
				for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
				{
					hxid = cp[tmesh[eid].cnct[i]].hex[j];
					if (tmesh[hxid].bzflag == 1)
					{
						flag = 1; break;
					}
				}
				if (flag == 1) break;
			}
			if (flag == 1) tmesh[eid].bzflag = 2;
		}
	}
	//add C1 functions to transition element
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 2)//must be an interior element
		{
			uint i, j;
			vector<int> enb;
			//check if any face neighbors with bzflag==1
			for (i = 0; i < 6; i++)
			{
				int fcnb(tmface[tmesh[eid].face[i]].hex[0]);
				if (fcnb == eid) fcnb = tmface[tmesh[eid].face[i]].hex[1];
				enb.push_back(fcnb);
				if (tmesh[fcnb].bzflag == 1)
				{
					for (j = 0; j < 4; j++)
					{
						int* it = find(tmesh[fcnb].cnct, tmesh[fcnb].cnct + 8, tmesh[eid].cnct[fc_cn[i][j]]);
						int loc(it - tmesh[fcnb].cnct);
						vector<double> coef(64, 0.);
						coef[bzfc[i][j]] = 0.5;
						coef[bzfc_ed[i][j][0]] = 0.25;
						coef[bzfc_ed[i][j][1]] = 0.25;
						coef[bzcn[fc_cn[i][j]]] = 0.125;
						tmesh[eid].IENc01.push_back(tmesh[fcnb].IENc01[loc]);
						tmesh[eid].cmat.push_back(coef);
					}
				}
			}
			for (i = 0; i < 12; i++)
			{
				int ednb(-1);
				for (j = 0; j < tmedge[tmesh[eid].edge[i]].hex.size(); j++)
				{
					int hxid(tmedge[tmesh[eid].edge[i]].hex[j]);
					if (hxid != eid)
					{
						vector<int>::iterator it = find(enb.begin(), enb.end(), hxid);
						if (it == enb.end())
						{
							enb.push_back(hxid);
							ednb = hxid; break;
						}
					}
				}
				if (ednb != -1 && tmesh[ednb].bzflag == 1)
				{
					for (j = 0; j < 2; j++)
					{
						int* it = find(tmesh[ednb].cnct, tmesh[ednb].cnct + 8, tmesh[eid].cnct[ed_cn[i][j]]);
						int loc(it - tmesh[ednb].cnct);
						vector<double> coef(64, 0.);
						coef[bzed[i][j]] = 0.25;
						coef[bzcn[ed_cn[i][j]]] = 0.125;
						tmesh[eid].IENc01.push_back(tmesh[ednb].IENc01[loc]);
						tmesh[eid].cmat.push_back(coef);
					}
				}
			}
			for (i = 0; i < 8; i++)
			{
				int cnnb(-1);
				for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
				{
					int hxid(cp[tmesh[eid].cnct[i]].hex[j]);
					if (hxid != eid)
					{
						vector<int>::iterator it = find(enb.begin(), enb.end(), hxid);
						if (it == enb.end())
						{
							cnnb = hxid; break;
						}
					}
				}
				if (cnnb != -1 && tmesh[cnnb].bzflag == 1)
				{
					int* it = find(tmesh[cnnb].cnct, tmesh[cnnb].cnct + 8, tmesh[eid].cnct[i]);
					int loc(it - tmesh[cnnb].cnct);
					vector<double> coef(64, 0.);
					coef[bzcn[i]] = 0.125;
					tmesh[eid].IENc01.push_back(tmesh[cnnb].IENc01[loc]);
					tmesh[eid].cmat.push_back(coef);
				}
			}
		}
	}

	cout << "Done adding!\n";
}

void TruncatedTspline_3D::AddC0C1Bezier_Boundary()
{
	int bzbd[8] = { 21, 22, 26, 25, 37, 38, 42, 41 };
	int cmb_bd2fc[8][3] = { { 5, 17, 20 }, { 6, 18, 23 }, { 10, 27, 30 }, { 9, 29, 24 }, { 33, 36, 53 }, { 34, 39, 54 }, { 43, 46, 58 }, { 45, 40, 57 } };
	int loc_bd2fc[8][3] = { { 0, 1, 4 }, { 0, 1, 2 }, { 0, 2, 3 }, { 0, 3, 4 }, { 1, 4, 5 }, { 1, 2, 5 }, { 2, 3, 5 }, { 3, 4, 5 } };
	int cmb_bd2ed[8][3] = { { 1, 4, 16 }, { 2, 7, 19 }, { 11, 14, 31 }, { 13, 8, 28 }, { 32, 49, 52 }, { 35, 50, 55 }, { 47, 59, 62 }, { 44, 61, 56 } };
	int loc_bd2ed[8][3] = { { 0, 3, 4 }, { 0, 1, 5 }, { 1, 2, 6 }, { 2, 3, 7 }, { 4, 8, 11 }, { 5, 8, 9 }, { 6, 9, 10 }, { 7, 10, 11 } };
	int cmb_bd2cn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };//same as bzcn

	int bzfc[6][4] = { { 5, 6, 10, 9 }, { 17, 18, 34, 33 }, { 23, 27, 43, 39 }, { 29, 30, 46, 45 }, { 20, 24, 40, 36 }, { 53, 54, 58, 57 } };
	int bzed[12][2] = { { 1, 2 }, { 7, 11 }, { 13, 14 }, { 4, 8 }, { 16, 32 }, { 19, 35 }, { 31, 47 }, { 28, 44 }, { 49, 50 }, { 55, 59 }, { 61, 62 }, { 52, 56 } };//
	int bzcn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };

	int fc_cn[6][4] = { { 0, 1, 2, 3 }, { 0, 1, 5, 4 }, { 1, 2, 6, 5 }, { 3, 2, 6, 7 }, { 0, 3, 7, 4 }, { 4, 5, 6, 7 } };//corresponding to bzfc
	int fc_ed[6][4] = { { 0, 1, 2, 3 }, { 0, 5, 8, 4 }, { 1, 6, 9, 5 }, { 2, 6, 10, 7 }, { 3, 7, 11, 4 }, { 8, 9, 10, 11 } };
	int bzfc_ed[6][4][2] = { { { 1, 4 }, { 7, 2 }, { 14, 11 }, { 8, 13 } }, { { 1, 16 }, { 19, 2 }, { 50, 35 }, { 32, 49 } }, { { 7, 19 }, { 31, 11 }, { 59, 47 }, { 35, 55 } },
	{ { 13, 28 }, { 31, 14 }, { 62, 47 }, { 44, 61 } }, { { 4, 16 }, { 28, 8 }, { 56, 44 }, { 32, 52 } }, { { 49, 52 }, { 55, 50 }, { 62, 59 }, { 56, 61 } } };
	int ed_cn[12][2] = { { 0, 1 }, { 1, 2 }, { 3, 2 }, { 0, 3 }, { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 5 }, { 5, 6 }, { 7, 6 }, { 4, 7 } };//corresponding to bzed

	//treat boundary separately and independently, need to use c0flag_b for boundary edges and boundary vertices
	//add face points for each boundary face element, edge points for edges of c0flag_b==1, corner points for corners of c0flag_b==1
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].act == 1 && tmesh[eid].type == 1)
		{
			uint i, j;
			for (i = 0; i < 6; i++)
			{
				if (tmface[tmesh[eid].face[i]].type == 1)
				{
					for (j = 0; j < 4; j++)
					{
						tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzfc[i][j]]);
						vector<double> coef(64, 0.);
						coef[bzfc[i][j]] = 1.;
						if (tmedge[tmesh[eid].edge[fc_ed[i][j]]].c0flag_b == 0)
							coef[bzfc_ed[i][j][0]] = 0.5;
						if (tmedge[tmesh[eid].edge[fc_ed[i][(j + 3) % 4]]].c0flag_b == 0)
							coef[bzfc_ed[i][j][1]] = 0.5;
						if (cp[tmesh[eid].cnct[fc_cn[i][j]]].c0flag_b == 0)
							coef[bzcn[fc_cn[i][j]]] = 0.25;
						tmesh[eid].cmat.push_back(coef);
					}
				}
			}
			for (i = 0; i < 12; i++)
			{
				if (tmedge[tmesh[eid].edge[i]].c0flag_b == 1)//must be a boundary edge
				{
					for (j = 0; j < 2; j++)
					{
						tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzed[i][j]]);
						vector<double> coef(64, 0.);
						coef[bzed[i][j]] = 1.;
						tmesh[eid].cmat.push_back(coef);
					}
				}
			}
			for (i = 0; i < 8; i++)
			{
				if (cp[tmesh[eid].cnct[i]].c0flag_b == 1)
				{
					tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzcn[i]]);
					vector<double> coef(64, 0.);
					coef[bzcn[i]] = 1.;
					tmesh[eid].cmat.push_back(coef);
				}
			}
		}
	}
	//include influence from neighboring boundary faces
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].act == 1 && tmesh[eid].type == 1)
		{
			uint i, j, k;
			for (i = 0; i < 6; i++)
			{
				if (tmface[tmesh[eid].face[i]].type == 1)
				{
					int fcid(tmesh[eid].face[i]);
					int fcnb[4] = { -1, -1, -1, -1 };//fcnb is a neighboring boundary face
					for (j = 0; j < 4; j++)//edges of face fcid
					{
						int edid(tmesh[eid].edge[fc_ed[i][j]]);
						for (k = 0; k < tmedge[edid].face.size(); k++)
						{
							int fctmp(tmedge[edid].face[k]);
							if (tmface[fctmp].type == 1 && fctmp != fcid)
							{
								fcnb[j] = fctmp; break;
							}
						}
						if (fcnb[j] != -1)
						{
							int hxnb(tmface[fcnb[j]].hex[0]);
							for (int k0 = 0; k0 < 2; k0++)
							{
								int* it1 = find(tmesh[hxnb].cnct, tmesh[hxnb].cnct + 8, tmesh[eid].cnct[fc_cn[i][(j + k0) % 4]]);
								int loc1(it1 - tmesh[hxnb].cnct);
								for (k = 0; k < 3; k++)
								{
									if (tmesh[hxnb].face[loc_bd2fc[loc1][k]] == fcnb[j])//only one k matches
									{
										int add_flag(0);
										vector<double> coef(64, 0.);
										if (tmedge[edid].c0flag_b == 0)
										{
											add_flag = 1; coef[bzed[fc_ed[i][j]][k0]] = 0.5;//problem
										}
										if (cp[tmesh[eid].cnct[fc_cn[i][(j + k0) % 4]]].c0flag_b == 0)
										{
											add_flag = 1; coef[bzcn[fc_cn[i][(j + k0) % 4]]] = 0.25;
										}
										if (add_flag == 1)
										{
											tmesh[eid].IENc01.push_back(tmesh[hxnb].IENb[cmb_bd2fc[loc1][k]]);
											tmesh[eid].cmat.push_back(coef);
										}
										break;
									}
								}
							}
						}
					}
					for (j = 0; j < 4; j++)//corners of the face fcid
					{
						int cnid(tmesh[eid].cnct[fc_cn[i][j]]);
						if (cp[cnid].c0flag_b == 0)
						{
							int cnnb(-1);
							for (k = 0; k < cp[cnid].face.size(); k++)
							{
								int fctmp(cp[cnid].face[k]);
								if (tmface[fctmp].type == 1 && fctmp != fcid && fctmp != fcnb[j] && fctmp != fcnb[(j + 3) % 4])
								{
									cnnb = fctmp; break;
								}
							}
							if (cnnb != -1)
							{
								int hxnb(tmface[cnnb].hex[0]);
								int* it1 = find(tmesh[hxnb].cnct, tmesh[hxnb].cnct + 8, tmesh[eid].cnct[fc_cn[i][j]]);
								int loc1(it1 - tmesh[hxnb].cnct);
								for (k = 0; k < 3; k++)
								{
									if (tmesh[hxnb].face[loc_bd2fc[loc1][k]] == cnnb)//only one k matches
									{
										vector<double> coef(64, 0.);
										coef[bzcn[fc_cn[i][j]]] = 0.25;
										tmesh[eid].IENc01.push_back(tmesh[hxnb].IENb[cmb_bd2fc[loc1][k]]);
										tmesh[eid].cmat.push_back(coef);
										break;
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::TruncateC0C1()
{
	cout << "Performing truncation...\n";
	//determine active C2 functions first
	for (uint i = 0; i < cp.size(); i++)
	{
		int flag(0);
		for (uint j = 0; j < cp[i].hex.size(); j++)
		{
			if (tmesh[cp[i].hex[j]].bzflag != 1) flag = 1;
		}
		if (flag == 0) cp[i].act = 0;
	}

	vector<int> etrun1;
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 1)
		{
			uint i, j, flag(0);
			for (i = 0; i < 8; i++)
			{
				for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
				{
					if (tmesh[cp[tmesh[eid].cnct[i]].hex[j]].bzflag != 1)
					{
						flag = 1; break;
					}
				}
				if (flag == 1) break;
			}
			if (flag == 1)
			{
				etrun1.push_back(eid);
				//vector<vector<double>> cmat;
				//BezierExtractC0C1_Trun(eid, cmat);
				//for (i = 0; i < tmesh[eid].IEN.size(); i++)
				//{
				//	if (cp[tmesh[eid].IEN[i]].act == 1)
				//	{
				//		tmesh[eid].IENc2.push_back(tmesh[eid].IEN[i]);
				//		tmesh[eid].cmat.push_back(cmat[i]);
				//	}
				//}
			}
		}
	}

#pragma omp parallel for
	for (int i0 = 0; i0 < etrun1.size(); i0++)
	{
		int eid(etrun1[i0]);
		vector<vector<double>> cmat;
		BezierExtractC0C1_Trun(eid, cmat);
		for (uint i = 0; i < tmesh[eid].IEN.size(); i++)
		{
			if (cp[tmesh[eid].IEN[i]].act == 1)
			{
				tmesh[eid].IENc2.push_back(tmesh[eid].IEN[i]);
				tmesh[eid].cmat.push_back(cmat[i]);
			}
		}
	}

//#pragma omp parallel for
	vector<int> etrun2;
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 2)
		{
			etrun2.push_back(eid);
			//vector<vector<double>> cmat;
			//BezierExtractC0C1_Trun(eid, cmat);
			//for (uint i = 0; i < tmesh[eid].IEN.size(); i++)
			//{
			//	if (cp[tmesh[eid].IEN[i]].act == 1)
			//	{
			//		tmesh[eid].IENc2.push_back(tmesh[eid].IEN[i]);
			//		tmesh[eid].cmat.push_back(cmat[i]);
			//	}
			//}
		}
	}

#pragma omp parallel for
	for (int i0 = 0; i0 < etrun2.size(); i0++)
	{
		int eid(etrun2[i0]);
		vector<vector<double>> cmat;
		BezierExtractC0C1_Trun(eid, cmat);
		for (uint i = 0; i < tmesh[eid].IEN.size(); i++)
		{
			if (cp[tmesh[eid].IEN[i]].act == 1)
			{
				tmesh[eid].IENc2.push_back(tmesh[eid].IEN[i]);
				tmesh[eid].cmat.push_back(cmat[i]);
			}
		}
	}

	//for (uint eid = 0; eid < tmesh.size(); eid++)
	//{
	//	if (tmesh[eid].bzflag == 1)
	//	{
	//		for (uint i = 0; i < 64; i++)
	//		{
	//			double sum(0.);
	//			for (uint j = 0; j < tmesh[eid].cmat.size(); j++)
	//			{
	//				sum += tmesh[eid].cmat[j][i];
	//			}
	//			if (fabs(sum - 1.)>1.e-6)
	//			{
	//				cout << "eid: " << eid << "\n";
	//				cout << "bzid: " << i << "\n";
	//				cout << "IENc01 dim: " << tmesh[eid].IENc01.size() << "\n";
	//				cout << "IENc2 dim : " << tmesh[eid].IENc2.size() << "\n";
	//				int edloc(5);
	//				//cout << "edge c0flag: ";
	//				//for (uint j = 0; j < 12; j++)
	//				//{
	//				//	cout << tmedge[tmesh[eid].edge[j]].c0flag << "(" << j << ") ";
	//				//}
	//				cout << "edge c0flag: " << tmedge[tmesh[eid].edge[edloc]].c0flag << "\n";
	//				cout << "edge type: " << tmedge[tmesh[eid].edge[edloc]].type << "\n";
	//				for (uint j = 0; j < tmedge[tmesh[eid].edge[edloc]].hex.size(); j++)
	//				{
	//					int hxid(tmedge[tmesh[eid].edge[edloc]].hex[j]);
	//					//cout << tmesh[hxid].bzflag << " ";
	//					cout << tmesh[hxid].type << " ";
	//				}
	//				cout << "\n";
	//				for (uint j = 0; j < tmesh[eid].cmat.size(); j++)
	//				{
	//					if (tmesh[eid].cmat[j][i] != 0.)
	//					{
	//						cout << tmesh[eid].cmat[j][i] << " ";
	//					}
	//				}
	//				cout << "\n"; getchar();
	//			}
	//		}
	//	}
	//}

	cout << "Done truncating!\n";
}

void TruncatedTspline_3D::BezierExtractC0C1_Trun(int eid, vector<vector<double>>& cmat)
{
	//two-step Bezier extraction: (1) C2 to C1; (2) C1 to C0
	//build local connectivity first
	uint i, j, k, hxid;
	vector<int> hx1r(1, eid);
	vector<array<int, 8>> eloc;
	array<int, 8> etmp;
	for (i = 0; i < 8; i++) etmp[i] = i;
	eloc.push_back(etmp);
	vector<vector<int>> cnb_loc(8);
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
		{
			hxid = cp[tmesh[eid].cnct[i]].hex[j];
			vector<int>::iterator it1 = find(hx1r.begin(), hx1r.end(), hxid);
			cnb_loc[i].push_back(it1 - hx1r.begin());
			if (it1 == hx1r.end())
			{
				hx1r.push_back(hxid);
				for (k = 0; k < 8; k++)
				{
					vector<int>::iterator it = find(tmesh[eid].IEN.begin(), tmesh[eid].IEN.end(), tmesh[hxid].cnct[k]);
					etmp[k] = it - tmesh[eid].IEN.begin();
				}
				eloc.push_back(etmp);
			}
		}
	}

	int bzbd[8] = { 21, 22, 26, 25, 37, 38, 42, 41 };
	int bzfc[6][4] = { { 5, 6, 10, 9 }, { 17, 18, 34, 33 }, { 23, 27, 43, 39 }, { 29, 30, 46, 45 }, { 20, 24, 40, 36 }, { 53, 54, 58, 57 } };
	int bzed[12][2] = { { 1, 2 }, { 7, 11 }, { 13, 14 }, { 4, 8 }, { 16, 32 }, { 19, 35 }, { 31, 47 }, { 28, 44 }, { 49, 50 }, { 55, 59 }, { 61, 62 }, { 52, 56 } };
	int bzcn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };
	int fc_cn[6][4] = { { 0, 1, 2, 3 }, { 0, 1, 5, 4 }, { 1, 2, 6, 5 }, { 3, 2, 6, 7 }, { 0, 3, 7, 4 }, { 4, 5, 6, 7 } };
	int ed_cn[12][2] = { { 0, 1 }, { 1, 2 }, { 3, 2 }, { 0, 3 }, { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 5 }, { 5, 6 }, { 7, 6 }, { 4, 7 } };
	//uint nc1(0);
	//for (i = 0; i < 8; i++) nc1 += cp[tmesh[eid].cnct[i]].hex.size();
	//vector<vector<double>> cmat1(tmesh[eid].IEN.size(), vector<double>(nc1, 0.));
	vector<vector<double>> cmat1(tmesh[eid].IEN.size(), vector<double>(8 * hx1r.size(), 0.));
	int count(0);
	for (i = 0; i < hx1r.size(); i++)
	{
		for (j = 0; j < 8; j++)//Bezier body points
		{
			for (k = 0; k < 8; k++)//element corners
			{
				cmat1[eloc[i][k]][count]=tmesh[hx1r[i]].bemat[k][bzbd[j]];
				if (tmesh[hx1r[i]].bzflag == 1) cmat1[eloc[i][k]][count] = 0.;//truncation
			}
			count++;
		}
	}

	vector<vector<double>> cmat0(8 * hx1r.size(), vector<double>(64, 0.));
	for (i = 0; i < 8; i++)//body points themselves
	{
		cmat0[i][bzbd[i]] = 1.;
	}
	for (i = 0; i < 6; i++)//face neighbor
	{
		double fcc(0.5);
		//if (tmface[tmesh[eid].face[i]].type == 1) fcc = 0.;
		for (j = 0; j < tmface[tmesh[eid].face[i]].hex.size(); j++)
		{
			hxid = tmface[tmesh[eid].face[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			int loc(it - hx1r.begin());
			for (k = 0; k < 4; k++)
			{
				int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[fc_cn[i][k]]);
				int loc1(it1 - tmesh[hxid].cnct);
				cmat0[8 * loc + loc1][bzfc[i][k]] = fcc;
			}
		}
	}
	for (i = 0; i < 12; i++)//edge neighbor
	{
		double edc(1. / double(tmedge[tmesh[eid].edge[i]].hex.size()));
		for (j = 0; j < tmedge[tmesh[eid].edge[i]].hex.size(); j++)
		{
			hxid = tmedge[tmesh[eid].edge[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			int loc(it - hx1r.begin());
			for (k = 0; k < 2; k++)
			{
				int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[ed_cn[i][k]]);
				int loc1(it1 - tmesh[hxid].cnct);
				cmat0[8 * loc + loc1][bzed[i][k]] = edc;
			}
		}
	}
	for (i = 0; i < 8; i++)//corner neighbor
	{
		double cnc(1. / double(cp[tmesh[eid].cnct[i]].hex.size()));
		for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
		{
			hxid = cp[tmesh[eid].cnct[i]].hex[j];
			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
			int loc(it - hx1r.begin());
			int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[i]);
			int loc1(it1 - tmesh[hxid].cnct);
			cmat0[8 * loc + loc1][bzcn[i]] = cnc;
		}
	}

	for (i = 0; i < cmat.size(); i++) cmat[i].clear();
	cmat.clear();
	cmat.resize(tmesh[eid].IEN.size(), vector<double>(64, 0.));
	for (i = 0; i < tmesh[eid].IEN.size(); i++)
	{
		for (j = 0; j < 64; j++)
		{
			for (k = 0; k < 8 * hx1r.size(); k++)
			{
				if (cmat1[i][k] != 0. && cmat0[k][j] != 0.)
					cmat[i][j] += cmat1[i][k] * cmat0[k][j];
			}
		}
	}
}

void TruncatedTspline_3D::OutputGeom_C0C1(string fn)
{
	cout << "Outputing geometry...\n";
	vector<array<double, 3>> spt;
	//vector<array<double, 3>> sval;
	//vector<double> ssum;
	vector<array<int, 8>> sele;
	vector<array<double, 3>> lpt;//visulize parameter lines
	vector<array<int, 2>> led;//line connectivity
	int ns(5), ne_ref(0), loc0, loc1, loc2;

	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].act == 1 /*&& tmesh[eid].type == 2*/)
		{
			vector<double> su(ns), sv(ns), sw(ns);
			double ul[3] = { 1., 1., 1. };
			for (int i = 0; i<ns; i++)
			{
				su[i] = i*ul[0] / (ns - 1);
				sv[i] = i*ul[1] / (ns - 1);
				sw[i] = i*ul[2] / (ns - 1);
			}
			for (int a = 0; a<ns; a++)
			{
				for (int b = 0; b<ns; b++)
				{
					for (int c = 0; c < ns; c++)
					{
						array<double, 3> pt;
						array<double, 3> uval = { su[c], sv[b], sw[a] };
						GeomMap_C0C1(eid, uval.data(), pt.data());
						//double sumtmp = BasisSum(lev, eid, uval);
						//GeomMap_Lev(lev, eid, uval, pt);
						//double sumtmp = BasisSum_Lev(lev, eid, uval);
						spt.push_back(pt);
						//ssum.push_back(sumtmp);
						//if(a==0||a==ns-1||b==0||b==ns-1)
						//{
						//	lpt.push_back(pt);
						//}
					}
				}
			}

			for (int a = 0; a<ns - 1; a++)
			{
				for (int b = 0; b<ns - 1; b++)
				{
					for (int c = 0; c < ns - 1; c++)
					{
						array<int, 8> el;
						el[0] = ne_ref + a*ns*ns + b*ns + c;
						el[1] = ne_ref + a*ns*ns + b*ns + c + 1;
						el[2] = ne_ref + a*ns*ns + (b + 1)*ns + c + 1;
						el[3] = ne_ref + a*ns*ns + (b + 1)*ns + c;
						el[4] = ne_ref + (a + 1)*ns*ns + b*ns + c;
						el[5] = ne_ref + (a + 1)*ns*ns + b*ns + c + 1;
						el[6] = ne_ref + (a + 1)*ns*ns + (b + 1)*ns + c + 1;
						el[7] = ne_ref + (a + 1)*ns*ns + (b + 1)*ns + c;
						sele.push_back(el);
					}
				}
			}
			ne_ref += ns*ns*ns;
		}
	}

	string fname = fn + ".vtk";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << spt.size() << " float\n";
		for (uint i = 0; i<spt.size(); i++)
		{
			fout << spt[i][0] << " " << spt[i][1] << " " << spt[i][2] << "\n";
		}
		fout << "\nCELLS " << sele.size() << " " << 9 * sele.size() << '\n';
		for (uint i = 0; i<sele.size(); i++)
		{
			fout << "8 " << sele[i][0] << " " << sele[i][1] << " " << sele[i][2] << " " << sele[i][3] << " " << sele[i][4] << " " << sele[i][5] << " " << sele[i][6] << " " << sele[i][7] << '\n';
		}
		fout << "\nCELL_TYPES " << sele.size() << '\n';
		for (uint i = 0; i<sele.size(); i++)
		{
			fout << "12\n";
		}
		//fout << "\nPOINT_DATA " << ssum.size() << "\nSCALARS sum FLOAT\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<ssum.size(); i++)
		//{
		//	fout << ssum[i] << "\n";
		//}
		//fout<<"\nPOINT_DATA "<<sval.size()<<"\nNORMALS Normal FLOAT\n";
		//for(uint i=0;i<sval.size();i++)
		//{
		//	fout<<sval[i][0]<<" "<<sval[i][1]<<" "<<sval[i][2]<<"\n";
		//}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}

	cout << "Done outputing!\n";
}

void TruncatedTspline_3D::GeomMap_C0C1(int eid, double u[3], double pt[3])
{
	BezierElement3D bzel;
	vector<double> Bt;
	vector<array<double, 3>> dBdt;
	bzel.Basis(u[0], u[1], u[2], Bt, dBdt);
	pt[0] = 0.; pt[1] = 0.; pt[2] = 0.;
	if (tmesh[eid].bzflag == 1 || tmesh[eid].bzflag == 2)
	{
		double Bx;
		for (uint i = 0; i < tmesh[eid].IENc01.size(); i++)
		{
			Bx = 0.;
			for (uint j = 0; j < tmesh[eid].cmat[i].size(); j++)
			{
				if (tmesh[eid].cmat[i][j] != 0.) 
					Bx += tmesh[eid].cmat[i][j] * Bt[j];
			}
			pt[0] += Bx*bzcp[tmesh[eid].IENc01[i]][0];
			pt[1] += Bx*bzcp[tmesh[eid].IENc01[i]][1];
			pt[2] += Bx*bzcp[tmesh[eid].IENc01[i]][2];
		}
		for (uint i = 0; i < tmesh[eid].IENc2.size(); i++)
		{
			Bx = 0.;
			int i1(tmesh[eid].IENc01.size() + i);
			for (uint j = 0; j < tmesh[eid].cmat[i1].size(); j++)
			{
				if (tmesh[eid].cmat[i1][j] != 0.)
					Bx += tmesh[eid].cmat[i1][j] * Bt[j];
			}
			pt[0] += Bx*cp[tmesh[eid].IENc2[i]].coor[0];
			pt[1] += Bx*cp[tmesh[eid].IENc2[i]].coor[1];
			pt[2] += Bx*cp[tmesh[eid].IENc2[i]].coor[2];
		}
	}
	else if (tmesh[eid].bzflag == 0)
	{
		double Bx;
		for (uint i = 0; i < tmesh[eid].IEN.size(); i++)
		{
			Bx = 0.;
			for (uint j = 0; j < tmesh[eid].bemat[i].size(); j++)
			{
				if (tmesh[eid].bemat[i][j] != 0.)
					Bx += tmesh[eid].bemat[i][j] * Bt[j];
			}
			pt[0] += Bx*cp[tmesh[eid].IEN[i]].coor[0];
			pt[1] += Bx*cp[tmesh[eid].IEN[i]].coor[1];
			pt[2] += Bx*cp[tmesh[eid].IEN[i]].coor[2];
		}
	}
}

void TruncatedTspline_3D::Global_Subdivide_C0C1Bezier()
{
	//body points
	vector<array<double, 3>> pts_bd(tmesh.size());
	for (int i = 0; i < tmesh.size(); i++)
	{
		pts_bd[i][0] = 0.; pts_bd[i][1] = 0.; pts_bd[i][2] = 0.;
		for (int j = 0; j < 8; j++)
		{
			pts_bd[i][0] += cp[tmesh[i].cnct[j]].coor[0];
			pts_bd[i][1] += cp[tmesh[i].cnct[j]].coor[1];
			pts_bd[i][2] += cp[tmesh[i].cnct[j]].coor[2];
		}
		pts_bd[i][0] /= 8.; pts_bd[i][1] /= 8.; pts_bd[i][2] /= 8.;
	}
	//face points
	vector<array<double, 3>> pts_fc0(tmface.size());//simply average
	vector<array<double, 3>> pts_fc(tmface.size());//desired
	for (int i = 0; i < tmface.size(); i++)
	{
		pts_fc0[i][0] = 0.; pts_fc0[i][1] = 0.; pts_fc0[i][2] = 0.;
		for (int j = 0; j < 4; j++)
		{
			pts_fc0[i][0] += cp[tmface[i].cnct[j]].coor[0];
			pts_fc0[i][1] += cp[tmface[i].cnct[j]].coor[1];
			pts_fc0[i][2] += cp[tmface[i].cnct[j]].coor[2];
		}
		pts_fc0[i][0] /= 4.; pts_fc0[i][1] /= 4.; pts_fc0[i][2] /= 4.;
		if (tmface[i].hex.size() == 2)//interior face points
		{
			int hxid[2] = { tmface[i].hex[0], tmface[i].hex[1] };
			pts_fc[i][0] = (pts_bd[hxid[0]][0] + pts_bd[hxid[1]][0] + 2.*pts_fc0[i][0]) / 4.;
			pts_fc[i][1] = (pts_bd[hxid[0]][1] + pts_bd[hxid[1]][1] + 2.*pts_fc0[i][1]) / 4.;
			pts_fc[i][2] = (pts_bd[hxid[0]][2] + pts_bd[hxid[1]][2] + 2.*pts_fc0[i][2]) / 4.;
		}
		else
		{
			pts_fc[i][0] = pts_fc0[i][0]; pts_fc[i][1] = pts_fc0[i][1]; pts_fc[i][2] = pts_fc0[i][2];
		}
	}
	//edge points
	vector<array<double, 3>> pts_ed0(tmedge.size());//simply average
	vector<array<double, 3>> pts_ed(tmedge.size());//desired
	for (int i = 0; i < tmedge.size(); i++)
	{
		pts_ed0[i][0] = (cp[tmedge[i].pt[0]].coor[0] + cp[tmedge[i].pt[1]].coor[0]) / 2.;
		pts_ed0[i][1] = (cp[tmedge[i].pt[0]].coor[1] + cp[tmedge[i].pt[1]].coor[1]) / 2.;
		pts_ed0[i][2] = (cp[tmedge[i].pt[0]].coor[2] + cp[tmedge[i].pt[1]].coor[2]) / 2.;
		if (tmedge[i].type != 1)//non-boundary, i.e. interior
		{
			double cavg[3] = { 0., 0., 0. };
			for (uint j = 0; j < tmedge[i].hex.size(); j++)
			{
				cavg[0] += pts_bd[tmedge[i].hex[j]][0];
				cavg[1] += pts_bd[tmedge[i].hex[j]][1];
				cavg[2] += pts_bd[tmedge[i].hex[j]][2];
			}
			cavg[0] /= double(tmedge[i].hex.size());
			cavg[1] /= double(tmedge[i].hex.size());
			cavg[2] /= double(tmedge[i].hex.size());
			double aavg[3] = { 0., 0., 0. };
			for (uint j = 0; j < tmedge[i].face.size(); j++)
			{
				aavg[0] += pts_fc0[tmedge[i].face[j]][0];
				aavg[1] += pts_fc0[tmedge[i].face[j]][1];
				aavg[2] += pts_fc0[tmedge[i].face[j]][2];
			}
			aavg[0] /= double(tmedge[i].face.size());
			aavg[1] /= double(tmedge[i].face.size());
			aavg[2] /= double(tmedge[i].face.size());
			pts_ed[i][0] = (cavg[0] + 2.*aavg[0] + double(tmedge[i].face.size() - 3)*pts_ed0[i][0]) / double(tmedge[i].face.size());
			pts_ed[i][1] = (cavg[1] + 2.*aavg[1] + double(tmedge[i].face.size() - 3)*pts_ed0[i][1]) / double(tmedge[i].face.size());
			pts_ed[i][2] = (cavg[2] + 2.*aavg[2] + double(tmedge[i].face.size() - 3)*pts_ed0[i][2]) / double(tmedge[i].face.size());
		}
		else
		{
			if (tmedge[i].sharp == 0)//boundary non-sharp edge
			{
				double aavg[3] = { 0., 0., 0. };
				for (uint j = 0; j < tmedge[i].face.size(); j++)
				{
					if (tmface[tmedge[i].face[j]].type == 1)
					{
						aavg[0] += pts_fc0[tmedge[i].face[j]][0];
						aavg[1] += pts_fc0[tmedge[i].face[j]][1];
						aavg[2] += pts_fc0[tmedge[i].face[j]][2];
					}
				}
				pts_ed[i][0] = (aavg[0] + 2.*pts_ed0[i][0]) / 4.;
				pts_ed[i][1] = (aavg[1] + 2.*pts_ed0[i][1]) / 4.;
				pts_ed[i][2] = (aavg[2] + 2.*pts_ed0[i][2]) / 4.;
			}
			else//sharp edge
			{
				pts_ed[i][0] = pts_ed0[i][0];
				pts_ed[i][1] = pts_ed0[i][1];
				pts_ed[i][2] = pts_ed0[i][2];
			}
		}
	}
	//vertex points
#pragma omp parallel for
	for (int i = 0; i < cp.size(); i++)
	{
		if (cp[i].type != 1)//interior, careful
		{
			double cavg[3] = { 0., 0., 0. };
			for (uint j = 0; j < cp[i].hex.size(); j++)
			{
				cavg[0] += pts_bd[cp[i].hex[j]][0];
				cavg[1] += pts_bd[cp[i].hex[j]][1];
				cavg[2] += pts_bd[cp[i].hex[j]][2];
			}
			cavg[0] /= double(cp[i].hex.size());
			cavg[1] /= double(cp[i].hex.size());
			cavg[2] /= double(cp[i].hex.size());
			double aavg[3] = { 0., 0., 0. };
			for (uint j = 0; j < cp[i].face.size(); j++)
			{
				aavg[0] += pts_fc0[cp[i].face[j]][0];
				aavg[1] += pts_fc0[cp[i].face[j]][1];
				aavg[2] += pts_fc0[cp[i].face[j]][2];
			}
			aavg[0] /= double(cp[i].face.size());
			aavg[1] /= double(cp[i].face.size());
			aavg[2] /= double(cp[i].face.size());
			double mavg[3] = { 0., 0., 0. };
			for (uint j = 0; j < cp[i].edge.size(); j++)
			{
				mavg[0] += pts_ed0[cp[i].edge[j]][0];
				mavg[1] += pts_ed0[cp[i].edge[j]][1];
				mavg[2] += pts_ed0[cp[i].edge[j]][2];
			}
			mavg[0] /= double(cp[i].edge.size());
			mavg[1] /= double(cp[i].edge.size());
			mavg[2] /= double(cp[i].edge.size());
			cp[i].coor[0] = (cavg[0] + 3.*aavg[0] + 3.*mavg[0] + cp[i].coor[0]) / 8.;
			cp[i].coor[1] = (cavg[1] + 3.*aavg[1] + 3.*mavg[1] + cp[i].coor[1]) / 8.;
			cp[i].coor[2] = (cavg[2] + 3.*aavg[2] + 3.*mavg[2] + cp[i].coor[2]) / 8.;
		}
		else
		{
			if (cp[i].sharp == 0)
			{
				double aavg[3] = { 0., 0., 0. };
				int nfc(0);
				for (uint j = 0; j < cp[i].face.size(); j++)
				{
					if (tmface[cp[i].face[j]].type == 1)
					{
						aavg[0] += pts_fc0[cp[i].face[j]][0];
						aavg[1] += pts_fc0[cp[i].face[j]][1];
						aavg[2] += pts_fc0[cp[i].face[j]][2];
						nfc++;
					}
				}
				aavg[0] /= double(nfc); aavg[1] /= double(nfc); aavg[2] /= double(nfc);//nfc==2
				double mavg[3] = { 0., 0., 0. };
				int ned(0);
				for (uint j = 0; j < cp[i].edge.size(); j++)
				{
					if (tmedge[cp[i].edge[j]].type == 1)
					{
						mavg[0] += pts_ed0[cp[i].edge[j]][0];
						mavg[1] += pts_ed0[cp[i].edge[j]][1];
						mavg[2] += pts_ed0[cp[i].edge[j]][2];
						ned++;
					}
				}
				mavg[0] /= double(ned); mavg[1] /= double(ned); mavg[2] /= double(ned);
				cp[i].coor[0] = (aavg[0] + 2.*mavg[0] + double(nfc - 3)*cp[i].coor[0]) / double(nfc);
				cp[i].coor[1] = (aavg[1] + 2.*mavg[1] + double(nfc - 3)*cp[i].coor[1]) / double(nfc);
				cp[i].coor[2] = (aavg[2] + 2.*mavg[2] + double(nfc - 3)*cp[i].coor[2]) / double(nfc);
			}
			else if (cp[i].sharp == 1)//associated with sharp edge
			{
				double mavg[3] = { 0., 0., 0. };
				for (uint j = 0; j < cp[i].edge.size(); j++)
				{
					if (tmedge[cp[i].edge[j]].sharp == 1)
					{
						mavg[0] += pts_ed0[cp[i].edge[j]][0];
						mavg[1] += pts_ed0[cp[i].edge[j]][1];
						mavg[2] += pts_ed0[cp[i].edge[j]][2];
					}
				}
				cp[i].coor[0] = (mavg[0] + 2.*cp[i].coor[0]) / 4.;
				cp[i].coor[1] = (mavg[1] + 2.*cp[i].coor[1]) / 4.;
				cp[i].coor[2] = (mavg[2] + 2.*cp[i].coor[2]) / 4.;
			}
			else//sharp corner
			{
				cp[i].coor[0] = cp[i].coor[0]; cp[i].coor[1] = cp[i].coor[1]; cp[i].coor[2] = cp[i].coor[2];
			}
		}
	}
#pragma omp barrier
	//update cp
	vector<int> pid_vt(cp.size());
	vector<int> pid_ed(tmedge.size());
	vector<int> pid_fc(tmface.size());
	vector<int> pid_bd(tmesh.size());
	int count(0);
	for (int i = 0; i < cp.size(); i++)
	{
		pid_vt[i] = count++;
	}
	for (int i = 0; i < tmedge.size(); i++)
	{
		pid_ed[i] = count++;
		Vertex3D ptmp;
		ptmp.act = 1;
		if (tmedge[i].type == 1) ptmp.type = 1;//default 0
		if (tmedge[i].sharp == 1) ptmp.sharp = 1;//default 0
		if (tmedge[i].c0flag == 1) ptmp.c0flag = 1;//new
		if (tmedge[i].c0flag_b == 1) ptmp.c0flag_b = 1;//new
		ptmp.coor[0] = pts_ed[i][0]; ptmp.coor[1] = pts_ed[i][1]; ptmp.coor[2] = pts_ed[i][2];
		cp.push_back(ptmp);
	}
	for (int i = 0; i < tmface.size(); i++)
	{
		pid_fc[i] = count++;
		Vertex3D ptmp;
		ptmp.act = 1;
		if (tmface[i].type == 1) ptmp.type = 1;//default 0
		if (tmface[i].c0flag == 1) ptmp.c0flag = 1;//new
		ptmp.coor[0] = pts_fc[i][0]; ptmp.coor[1] = pts_fc[i][1]; ptmp.coor[2] = pts_fc[i][2];
		cp.push_back(ptmp);
	}
	for (int i = 0; i < tmesh.size(); i++)
	{
		pid_bd[i] = count++;
		Vertex3D ptmp;
		ptmp.act = 1;
		ptmp.coor[0] = pts_bd[i][0]; ptmp.coor[1] = pts_bd[i][1]; ptmp.coor[2] = pts_bd[i][2];
		cp.push_back(ptmp);
	}
	//update edge
	vector<Edge3D> ednew(2 * tmedge.size() + 4 * tmface.size() + 6 * tmesh.size());
	int edloc(0);
	for (int i = 0; i < tmedge.size(); i++)
	{
		ednew[edloc].pt[0] = tmedge[i].pt[0];
		ednew[edloc].pt[1] = pid_ed[i];
		ednew[edloc].type = tmedge[i].type;//
		ednew[edloc].sharp = tmedge[i].sharp;//
		ednew[edloc].c0flag = tmedge[i].c0flag;//new
		ednew[edloc].c0flag_b = tmedge[i].c0flag_b;//new
		edloc++;
		ednew[edloc].pt[0] = pid_ed[i];
		ednew[edloc].pt[1] = tmedge[i].pt[1];
		ednew[edloc].type = tmedge[i].type;//
		ednew[edloc].sharp = tmedge[i].sharp;//
		ednew[edloc].c0flag = tmedge[i].c0flag;//new
		ednew[edloc].c0flag_b = tmedge[i].c0flag_b;//new
		edloc++;
	}
	//update face
	vector<Face3D> fcnew(4 * tmface.size() + 12 * tmesh.size());
	int fcloc(0);
	for (int i = 0; i < tmface.size(); i++)
	{
		int fcnct[4][4] = { { tmface[i].cnct[0], pid_ed[tmface[i].edge[0]], pid_fc[i], pid_ed[tmface[i].edge[3]] },
		{ pid_ed[tmface[i].edge[0]], tmface[i].cnct[1], pid_ed[tmface[i].edge[1]], pid_fc[i] },
		{ pid_fc[i], pid_ed[tmface[i].edge[1]], tmface[i].cnct[2], pid_ed[tmface[i].edge[2]] },
		{ pid_ed[tmface[i].edge[3]], pid_fc[i], pid_ed[tmface[i].edge[2]], tmface[i].cnct[3] } };
		int edid[12];
		for (int j = 0; j < 4; j++)
		{
			edid[2 * j] = 2 * tmface[i].edge[j]; edid[2 * j + 1] = 2 * tmface[i].edge[j] + 1;
			if (tmedge[tmface[i].edge[j]].pt[0] != tmface[i].cnct[j])
			{
				edid[2 * j] = 2 * tmface[i].edge[j] + 1; edid[2 * j + 1] = 2 * tmface[i].edge[j];
			}
		}
		//construct 4 new edges
		for (int j = 0; j < 4; j++)
		{
			ednew[edloc].pt[0] = pid_fc[i];
			ednew[edloc].pt[1] = pid_ed[tmface[i].edge[j]];
			if (tmface[i].type == 1) ednew[edloc].type = 1;//boundary
			if (tmface[i].c0flag == 1) ednew[edloc].c0flag = 1;//new
			edid[8 + j] = edloc;
			edloc++;
		}
		int fedge[4][4] = { { edid[0], edid[8], edid[11], edid[7] }, { edid[1], edid[2], edid[9], edid[8] },
		{ edid[9], edid[3], edid[4], edid[10] }, { edid[11], edid[10], edid[5], edid[6] } };
		for (int j = 0; j < 4; j++)
		{
			fcnew[fcloc].type = tmface[i].type;//
			fcnew[fcloc].c0flag = tmface[i].c0flag;//new
			for (int k = 0; k < 4; k++)
			{
				fcnew[fcloc].cnct[k] = fcnct[j][k];
				fcnew[fcloc].edge[k] = fedge[j][k];
			}
			fcloc++;
		}
	}
	//update hex
	vector<Element3D> hxnew(8 * tmesh.size());
	int hxloc(0);
	for (int i = 0; i < tmesh.size(); i++)
	{
		//construct new edges
		for (int j = 0; j < 6; j++)
		{
			ednew[edloc].pt[0] = pid_bd[i];
			ednew[edloc].pt[1] = pid_fc[tmesh[i].face[j]];
			edloc++;
		}
		//construct new faces
		int fcnct[12][4] = { { pid_ed[tmesh[i].edge[0]], pid_fc[tmesh[i].face[0]], pid_bd[i], pid_fc[tmesh[i].face[1]] },
		{ pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[2]], pid_fc[tmesh[i].face[3]], pid_bd[i] },
		{ pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[10]], pid_fc[tmesh[i].face[5]] },
		{ pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[8]] },
		{ pid_ed[tmesh[i].edge[3]], pid_fc[tmesh[i].face[0]], pid_bd[i], pid_fc[tmesh[i].face[4]] },
		{ pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[1]], pid_fc[tmesh[i].face[2]], pid_bd[i] },
		{ pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[9]], pid_fc[tmesh[i].face[5]] },
		{ pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[11]] },
		{ pid_ed[tmesh[i].edge[4]], pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[4]] },
		{ pid_fc[tmesh[i].face[1]], pid_ed[tmesh[i].edge[5]], pid_fc[tmesh[i].face[2]], pid_bd[i] },
		{ pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[6]], pid_fc[tmesh[i].face[3]] },
		{ pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[7]] } };
		//collect all edges and faces in this element
		int edids[12 * 2 + 6 * 4 + 6], fcids[6 * 4 + 12];
		for (int j = 0; j < 12; j++)
		{
			edids[2 * j] = 2 * tmesh[i].edge[j];
			edids[2 * j + 1] = 2 * tmesh[i].edge[j] + 1;
			fcids[24 + j] = 4 * tmface.size() + 12 * i + j;
		}
		for (int j = 0; j < 6; j++)
		{
			edids[24 + 4 * j] = 2 * tmedge.size() + 4 * tmesh[i].face[j];
			edids[24 + 4 * j + 1] = 2 * tmedge.size() + 4 * tmesh[i].face[j] + 1;
			edids[24 + 4 * j + 2] = 2 * tmedge.size() + 4 * tmesh[i].face[j] + 2;
			edids[24 + 4 * j + 3] = 2 * tmedge.size() + 4 * tmesh[i].face[j] + 3;
			edids[48 + j] = 2 * tmedge.size() + 4 * tmface.size() + 6 * i + j;
			fcids[4 * j] = 4 * tmesh[i].face[j];
			fcids[4 * j + 1] = 4 * tmesh[i].face[j] + 1;
			fcids[4 * j + 2] = 4 * tmesh[i].face[j] + 2;
			fcids[4 * j + 3] = 4 * tmesh[i].face[j] + 3;
		}
		for (int j = 0; j < 12; j++)
		{
			for (int k = 0; k < 4; k++)
			{
				fcnew[fcloc].cnct[k] = fcnct[j][k];
				for (int k0 = 24; k0 < 54; k0++)
				{
					if ((fcnct[j][k] == ednew[edids[k0]].pt[0] && fcnct[j][(k + 1) % 4] == ednew[edids[k0]].pt[1]) ||
						(fcnct[j][k] == ednew[edids[k0]].pt[1] && fcnct[j][(k + 1) % 4] == ednew[edids[k0]].pt[0]))
					{
						fcnew[fcloc].edge[k] = edids[k0]; break;
					}
				}
			}
			fcloc++;
		}
		//construct new hex
		int ecnct[8][8] = { { tmesh[i].cnct[0], pid_ed[tmesh[i].edge[0]], pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[3]], pid_ed[tmesh[i].edge[4]], pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[4]] },
		{ pid_ed[tmesh[i].edge[0]], tmesh[i].cnct[1], pid_ed[tmesh[i].edge[1]], pid_fc[tmesh[i].face[0]], pid_fc[tmesh[i].face[1]], pid_ed[tmesh[i].edge[5]], pid_fc[tmesh[i].face[2]], pid_bd[i] },
		{ pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[1]], tmesh[i].cnct[2], pid_ed[tmesh[i].edge[2]], pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[6]], pid_fc[tmesh[i].face[3]] },
		{ pid_ed[tmesh[i].edge[3]], pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[2]], tmesh[i].cnct[3], pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[7]] },
		{ pid_ed[tmesh[i].edge[4]], pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[4]], tmesh[i].cnct[4], pid_ed[tmesh[i].edge[8]], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[11]] },
		{ pid_fc[tmesh[i].face[1]], pid_ed[tmesh[i].edge[5]], pid_fc[tmesh[i].face[2]], pid_bd[i], pid_ed[tmesh[i].edge[8]], tmesh[i].cnct[5], pid_ed[tmesh[i].edge[9]], pid_fc[tmesh[i].face[5]] },
		{ pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[6]], pid_fc[tmesh[i].face[3]], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[9]], tmesh[i].cnct[6], pid_ed[tmesh[i].edge[10]] },
		{ pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[7]], pid_ed[tmesh[i].edge[11]], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[10]], tmesh[i].cnct[7] } };
		for (int j = 0; j < 8; j++)
		{
			for (int k = 0; k < 8; k++)
			{
				hxnew[hxloc].cnct[k] = ecnct[j][k];
			}
			//find face connectivity
			for (int k = 0; k < 6; k++)
			{
				array<int, 4> tmp1 = { ecnct[j][solid_fc[k][0]], ecnct[j][solid_fc[k][1]], ecnct[j][solid_fc[k][2]], ecnct[j][solid_fc[k][3]] };
				sort(tmp1.begin(), tmp1.end());
				for (int k0 = 0; k0 < 36; k0++)
				{
					array<int, 4> tmp2 = { fcnew[fcids[k0]].cnct[0], fcnew[fcids[k0]].cnct[1], fcnew[fcids[k0]].cnct[2], fcnew[fcids[k0]].cnct[3] };
					sort(tmp2.begin(), tmp2.end());
					if (tmp1 == tmp2)
					{
						hxnew[hxloc].face[k] = fcids[k0]; break;
					}
				}
			}
			//find edge connectivity
			for (int k = 0; k < 12; k++)
			{
				array<int, 2> tmp1 = { ecnct[j][solid_ed[k][0]], ecnct[j][solid_ed[k][1]] };
				for (int k0 = 0; k0 < 54; k0++)
				{
					if ((tmp1[0] == ednew[edids[k0]].pt[0] && tmp1[1] == ednew[edids[k0]].pt[1]) ||
						(tmp1[0] == ednew[edids[k0]].pt[1] && tmp1[1] == ednew[edids[k0]].pt[0]))
					{
						hxnew[hxloc].edge[k] = edids[k0]; break;
					}
				}
			}
			hxloc++;
		}
	}//type of hex not assigned yet

	//refinement of Bezier patch
	BezierPatch_Refine(hxnew);

	//update connectivity
	tmedge.resize(ednew.size());
	tmface.resize(fcnew.size());
	tmesh.resize(hxnew.size());
	for (int i = 0; i < cp.size(); i++)
	{
		cp[i].edge.clear();
		cp[i].face.clear();
		cp[i].hex.clear();
	}
	for (int i = 0; i < ednew.size(); i++)
	{
		tmedge[i].act = 1;
		tmedge[i].type = ednew[i].type;
		tmedge[i].sharp = ednew[i].sharp;
		tmedge[i].c0flag = ednew[i].c0flag;
		tmedge[i].c0flag_b = ednew[i].c0flag_b;
		tmedge[i].pt[0] = ednew[i].pt[0]; tmedge[i].pt[1] = ednew[i].pt[1];
		tmedge[i].face.clear();
		tmedge[i].hex.clear();
	}
	for (int i = 0; i < fcnew.size(); i++)
	{
		tmface[i].act = 1;
		tmface[i].type = fcnew[i].type;
		tmface[i].c0flag = fcnew[i].c0flag;
		for (int j = 0; j < 4; j++)
		{
			tmface[i].cnct[j] = fcnew[i].cnct[j];
			tmface[i].edge[j] = fcnew[i].edge[j];
		}
		tmface[i].hex.clear();
	}
	for (int i = 0; i < hxnew.size(); i++)
	{
		tmesh[i].act = 1;
		//tmesh[i].type = hxnew[i].type;//problem
		tmesh[i].type = 0;
		for (int j = 0; j < 8; j++)
		{
			tmesh[i].cnct[j] = hxnew[i].cnct[j];
		}
		for (int j = 0; j < 12; j++)
		{
			tmesh[i].edge[j] = hxnew[i].edge[j];
		}
		for (int j = 0; j < 6; j++)
		{
			tmesh[i].face[j] = hxnew[i].face[j];
		}
	}

	//further treatment of Bezier patches
	FindBezierIEN(hxnew);

	//deconstruct hxnew, fcnew, ednew
	ClearRefineMemory(hxnew, fcnew, ednew);

	//vertex-to-hex, edge-to-hex, face-to-hex
	for (int i = 0; i<tmesh.size(); i++)
	{
		for (int j = 0; j<8; j++)
		{
			cp[tmesh[i].cnct[j]].hex.push_back(i);
		}
		for (int j = 0; j<12; j++)
		{
			tmedge[tmesh[i].edge[j]].hex.push_back(i);
		}
		for (int j = 0; j<6; j++)
		{
			tmface[tmesh[i].face[j]].hex.push_back(i);
		}
	}
	//vertex-to-face, edge-to-face
	for (int i = 0; i<tmface.size(); i++)
	{
		for (int j = 0; j<4; j++)
		{
			cp[tmface[i].cnct[j]].face.push_back(i);
			tmedge[tmface[i].edge[j]].face.push_back(i);
		}
	}
	//vertex-to-edge
	for (int i = 0; i<tmedge.size(); i++)
	{
		for (int j = 0; j<2; j++)
		{
			cp[tmedge[i].pt[j]].edge.push_back(i);
		}
	}
	//find extraordinary edges and vertices
	for (int i = 0; i<tmedge.size(); i++)
	{
		if (tmedge[i].type != 1 && tmedge[i].hex.size() != 4)
		{
			tmedge[i].type = 2;
			if (cp[tmedge[i].pt[0]].type != 1)
				cp[tmedge[i].pt[0]].type = 3;
			if (cp[tmedge[i].pt[1]].type != 1)
				cp[tmedge[i].pt[1]].type = 3;
		}
	}
	//find boundary and irregular elements
	for (int i = 0; i<tmesh.size(); i++)
	{
		tmesh[i].type = 0;
		for (int j = 0; j < 8; j++)
		{
			if (cp[tmesh[i].cnct[j]].type == 1)
			{
				tmesh[i].type = 1; break;
			}
		}
		if (tmesh[i].type != 1)
		{
			for (int j = 0; j<12; j++)
			{
				if (tmedge[tmesh[i].edge[j]].type == 2)
				{
					tmesh[i].type = 2;
					break;
				}
			}
			//additional
			for (int j = 0; j<8; j++)
			{
				if (cp[tmesh[i].cnct[j]].type == 3)
				{
					tmesh[i].type = 2;
					break;
				}
			}
		}
	}

	//boundry extraordinary points
	//for (int i = 0; i<cp.size(); i++)
	//{
	//	if (cp[i].type == 1)
	//	{
	//		int count(0);
	//		for (j = 0; j < cp[i].edge.size(); j++)
	//		{
	//			if (tmedge[cp[i].edge[j]].type == 2) count++;
	//		}
	//		if (count == 1) cp[i].bcxp = 1;
	//		else if (count>1) cp[i].bcxp = 2;
	//	}
	//}
}

void TruncatedTspline_3D::BezierExtract_C0C1Bezier(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			aloc[i] = count++;
		}
	}
	vector<int> bz_aflag(bzcp.size(), 0);
	vector<int> bz_aloc(bzcp.size(), -1);
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].bzflag == 1)
		{
			for (uint i = 0; i < tmesh[eid].IENc01.size(); i++)
			{
				bz_aflag[tmesh[eid].IENc01[i]] = 1;
			}
		}
	}
	for (uint i = 0; i < bz_aflag.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			bz_aloc[i] = count++;
		}
	}
	cpa.clear();
	cpa.resize(count);
	int loc(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			cpa[loc][0] = cp[i].coor[0];
			cpa[loc][1] = cp[i].coor[1];
			cpa[loc][2] = cp[i].coor[2];
			loc++;
		}
	}
	for (uint i = 0; i < bzcp.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			cpa[loc][0] = bzcp[i][0];
			cpa[loc][1] = bzcp[i][1];
			cpa[loc][2] = bzcp[i][2];
			loc++;
		}
	}

	IDBC.clear();
	IDBC.resize(count);
	for (uint i = 0; i < IDBC.size(); i++)
	{
		IDBC[i] = i;//boundary weakly imposed
	}
	gh.clear();
	gh.resize(IDBC.size(), 0.);//initial guess for iterative solvers
	//count = 0;
	//double xcoor[3];
	//array<double, 3> xcoor;
	//for (uint i = 0; i < cp.size(); i++)
	//{
	//	if (aflag[i] == 1)
	//	{
	//		xcoor[0] = cp[i].coor[0];
	//		xcoor[1] = cp[i].coor[1];
	//		xcoor[2] = cp[i].coor[2];
	//		//gh[count] = SpecifyDirichBC(xcoor);
	//		gh[count] = exact_sol(xcoor);
	//		count++;
	//	}
	//}
	//for (uint i = 0; i < bzcp.size(); i++)
	//{
	//	gh[count + i] = SpecifyDirichBC(bzcp[i].data());
	//}

	cout << "Bezier extracting...\n";
	cout << "# Bezier: " << tmesh.size() << "\n";
	bzmesh.resize(tmesh.size());
#pragma omp parallel for
	for (int eid = 0; eid < tmesh.size(); eid++)
	{
		if (eid != 0 && eid % 500 == 0)
		{
			cout << eid << " ";
		}
		//find types of interfaces
		if (tmesh[eid].type == 1)
		{
			for (int k = 0; k < 6; k++)
			{
				if (tmface[tmesh[eid].face[k]].hex.size() == 1)//must be a boundary element
				{
					bzmesh[eid].bc[k] = 1;//boundary face for boundary condition
					//bzmesh[eid].bcflag = 1;
				}
				//else if (tmface[tmesh[eid].face[k]].hex.size() == 2)
				//{
				//	int hxnb(tmface[tmesh[eid].face[k]].hex[0]);
				//	if (hxnb == eid) hxnb = tmface[tmesh[eid].face[k]].hex[1];
				//	if (tmesh[hxnb].bzflag == 0)
				//	{
				//		bzmesh[eid].bc[k] = 2;//coupling interface
				//		bzmesh[eid].bzcouple = 1;
				//	}
				//}
			}
		}

		double tmp;
		bzmesh[eid].type = tmesh[eid].type;//used for visualization
		//bzmesh[eid].bzflag = tmesh[eid].bzflag;//not used
		//if (bzmesh[eid].bzcouple == 0)
		{
			if (tmesh[eid].bzflag == 0)
			{
				int count1 = 0;
				for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
				{
					if (aloc[tmesh[eid].IEN[k]] != -1)
					{
						count1++;
					}
				}
				bzmesh[eid].IEN.resize(count1);
				bzmesh[eid].cmat.resize(count1, vector<double>(64, 0.));
				//if (bzmesh[eid].IEN.size() > 64)
				//{
				//	cerr << "bzflag 0 eid: " << eid << "\n";
				//	getchar();
				//}
				count1 = 0;
				for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
				{
					if (aloc[tmesh[eid].IEN[k]] != -1)
					{
						bzmesh[eid].IEN[count1] = aloc[tmesh[eid].IEN[k]];
						for (int k1 = 0; k1 < 64; k1++)
						{
							if (tmesh[eid].bemat[k][k1] != 0.)
							{
								tmp = tmesh[eid].bemat[k][k1];
								bzmesh[eid].cmat[count1][k1] = tmp;
								bzmesh[eid].pts[k1][0] += tmp * cp[tmesh[eid].IEN[k]].coor[0];
								bzmesh[eid].pts[k1][1] += tmp * cp[tmesh[eid].IEN[k]].coor[1];
								bzmesh[eid].pts[k1][2] += tmp * cp[tmesh[eid].IEN[k]].coor[2];
							}
						}
						count1++;
					}
				}
			}
			else if (tmesh[eid].bzflag == 1 || tmesh[eid].bzflag == 2)
			{
				int count2 = 0;
				for (uint k = 0; k < tmesh[eid].IENc2.size(); k++)
				{
					if (aloc[tmesh[eid].IENc2[k]] != -1)
					{
						count2++;
					}
				}
				//bzmesh[eid].IEN.resize(tmesh[eid].IENc01.size() + tmesh[eid].IENc2.size());
				bzmesh[eid].IEN.resize(tmesh[eid].IENc01.size() + count2);
				bzmesh[eid].cmat.resize(bzmesh[eid].IEN.size(), vector<double>(64, 0.));
				//if (bzmesh[eid].IEN.size() > 64)
				//{
				//	cerr << "bzflag 1 or 2 eid: " << eid << "\n";
				//	cout << tmesh[eid].IENc01.size() << " " << count2 << "\n";
				//	getchar();
				//}
				for (uint k = 0; k < tmesh[eid].IENc01.size(); k++)
				{
					bzmesh[eid].IEN[k] = bz_aloc[tmesh[eid].IENc01[k]];
					for (int k1 = 0; k1 < 64; k1++)
					{
						if (tmesh[eid].cmat[k][k1] != 0.)
						{
							tmp = tmesh[eid].cmat[k][k1];
							bzmesh[eid].cmat[k][k1] = tmp;
							bzmesh[eid].pts[k1][0] += tmp * bzcp[tmesh[eid].IENc01[k]][0];
							bzmesh[eid].pts[k1][1] += tmp * bzcp[tmesh[eid].IENc01[k]][1];
							bzmesh[eid].pts[k1][2] += tmp * bzcp[tmesh[eid].IENc01[k]][2];
						}
					}
				}
				int ist(tmesh[eid].IENc01.size());
				count2 = 0;
				for (uint k = 0; k < tmesh[eid].IENc2.size(); k++)
				{
					if (aloc[tmesh[eid].IENc2[k]] != -1)
					{
						int k0(ist + count2);
						bzmesh[eid].IEN[k0] = aloc[tmesh[eid].IENc2[k]];
						for (int k1 = 0; k1 < 64; k1++)
						{
							//if (tmesh[eid].cmat[k0][k1] != 0.)
							if (tmesh[eid].cmat[ist + k][k1] != 0.)
							{
								tmp = tmesh[eid].cmat[ist + k][k1];
								bzmesh[eid].cmat[k0][k1] = tmp;
								bzmesh[eid].pts[k1][0] += tmp * cp[tmesh[eid].IENc2[k]].coor[0];
								bzmesh[eid].pts[k1][1] += tmp * cp[tmesh[eid].IENc2[k]].coor[1];
								bzmesh[eid].pts[k1][2] += tmp * cp[tmesh[eid].IENc2[k]].coor[2];
							}
						}
						count2++;
					}
					
				}
				//for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
				//{
				//	bzmesh[eid].IENb[k] = tmesh[eid].IENb[k] + count;
				//	bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
				//	bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
				//	bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
				//}
			}
			//else if (tmesh[eid].bzflag == 2)
			//{
			//}
		}
		//else//bzflag must be 1
		//{
		//	bzmesh[eid].IEN.resize(tmesh[eid].IEN.size());
		//	bzmesh[eid].cmat.resize(tmesh[eid].IEN.size(), vector<double>(64));
		//	for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
		//	{
		//		bzmesh[eid].IEN[k] = aloc[tmesh[eid].IEN[k]];
		//		for (int k1 = 0; k1 < 64; k1++)
		//		{
		//			bzmesh[eid].cmat[k][k1] = tmesh[eid].bemat[k][k1];
		//		}
		//	}
		//	bzmesh[eid].IENb.resize(tmesh[eid].IENb.size());
		//	for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
		//	{
		//		bzmesh[eid].IENb[k] = tmesh[eid].IENb[k] + count;
		//		bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
		//		bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
		//		bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
		//	}
		//}
	}

	//for (uint i = 0; i < bzmesh.size(); i++)
	//{
	//	for (uint j = 0; j < 64; j++)
	//	{
	//		double sum(0.);
	//		for (uint k = 0; k < bzmesh[i].cmat.size(); k++)
	//		{
	//			sum += bzmesh[i].cmat[k][j];
	//		}
	//		if (fabs(sum - 1.)>1.e-6)
	//		{
	//			cout << sum << "\n";
	//		}
	//	}
	//}
	//cout << "oo\n"; getchar();
}

void TruncatedTspline_3D::EnlargeRefineRegion()
{
	int bzbd[8] = { 21, 22, 26, 25, 37, 38, 42, 41 };
	int bzfc[6][4] = { { 5, 6, 10, 9 }, { 17, 18, 34, 33 }, { 23, 27, 43, 39 }, { 29, 30, 46, 45 }, { 20, 24, 40, 36 }, { 53, 54, 58, 57 } };
	int bzed[12][2] = { { 1, 2 }, { 7, 11 }, { 13, 14 }, { 4, 8 }, { 16, 32 }, { 19, 35 }, { 31, 47 }, { 28, 44 }, { 49, 50 }, { 55, 59 }, { 61, 62 }, { 52, 56 } };
	int bzcn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };

	vector<int> ring1;
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 0)
		{
			uint i, j, flag(0);
			for (i = 0; i < 8; i++)
			{
				for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
				{
					if (tmesh[cp[tmesh[eid].cnct[i]].hex[j]].bzflag == 1)
					{
						flag = 1; break;
					}
				}
				if (flag == 1) break;
			}
			if (flag == 1)
			{
				ring1.push_back(eid);
			}
		}
	}
	for (uint i0 = 0; i0 < ring1.size(); i0++)//convert such elements to Bezier
	{
		int eid(ring1[i0]);//must be an interior element
		if (tmesh[eid].type != 1)
		{
			BuildElementSplines_Interior(eid);
		}
		else
		{
			BuildElementSplines_Boundary(eid);
		}

		tmesh[eid].IENb.clear();
		tmesh[eid].IENb.resize(64);
		vector<array<double, 3>> bzcpe(64);
		double tmp;
		for (int i = 0; i < 64; i++)
		{
			bzcpe[i][0] = 0.; bzcpe[i][1] = 0.; bzcpe[i][2] = 0.;
			for (int j = 0; j < tmesh[eid].IEN.size(); j++)
			{
				tmp = tmesh[eid].bemat[j][i];
				bzcpe[i][0] += tmp*cp[tmesh[eid].IEN[j]].coor[0];
				bzcpe[i][1] += tmp*cp[tmesh[eid].IEN[j]].coor[1];
				bzcpe[i][2] += tmp*cp[tmesh[eid].IEN[j]].coor[2];
			}
		}
		for (int i = 0; i < 8; i++)//body points
		{
			bzcp.push_back(bzcpe[bzbd[i]]);
			tmesh[eid].IENb[bzbd[i]] = bzcp.size() - 1;
		}
		for (int i = 0; i < 6; i++)//face points
		{
			if (tmface[tmesh[eid].face[i]].bzid.size() == 0)
			{
				for (int j = 0; j < 4; j++)
				{
					bzcp.push_back(bzcpe[bzfc[i][j]]);
					tmesh[eid].IENb[bzfc[i][j]] = bzcp.size() - 1;
					tmface[tmesh[eid].face[i]].bzid.push_back(tmesh[eid].IENb[bzfc[i][j]]);
				}
			}
			else
			{
				int fcid(tmesh[eid].face[i]);
				for (int j = 0; j < 4; j++)
				{
					int loc(-1), pfid;
					for (int k = 0; k < 4; k++)
					{
						pfid = tmface[fcid].bzid[k];
						tmp = (bzcpe[bzfc[i][j]][0] - bzcp[pfid][0])*(bzcpe[bzfc[i][j]][0] - bzcp[pfid][0]) +
							(bzcpe[bzfc[i][j]][1] - bzcp[pfid][1])*(bzcpe[bzfc[i][j]][1] - bzcp[pfid][1]) +
							(bzcpe[bzfc[i][j]][2] - bzcp[pfid][2])*(bzcpe[bzfc[i][j]][2] - bzcp[pfid][2]);
						tmp = sqrt(tmp);
						if (tmp < 1.e-6)
						{
							loc = pfid; break;
						}
					}
					if (loc == -1)
					{
						cerr << "Can't find existing face points in a face!\n"; getchar();
					}
					tmesh[eid].IENb[bzfc[i][j]] = loc;
				}
			}
		}
		for (int i = 0; i < 12; i++)//edge points
		{
			if (tmedge[tmesh[eid].edge[i]].bzid.size() == 0)
			{
				for (int j = 0; j < 2; j++)
				{
					bzcp.push_back(bzcpe[bzed[i][j]]);
					tmesh[eid].IENb[bzed[i][j]] = bzcp.size() - 1;
					tmedge[tmesh[eid].edge[i]].bzid.push_back(tmesh[eid].IENb[bzed[i][j]]);
				}
			}
			else
			{
				int edid(tmesh[eid].edge[i]);
				for (int j = 0; j < 2; j++)
				{
					int loc(-1), peid;
					for (int k = 0; k < 2; k++)
					{
						peid = tmedge[edid].bzid[k];
						tmp = (bzcpe[bzed[i][j]][0] - bzcp[peid][0])*(bzcpe[bzed[i][j]][0] - bzcp[peid][0]) +
							(bzcpe[bzed[i][j]][1] - bzcp[peid][1])*(bzcpe[bzed[i][j]][1] - bzcp[peid][1]) +
							(bzcpe[bzed[i][j]][2] - bzcp[peid][2])*(bzcpe[bzed[i][j]][2] - bzcp[peid][2]);
						tmp = sqrt(tmp);
						if (tmp < 1.e-6)
						{
							loc = peid; break;
						}
					}
					if (loc == -1)
					{
						cerr << "Can't find existing edge points in an edge!\n"; getchar();
					}
					tmesh[eid].IENb[bzed[i][j]] = loc;
				}
			}
		}
		for (int i = 0; i < 8; i++)//corner points
		{
			if (cp[tmesh[eid].cnct[i]].bzid == -1)
			{
				bzcp.push_back(bzcpe[bzcn[i]]);
				tmesh[eid].IENb[bzcn[i]] = bzcp.size() - 1;
				cp[tmesh[eid].cnct[i]].bzid = tmesh[eid].IENb[bzcn[i]];
			}
			else
			{
				tmesh[eid].IENb[bzcn[i]] = cp[tmesh[eid].cnct[i]].bzid;
			}
		}

		tmesh[eid].bzflag = 1;
	}
}


void TruncatedTspline_3D::UserDefineIDBC(vector<int>& IDBC, vector<double>& gh)
{
	double gh1, gh2;
	vector<int> BC1, BC2;
	string fn1("../io/yuxuan/fertility/bc1.txt"), fn2("../io/yuxuan/fertility/bc2.txt");
	ifstream fin;
	fin.open(fn1.c_str());
	if (fin.is_open())
	{
		string stmp;
		int npt;
		fin >> stmp >> npt >> gh1;
		BC1.resize(npt);
		for (int i = 0; i < npt; i++)
		{
			fin >> BC1[i];
		}
		fin.close();
	}
	else
	{
		cerr << "Can't open " << fn1 << "!\n";
	}
	fin.open(fn2.c_str());
	if (fin.is_open())
	{
		string stmp;
		int npt;
		fin >> stmp >> npt >> gh2;
		BC2.resize(npt);
		for (int i = 0; i < npt; i++)
		{
			fin >> BC2[i];
		}
		fin.close();
	}
	else
	{
		cerr << "Can't open " << fn2 << "!\n";
	}

	IDBC.clear();
	IDBC.resize(cp.size(), -1);
	gh.clear();
	gh.resize(cp.size(), 0.);
	vector<int> bcflag(cp.size(), 0);
	for (uint i = 0; i < BC1.size(); i++)
	{
		bcflag[BC1[i]] = 1;
	}
	for (uint i = 0; i < BC2.size(); i++)
	{
		bcflag[BC2[i]] = 2;
	}
	int count(0);
	for (uint i = 0; i < IDBC.size(); i++)
	{
		if (bcflag[i] == 0)
		{
			IDBC[i] = count++;
		}
		else if (bcflag[i] == 1)
		{
			gh[i] = gh1;
		}
		else if (bcflag[i] == 2)
		{
			gh[i] = gh2;
		}
	}
}

















void TruncatedTspline_3D::Run_C0Bezier(string fn, int nrf, vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	InitializeMesh(fn);
	BuildSplines_Unstruct();
	Convert2Bezier();
	for (int i = 0; i < nrf; i++)
	{
		Global_Subdivide_wBezier();//need modification for c0flags
	}
	BuildSplines_Unstruct();
	AddC0Bezier();
	//OutputGeom_C0("../io/global6/cube2");
	//BezierExtract_C0Bezier(bzmesh, IDBC, gh);
	BezierExtract_C0Bezier_1(bzmesh, IDBC, gh);

	StrongDirichletBC_C0(bzmesh, IDBC, gh);
}

void TruncatedTspline_3D::AddC0Bezier()
{
	cout << "Adding C0 functions...\n";

	int bzfc[6][4] = { { 5, 6, 10, 9 }, { 17, 18, 34, 33 }, { 23, 27, 43, 39 }, { 29, 30, 46, 45 }, { 20, 24, 40, 36 }, { 53, 54, 58, 57 } };
	int bzed[12][2] = { { 1, 2 }, { 7, 11 }, { 13, 14 }, { 4, 8 }, { 16, 32 }, { 19, 35 }, { 31, 47 }, { 28, 44 }, { 49, 50 }, { 55, 59 }, { 61, 62 }, { 52, 56 } };//
	int bzcn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };

	//find transition element
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 0)
		{
			uint i, j, hxid, flag(0);
			for (i = 0; i < 8; i++)
			{
				for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
				{
					hxid = cp[tmesh[eid].cnct[i]].hex[j];
					if (tmesh[hxid].bzflag == 1)
					{
						flag = 1; break;
					}
				}
				if (flag == 1) break;
			}
			if (flag == 1) tmesh[eid].bzflag = 2;
		}
	}

	for (uint i = 0; i < cp.size(); i++)
	{
		int flag(0);
		for (uint j = 0; j < cp[i].hex.size(); j++)
		{
			if (tmesh[cp[i].hex[j]].bzflag != 1) flag = 1;
		}
		if (flag == 0) cp[i].act = 0;
	}

	//add C0 functions to transition element
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 2)//must be an interior element
		{
			uint i, j, k;
			//get all bzpts first
			vector<array<double, 3>> bzcpe(64);
			double tmp;
			for (i = 0; i < 64; i++)
			{
				bzcpe[i][0] = 0.; bzcpe[i][1] = 0.; bzcpe[i][2] = 0.;
				for (int j = 0; j < tmesh[eid].IEN.size(); j++)
				{
					tmp = tmesh[eid].bemat[j][i];
					bzcpe[i][0] += tmp*cp[tmesh[eid].IEN[j]].coor[0];
					bzcpe[i][1] += tmp*cp[tmesh[eid].IEN[j]].coor[1];
					bzcpe[i][2] += tmp*cp[tmesh[eid].IEN[j]].coor[2];
				}
			}
			//check if any face neighbors with bzflag==1
			for (i = 0; i < 6; i++)
			{
				if (tmface[tmesh[eid].face[i]].bzid.size() != 0)
				{
					int fcid(tmesh[eid].face[i]);
					for (j = 0; j < 4; j++)
					{
						int loc(-1), pfid;
						for (k = 0; k < 4; k++)
						{
							pfid = tmface[fcid].bzid[k];
							tmp = (bzcpe[bzfc[i][j]][0] - bzcp[pfid][0])*(bzcpe[bzfc[i][j]][0] - bzcp[pfid][0]) +
								(bzcpe[bzfc[i][j]][1] - bzcp[pfid][1])*(bzcpe[bzfc[i][j]][1] - bzcp[pfid][1]) +
								(bzcpe[bzfc[i][j]][2] - bzcp[pfid][2])*(bzcpe[bzfc[i][j]][2] - bzcp[pfid][2]);
							tmp = sqrt(tmp);
							if (tmp < 1.e-6)
							{
								loc = pfid; break;
							}
						}
						if (loc == -1)
						{
							cerr << "Can't find existing face points in a face!\n"; getchar();
						}
						tmesh[eid].IENb.push_back(loc);
						tmesh[eid].IENb_loc.push_back(bzfc[i][j]);
						//truncation
						for (k = 0; k < tmesh[eid].IEN.size(); k++)
						{
							tmesh[eid].bemat[k][bzfc[i][j]] = 0.;
						}
					}
				}
			}
			for (i = 0; i < 12; i++)
			{
				if (tmedge[tmesh[eid].edge[i]].bzid.size() != 0)
				{
					int edid(tmesh[eid].edge[i]);
					for (j = 0; j < 2; j++)
					{
						int loc(-1), peid;
						for (k = 0; k < 2; k++)
						{
							peid = tmedge[edid].bzid[k];
							tmp = (bzcpe[bzed[i][j]][0] - bzcp[peid][0])*(bzcpe[bzed[i][j]][0] - bzcp[peid][0]) +
								(bzcpe[bzed[i][j]][1] - bzcp[peid][1])*(bzcpe[bzed[i][j]][1] - bzcp[peid][1]) +
								(bzcpe[bzed[i][j]][2] - bzcp[peid][2])*(bzcpe[bzed[i][j]][2] - bzcp[peid][2]);
							tmp = sqrt(tmp);
							if (tmp < 1.e-6)
							{
								loc = peid; break;
							}
						}
						if (loc == -1)
						{
							cerr << "Can't find existing edge points in an edge!\n"; getchar();
						}
						tmesh[eid].IENb.push_back(loc);
						tmesh[eid].IENb_loc.push_back(bzed[i][j]);
						//truncation
						for (k = 0; k < tmesh[eid].IEN.size(); k++)
						{
							tmesh[eid].bemat[k][bzed[i][j]] = 0.;
						}
					}
				}
			}
			for (i = 0; i < 8; i++)
			{
				if (cp[tmesh[eid].cnct[i]].bzid != -1)
				{
					tmesh[eid].IENb.push_back(cp[tmesh[eid].cnct[i]].bzid);
					tmesh[eid].IENb_loc.push_back(bzcn[i]);
					//truncation
					for (k = 0; k < tmesh[eid].IEN.size(); k++)
					{
						tmesh[eid].bemat[k][bzcn[i]] = 0.;
					}
				}
			}
			for (i = 0; i < tmesh[eid].IEN.size(); i++)
			{
				if (cp[tmesh[eid].IEN[i]].act == 1)
				{
					tmesh[eid].IENc2.push_back(tmesh[eid].IEN[i]);
					tmesh[eid].cmat.push_back(tmesh[eid].bemat[i]);
				}
			}
		}
	}

	cout << "Done adding!\n";
}

void TruncatedTspline_3D::OutputGeom_C0(string fn)
{
	cout << "Outputing geometry...\n";
	vector<array<double, 3>> spt;
	//vector<array<double, 3>> sval;
	//vector<double> ssum;
	vector<array<int, 8>> sele;
	vector<array<double, 3>> lpt;//visulize parameter lines
	vector<array<int, 2>> led;//line connectivity
	int ns(2), ne_ref(0), loc0, loc1, loc2;

	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].act == 1)
		{
			vector<double> su(ns), sv(ns), sw(ns);
			double ul[3] = { 1., 1., 1. };
			for (int i = 0; i<ns; i++)
			{
				su[i] = i*ul[0] / (ns - 1);
				sv[i] = i*ul[1] / (ns - 1);
				sw[i] = i*ul[2] / (ns - 1);
			}
			for (int a = 0; a<ns; a++)
			{
				for (int b = 0; b<ns; b++)
				{
					for (int c = 0; c < ns; c++)
					{
						array<double, 3> pt;
						array<double, 3> uval = { su[c], sv[b], sw[a] };
						GeomMap_C0(eid, uval.data(), pt.data());
						//double sumtmp = BasisSum(lev, eid, uval);
						//GeomMap_Lev(lev, eid, uval, pt);
						//double sumtmp = BasisSum_Lev(lev, eid, uval);
						spt.push_back(pt);
						//ssum.push_back(sumtmp);
						//if(a==0||a==ns-1||b==0||b==ns-1)
						//{
						//	lpt.push_back(pt);
						//}
					}
				}
			}

			for (int a = 0; a<ns - 1; a++)
			{
				for (int b = 0; b<ns - 1; b++)
				{
					for (int c = 0; c < ns - 1; c++)
					{
						array<int, 8> el;
						el[0] = ne_ref + a*ns*ns + b*ns + c;
						el[1] = ne_ref + a*ns*ns + b*ns + c + 1;
						el[2] = ne_ref + a*ns*ns + (b + 1)*ns + c + 1;
						el[3] = ne_ref + a*ns*ns + (b + 1)*ns + c;
						el[4] = ne_ref + (a + 1)*ns*ns + b*ns + c;
						el[5] = ne_ref + (a + 1)*ns*ns + b*ns + c + 1;
						el[6] = ne_ref + (a + 1)*ns*ns + (b + 1)*ns + c + 1;
						el[7] = ne_ref + (a + 1)*ns*ns + (b + 1)*ns + c;
						sele.push_back(el);
					}
				}
			}
			ne_ref += ns*ns*ns;
		}
	}

	string fname = fn + ".vtk";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << spt.size() << " float\n";
		for (uint i = 0; i<spt.size(); i++)
		{
			fout << spt[i][0] << " " << spt[i][1] << " " << spt[i][2] << "\n";
		}
		fout << "\nCELLS " << sele.size() << " " << 9 * sele.size() << '\n';
		for (uint i = 0; i<sele.size(); i++)
		{
			fout << "8 " << sele[i][0] << " " << sele[i][1] << " " << sele[i][2] << " " << sele[i][3] << " " << sele[i][4] << " " << sele[i][5] << " " << sele[i][6] << " " << sele[i][7] << '\n';
		}
		fout << "\nCELL_TYPES " << sele.size() << '\n';
		for (uint i = 0; i<sele.size(); i++)
		{
			fout << "12\n";
		}
		//fout << "\nPOINT_DATA " << ssum.size() << "\nSCALARS sum FLOAT\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<ssum.size(); i++)
		//{
		//	fout << ssum[i] << "\n";
		//}
		//fout<<"\nPOINT_DATA "<<sval.size()<<"\nNORMALS Normal FLOAT\n";
		//for(uint i=0;i<sval.size();i++)
		//{
		//	fout<<sval[i][0]<<" "<<sval[i][1]<<" "<<sval[i][2]<<"\n";
		//}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}

	cout << "Done outputing!\n";
}

void TruncatedTspline_3D::GeomMap_C0(int eid, double u[3], double pt[3])
{
	BezierElement3D bzel;
	vector<double> Bt;
	vector<array<double, 3>> dBdt;
	bzel.Basis(u[0], u[1], u[2], Bt, dBdt);
	pt[0] = 0.; pt[1] = 0.; pt[2] = 0.;
	if (tmesh[eid].bzflag == 2)
	{
		double Bx;
		for (uint i = 0; i < tmesh[eid].IENb.size(); i++)
		{
			pt[0] += Bt[tmesh[eid].IENb_loc[i]] * bzcp[tmesh[eid].IENb[i]][0];
			pt[1] += Bt[tmesh[eid].IENb_loc[i]] * bzcp[tmesh[eid].IENb[i]][1];
			pt[2] += Bt[tmesh[eid].IENb_loc[i]] * bzcp[tmesh[eid].IENb[i]][2];
		}
		for (uint i = 0; i < tmesh[eid].IENc2.size(); i++)
		{
			Bx = 0.;
			for (uint j = 0; j < tmesh[eid].cmat[i].size(); j++)
			{
				if (tmesh[eid].cmat[i][j] != 0.)
					Bx += tmesh[eid].cmat[i][j] * Bt[j];
			}
			pt[0] += Bx*cp[tmesh[eid].IENc2[i]].coor[0];
			pt[1] += Bx*cp[tmesh[eid].IENc2[i]].coor[1];
			pt[2] += Bx*cp[tmesh[eid].IENc2[i]].coor[2];
		}
	}
	else if (tmesh[eid].bzflag == 1)
	{
		for (uint i = 0; i < tmesh[eid].IENb.size(); i++)
		{
			pt[0] += Bt[i] * bzcp[tmesh[eid].IENb[i]][0];
			pt[1] += Bt[i] * bzcp[tmesh[eid].IENb[i]][1];
			pt[2] += Bt[i] * bzcp[tmesh[eid].IENb[i]][2];
		}
	}
	else if (tmesh[eid].bzflag == 0)
	{
		double Bx;
		for (uint i = 0; i < tmesh[eid].IEN.size(); i++)
		{
			Bx = 0.;
			for (uint j = 0; j < tmesh[eid].bemat[i].size(); j++)
			{
				if (tmesh[eid].bemat[i][j] != 0.)
					Bx += tmesh[eid].bemat[i][j] * Bt[j];
			}
			pt[0] += Bx*cp[tmesh[eid].IEN[i]].coor[0];
			pt[1] += Bx*cp[tmesh[eid].IEN[i]].coor[1];
			pt[2] += Bx*cp[tmesh[eid].IEN[i]].coor[2];
		}
	}
}

void TruncatedTspline_3D::BezierExtract_C0Bezier(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			aloc[i] = count++;
		}
	}
	IDBC.clear();
	IDBC.resize(count + bzcp.size());
	for (uint i = 0; i < IDBC.size(); i++)
	{
		IDBC[i] = i;//boundary weakly imposed
	}
	gh.clear();
	gh.resize(IDBC.size(), 0.);//initial guess for iterative solvers

	cout << "Bezier extracting...\n";
	cout << "# Bezier: " << tmesh.size() << "\n";
	bzmesh.resize(tmesh.size());
#pragma omp parallel for
	for (int eid = 0; eid < tmesh.size(); eid++)
	{
		if (eid != 0 && eid % 500 == 0)
		{
			cout << eid << " ";
		}
		//find types of interfaces
		if (tmesh[eid].bzflag == 1)
		{
			for (int k = 0; k < 6; k++)
			{
				if (tmface[tmesh[eid].face[k]].hex.size() == 1)//must be a boundary element
				{
					bzmesh[eid].bc[k] = 1;//boundary face for boundary condition
					bzmesh[eid].bcflag = 1;
				}
				//else if (tmface[tmesh[eid].face[k]].hex.size() == 2)
				//{
				//	int hxnb(tmface[tmesh[eid].face[k]].hex[0]);
				//	if (hxnb == eid) hxnb = tmface[tmesh[eid].face[k]].hex[1];
				//	if (tmesh[hxnb].bzflag == 0)
				//	{
				//		bzmesh[eid].bc[k] = 2;//coupling interface
				//		bzmesh[eid].bzcouple = 1;
				//	}
				//}
			}
		}

		double tmp;
		bzmesh[eid].type = tmesh[eid].type;//used for visualization
		//bzmesh[eid].bzflag = tmesh[eid].bzflag;
		if (tmesh[eid].bzflag == 1) bzmesh[eid].bzflag = 1;
		//if (bzmesh[eid].bzcouple == 0)
		{
			if (tmesh[eid].bzflag == 0)
			{
				bzmesh[eid].IEN.resize(tmesh[eid].IEN.size());
				bzmesh[eid].cmat.resize(tmesh[eid].IEN.size(), vector<double>(64));
				for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
				{
					bzmesh[eid].IEN[k] = aloc[tmesh[eid].IEN[k]];//some IEN may be -1
					for (int k1 = 0; k1 < 64; k1++)
					{
						tmp = tmesh[eid].bemat[k][k1];
						bzmesh[eid].cmat[k][k1] = tmp;
						bzmesh[eid].pts[k1][0] += tmp * cp[tmesh[eid].IEN[k]].coor[0];
						bzmesh[eid].pts[k1][1] += tmp * cp[tmesh[eid].IEN[k]].coor[1];
						bzmesh[eid].pts[k1][2] += tmp * cp[tmesh[eid].IEN[k]].coor[2];
					}
				}
			}
			else if (tmesh[eid].bzflag == 1)
			{
				bzmesh[eid].IENb.resize(tmesh[eid].IENb.size());//64
				for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
				{
					bzmesh[eid].IENb[k] = tmesh[eid].IENb[k] + count;
					bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
					bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
					bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
				}
			}
			else if (tmesh[eid].bzflag == 2)
			{
				bzmesh[eid].IEN.resize(tmesh[eid].IENb.size() + tmesh[eid].IENc2.size());
				bzmesh[eid].cmat.resize(bzmesh[eid].IEN.size(), vector<double>(64, 0.));
				for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
				{
					bzmesh[eid].IEN[k] = tmesh[eid].IENb[k] + count;
					bzmesh[eid].cmat[k][tmesh[eid].IENb_loc[k]] = 1.;
					bzmesh[eid].pts[tmesh[eid].IENb_loc[k]][0] = bzcp[tmesh[eid].IENb[k]][0];
					bzmesh[eid].pts[tmesh[eid].IENb_loc[k]][1] = bzcp[tmesh[eid].IENb[k]][1];
					bzmesh[eid].pts[tmesh[eid].IENb_loc[k]][2] = bzcp[tmesh[eid].IENb[k]][2];
				}
				for (uint k = 0; k < tmesh[eid].IENc2.size(); k++)
				{
					int k0(tmesh[eid].IENb.size() + k);
					bzmesh[eid].IEN[k0] = aloc[tmesh[eid].IENc2[k]];//some IEN may be -1
					for (int k1 = 0; k1 < 64; k1++)
					{
						tmp = tmesh[eid].cmat[k][k1];
						bzmesh[eid].cmat[k0][k1] = tmp;
						bzmesh[eid].pts[k1][0] += tmp * cp[tmesh[eid].IENc2[k]].coor[0];
						bzmesh[eid].pts[k1][1] += tmp * cp[tmesh[eid].IENc2[k]].coor[1];
						bzmesh[eid].pts[k1][2] += tmp * cp[tmesh[eid].IENc2[k]].coor[2];
					}
				}
			}
		}
		//else//bzflag must be 1
		//{
		//	bzmesh[eid].IEN.resize(tmesh[eid].IEN.size());
		//	bzmesh[eid].cmat.resize(tmesh[eid].IEN.size(), vector<double>(64));
		//	for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
		//	{
		//		bzmesh[eid].IEN[k] = aloc[tmesh[eid].IEN[k]];
		//		for (int k1 = 0; k1 < 64; k1++)
		//		{
		//			bzmesh[eid].cmat[k][k1] = tmesh[eid].bemat[k][k1];
		//		}
		//	}
		//	bzmesh[eid].IENb.resize(tmesh[eid].IENb.size());
		//	for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
		//	{
		//		bzmesh[eid].IENb[k] = tmesh[eid].IENb[k] + count;
		//		bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
		//		bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
		//		bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
		//	}
		//}
	}
}

void TruncatedTspline_3D::BezierExtract_C0Bezier_1(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			aloc[i] = count++;
		}
	}
	IDBC.clear();
	IDBC.resize(count + bzcp.size());
	for (uint i = 0; i < IDBC.size(); i++)
	{
		IDBC[i] = i;//boundary weakly imposed
	}
	gh.clear();
	gh.resize(IDBC.size(), 0.);//initial guess for iterative solvers

	cout << "Bezier extracting...\n";
	cout << "# Bezier: " << tmesh.size() << "\n";
	bzmesh.resize(tmesh.size());
#pragma omp parallel for
	for (int eid = 0; eid < tmesh.size(); eid++)
	{
		if (eid != 0 && eid % 500 == 0)
		{
			cout << eid << " ";
		}
		//find types of interfaces
		if (tmesh[eid].bzflag == 1)
		{
			for (int k = 0; k < 6; k++)
			{
				if (tmface[tmesh[eid].face[k]].hex.size() == 1)//must be a boundary element
				{
					bzmesh[eid].bc[k] = 1;//boundary face for boundary condition
					bzmesh[eid].bcflag = 1;
				}
				//else if (tmface[tmesh[eid].face[k]].hex.size() == 2)
				//{
				//	int hxnb(tmface[tmesh[eid].face[k]].hex[0]);
				//	if (hxnb == eid) hxnb = tmface[tmesh[eid].face[k]].hex[1];
				//	if (tmesh[hxnb].bzflag == 0)
				//	{
				//		bzmesh[eid].bc[k] = 2;//coupling interface
				//		bzmesh[eid].bzcouple = 1;
				//	}
				//}
			}
		}

		double tmp;
		bzmesh[eid].type = tmesh[eid].type;//used for visualization
		//bzmesh[eid].bzflag = tmesh[eid].bzflag;
		//if (tmesh[eid].bzflag == 1) bzmesh[eid].bzflag = 1;
		//if (bzmesh[eid].bzcouple == 0)
		{
			if (tmesh[eid].bzflag == 0)
			{
				bzmesh[eid].IEN.resize(tmesh[eid].IEN.size());
				bzmesh[eid].cmat.resize(tmesh[eid].IEN.size(), vector<double>(64));
				for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
				{
					bzmesh[eid].IEN[k] = aloc[tmesh[eid].IEN[k]];//some IEN may be -1
					for (int k1 = 0; k1 < 64; k1++)
					{
						tmp = tmesh[eid].bemat[k][k1];
						bzmesh[eid].cmat[k][k1] = tmp;
						bzmesh[eid].pts[k1][0] += tmp * cp[tmesh[eid].IEN[k]].coor[0];
						bzmesh[eid].pts[k1][1] += tmp * cp[tmesh[eid].IEN[k]].coor[1];
						bzmesh[eid].pts[k1][2] += tmp * cp[tmesh[eid].IEN[k]].coor[2];
					}
				}
			}
			else if (tmesh[eid].bzflag == 1)
			{
				//bzmesh[eid].IENb.resize(tmesh[eid].IENb.size());//64
				bzmesh[eid].IEN.resize(tmesh[eid].IENb.size());//64
				bzmesh[eid].cmat.resize(bzmesh[eid].IEN.size(), vector<double>(64, 0.));
				for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
				{
					bzmesh[eid].IEN[k] = tmesh[eid].IENb[k] + count;
					bzmesh[eid].cmat[k][k] = 1.;
					bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
					bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
					bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
				}
			}
			else if (tmesh[eid].bzflag == 2)
			{
				bzmesh[eid].IEN.resize(tmesh[eid].IENb.size() + tmesh[eid].IENc2.size());
				bzmesh[eid].cmat.resize(bzmesh[eid].IEN.size(), vector<double>(64, 0.));
				for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
				{
					bzmesh[eid].IEN[k] = tmesh[eid].IENb[k] + count;
					bzmesh[eid].cmat[k][tmesh[eid].IENb_loc[k]] = 1.;
					bzmesh[eid].pts[tmesh[eid].IENb_loc[k]][0] = bzcp[tmesh[eid].IENb[k]][0];
					bzmesh[eid].pts[tmesh[eid].IENb_loc[k]][1] = bzcp[tmesh[eid].IENb[k]][1];
					bzmesh[eid].pts[tmesh[eid].IENb_loc[k]][2] = bzcp[tmesh[eid].IENb[k]][2];
				}
				for (uint k = 0; k < tmesh[eid].IENc2.size(); k++)
				{
					int k0(tmesh[eid].IENb.size() + k);
					bzmesh[eid].IEN[k0] = aloc[tmesh[eid].IENc2[k]];//some IEN may be -1
					for (int k1 = 0; k1 < 64; k1++)
					{
						tmp = tmesh[eid].cmat[k][k1];
						bzmesh[eid].cmat[k0][k1] = tmp;
						bzmesh[eid].pts[k1][0] += tmp * cp[tmesh[eid].IENc2[k]].coor[0];
						bzmesh[eid].pts[k1][1] += tmp * cp[tmesh[eid].IENc2[k]].coor[1];
						bzmesh[eid].pts[k1][2] += tmp * cp[tmesh[eid].IENc2[k]].coor[2];
					}
				}
			}
		}
		//else//bzflag must be 1
		//{
		//	bzmesh[eid].IEN.resize(tmesh[eid].IEN.size());
		//	bzmesh[eid].cmat.resize(tmesh[eid].IEN.size(), vector<double>(64));
		//	for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
		//	{
		//		bzmesh[eid].IEN[k] = aloc[tmesh[eid].IEN[k]];
		//		for (int k1 = 0; k1 < 64; k1++)
		//		{
		//			bzmesh[eid].cmat[k][k1] = tmesh[eid].bemat[k][k1];
		//		}
		//	}
		//	bzmesh[eid].IENb.resize(tmesh[eid].IENb.size());
		//	for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
		//	{
		//		bzmesh[eid].IENb[k] = tmesh[eid].IENb[k] + count;
		//		bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
		//		bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
		//		bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
		//	}
		//}
	}
}













void TruncatedTspline_3D::Run_C02iBezier(string fn, int nrf, vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	InitializeMesh(fn);
	InitializeC0Component_C02i();
	//OutputCM(fn);
	//ReportDiffEleNumber();
	BuildSplines_Unstruct();
	Convert2Bezier();
	for (int i = 0; i < nrf; i++)
	{
		Global_Subdivide_C0C1Bezier();//need modification for c0flags
		//EnlargeRefineRegion();
	}
	BuildSplines_Unstruct();
	AddC0C1Bezier_C02i();
	TruncateC02i();
	//OutputGeom_C0C1("../io/global8/cube1");
	//OutputGeom_C0C1("../io/yuxuan/cube1"); getchar();
	BezierExtract_C0C1Bezier(bzmesh, IDBC, gh);

	//PatchTest_BC(IDBC, gh);//only for patch test on a unit cube
	//StrongDirichletBC(bzmesh, IDBC, gh);
	//StrongDirichletBC_Elasticity(bzmesh, IDBC, gh);
	//StrongDirichletBC_Elasticity_FromFile(bzmesh, IDBC, gh);
	//StrongDirichletBC_Poisson_FromFile(bzmesh, IDBC, gh);
	//WeakDirichletBC_Poisson_FromFile(bzmesh, IDBC, gh);
	StrongDirichletBC_Elasticity_Coor(bzmesh, IDBC, gh);

	TTSP3D_Clear();
}

void TruncatedTspline_3D::InitializeC0Component_C02i()
{
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].act == 1 && (tmesh[eid].type == 2 || tmesh[eid].type == 1))//interior irregular element
		{
			for (int i = 0; i < 8; i++)
			{
				cp[tmesh[eid].cnct[i]].c0flag = 1;
			}
			for (int i = 0; i < 12; i++)
			{
				tmedge[tmesh[eid].edge[i]].c0flag = 1;
			}
			for (int i = 0; i < 6; i++)
			{
				tmface[tmesh[eid].face[i]].c0flag = 1;
			}
		}
	}
}

void TruncatedTspline_3D::AddC0C1Bezier_C02i()
{
	cout << "Adding C0 and C1 functions...\n";

	//all boundary elements have bzflag==1
	//all c0flag assigned only to interior faces, edges and vertices
	//all c0flag_b assigned only to boundary edges and vertices
	//all boundary faces converted to 2D Bezier meshes

	int bzbd[8] = { 21, 22, 26, 25, 37, 38, 42, 41 };
	int cmb_bd2fc[8][3] = { { 5, 17, 20 }, { 6, 18, 23 }, { 10, 27, 30 }, { 9, 29, 24 }, { 33, 36, 53 }, { 34, 39, 54 }, { 43, 46, 58 }, { 45, 40, 57 } };
	int loc_bd2fc[8][3] = { { 0, 1, 4 }, { 0, 1, 2 }, { 0, 2, 3 }, { 0, 3, 4 }, { 1, 4, 5 }, { 1, 2, 5 }, { 2, 3, 5 }, { 3, 4, 5 } };
	int cmb_bd2ed[8][3] = { { 1, 4, 16 }, { 2, 7, 19 }, { 11, 14, 31 }, { 13, 8, 28 }, { 32, 49, 52 }, { 35, 50, 55 }, { 47, 59, 62 }, { 44, 61, 56 } };
	int loc_bd2ed[8][3] = { { 0, 3, 4 }, { 0, 1, 5 }, { 1, 2, 6 }, { 2, 3, 7 }, { 4, 8, 11 }, { 5, 8, 9 }, { 6, 9, 10 }, { 7, 10, 11 } };
	int cmb_bd2cn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };//same as bzcn

	int bzfc[6][4] = { { 5, 6, 10, 9 }, { 17, 18, 34, 33 }, { 23, 27, 43, 39 }, { 29, 30, 46, 45 }, { 20, 24, 40, 36 }, { 53, 54, 58, 57 } };
	int bzed[12][2] = { { 1, 2 }, { 7, 11 }, { 13, 14 }, { 4, 8 }, { 16, 32 }, { 19, 35 }, { 31, 47 }, { 28, 44 }, { 49, 50 }, { 55, 59 }, { 61, 62 }, { 52, 56 } };//
	int bzcn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };

	int fc_cn[6][4] = { { 0, 1, 2, 3 }, { 0, 1, 5, 4 }, { 1, 2, 6, 5 }, { 3, 2, 6, 7 }, { 0, 3, 7, 4 }, { 4, 5, 6, 7 } };//corresponding to bzfc
	int fc_ed[6][4] = { { 0, 1, 2, 3 }, { 0, 5, 8, 4 }, { 1, 6, 9, 5 }, { 2, 6, 10, 7 }, { 3, 7, 11, 4 }, { 8, 9, 10, 11 } };
	int bzfc_ed[6][4][2] = { { { 1, 4 }, { 7, 2 }, { 14, 11 }, { 8, 13 } }, { { 1, 16 }, { 19, 2 }, { 50, 35 }, { 32, 49 } }, { { 7, 19 }, { 31, 11 }, { 59, 47 }, { 35, 55 } },
	{ { 13, 28 }, { 31, 14 }, { 62, 47 }, { 44, 61 } }, { { 4, 16 }, { 28, 8 }, { 56, 44 }, { 32, 52 } }, { { 49, 52 }, { 55, 50 }, { 62, 59 }, { 56, 61 } } };
	int ed_cn[12][2] = { { 0, 1 }, { 1, 2 }, { 3, 2 }, { 0, 3 }, { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 5 }, { 5, 6 }, { 7, 6 }, { 4, 7 } };//corresponding to bzed

	int cmb_fc2ed[6][4][2] = { { { 4, 1 }, { 2, 7 }, { 11, 14 }, { 13, 8 } }, { { 16, 1, }, { 2, 19 }, { 35, 50 }, { 49, 32 } }, { { 19, 7 }, { 11, 31 }, { 47, 59 }, { 55, 35 } },
	{ { 28, 13 }, { 14, 31 }, { 47, 62 }, { 61, 44 } }, { { 16, 4 }, { 8, 28 }, { 44, 56 }, { 52, 32 } }, { { 52, 49 }, { 50, 55 }, { 59, 62 }, { 61, 56 } } };
	int loc_fc2ed[6][4][2] = { { { 3, 0 }, { 0, 1 }, { 1, 2 }, { 2, 3 } }, { { 4, 0 }, { 0, 5 }, { 5, 8 }, { 8, 4 } }, { { 5, 1 }, { 1, 6 }, { 6, 9 }, { 9, 5 } },
	{ { 7, 2 }, { 2, 6 }, { 6, 10 }, { 10, 7 } }, { { 4, 3 }, { 3, 7 }, { 7, 11 }, { 11, 4 } }, { { 11, 8 }, { 8, 9 }, { 9, 10 }, { 10, 11 } } };
	int cmb_fc2cn[6][4] = { { 0, 3, 15, 12 }, { 0, 3, 51, 48 }, { 3, 15, 63, 51 }, { 12, 15, 63, 60 }, { 0, 12, 60, 48 }, { 48, 51, 63, 60 } };
	//int loc_fc2cn[6][4] = {};//same as fc_cn

	for (uint eid = 0; eid < tmesh.size(); eid++)//add C1 splines
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 1)//all boundary elements have bzflag == 1
		{
			uint i, j;
			for (i = 0; i < 8; i++)
			{
				tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzbd[i]]);
				vector<double> coef(64, 0.);
				coef[bzbd[i]] = 1.;
				for (j = 0; j < 3; j++)
				{
					if (tmface[tmesh[eid].face[loc_bd2fc[i][j]]].c0flag == 0 && tmface[tmesh[eid].face[loc_bd2fc[i][j]]].type != 1)
						coef[cmb_bd2fc[i][j]] = 0.5;
					if (tmedge[tmesh[eid].edge[loc_bd2ed[i][j]]].c0flag == 0 && tmedge[tmesh[eid].edge[loc_bd2ed[i][j]]].type != 1)
						coef[cmb_bd2ed[i][j]] = 0.25;
				}
				if (cp[tmesh[eid].cnct[i]].c0flag == 0 && cp[tmesh[eid].cnct[i]].type != 1) coef[cmb_bd2cn[i]] = 0.125;
				tmesh[eid].cmat.push_back(coef);
			}
		}
	}
	for (uint eid = 0; eid < tmesh.size(); eid++)//add C0 Bezier
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 1)//all boundary elements have bzflag == 1
		{
			uint i, j;
			for (i = 0; i < 6; i++)//add face points
			{
				if (tmface[tmesh[eid].face[i]].c0flag == 1 || tmface[tmesh[eid].face[i]].type == 1)//interior face with c0flag==1 or boundary face
				{
					for (j = 0; j < 4; j++)
					{
						tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzfc[i][j]]);
						vector<double> coef(64, 0.);
						coef[bzfc[i][j]] = 1.;
						tmesh[eid].cmat.push_back(coef);
					}
				}
			}
			for (i = 0; i < 12; i++)//add edge points
			{
				if (tmedge[tmesh[eid].edge[i]].c0flag == 1 || tmedge[tmesh[eid].edge[i]].type == 1)
				{
					for (j = 0; j < 2; j++)
					{
						tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzed[i][j]]);
						vector<double> coef(64, 0.);
						coef[bzed[i][j]] = 1.;
						tmesh[eid].cmat.push_back(coef);
					}
				}
			}
			for (i = 0; i < 8; i++)//add corner points
			{
				if (cp[tmesh[eid].cnct[i]].c0flag == 1 || cp[tmesh[eid].cnct[i]].type == 1)
				{
					tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzcn[i]]);
					vector<double> coef(64, 0.);
					coef[bzcn[i]] = 1.;
					tmesh[eid].cmat.push_back(coef);
				}
			}
		}
	}

	for (uint eid = 0; eid < tmesh.size(); eid++)//add neighboring influence
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 1)
		{
			uint i, j;
			vector<int> enb;
			for (i = 0; i < 6; i++)//influence from face neighbor
			{
				int fcnb(-1);
				if (tmface[tmesh[eid].face[i]].type == 0)//interior
				{
					fcnb = tmface[tmesh[eid].face[i]].hex[0];
					if (fcnb == eid) fcnb = tmface[tmesh[eid].face[i]].hex[1];
					enb.push_back(fcnb);
				}
				if (fcnb != -1)
				{
					if (tmesh[fcnb].bzflag == 1)
					{
						for (j = 0; j < 4; j++)
						{
							int* it = find(tmesh[fcnb].cnct, tmesh[fcnb].cnct + 8, tmesh[eid].cnct[fc_cn[i][j]]);
							int loc(it - tmesh[fcnb].cnct);
							vector<double> coef(64, 0.);
							int add_flag(0);
							if (tmface[tmesh[eid].face[i]].c0flag == 0 && tmface[tmesh[eid].face[i]].type != 1)
							{
								add_flag = 1;
								coef[bzfc[i][j]] = 0.5;
							}
							if (tmedge[tmesh[eid].edge[fc_ed[i][j]]].c0flag == 0 && tmedge[tmesh[eid].edge[fc_ed[i][j]]].type != 1)
							{
								add_flag = 1;
								coef[bzfc_ed[i][j][0]] = 0.25;
							}
							if (tmedge[tmesh[eid].edge[fc_ed[i][(j + 3) % 4]]].c0flag == 0 && tmedge[tmesh[eid].edge[fc_ed[i][(j + 3) % 4]]].type != 1)
							{
								add_flag = 1;
								coef[bzfc_ed[i][j][1]] = 0.25;
							}
							if (cp[tmesh[eid].cnct[fc_cn[i][j]]].c0flag == 0 && cp[tmesh[eid].cnct[fc_cn[i][j]]].type != 1)
							{
								add_flag = 1;
								coef[bzcn[fc_cn[i][j]]] = 0.125;
							}
							if (add_flag == 1)
							{
								tmesh[eid].IENc01.push_back(tmesh[fcnb].IENc01[loc]);
								tmesh[eid].cmat.push_back(coef);
							}
						}
					}
				}
			}
			for (i = 0; i < 12; i++)//influence from edge neighbor
			{
				int ednb(-1);
				for (j = 0; j < tmedge[tmesh[eid].edge[i]].hex.size(); j++)
				{
					int hxid(tmedge[tmesh[eid].edge[i]].hex[j]);
					if (hxid != eid)
					{
						vector<int>::iterator it = find(enb.begin(), enb.end(), hxid);
						if (it == enb.end())
						{
							enb.push_back(hxid);
							if (tmedge[tmesh[eid].edge[i]].type != 1/* && tmedge[tmesh[eid].edge[i]].c0flag == 0*/)
								ednb = hxid;
						}
					}
				}
				if (tmedge[tmesh[eid].edge[i]].type != 1 && ednb != -1)//must be an interior edge
				{
					if (tmesh[ednb].bzflag == 1)
					{
						for (j = 0; j < 2; j++)
						{
							int* it = find(tmesh[ednb].cnct, tmesh[ednb].cnct + 8, tmesh[eid].cnct[ed_cn[i][j]]);
							int loc(it - tmesh[ednb].cnct);
							vector<double> coef(64, 0.);
							int add_flag(0);
							if (tmedge[tmesh[eid].edge[i]].c0flag == 0)//already known as an interior edge
							{
								add_flag = 1;
								coef[bzed[i][j]] = 0.25;
							}
							if (cp[tmesh[eid].cnct[ed_cn[i][j]]].c0flag == 0 && cp[tmesh[eid].cnct[ed_cn[i][j]]].type != 1)
							{
								add_flag = 1;
								coef[bzcn[ed_cn[i][j]]] = 0.125;
							}
							if (add_flag == 1)
							{
								tmesh[eid].IENc01.push_back(tmesh[ednb].IENc01[loc]);
								tmesh[eid].cmat.push_back(coef);
							}
						}
					}
				}
			}
			for (i = 0; i < 8; i++)//influence from corner neighbor
			{
				if (cp[tmesh[eid].cnct[i]].c0flag == 0 && cp[tmesh[eid].cnct[i]].type != 1)
				{
					int cnnb(-1);
					for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
					{
						int hxid(cp[tmesh[eid].cnct[i]].hex[j]);
						if (hxid != eid)
						{
							vector<int>::iterator it = find(enb.begin(), enb.end(), hxid);
							if (it == enb.end())
							{
								cnnb = hxid; break;
							}
						}
					}
					if (cnnb != -1)
					{
						if (tmesh[cnnb].bzflag == 1)
						{
							int* it = find(tmesh[cnnb].cnct, tmesh[cnnb].cnct + 8, tmesh[eid].cnct[i]);
							int loc(it - tmesh[cnnb].cnct);
							vector<double> coef(64, 0.);
							coef[bzcn[i]] = 0.125;
							tmesh[eid].IENc01.push_back(tmesh[cnnb].IENc01[loc]);
							tmesh[eid].cmat.push_back(coef);
						}
					}
					else
					{
						cerr << "Can't find cnnb even though cp.c0flag==0!\n"; getchar();
					}
				}
			}
		}
	}

	//find transition element
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 0)
		{
			uint i, j, hxid, flag(0);
			for (i = 0; i < 8; i++)
			{
				for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
				{
					hxid = cp[tmesh[eid].cnct[i]].hex[j];
					if (tmesh[hxid].bzflag == 1)
					{
						flag = 1; break;
					}
				}
				if (flag == 1) break;
			}
			if (flag == 1) tmesh[eid].bzflag = 2;
		}
	}
	//add C0 functions to transition element
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 2)//must be an interior element
		{
			uint i, j, k;
			vector<array<double, 3>> bzcpe(64);
			double tmp;
			for (i = 0; i < 64; i++)
			{
				bzcpe[i][0] = 0.; bzcpe[i][1] = 0.; bzcpe[i][2] = 0.;
				for (int j = 0; j < tmesh[eid].IEN.size(); j++)
				{
					tmp = tmesh[eid].bemat[j][i];
					bzcpe[i][0] += tmp*cp[tmesh[eid].IEN[j]].coor[0];
					bzcpe[i][1] += tmp*cp[tmesh[eid].IEN[j]].coor[1];
					bzcpe[i][2] += tmp*cp[tmesh[eid].IEN[j]].coor[2];
				}
			}
			for (i = 0; i < 6; i++)//add face points
			{
				if (tmface[tmesh[eid].face[i]].bzid.size() != 0)//interior face with c0flag==1 or boundary face
				{
					int fcid(tmesh[eid].face[i]);
					for (j = 0; j < 4; j++)
					{
						int loc(-1), pfid;
						for (k = 0; k < 4; k++)
						{
							pfid = tmface[fcid].bzid[k];
							tmp = (bzcpe[bzfc[i][j]][0] - bzcp[pfid][0])*(bzcpe[bzfc[i][j]][0] - bzcp[pfid][0]) +
								(bzcpe[bzfc[i][j]][1] - bzcp[pfid][1])*(bzcpe[bzfc[i][j]][1] - bzcp[pfid][1]) +
								(bzcpe[bzfc[i][j]][2] - bzcp[pfid][2])*(bzcpe[bzfc[i][j]][2] - bzcp[pfid][2]);
							tmp = sqrt(tmp);
							if (tmp < 1.e-6)
							{
								loc = pfid; break;
							}
						}
						if (loc == -1)
						{
							cerr << "Can't find existing face points in a face!\n"; getchar();
						}
						tmesh[eid].IENc01.push_back(loc);
						vector<double> coef(64, 0.);
						coef[bzfc[i][j]] = 1.;
						tmesh[eid].cmat.push_back(coef);
					}
				}
			}
			for (i = 0; i < 12; i++)//add edge points
			{
				if (tmedge[tmesh[eid].edge[i]].bzid.size() != 0)
				{
					int edid(tmesh[eid].edge[i]);
					for (j = 0; j < 2; j++)
					{
						int loc(-1), peid;
						for (k = 0; k < 2; k++)
						{
							peid = tmedge[edid].bzid[k];
							tmp = (bzcpe[bzed[i][j]][0] - bzcp[peid][0])*(bzcpe[bzed[i][j]][0] - bzcp[peid][0]) +
								(bzcpe[bzed[i][j]][1] - bzcp[peid][1])*(bzcpe[bzed[i][j]][1] - bzcp[peid][1]) +
								(bzcpe[bzed[i][j]][2] - bzcp[peid][2])*(bzcpe[bzed[i][j]][2] - bzcp[peid][2]);
							tmp = sqrt(tmp);
							if (tmp < 1.e-6)
							{
								loc = peid; break;
							}
						}
						if (loc == -1)
						{
							cerr << "Can't find existing edge points in an edge!\n"; getchar();
						}
						tmesh[eid].IENc01.push_back(loc);
						vector<double> coef(64, 0.);
						coef[bzed[i][j]] = 1.;
						tmesh[eid].cmat.push_back(coef);
					}
				}
			}
			for (i = 0; i < 8; i++)//add corner points
			{
				if (cp[tmesh[eid].cnct[i]].bzid != -1)
				{
					tmesh[eid].IENc01.push_back(cp[tmesh[eid].cnct[i]].bzid);
					vector<double> coef(64, 0.);
					coef[bzcn[i]] = 1.;
					tmesh[eid].cmat.push_back(coef);
				}
			}
		}
	}

	cout << "Done adding!\n";
}

void TruncatedTspline_3D::TruncateC02i()
{
	int bzfc[6][4] = { { 5, 6, 10, 9 }, { 17, 18, 34, 33 }, { 23, 27, 43, 39 }, { 29, 30, 46, 45 }, { 20, 24, 40, 36 }, { 53, 54, 58, 57 } };
	int bzed[12][2] = { { 1, 2 }, { 7, 11 }, { 13, 14 }, { 4, 8 }, { 16, 32 }, { 19, 35 }, { 31, 47 }, { 28, 44 }, { 49, 50 }, { 55, 59 }, { 61, 62 }, { 52, 56 } };//
	int bzcn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };

	cout << "Performing truncation...\n";
	//determine active C2 functions first
	for (uint i = 0; i < cp.size(); i++)
	{
		int flag(0);
		for (uint j = 0; j < cp[i].hex.size(); j++)
		{
			if (tmesh[cp[i].hex[j]].bzflag != 1) flag = 1;
		}
		if (flag == 0) cp[i].act = 0;
	}

	//#pragma omp parallel for
	vector<int> etrun2;
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 2)
		{
			etrun2.push_back(eid);
		}
	}

#pragma omp parallel for
	for (int i0 = 0; i0 < etrun2.size(); i0++)
	{
		int eid(etrun2[i0]);
		uint i, j, k;
		for (i = 0; i < 6; i++)
		{
			if (tmface[tmesh[eid].face[i]].bzid.size() != 0)
			{
				for (j = 0; j < tmesh[eid].IEN.size(); j++)
				{
					for (k = 0; k < 4; k++)
					{
						tmesh[eid].bemat[j][bzfc[i][k]] = 0.;
					}
				}
			}
		}
		for (i = 0; i < 12; i++)
		{
			if (tmedge[tmesh[eid].edge[i]].bzid.size() != 0)
			{
				for (j = 0; j < tmesh[eid].IEN.size(); j++)
				{
					tmesh[eid].bemat[j][bzed[i][0]] = 0.;
					tmesh[eid].bemat[j][bzed[i][1]] = 0.;
				}
			}
		}
		for (i = 0; i < 8; i++)
		{
			if (cp[tmesh[eid].cnct[i]].bzid != -1)
			{
				for (j = 0; j < tmesh[eid].IEN.size(); j++)
				{
					tmesh[eid].bemat[j][bzcn[i]] = 0.;
				}
			}
		}

		for (i = 0; i < tmesh[eid].IEN.size(); i++)
		{
			if (cp[tmesh[eid].IEN[i]].act == 1)
			{
				tmesh[eid].IENc2.push_back(tmesh[eid].IEN[i]);
				tmesh[eid].cmat.push_back(tmesh[eid].bemat[i]);
			}
		}
	}

	cout << "Done truncating!\n";
}

void TruncatedTspline_3D::TTSP3D_Clear()
{
	for (uint i = 0; i < cp.size(); i++)
	{
		vector<int>().swap(cp[i].edge);
		vector<int>().swap(cp[i].face);
		vector<int>().swap(cp[i].hex);
	}
	vector<Vertex3D>().swap(cp);

	for (uint i = 0; i < tmedge.size(); i++)
	{
		vector<int>().swap(tmedge[i].face);
		vector<int>().swap(tmedge[i].hex);
		vector<int>().swap(tmedge[i].mpid);
		vector<int>().swap(tmedge[i].bzid);
	}
	vector<Edge3D>().swap(tmedge);

	for (uint i = 0; i < tmface.size(); i++)
	{
		vector<int>().swap(tmface[i].hex);
		vector<int>().swap(tmface[i].chd);
		vector<int>().swap(tmface[i].mpid);
		vector<int>().swap(tmface[i].bzid);
	}
	vector<Face3D>().swap(tmface);

	for (uint i = 0; i < tmesh.size(); i++)
	{
		vector<int>().swap(tmesh[i].chd);
		vector<int>().swap(tmesh[i].IEN);
		vector<int>().swap(tmesh[i].IENtmp);
		vector<int>().swap(tmesh[i].IENb);
		vector<int>().swap(tmesh[i].IENb_loc);
		vector<int>().swap(tmesh[i].IENc01);
		vector<int>().swap(tmesh[i].IENc2);

		for (uint j = 0; j < tmesh[i].bemat.size(); j++)
		{
			vector<double>().swap(tmesh[i].bemat[j]);
		}
		vector<vector<double>>().swap(tmesh[i].bemat);

		for (uint j = 0; j < tmesh[i].tmat.size(); j++)
		{
			vector<double>().swap(tmesh[i].tmat[j]);
		}
		vector<vector<double>>().swap(tmesh[i].tmat);

		vector<array<int, 2>>().swap(tmesh[i].IEN_act);
		vector<array<double, 3>>().swap(tmesh[i].bzpt);

		for (uint j = 0; j < tmesh[i].cmat.size(); j++)
		{
			vector<double>().swap(tmesh[i].cmat[j]);
		}
		vector<vector<double>>().swap(tmesh[i].cmat);
	}
	vector<Element3D>().swap(tmesh);

	vector<array<double, 3>>().swap(bzcp);
}





///////////////////////////////////////////////////////////////////////////
////C012 construction with improved boundary
//void TruncatedTspline_3D::Run_C012ib(string fn, int nrf, vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
//{
//	InitializeMesh(fn);//need change
//	InitializeC0Component_C012ib();
//	//OutputCM(fn);
//	//ReportDiffEleNumber();
//	BuildSplines_Unstruct();
//	Convert2Bezier();
//	for (int i = 0; i < nrf; i++)
//	{
//		Global_Subdivide_C0C1Bezier();//need modification for c0flags
//									  //EnlargeRefineRegion();
//	}
//	BuildSplines_Unstruct();
//	AddC0C1Bezier();
//	TruncateC0C1();
//	//OutputGeom_C0C1("../io/global5/cube2");
//	BezierExtract_C0C1Bezier(bzmesh, IDBC, gh);
//
//	PatchTest_BC(IDBC, gh);
//	//StrongDirichletBC(bzmesh, IDBC, gh);
//}
//
//void TruncatedTspline_3D::InitializeC0Component_C012ib()
//{
//	//treat boundary components (i.e. vertices, edges and faces) and interior ones separately
//	//C0 interior faces, C0 continuity across such faces that are connected to extraordinary edges
//	for (uint i = 0; i < tmedge.size(); i++)
//	{
//		if (tmedge[i].type == 2)//must be interior
//		{
//			tmedge[i].c0flag = 1;
//			for (uint j = 0; j < tmedge[i].face.size(); j++)
//			{
//				tmface[tmedge[i].face[j]].c0flag = 1;
//			}
//			for (int j = 0; j < 2; j++)
//			{
//				if (cp[tmedge[i].pt[j]].type != 1)
//					cp[tmedge[i].pt[j]].c0flag = 1;
//				//if (cp[tmedge[i].pt[j]].type == 1)//boundary
//				//{
//				//	//cp[tmedge[i].pt[j]].c0flag_b = 1;
//				//}
//			}
//		}
//		else if (tmedge[i].type == 1)//boundary
//		{
//			if (tmedge[i].sharp == 1)
//			{
//				tmedge[i].c0flag_b = 1;
//				for (uint j = 0; j < tmedge[i].face.size(); j++)
//				{
//					if (tmface[tmedge[i].face[j]].type == 0)
//					{
//						tmface[tmedge[i].face[j]].c0flag = 1;
//					}
//				}
//			}
//			else
//			{
//				if (tmedge[i].face.size() != 3)//boundary extraordinary edges
//				{
//					tmedge[i].c0flag_b = 1;
//					for (uint j = 0; j < tmedge[i].face.size(); j++)
//					{
//						if (tmface[tmedge[i].face[j]].type == 0)
//						{
//							tmface[tmedge[i].face[j]].c0flag = 1;
//						}
//					}
//				}
//			}
//		}
//	}
//
//	for (uint i = 0; i < cp.size(); i++)
//	{
//		if (cp[i].type == 3)
//		{
//			cp[i].c0flag = 1;
//		}
//		else if (cp[i].type == 1)
//		{
//			if (cp[i].sharp != 0)
//			{
//				cp[i].c0flag_b = 1;
//			}
//			else
//			{
//				int nv_b(0), nv_i(0);
//				for (uint j = 0; j < cp[i].edge.size(); j++)
//				{
//					if (tmedge[cp[i].edge[j]].type == 1) nv_b++;
//					else nv_i++;
//				}
//				if (nv_i != 1 || nv_b != 4)
//				{
//					cp[i].c0flag_b = 1;
//					for (uint j = 0; j < cp[i].edge.size(); j++)
//					{
//						if (tmedge[cp[i].edge[j]].type != 1)
//						{
//							tmedge[cp[i].edge[j]].c0flag = 1;
//						}
//						else
//						{
//							tmedge[cp[i].edge[j]].c0flag_b = 1;
//						}
//					}
//					for (uint j = 0; j < cp[i].face.size(); j++)
//					{
//						if (tmface[cp[i].face[j]].type != 1)
//						{
//							tmface[cp[i].face[j]].c0flag = 1;
//						}
//					}
//				}
//			}
//		}
//	}
//}
//
//void TruncatedTspline_3D::AddC0C1Bezier()
//{
//	cout << "Adding C0 and C1 functions...\n";
//
//	//all boundary elements have bzflag==1
//	//all c0flag assigned only to interior faces, edges and vertices
//	//all c0flag_b assigned only to boundary edges and vertices
//	//all boundary faces converted to 2D Bezier meshes
//
//	int bzbd[8] = { 21, 22, 26, 25, 37, 38, 42, 41 };
//	int cmb_bd2fc[8][3] = { { 5, 17, 20 },{ 6, 18, 23 },{ 10, 27, 30 },{ 9, 29, 24 },{ 33, 36, 53 },{ 34, 39, 54 },{ 43, 46, 58 },{ 45, 40, 57 } };
//	int loc_bd2fc[8][3] = { { 0, 1, 4 },{ 0, 1, 2 },{ 0, 2, 3 },{ 0, 3, 4 },{ 1, 4, 5 },{ 1, 2, 5 },{ 2, 3, 5 },{ 3, 4, 5 } };
//	int cmb_bd2ed[8][3] = { { 1, 4, 16 },{ 2, 7, 19 },{ 11, 14, 31 },{ 13, 8, 28 },{ 32, 49, 52 },{ 35, 50, 55 },{ 47, 59, 62 },{ 44, 61, 56 } };
//	int loc_bd2ed[8][3] = { { 0, 3, 4 },{ 0, 1, 5 },{ 1, 2, 6 },{ 2, 3, 7 },{ 4, 8, 11 },{ 5, 8, 9 },{ 6, 9, 10 },{ 7, 10, 11 } };
//	int cmb_bd2cn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };//same as bzcn
//
//	int bzfc[6][4] = { { 5, 6, 10, 9 },{ 17, 18, 34, 33 },{ 23, 27, 43, 39 },{ 29, 30, 46, 45 },{ 20, 24, 40, 36 },{ 53, 54, 58, 57 } };
//	int bzed[12][2] = { { 1, 2 },{ 7, 11 },{ 13, 14 },{ 4, 8 },{ 16, 32 },{ 19, 35 },{ 31, 47 },{ 28, 44 },{ 49, 50 },{ 55, 59 },{ 61, 62 },{ 52, 56 } };//
//	int bzcn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };
//
//	int fc_cn[6][4] = { { 0, 1, 2, 3 },{ 0, 1, 5, 4 },{ 1, 2, 6, 5 },{ 3, 2, 6, 7 },{ 0, 3, 7, 4 },{ 4, 5, 6, 7 } };//corresponding to bzfc
//	int fc_ed[6][4] = { { 0, 1, 2, 3 },{ 0, 5, 8, 4 },{ 1, 6, 9, 5 },{ 2, 6, 10, 7 },{ 3, 7, 11, 4 },{ 8, 9, 10, 11 } };
//	int bzfc_ed[6][4][2] = { { { 1, 4 },{ 7, 2 },{ 14, 11 },{ 8, 13 } },{ { 1, 16 },{ 19, 2 },{ 50, 35 },{ 32, 49 } },{ { 7, 19 },{ 31, 11 },{ 59, 47 },{ 35, 55 } },
//	{ { 13, 28 },{ 31, 14 },{ 62, 47 },{ 44, 61 } },{ { 4, 16 },{ 28, 8 },{ 56, 44 },{ 32, 52 } },{ { 49, 52 },{ 55, 50 },{ 62, 59 },{ 56, 61 } } };
//	int ed_cn[12][2] = { { 0, 1 },{ 1, 2 },{ 3, 2 },{ 0, 3 },{ 0, 4 },{ 1, 5 },{ 2, 6 },{ 3, 7 },{ 4, 5 },{ 5, 6 },{ 7, 6 },{ 4, 7 } };//corresponding to bzed
//
//	int cmb_fc2ed[6][4][2] = { { { 4, 1 },{ 2, 7 },{ 11, 14 },{ 13, 8 } },{ { 16, 1, },{ 2, 19 },{ 35, 50 },{ 49, 32 } },{ { 19, 7 },{ 11, 31 },{ 47, 59 },{ 55, 35 } },
//	{ { 28, 13 },{ 14, 31 },{ 47, 62 },{ 61, 44 } },{ { 16, 4 },{ 8, 28 },{ 44, 56 },{ 52, 32 } },{ { 52, 49 },{ 50, 55 },{ 59, 62 },{ 61, 56 } } };
//	int loc_fc2ed[6][4][2] = { { { 3, 0 },{ 0, 1 },{ 1, 2 },{ 2, 3 } },{ { 4, 0 },{ 0, 5 },{ 5, 8 },{ 8, 4 } },{ { 5, 1 },{ 1, 6 },{ 6, 9 },{ 9, 5 } },
//	{ { 7, 2 },{ 2, 6 },{ 6, 10 },{ 10, 7 } },{ { 4, 3 },{ 3, 7 },{ 7, 11 },{ 11, 4 } },{ { 11, 8 },{ 8, 9 },{ 9, 10 },{ 10, 11 } } };
//	int cmb_fc2cn[6][4] = { { 0, 3, 15, 12 },{ 0, 3, 51, 48 },{ 3, 15, 63, 51 },{ 12, 15, 63, 60 },{ 0, 12, 60, 48 },{ 48, 51, 63, 60 } };
//	//int loc_fc2cn[6][4] = {};//same as fc_cn
//
//	for (uint eid = 0; eid < tmesh.size(); eid++)//add C1 splines
//	{
//		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 1)//all boundary elements have bzflag == 1
//		{
//			uint i, j;
//			for (i = 0; i < 8; i++)
//			{
//				tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzbd[i]]);
//				vector<double> coef(64, 0.);
//				coef[bzbd[i]] = 1.;
//				for (j = 0; j < 3; j++)
//				{
//					if (tmface[tmesh[eid].face[loc_bd2fc[i][j]]].c0flag == 0 && tmface[tmesh[eid].face[loc_bd2fc[i][j]]].type != 1)
//						coef[cmb_bd2fc[i][j]] = 0.5;
//					if (tmedge[tmesh[eid].edge[loc_bd2ed[i][j]]].c0flag == 0 && tmedge[tmesh[eid].edge[loc_bd2ed[i][j]]].type != 1)
//						coef[cmb_bd2ed[i][j]] = 0.25;
//				}
//				if (cp[tmesh[eid].cnct[i]].c0flag == 0 && cp[tmesh[eid].cnct[i]].type != 1) coef[cmb_bd2cn[i]] = 0.125;
//				tmesh[eid].cmat.push_back(coef);
//			}
//		}
//	}
//	for (uint eid = 0; eid < tmesh.size(); eid++)//add C0 Bezier
//	{
//		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 1)//all boundary elements have bzflag == 1
//		{
//			uint i, j;
//			for (i = 0; i < 6; i++)//add face points
//			{
//				if (tmface[tmesh[eid].face[i]].c0flag == 1 || tmface[tmesh[eid].face[i]].type == 1)//interior face with c0flag==1 or boundary face
//				{
//					for (j = 0; j < 4; j++)
//					{
//						tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzfc[i][j]]);
//						//tmesh[eid].IENc0_loc.push_back(bzfc[i][j]);
//						//if (tmface[tmesh[eid].face[i]].type == 1) tmesh[eid].IENc01_b.push_back(tmesh[eid].IENb[bzfc[i][j]]);
//						vector<double> coef(64, 0.);
//						coef[bzfc[i][j]] = 1.;//not consider neighboring influence from face first for simplification
//											  //if (tmedge[tmesh[eid].edge[loc_fc2ed[i][j][0]]].type == 1 && tmedge[tmesh[eid].edge[loc_fc2ed[i][j][0]]].c0flag_b == 0)//boundary
//											  //	coef[cmb_fc2ed[i][j][0]] = 0.5;
//											  //if (tmedge[tmesh[eid].edge[loc_fc2ed[i][j][1]]].type == 1 && tmedge[tmesh[eid].edge[loc_fc2ed[i][j][1]]].c0flag_b == 0)//boundary
//											  //	coef[cmb_fc2ed[i][j][1]] = 0.5;
//											  //if (cp[tmesh[eid].cnct[fc_cn[i][j]]].type == 1 && cp[tmesh[eid].cnct[fc_cn[i][j]]].c0flag_b == 0)//boundary
//											  //	coef[cmb_fc2cn[i][j]] = 0.25;
//						tmesh[eid].cmat.push_back(coef);
//					}
//				}
//			}
//			for (i = 0; i < 12; i++)//add edge points
//			{
//				if (tmedge[tmesh[eid].edge[i]].c0flag == 1 || tmedge[tmesh[eid].edge[i]].type == 1)
//				{
//					for (j = 0; j < 2; j++)
//					{
//						tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzed[i][j]]);
//						//tmesh[eid].IENc0_loc.push_back(bzed[i][j]);
//						vector<double> coef(64, 0.);
//						coef[bzed[i][j]] = 1.;
//						tmesh[eid].cmat.push_back(coef);
//					}
//				}
//			}
//			for (i = 0; i < 8; i++)//add corner points
//			{
//				if (cp[tmesh[eid].cnct[i]].c0flag == 1 || cp[tmesh[eid].cnct[i]].type == 1)
//				{
//					tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzcn[i]]);
//					//tmesh[eid].IENc0_loc.push_back(bzcn[i]);
//					vector<double> coef(64, 0.);
//					coef[bzcn[i]] = 1.;
//					tmesh[eid].cmat.push_back(coef);
//				}
//			}
//		}
//	}
//
//	for (uint eid = 0; eid < tmesh.size(); eid++)//add neighboring influence
//	{
//		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 1)
//		{
//			uint i, j;
//			vector<int> enb;
//			for (i = 0; i < 6; i++)//influence from face neighbor
//			{
//				int fcnb(-1);
//				if (tmface[tmesh[eid].face[i]].type == 0)//interior
//				{
//					fcnb = tmface[tmesh[eid].face[i]].hex[0];
//					if (fcnb == eid) fcnb = tmface[tmesh[eid].face[i]].hex[1];
//					enb.push_back(fcnb);
//				}
//				if (fcnb != -1)
//				{
//					if (tmesh[fcnb].bzflag == 1)
//					{
//						for (j = 0; j < 4; j++)
//						{
//							int* it = find(tmesh[fcnb].cnct, tmesh[fcnb].cnct + 8, tmesh[eid].cnct[fc_cn[i][j]]);
//							int loc(it - tmesh[fcnb].cnct);
//							vector<double> coef(64, 0.);
//							int add_flag(0);
//							if (tmface[tmesh[eid].face[i]].c0flag == 0 && tmface[tmesh[eid].face[i]].type != 1)
//							{
//								add_flag = 1;
//								coef[bzfc[i][j]] = 0.5;
//							}
//							if (tmedge[tmesh[eid].edge[fc_ed[i][j]]].c0flag == 0 && tmedge[tmesh[eid].edge[fc_ed[i][j]]].type != 1)
//							{
//								add_flag = 1;
//								coef[bzfc_ed[i][j][0]] = 0.25;
//							}
//							if (tmedge[tmesh[eid].edge[fc_ed[i][(j + 3) % 4]]].c0flag == 0 && tmedge[tmesh[eid].edge[fc_ed[i][(j + 3) % 4]]].type != 1)
//							{
//								add_flag = 1;
//								coef[bzfc_ed[i][j][1]] = 0.25;
//							}
//							if (cp[tmesh[eid].cnct[fc_cn[i][j]]].c0flag == 0 && cp[tmesh[eid].cnct[fc_cn[i][j]]].type != 1)
//							{
//								add_flag = 1;
//								coef[bzcn[fc_cn[i][j]]] = 0.125;
//							}
//							if (add_flag == 1)
//							{
//								tmesh[eid].IENc01.push_back(tmesh[fcnb].IENc01[loc]);
//								tmesh[eid].cmat.push_back(coef);
//							}
//						}
//					}
//					//else
//					//{
//					//	//tmesh[fcnb].bzflag = 2;//transition, later need to add C1 contributions to such elements
//					//}
//				}
//			}
//			for (i = 0; i < 12; i++)//influence from edge neighbor
//			{
//				int ednb(-1);
//				for (j = 0; j < tmedge[tmesh[eid].edge[i]].hex.size(); j++)
//				{
//					int hxid(tmedge[tmesh[eid].edge[i]].hex[j]);
//					if (hxid != eid)
//					{
//						vector<int>::iterator it = find(enb.begin(), enb.end(), hxid);
//						if (it == enb.end())
//						{
//							enb.push_back(hxid);
//							if (tmedge[tmesh[eid].edge[i]].type != 1/* && tmedge[tmesh[eid].edge[i]].c0flag == 0*/)
//								ednb = hxid;
//						}
//					}
//				}
//				if (tmedge[tmesh[eid].edge[i]].type != 1 && ednb != -1)//must be an interior edge
//				{
//					if (tmesh[ednb].bzflag == 1)
//					{
//						for (j = 0; j < 2; j++)
//						{
//							int* it = find(tmesh[ednb].cnct, tmesh[ednb].cnct + 8, tmesh[eid].cnct[ed_cn[i][j]]);
//							int loc(it - tmesh[ednb].cnct);
//							vector<double> coef(64, 0.);
//							int add_flag(0);
//							if (tmedge[tmesh[eid].edge[i]].c0flag == 0)//already known as an interior edge
//							{
//								add_flag = 1;
//								coef[bzed[i][j]] = 0.25;
//							}
//							if (cp[tmesh[eid].cnct[ed_cn[i][j]]].c0flag == 0 && cp[tmesh[eid].cnct[ed_cn[i][j]]].type != 1)
//							{
//								add_flag = 1;
//								coef[bzcn[ed_cn[i][j]]] = 0.125;
//							}
//							if (add_flag == 1)
//							{
//								tmesh[eid].IENc01.push_back(tmesh[ednb].IENc01[loc]);
//								tmesh[eid].cmat.push_back(coef);
//							}
//						}
//					}
//					//else
//					//{
//					//	//tmesh[ednb].bzflag = 2;
//					//}
//				}
//			}
//			for (i = 0; i < 8; i++)//influence from corner neighbor
//			{
//				if (cp[tmesh[eid].cnct[i]].c0flag == 0 && cp[tmesh[eid].cnct[i]].type != 1)
//				{
//					int cnnb(-1);
//					for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
//					{
//						int hxid(cp[tmesh[eid].cnct[i]].hex[j]);
//						if (hxid != eid)
//						{
//							vector<int>::iterator it = find(enb.begin(), enb.end(), hxid);
//							if (it == enb.end())
//							{
//								cnnb = hxid; break;
//							}
//						}
//					}
//					if (cnnb != -1)
//					{
//						if (tmesh[cnnb].bzflag == 1)
//						{
//							int* it = find(tmesh[cnnb].cnct, tmesh[cnnb].cnct + 8, tmesh[eid].cnct[i]);
//							int loc(it - tmesh[cnnb].cnct);
//							vector<double> coef(64, 0.);
//							coef[bzcn[i]] = 0.125;
//							tmesh[eid].IENc01.push_back(tmesh[cnnb].IENc01[loc]);
//							tmesh[eid].cmat.push_back(coef);
//						}
//						//else
//						//{
//						//	//tmesh[cnnb].bzflag = 2;
//						//}
//					}
//					else
//					{
//						cerr << "Can't find cnnb even though cp.c0flag==0!\n"; getchar();
//					}
//				}
//			}
//		}
//	}
//
//	//AddC0C1Bezier_Boundary();
//
//	//boundry faces, influence from neighboring faces
//	//for (uint eid = 0; eid < tmesh.size(); eid++)
//	//{
//	//	if (tmesh[eid].act == 1 && tmesh[eid].type == 1)//boundary elements, must have bzflag==1
//	//	{
//	//		uint i, j, k, k0;
//	//		for (i = 0; i < 6; i++)
//	//		{
//	//			if (tmface[tmesh[eid].face[i]].type == 1)
//	//			{
//	//				int fcid(tmesh[eid].face[i]);
//	//				for (j = 0; j < 4; j++)
//	//				{
//	//					int hxid[2] = { -1, -1 }, fcnb(-1);
//	//					for (k = 0; k < tmedge[tmface[fcid].edge[j]].hex.size(); k++)
//	//					{
//	//						int hxtmp(tmedge[tmface[fcid].edge[j]].hex[k]);
//	//						if (hxtmp != eid)
//	//						{
//	//							for (k0 = 0; k0 < 6; k0++)
//	//							{
//	//							}
//	//						}
//	//					}
//	//				}
//	//			}
//	//		}
//	//	}
//	//}
//
//	//find transition element
//	for (uint eid = 0; eid < tmesh.size(); eid++)
//	{
//		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 0)
//		{
//			uint i, j, hxid, flag(0);
//			for (i = 0; i < 8; i++)
//			{
//				for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
//				{
//					hxid = cp[tmesh[eid].cnct[i]].hex[j];
//					if (tmesh[hxid].bzflag == 1)
//					{
//						flag = 1; break;
//					}
//				}
//				if (flag == 1) break;
//			}
//			if (flag == 1) tmesh[eid].bzflag = 2;
//		}
//	}
//	//add C1 functions to transition element
//	for (uint eid = 0; eid < tmesh.size(); eid++)
//	{
//		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 2)//must be an interior element
//		{
//			uint i, j;
//			vector<int> enb;
//			//check if any face neighbors with bzflag==1
//			for (i = 0; i < 6; i++)
//			{
//				int fcnb(tmface[tmesh[eid].face[i]].hex[0]);
//				if (fcnb == eid) fcnb = tmface[tmesh[eid].face[i]].hex[1];
//				enb.push_back(fcnb);
//				if (tmesh[fcnb].bzflag == 1)
//				{
//					for (j = 0; j < 4; j++)
//					{
//						int* it = find(tmesh[fcnb].cnct, tmesh[fcnb].cnct + 8, tmesh[eid].cnct[fc_cn[i][j]]);
//						int loc(it - tmesh[fcnb].cnct);
//						vector<double> coef(64, 0.);
//						coef[bzfc[i][j]] = 0.5;
//						coef[bzfc_ed[i][j][0]] = 0.25;
//						coef[bzfc_ed[i][j][1]] = 0.25;
//						coef[bzcn[fc_cn[i][j]]] = 0.125;
//						tmesh[eid].IENc01.push_back(tmesh[fcnb].IENc01[loc]);
//						tmesh[eid].cmat.push_back(coef);
//					}
//				}
//			}
//			for (i = 0; i < 12; i++)
//			{
//				int ednb(-1);
//				for (j = 0; j < tmedge[tmesh[eid].edge[i]].hex.size(); j++)
//				{
//					int hxid(tmedge[tmesh[eid].edge[i]].hex[j]);
//					if (hxid != eid)
//					{
//						vector<int>::iterator it = find(enb.begin(), enb.end(), hxid);
//						if (it == enb.end())
//						{
//							enb.push_back(hxid);
//							ednb = hxid; break;
//						}
//					}
//				}
//				if (ednb != -1 && tmesh[ednb].bzflag == 1)
//				{
//					for (j = 0; j < 2; j++)
//					{
//						int* it = find(tmesh[ednb].cnct, tmesh[ednb].cnct + 8, tmesh[eid].cnct[ed_cn[i][j]]);
//						int loc(it - tmesh[ednb].cnct);
//						vector<double> coef(64, 0.);
//						coef[bzed[i][j]] = 0.25;
//						coef[bzcn[ed_cn[i][j]]] = 0.125;
//						tmesh[eid].IENc01.push_back(tmesh[ednb].IENc01[loc]);
//						tmesh[eid].cmat.push_back(coef);
//					}
//				}
//			}
//			for (i = 0; i < 8; i++)
//			{
//				int cnnb(-1);
//				for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
//				{
//					int hxid(cp[tmesh[eid].cnct[i]].hex[j]);
//					if (hxid != eid)
//					{
//						vector<int>::iterator it = find(enb.begin(), enb.end(), hxid);
//						if (it == enb.end())
//						{
//							cnnb = hxid; break;
//						}
//					}
//				}
//				if (cnnb != -1 && tmesh[cnnb].bzflag == 1)
//				{
//					int* it = find(tmesh[cnnb].cnct, tmesh[cnnb].cnct + 8, tmesh[eid].cnct[i]);
//					int loc(it - tmesh[cnnb].cnct);
//					vector<double> coef(64, 0.);
//					coef[bzcn[i]] = 0.125;
//					tmesh[eid].IENc01.push_back(tmesh[cnnb].IENc01[loc]);
//					tmesh[eid].cmat.push_back(coef);
//				}
//			}
//		}
//	}
//
//	cout << "Done adding!\n";
//}
//
//void TruncatedTspline_3D::AddC0C1Bezier_Boundary()
//{
//	int bzbd[8] = { 21, 22, 26, 25, 37, 38, 42, 41 };
//	int cmb_bd2fc[8][3] = { { 5, 17, 20 },{ 6, 18, 23 },{ 10, 27, 30 },{ 9, 29, 24 },{ 33, 36, 53 },{ 34, 39, 54 },{ 43, 46, 58 },{ 45, 40, 57 } };
//	int loc_bd2fc[8][3] = { { 0, 1, 4 },{ 0, 1, 2 },{ 0, 2, 3 },{ 0, 3, 4 },{ 1, 4, 5 },{ 1, 2, 5 },{ 2, 3, 5 },{ 3, 4, 5 } };
//	int cmb_bd2ed[8][3] = { { 1, 4, 16 },{ 2, 7, 19 },{ 11, 14, 31 },{ 13, 8, 28 },{ 32, 49, 52 },{ 35, 50, 55 },{ 47, 59, 62 },{ 44, 61, 56 } };
//	int loc_bd2ed[8][3] = { { 0, 3, 4 },{ 0, 1, 5 },{ 1, 2, 6 },{ 2, 3, 7 },{ 4, 8, 11 },{ 5, 8, 9 },{ 6, 9, 10 },{ 7, 10, 11 } };
//	int cmb_bd2cn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };//same as bzcn
//
//	int bzfc[6][4] = { { 5, 6, 10, 9 },{ 17, 18, 34, 33 },{ 23, 27, 43, 39 },{ 29, 30, 46, 45 },{ 20, 24, 40, 36 },{ 53, 54, 58, 57 } };
//	int bzed[12][2] = { { 1, 2 },{ 7, 11 },{ 13, 14 },{ 4, 8 },{ 16, 32 },{ 19, 35 },{ 31, 47 },{ 28, 44 },{ 49, 50 },{ 55, 59 },{ 61, 62 },{ 52, 56 } };//
//	int bzcn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };
//
//	int fc_cn[6][4] = { { 0, 1, 2, 3 },{ 0, 1, 5, 4 },{ 1, 2, 6, 5 },{ 3, 2, 6, 7 },{ 0, 3, 7, 4 },{ 4, 5, 6, 7 } };//corresponding to bzfc
//	int fc_ed[6][4] = { { 0, 1, 2, 3 },{ 0, 5, 8, 4 },{ 1, 6, 9, 5 },{ 2, 6, 10, 7 },{ 3, 7, 11, 4 },{ 8, 9, 10, 11 } };
//	int bzfc_ed[6][4][2] = { { { 1, 4 },{ 7, 2 },{ 14, 11 },{ 8, 13 } },{ { 1, 16 },{ 19, 2 },{ 50, 35 },{ 32, 49 } },{ { 7, 19 },{ 31, 11 },{ 59, 47 },{ 35, 55 } },
//	{ { 13, 28 },{ 31, 14 },{ 62, 47 },{ 44, 61 } },{ { 4, 16 },{ 28, 8 },{ 56, 44 },{ 32, 52 } },{ { 49, 52 },{ 55, 50 },{ 62, 59 },{ 56, 61 } } };
//	int ed_cn[12][2] = { { 0, 1 },{ 1, 2 },{ 3, 2 },{ 0, 3 },{ 0, 4 },{ 1, 5 },{ 2, 6 },{ 3, 7 },{ 4, 5 },{ 5, 6 },{ 7, 6 },{ 4, 7 } };//corresponding to bzed
//
//																																	   //treat boundary separately and independently, need to use c0flag_b for boundary edges and boundary vertices
//																																	   //add face points for each boundary face element, edge points for edges of c0flag_b==1, corner points for corners of c0flag_b==1
//	for (uint eid = 0; eid < tmesh.size(); eid++)
//	{
//		if (tmesh[eid].act == 1 && tmesh[eid].type == 1)
//		{
//			uint i, j;
//			for (i = 0; i < 6; i++)
//			{
//				if (tmface[tmesh[eid].face[i]].type == 1)
//				{
//					for (j = 0; j < 4; j++)
//					{
//						tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzfc[i][j]]);
//						vector<double> coef(64, 0.);
//						coef[bzfc[i][j]] = 1.;
//						if (tmedge[tmesh[eid].edge[fc_ed[i][j]]].c0flag_b == 0)
//							coef[bzfc_ed[i][j][0]] = 0.5;
//						if (tmedge[tmesh[eid].edge[fc_ed[i][(j + 3) % 4]]].c0flag_b == 0)
//							coef[bzfc_ed[i][j][1]] = 0.5;
//						if (cp[tmesh[eid].cnct[fc_cn[i][j]]].c0flag_b == 0)
//							coef[bzcn[fc_cn[i][j]]] = 0.25;
//						tmesh[eid].cmat.push_back(coef);
//					}
//				}
//			}
//			for (i = 0; i < 12; i++)
//			{
//				if (tmedge[tmesh[eid].edge[i]].c0flag_b == 1)//must be a boundary edge
//				{
//					for (j = 0; j < 2; j++)
//					{
//						tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzed[i][j]]);
//						vector<double> coef(64, 0.);
//						coef[bzed[i][j]] = 1.;
//						tmesh[eid].cmat.push_back(coef);
//					}
//				}
//			}
//			for (i = 0; i < 8; i++)
//			{
//				if (cp[tmesh[eid].cnct[i]].c0flag_b == 1)
//				{
//					tmesh[eid].IENc01.push_back(tmesh[eid].IENb[bzcn[i]]);
//					vector<double> coef(64, 0.);
//					coef[bzcn[i]] = 1.;
//					tmesh[eid].cmat.push_back(coef);
//				}
//			}
//		}
//	}
//	//include influence from neighboring boundary faces
//	for (uint eid = 0; eid < tmesh.size(); eid++)
//	{
//		if (tmesh[eid].act == 1 && tmesh[eid].type == 1)
//		{
//			uint i, j, k;
//			for (i = 0; i < 6; i++)
//			{
//				if (tmface[tmesh[eid].face[i]].type == 1)
//				{
//					int fcid(tmesh[eid].face[i]);
//					int fcnb[4] = { -1, -1, -1, -1 };//fcnb is a neighboring boundary face
//					for (j = 0; j < 4; j++)//edges of face fcid
//					{
//						int edid(tmesh[eid].edge[fc_ed[i][j]]);
//						for (k = 0; k < tmedge[edid].face.size(); k++)
//						{
//							int fctmp(tmedge[edid].face[k]);
//							if (tmface[fctmp].type == 1 && fctmp != fcid)
//							{
//								fcnb[j] = fctmp; break;
//							}
//						}
//						if (fcnb[j] != -1)
//						{
//							int hxnb(tmface[fcnb[j]].hex[0]);
//							for (int k0 = 0; k0 < 2; k0++)
//							{
//								int* it1 = find(tmesh[hxnb].cnct, tmesh[hxnb].cnct + 8, tmesh[eid].cnct[fc_cn[i][(j + k0) % 4]]);
//								int loc1(it1 - tmesh[hxnb].cnct);
//								for (k = 0; k < 3; k++)
//								{
//									if (tmesh[hxnb].face[loc_bd2fc[loc1][k]] == fcnb[j])//only one k matches
//									{
//										int add_flag(0);
//										vector<double> coef(64, 0.);
//										if (tmedge[edid].c0flag_b == 0)
//										{
//											add_flag = 1; coef[bzed[fc_ed[i][j]][k0]] = 0.5;//problem
//										}
//										if (cp[tmesh[eid].cnct[fc_cn[i][(j + k0) % 4]]].c0flag_b == 0)
//										{
//											add_flag = 1; coef[bzcn[fc_cn[i][(j + k0) % 4]]] = 0.25;
//										}
//										if (add_flag == 1)
//										{
//											tmesh[eid].IENc01.push_back(tmesh[hxnb].IENb[cmb_bd2fc[loc1][k]]);
//											tmesh[eid].cmat.push_back(coef);
//										}
//										break;
//									}
//								}
//							}
//						}
//					}
//					for (j = 0; j < 4; j++)//corners of the face fcid
//					{
//						int cnid(tmesh[eid].cnct[fc_cn[i][j]]);
//						if (cp[cnid].c0flag_b == 0)
//						{
//							int cnnb(-1);
//							for (k = 0; k < cp[cnid].face.size(); k++)
//							{
//								int fctmp(cp[cnid].face[k]);
//								if (tmface[fctmp].type == 1 && fctmp != fcid && fctmp != fcnb[j] && fctmp != fcnb[(j + 3) % 4])
//								{
//									cnnb = fctmp; break;
//								}
//							}
//							if (cnnb != -1)
//							{
//								int hxnb(tmface[cnnb].hex[0]);
//								int* it1 = find(tmesh[hxnb].cnct, tmesh[hxnb].cnct + 8, tmesh[eid].cnct[fc_cn[i][j]]);
//								int loc1(it1 - tmesh[hxnb].cnct);
//								for (k = 0; k < 3; k++)
//								{
//									if (tmesh[hxnb].face[loc_bd2fc[loc1][k]] == cnnb)//only one k matches
//									{
//										vector<double> coef(64, 0.);
//										coef[bzcn[fc_cn[i][j]]] = 0.25;
//										tmesh[eid].IENc01.push_back(tmesh[hxnb].IENb[cmb_bd2fc[loc1][k]]);
//										tmesh[eid].cmat.push_back(coef);
//										break;
//									}
//								}
//							}
//						}
//					}
//				}
//			}
//		}
//	}
//}
//
//void TruncatedTspline_3D::TruncateC0C1()
//{
//	cout << "Performing truncation...\n";
//	//determine active C2 functions first
//	for (uint i = 0; i < cp.size(); i++)
//	{
//		int flag(0);
//		for (uint j = 0; j < cp[i].hex.size(); j++)
//		{
//			if (tmesh[cp[i].hex[j]].bzflag != 1) flag = 1;
//		}
//		if (flag == 0) cp[i].act = 0;
//	}
//
//	vector<int> etrun1;
//	for (uint eid = 0; eid < tmesh.size(); eid++)
//	{
//		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 1)
//		{
//			uint i, j, flag(0);
//			for (i = 0; i < 8; i++)
//			{
//				for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
//				{
//					if (tmesh[cp[tmesh[eid].cnct[i]].hex[j]].bzflag != 1)
//					{
//						flag = 1; break;
//					}
//				}
//				if (flag == 1) break;
//			}
//			if (flag == 1)
//			{
//				etrun1.push_back(eid);
//				//vector<vector<double>> cmat;
//				//BezierExtractC0C1_Trun(eid, cmat);
//				//for (i = 0; i < tmesh[eid].IEN.size(); i++)
//				//{
//				//	if (cp[tmesh[eid].IEN[i]].act == 1)
//				//	{
//				//		tmesh[eid].IENc2.push_back(tmesh[eid].IEN[i]);
//				//		tmesh[eid].cmat.push_back(cmat[i]);
//				//	}
//				//}
//			}
//		}
//	}
//
//#pragma omp parallel for
//	for (int i0 = 0; i0 < etrun1.size(); i0++)
//	{
//		int eid(etrun1[i0]);
//		vector<vector<double>> cmat;
//		BezierExtractC0C1_Trun(eid, cmat);
//		for (uint i = 0; i < tmesh[eid].IEN.size(); i++)
//		{
//			if (cp[tmesh[eid].IEN[i]].act == 1)
//			{
//				tmesh[eid].IENc2.push_back(tmesh[eid].IEN[i]);
//				tmesh[eid].cmat.push_back(cmat[i]);
//			}
//		}
//	}
//
//	//#pragma omp parallel for
//	vector<int> etrun2;
//	for (uint eid = 0; eid < tmesh.size(); eid++)
//	{
//		if (tmesh[eid].act == 1 && tmesh[eid].bzflag == 2)
//		{
//			etrun2.push_back(eid);
//			//vector<vector<double>> cmat;
//			//BezierExtractC0C1_Trun(eid, cmat);
//			//for (uint i = 0; i < tmesh[eid].IEN.size(); i++)
//			//{
//			//	if (cp[tmesh[eid].IEN[i]].act == 1)
//			//	{
//			//		tmesh[eid].IENc2.push_back(tmesh[eid].IEN[i]);
//			//		tmesh[eid].cmat.push_back(cmat[i]);
//			//	}
//			//}
//		}
//	}
//
//#pragma omp parallel for
//	for (int i0 = 0; i0 < etrun2.size(); i0++)
//	{
//		int eid(etrun2[i0]);
//		vector<vector<double>> cmat;
//		BezierExtractC0C1_Trun(eid, cmat);
//		for (uint i = 0; i < tmesh[eid].IEN.size(); i++)
//		{
//			if (cp[tmesh[eid].IEN[i]].act == 1)
//			{
//				tmesh[eid].IENc2.push_back(tmesh[eid].IEN[i]);
//				tmesh[eid].cmat.push_back(cmat[i]);
//			}
//		}
//	}
//
//	//for (uint eid = 0; eid < tmesh.size(); eid++)
//	//{
//	//	if (tmesh[eid].bzflag == 1)
//	//	{
//	//		for (uint i = 0; i < 64; i++)
//	//		{
//	//			double sum(0.);
//	//			for (uint j = 0; j < tmesh[eid].cmat.size(); j++)
//	//			{
//	//				sum += tmesh[eid].cmat[j][i];
//	//			}
//	//			if (fabs(sum - 1.)>1.e-6)
//	//			{
//	//				cout << "eid: " << eid << "\n";
//	//				cout << "bzid: " << i << "\n";
//	//				cout << "IENc01 dim: " << tmesh[eid].IENc01.size() << "\n";
//	//				cout << "IENc2 dim : " << tmesh[eid].IENc2.size() << "\n";
//	//				int edloc(5);
//	//				//cout << "edge c0flag: ";
//	//				//for (uint j = 0; j < 12; j++)
//	//				//{
//	//				//	cout << tmedge[tmesh[eid].edge[j]].c0flag << "(" << j << ") ";
//	//				//}
//	//				cout << "edge c0flag: " << tmedge[tmesh[eid].edge[edloc]].c0flag << "\n";
//	//				cout << "edge type: " << tmedge[tmesh[eid].edge[edloc]].type << "\n";
//	//				for (uint j = 0; j < tmedge[tmesh[eid].edge[edloc]].hex.size(); j++)
//	//				{
//	//					int hxid(tmedge[tmesh[eid].edge[edloc]].hex[j]);
//	//					//cout << tmesh[hxid].bzflag << " ";
//	//					cout << tmesh[hxid].type << " ";
//	//				}
//	//				cout << "\n";
//	//				for (uint j = 0; j < tmesh[eid].cmat.size(); j++)
//	//				{
//	//					if (tmesh[eid].cmat[j][i] != 0.)
//	//					{
//	//						cout << tmesh[eid].cmat[j][i] << " ";
//	//					}
//	//				}
//	//				cout << "\n"; getchar();
//	//			}
//	//		}
//	//	}
//	//}
//
//	cout << "Done truncating!\n";
//}
//
//void TruncatedTspline_3D::BezierExtractC0C1_Trun(int eid, vector<vector<double>>& cmat)
//{
//	//two-step Bezier extraction: (1) C2 to C1; (2) C1 to C0
//	//build local connectivity first
//	uint i, j, k, hxid;
//	vector<int> hx1r(1, eid);
//	vector<array<int, 8>> eloc;
//	array<int, 8> etmp;
//	for (i = 0; i < 8; i++) etmp[i] = i;
//	eloc.push_back(etmp);
//	vector<vector<int>> cnb_loc(8);
//	for (i = 0; i < 8; i++)
//	{
//		for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
//		{
//			hxid = cp[tmesh[eid].cnct[i]].hex[j];
//			vector<int>::iterator it1 = find(hx1r.begin(), hx1r.end(), hxid);
//			cnb_loc[i].push_back(it1 - hx1r.begin());
//			if (it1 == hx1r.end())
//			{
//				hx1r.push_back(hxid);
//				for (k = 0; k < 8; k++)
//				{
//					vector<int>::iterator it = find(tmesh[eid].IEN.begin(), tmesh[eid].IEN.end(), tmesh[hxid].cnct[k]);
//					etmp[k] = it - tmesh[eid].IEN.begin();
//				}
//				eloc.push_back(etmp);
//			}
//		}
//	}
//
//	int bzbd[8] = { 21, 22, 26, 25, 37, 38, 42, 41 };
//	int bzfc[6][4] = { { 5, 6, 10, 9 },{ 17, 18, 34, 33 },{ 23, 27, 43, 39 },{ 29, 30, 46, 45 },{ 20, 24, 40, 36 },{ 53, 54, 58, 57 } };
//	int bzed[12][2] = { { 1, 2 },{ 7, 11 },{ 13, 14 },{ 4, 8 },{ 16, 32 },{ 19, 35 },{ 31, 47 },{ 28, 44 },{ 49, 50 },{ 55, 59 },{ 61, 62 },{ 52, 56 } };
//	int bzcn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };
//	int fc_cn[6][4] = { { 0, 1, 2, 3 },{ 0, 1, 5, 4 },{ 1, 2, 6, 5 },{ 3, 2, 6, 7 },{ 0, 3, 7, 4 },{ 4, 5, 6, 7 } };
//	int ed_cn[12][2] = { { 0, 1 },{ 1, 2 },{ 3, 2 },{ 0, 3 },{ 0, 4 },{ 1, 5 },{ 2, 6 },{ 3, 7 },{ 4, 5 },{ 5, 6 },{ 7, 6 },{ 4, 7 } };
//	//uint nc1(0);
//	//for (i = 0; i < 8; i++) nc1 += cp[tmesh[eid].cnct[i]].hex.size();
//	//vector<vector<double>> cmat1(tmesh[eid].IEN.size(), vector<double>(nc1, 0.));
//	vector<vector<double>> cmat1(tmesh[eid].IEN.size(), vector<double>(8 * hx1r.size(), 0.));
//	int count(0);
//	for (i = 0; i < hx1r.size(); i++)
//	{
//		for (j = 0; j < 8; j++)//Bezier body points
//		{
//			for (k = 0; k < 8; k++)//element corners
//			{
//				cmat1[eloc[i][k]][count] = tmesh[hx1r[i]].bemat[k][bzbd[j]];
//				if (tmesh[hx1r[i]].bzflag == 1) cmat1[eloc[i][k]][count] = 0.;//truncation
//			}
//			count++;
//		}
//	}
//
//	vector<vector<double>> cmat0(8 * hx1r.size(), vector<double>(64, 0.));
//	for (i = 0; i < 8; i++)//body points themselves
//	{
//		cmat0[i][bzbd[i]] = 1.;
//	}
//	for (i = 0; i < 6; i++)//face neighbor
//	{
//		double fcc(0.5);
//		//if (tmface[tmesh[eid].face[i]].type == 1) fcc = 0.;
//		for (j = 0; j < tmface[tmesh[eid].face[i]].hex.size(); j++)
//		{
//			hxid = tmface[tmesh[eid].face[i]].hex[j];
//			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
//			int loc(it - hx1r.begin());
//			for (k = 0; k < 4; k++)
//			{
//				int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[fc_cn[i][k]]);
//				int loc1(it1 - tmesh[hxid].cnct);
//				cmat0[8 * loc + loc1][bzfc[i][k]] = fcc;
//			}
//		}
//	}
//	for (i = 0; i < 12; i++)//edge neighbor
//	{
//		double edc(1. / double(tmedge[tmesh[eid].edge[i]].hex.size()));
//		for (j = 0; j < tmedge[tmesh[eid].edge[i]].hex.size(); j++)
//		{
//			hxid = tmedge[tmesh[eid].edge[i]].hex[j];
//			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
//			int loc(it - hx1r.begin());
//			for (k = 0; k < 2; k++)
//			{
//				int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[ed_cn[i][k]]);
//				int loc1(it1 - tmesh[hxid].cnct);
//				cmat0[8 * loc + loc1][bzed[i][k]] = edc;
//			}
//		}
//	}
//	for (i = 0; i < 8; i++)//corner neighbor
//	{
//		double cnc(1. / double(cp[tmesh[eid].cnct[i]].hex.size()));
//		for (j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
//		{
//			hxid = cp[tmesh[eid].cnct[i]].hex[j];
//			vector<int>::iterator it = find(hx1r.begin(), hx1r.end(), hxid);
//			int loc(it - hx1r.begin());
//			int* it1 = find(tmesh[hxid].cnct, tmesh[hxid].cnct + 8, tmesh[eid].cnct[i]);
//			int loc1(it1 - tmesh[hxid].cnct);
//			cmat0[8 * loc + loc1][bzcn[i]] = cnc;
//		}
//	}
//
//	for (i = 0; i < cmat.size(); i++) cmat[i].clear();
//	cmat.clear();
//	cmat.resize(tmesh[eid].IEN.size(), vector<double>(64, 0.));
//	for (i = 0; i < tmesh[eid].IEN.size(); i++)
//	{
//		for (j = 0; j < 64; j++)
//		{
//			for (k = 0; k < 8 * hx1r.size(); k++)
//			{
//				if (cmat1[i][k] != 0. && cmat0[k][j] != 0.)
//					cmat[i][j] += cmat1[i][k] * cmat0[k][j];
//			}
//		}
//	}
//}
//
//void TruncatedTspline_3D::OutputGeom_C0C1(string fn)
//{
//	cout << "Outputing geometry...\n";
//	vector<array<double, 3>> spt;
//	//vector<array<double, 3>> sval;
//	//vector<double> ssum;
//	vector<array<int, 8>> sele;
//	vector<array<double, 3>> lpt;//visulize parameter lines
//	vector<array<int, 2>> led;//line connectivity
//	int ns(2), ne_ref(0), loc0, loc1, loc2;
//
//	for (uint eid = 0; eid < tmesh.size(); eid++)
//	{
//		if (tmesh[eid].act == 1 /*&& tmesh[eid].type == 2*/)
//		{
//			vector<double> su(ns), sv(ns), sw(ns);
//			double ul[3] = { 1., 1., 1. };
//			for (int i = 0; i<ns; i++)
//			{
//				su[i] = i*ul[0] / (ns - 1);
//				sv[i] = i*ul[1] / (ns - 1);
//				sw[i] = i*ul[2] / (ns - 1);
//			}
//			for (int a = 0; a<ns; a++)
//			{
//				for (int b = 0; b<ns; b++)
//				{
//					for (int c = 0; c < ns; c++)
//					{
//						array<double, 3> pt;
//						array<double, 3> uval = { su[c], sv[b], sw[a] };
//						GeomMap_C0C1(eid, uval.data(), pt.data());
//						//double sumtmp = BasisSum(lev, eid, uval);
//						//GeomMap_Lev(lev, eid, uval, pt);
//						//double sumtmp = BasisSum_Lev(lev, eid, uval);
//						spt.push_back(pt);
//						//ssum.push_back(sumtmp);
//						//if(a==0||a==ns-1||b==0||b==ns-1)
//						//{
//						//	lpt.push_back(pt);
//						//}
//					}
//				}
//			}
//
//			for (int a = 0; a<ns - 1; a++)
//			{
//				for (int b = 0; b<ns - 1; b++)
//				{
//					for (int c = 0; c < ns - 1; c++)
//					{
//						array<int, 8> el;
//						el[0] = ne_ref + a*ns*ns + b*ns + c;
//						el[1] = ne_ref + a*ns*ns + b*ns + c + 1;
//						el[2] = ne_ref + a*ns*ns + (b + 1)*ns + c + 1;
//						el[3] = ne_ref + a*ns*ns + (b + 1)*ns + c;
//						el[4] = ne_ref + (a + 1)*ns*ns + b*ns + c;
//						el[5] = ne_ref + (a + 1)*ns*ns + b*ns + c + 1;
//						el[6] = ne_ref + (a + 1)*ns*ns + (b + 1)*ns + c + 1;
//						el[7] = ne_ref + (a + 1)*ns*ns + (b + 1)*ns + c;
//						sele.push_back(el);
//					}
//				}
//			}
//			ne_ref += ns*ns*ns;
//		}
//	}
//
//	string fname = fn + ".vtk";
//	ofstream fout;
//	fout.open(fname.c_str());
//	if (fout.is_open())
//	{
//		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
//		fout << "POINTS " << spt.size() << " float\n";
//		for (uint i = 0; i<spt.size(); i++)
//		{
//			fout << spt[i][0] << " " << spt[i][1] << " " << spt[i][2] << "\n";
//		}
//		fout << "\nCELLS " << sele.size() << " " << 9 * sele.size() << '\n';
//		for (uint i = 0; i<sele.size(); i++)
//		{
//			fout << "8 " << sele[i][0] << " " << sele[i][1] << " " << sele[i][2] << " " << sele[i][3] << " " << sele[i][4] << " " << sele[i][5] << " " << sele[i][6] << " " << sele[i][7] << '\n';
//		}
//		fout << "\nCELL_TYPES " << sele.size() << '\n';
//		for (uint i = 0; i<sele.size(); i++)
//		{
//			fout << "12\n";
//		}
//		//fout << "\nPOINT_DATA " << ssum.size() << "\nSCALARS sum FLOAT\nLOOKUP_TABLE default\n";
//		//for (uint i = 0; i<ssum.size(); i++)
//		//{
//		//	fout << ssum[i] << "\n";
//		//}
//		//fout<<"\nPOINT_DATA "<<sval.size()<<"\nNORMALS Normal FLOAT\n";
//		//for(uint i=0;i<sval.size();i++)
//		//{
//		//	fout<<sval[i][0]<<" "<<sval[i][1]<<" "<<sval[i][2]<<"\n";
//		//}
//		fout.close();
//	}
//	else
//	{
//		cout << "Cannot open " << fname << "!\n";
//	}
//
//	cout << "Done outputing!\n";
//}
//
//void TruncatedTspline_3D::GeomMap_C0C1(int eid, double u[3], double pt[3])
//{
//	BezierElement3D bzel;
//	vector<double> Bt;
//	vector<array<double, 3>> dBdt;
//	bzel.Basis(u[0], u[1], u[2], Bt, dBdt);
//	pt[0] = 0.; pt[1] = 0.; pt[2] = 0.;
//	if (tmesh[eid].bzflag == 1 || tmesh[eid].bzflag == 2)
//	{
//		double Bx;
//		for (uint i = 0; i < tmesh[eid].IENc01.size(); i++)
//		{
//			Bx = 0.;
//			for (uint j = 0; j < tmesh[eid].cmat[i].size(); j++)
//			{
//				if (tmesh[eid].cmat[i][j] != 0.)
//					Bx += tmesh[eid].cmat[i][j] * Bt[j];
//			}
//			pt[0] += Bx*bzcp[tmesh[eid].IENc01[i]][0];
//			pt[1] += Bx*bzcp[tmesh[eid].IENc01[i]][1];
//			pt[2] += Bx*bzcp[tmesh[eid].IENc01[i]][2];
//		}
//		for (uint i = 0; i < tmesh[eid].IENc2.size(); i++)
//		{
//			Bx = 0.;
//			int i1(tmesh[eid].IENc01.size() + i);
//			for (uint j = 0; j < tmesh[eid].cmat[i1].size(); j++)
//			{
//				if (tmesh[eid].cmat[i1][j] != 0.)
//					Bx += tmesh[eid].cmat[i1][j] * Bt[j];
//			}
//			pt[0] += Bx*cp[tmesh[eid].IENc2[i]].coor[0];
//			pt[1] += Bx*cp[tmesh[eid].IENc2[i]].coor[1];
//			pt[2] += Bx*cp[tmesh[eid].IENc2[i]].coor[2];
//		}
//	}
//	else if (tmesh[eid].bzflag == 0)
//	{
//		double Bx;
//		for (uint i = 0; i < tmesh[eid].IEN.size(); i++)
//		{
//			Bx = 0.;
//			for (uint j = 0; j < tmesh[eid].bemat[i].size(); j++)
//			{
//				if (tmesh[eid].bemat[i][j] != 0.)
//					Bx += tmesh[eid].bemat[i][j] * Bt[j];
//			}
//			pt[0] += Bx*cp[tmesh[eid].IEN[i]].coor[0];
//			pt[1] += Bx*cp[tmesh[eid].IEN[i]].coor[1];
//			pt[2] += Bx*cp[tmesh[eid].IEN[i]].coor[2];
//		}
//	}
//}
//
//void TruncatedTspline_3D::Global_Subdivide_C0C1Bezier()
//{
//	//body points
//	vector<array<double, 3>> pts_bd(tmesh.size());
//	for (int i = 0; i < tmesh.size(); i++)
//	{
//		pts_bd[i][0] = 0.; pts_bd[i][1] = 0.; pts_bd[i][2] = 0.;
//		for (int j = 0; j < 8; j++)
//		{
//			pts_bd[i][0] += cp[tmesh[i].cnct[j]].coor[0];
//			pts_bd[i][1] += cp[tmesh[i].cnct[j]].coor[1];
//			pts_bd[i][2] += cp[tmesh[i].cnct[j]].coor[2];
//		}
//		pts_bd[i][0] /= 8.; pts_bd[i][1] /= 8.; pts_bd[i][2] /= 8.;
//	}
//	//face points
//	vector<array<double, 3>> pts_fc0(tmface.size());//simply average
//	vector<array<double, 3>> pts_fc(tmface.size());//desired
//	for (int i = 0; i < tmface.size(); i++)
//	{
//		pts_fc0[i][0] = 0.; pts_fc0[i][1] = 0.; pts_fc0[i][2] = 0.;
//		for (int j = 0; j < 4; j++)
//		{
//			pts_fc0[i][0] += cp[tmface[i].cnct[j]].coor[0];
//			pts_fc0[i][1] += cp[tmface[i].cnct[j]].coor[1];
//			pts_fc0[i][2] += cp[tmface[i].cnct[j]].coor[2];
//		}
//		pts_fc0[i][0] /= 4.; pts_fc0[i][1] /= 4.; pts_fc0[i][2] /= 4.;
//		if (tmface[i].hex.size() == 2)//interior face points
//		{
//			int hxid[2] = { tmface[i].hex[0], tmface[i].hex[1] };
//			pts_fc[i][0] = (pts_bd[hxid[0]][0] + pts_bd[hxid[1]][0] + 2.*pts_fc0[i][0]) / 4.;
//			pts_fc[i][1] = (pts_bd[hxid[0]][1] + pts_bd[hxid[1]][1] + 2.*pts_fc0[i][1]) / 4.;
//			pts_fc[i][2] = (pts_bd[hxid[0]][2] + pts_bd[hxid[1]][2] + 2.*pts_fc0[i][2]) / 4.;
//		}
//		else
//		{
//			pts_fc[i][0] = pts_fc0[i][0]; pts_fc[i][1] = pts_fc0[i][1]; pts_fc[i][2] = pts_fc0[i][2];
//		}
//	}
//	//edge points
//	vector<array<double, 3>> pts_ed0(tmedge.size());//simply average
//	vector<array<double, 3>> pts_ed(tmedge.size());//desired
//	for (int i = 0; i < tmedge.size(); i++)
//	{
//		pts_ed0[i][0] = (cp[tmedge[i].pt[0]].coor[0] + cp[tmedge[i].pt[1]].coor[0]) / 2.;
//		pts_ed0[i][1] = (cp[tmedge[i].pt[0]].coor[1] + cp[tmedge[i].pt[1]].coor[1]) / 2.;
//		pts_ed0[i][2] = (cp[tmedge[i].pt[0]].coor[2] + cp[tmedge[i].pt[1]].coor[2]) / 2.;
//		if (tmedge[i].type != 1)//non-boundary, i.e. interior
//		{
//			double cavg[3] = { 0., 0., 0. };
//			for (uint j = 0; j < tmedge[i].hex.size(); j++)
//			{
//				cavg[0] += pts_bd[tmedge[i].hex[j]][0];
//				cavg[1] += pts_bd[tmedge[i].hex[j]][1];
//				cavg[2] += pts_bd[tmedge[i].hex[j]][2];
//			}
//			cavg[0] /= double(tmedge[i].hex.size());
//			cavg[1] /= double(tmedge[i].hex.size());
//			cavg[2] /= double(tmedge[i].hex.size());
//			double aavg[3] = { 0., 0., 0. };
//			for (uint j = 0; j < tmedge[i].face.size(); j++)
//			{
//				aavg[0] += pts_fc0[tmedge[i].face[j]][0];
//				aavg[1] += pts_fc0[tmedge[i].face[j]][1];
//				aavg[2] += pts_fc0[tmedge[i].face[j]][2];
//			}
//			aavg[0] /= double(tmedge[i].face.size());
//			aavg[1] /= double(tmedge[i].face.size());
//			aavg[2] /= double(tmedge[i].face.size());
//			pts_ed[i][0] = (cavg[0] + 2.*aavg[0] + double(tmedge[i].face.size() - 3)*pts_ed0[i][0]) / double(tmedge[i].face.size());
//			pts_ed[i][1] = (cavg[1] + 2.*aavg[1] + double(tmedge[i].face.size() - 3)*pts_ed0[i][1]) / double(tmedge[i].face.size());
//			pts_ed[i][2] = (cavg[2] + 2.*aavg[2] + double(tmedge[i].face.size() - 3)*pts_ed0[i][2]) / double(tmedge[i].face.size());
//		}
//		else
//		{
//			if (tmedge[i].sharp == 0)//boundary non-sharp edge
//			{
//				double aavg[3] = { 0., 0., 0. };
//				for (uint j = 0; j < tmedge[i].face.size(); j++)
//				{
//					if (tmface[tmedge[i].face[j]].type == 1)
//					{
//						aavg[0] += pts_fc0[tmedge[i].face[j]][0];
//						aavg[1] += pts_fc0[tmedge[i].face[j]][1];
//						aavg[2] += pts_fc0[tmedge[i].face[j]][2];
//					}
//				}
//				pts_ed[i][0] = (aavg[0] + 2.*pts_ed0[i][0]) / 4.;
//				pts_ed[i][1] = (aavg[1] + 2.*pts_ed0[i][1]) / 4.;
//				pts_ed[i][2] = (aavg[2] + 2.*pts_ed0[i][2]) / 4.;
//			}
//			else//sharp edge
//			{
//				pts_ed[i][0] = pts_ed0[i][0];
//				pts_ed[i][1] = pts_ed0[i][1];
//				pts_ed[i][2] = pts_ed0[i][2];
//			}
//		}
//	}
//	//vertex points
//#pragma omp parallel for
//	for (int i = 0; i < cp.size(); i++)
//	{
//		if (cp[i].type != 1)//interior, careful
//		{
//			double cavg[3] = { 0., 0., 0. };
//			for (uint j = 0; j < cp[i].hex.size(); j++)
//			{
//				cavg[0] += pts_bd[cp[i].hex[j]][0];
//				cavg[1] += pts_bd[cp[i].hex[j]][1];
//				cavg[2] += pts_bd[cp[i].hex[j]][2];
//			}
//			cavg[0] /= double(cp[i].hex.size());
//			cavg[1] /= double(cp[i].hex.size());
//			cavg[2] /= double(cp[i].hex.size());
//			double aavg[3] = { 0., 0., 0. };
//			for (uint j = 0; j < cp[i].face.size(); j++)
//			{
//				aavg[0] += pts_fc0[cp[i].face[j]][0];
//				aavg[1] += pts_fc0[cp[i].face[j]][1];
//				aavg[2] += pts_fc0[cp[i].face[j]][2];
//			}
//			aavg[0] /= double(cp[i].face.size());
//			aavg[1] /= double(cp[i].face.size());
//			aavg[2] /= double(cp[i].face.size());
//			double mavg[3] = { 0., 0., 0. };
//			for (uint j = 0; j < cp[i].edge.size(); j++)
//			{
//				mavg[0] += pts_ed0[cp[i].edge[j]][0];
//				mavg[1] += pts_ed0[cp[i].edge[j]][1];
//				mavg[2] += pts_ed0[cp[i].edge[j]][2];
//			}
//			mavg[0] /= double(cp[i].edge.size());
//			mavg[1] /= double(cp[i].edge.size());
//			mavg[2] /= double(cp[i].edge.size());
//			cp[i].coor[0] = (cavg[0] + 3.*aavg[0] + 3.*mavg[0] + cp[i].coor[0]) / 8.;
//			cp[i].coor[1] = (cavg[1] + 3.*aavg[1] + 3.*mavg[1] + cp[i].coor[1]) / 8.;
//			cp[i].coor[2] = (cavg[2] + 3.*aavg[2] + 3.*mavg[2] + cp[i].coor[2]) / 8.;
//		}
//		else
//		{
//			if (cp[i].sharp == 0)
//			{
//				double aavg[3] = { 0., 0., 0. };
//				int nfc(0);
//				for (uint j = 0; j < cp[i].face.size(); j++)
//				{
//					if (tmface[cp[i].face[j]].type == 1)
//					{
//						aavg[0] += pts_fc0[cp[i].face[j]][0];
//						aavg[1] += pts_fc0[cp[i].face[j]][1];
//						aavg[2] += pts_fc0[cp[i].face[j]][2];
//						nfc++;
//					}
//				}
//				aavg[0] /= double(nfc); aavg[1] /= double(nfc); aavg[2] /= double(nfc);//nfc==2
//				double mavg[3] = { 0., 0., 0. };
//				int ned(0);
//				for (uint j = 0; j < cp[i].edge.size(); j++)
//				{
//					if (tmedge[cp[i].edge[j]].type == 1)
//					{
//						mavg[0] += pts_ed0[cp[i].edge[j]][0];
//						mavg[1] += pts_ed0[cp[i].edge[j]][1];
//						mavg[2] += pts_ed0[cp[i].edge[j]][2];
//						ned++;
//					}
//				}
//				mavg[0] /= double(ned); mavg[1] /= double(ned); mavg[2] /= double(ned);
//				cp[i].coor[0] = (aavg[0] + 2.*mavg[0] + double(nfc - 3)*cp[i].coor[0]) / double(nfc);
//				cp[i].coor[1] = (aavg[1] + 2.*mavg[1] + double(nfc - 3)*cp[i].coor[1]) / double(nfc);
//				cp[i].coor[2] = (aavg[2] + 2.*mavg[2] + double(nfc - 3)*cp[i].coor[2]) / double(nfc);
//			}
//			else if (cp[i].sharp == 1)//associated with sharp edge
//			{
//				double mavg[3] = { 0., 0., 0. };
//				for (uint j = 0; j < cp[i].edge.size(); j++)
//				{
//					if (tmedge[cp[i].edge[j]].sharp == 1)
//					{
//						mavg[0] += pts_ed0[cp[i].edge[j]][0];
//						mavg[1] += pts_ed0[cp[i].edge[j]][1];
//						mavg[2] += pts_ed0[cp[i].edge[j]][2];
//					}
//				}
//				cp[i].coor[0] = (mavg[0] + 2.*cp[i].coor[0]) / 4.;
//				cp[i].coor[1] = (mavg[1] + 2.*cp[i].coor[1]) / 4.;
//				cp[i].coor[2] = (mavg[2] + 2.*cp[i].coor[2]) / 4.;
//			}
//			else//sharp corner
//			{
//				cp[i].coor[0] = cp[i].coor[0]; cp[i].coor[1] = cp[i].coor[1]; cp[i].coor[2] = cp[i].coor[2];
//			}
//		}
//	}
//#pragma omp barrier
//	//update cp
//	vector<int> pid_vt(cp.size());
//	vector<int> pid_ed(tmedge.size());
//	vector<int> pid_fc(tmface.size());
//	vector<int> pid_bd(tmesh.size());
//	int count(0);
//	for (int i = 0; i < cp.size(); i++)
//	{
//		pid_vt[i] = count++;
//	}
//	for (int i = 0; i < tmedge.size(); i++)
//	{
//		pid_ed[i] = count++;
//		Vertex3D ptmp;
//		ptmp.act = 1;
//		if (tmedge[i].type == 1) ptmp.type = 1;//default 0
//		if (tmedge[i].sharp == 1) ptmp.sharp = 1;//default 0
//		if (tmedge[i].c0flag == 1) ptmp.c0flag = 1;//new
//		if (tmedge[i].c0flag_b == 1) ptmp.c0flag_b = 1;//new
//		ptmp.coor[0] = pts_ed[i][0]; ptmp.coor[1] = pts_ed[i][1]; ptmp.coor[2] = pts_ed[i][2];
//		cp.push_back(ptmp);
//	}
//	for (int i = 0; i < tmface.size(); i++)
//	{
//		pid_fc[i] = count++;
//		Vertex3D ptmp;
//		ptmp.act = 1;
//		if (tmface[i].type == 1) ptmp.type = 1;//default 0
//		if (tmface[i].c0flag == 1) ptmp.c0flag = 1;//new
//		ptmp.coor[0] = pts_fc[i][0]; ptmp.coor[1] = pts_fc[i][1]; ptmp.coor[2] = pts_fc[i][2];
//		cp.push_back(ptmp);
//	}
//	for (int i = 0; i < tmesh.size(); i++)
//	{
//		pid_bd[i] = count++;
//		Vertex3D ptmp;
//		ptmp.act = 1;
//		ptmp.coor[0] = pts_bd[i][0]; ptmp.coor[1] = pts_bd[i][1]; ptmp.coor[2] = pts_bd[i][2];
//		cp.push_back(ptmp);
//	}
//	//update edge
//	vector<Edge3D> ednew(2 * tmedge.size() + 4 * tmface.size() + 6 * tmesh.size());
//	int edloc(0);
//	for (int i = 0; i < tmedge.size(); i++)
//	{
//		ednew[edloc].pt[0] = tmedge[i].pt[0];
//		ednew[edloc].pt[1] = pid_ed[i];
//		ednew[edloc].type = tmedge[i].type;//
//		ednew[edloc].sharp = tmedge[i].sharp;//
//		ednew[edloc].c0flag = tmedge[i].c0flag;//new
//		ednew[edloc].c0flag_b = tmedge[i].c0flag_b;//new
//		edloc++;
//		ednew[edloc].pt[0] = pid_ed[i];
//		ednew[edloc].pt[1] = tmedge[i].pt[1];
//		ednew[edloc].type = tmedge[i].type;//
//		ednew[edloc].sharp = tmedge[i].sharp;//
//		ednew[edloc].c0flag = tmedge[i].c0flag;//new
//		ednew[edloc].c0flag_b = tmedge[i].c0flag_b;//new
//		edloc++;
//	}
//	//update face
//	vector<Face3D> fcnew(4 * tmface.size() + 12 * tmesh.size());
//	int fcloc(0);
//	for (int i = 0; i < tmface.size(); i++)
//	{
//		int fcnct[4][4] = { { tmface[i].cnct[0], pid_ed[tmface[i].edge[0]], pid_fc[i], pid_ed[tmface[i].edge[3]] },
//		{ pid_ed[tmface[i].edge[0]], tmface[i].cnct[1], pid_ed[tmface[i].edge[1]], pid_fc[i] },
//		{ pid_fc[i], pid_ed[tmface[i].edge[1]], tmface[i].cnct[2], pid_ed[tmface[i].edge[2]] },
//		{ pid_ed[tmface[i].edge[3]], pid_fc[i], pid_ed[tmface[i].edge[2]], tmface[i].cnct[3] } };
//		int edid[12];
//		for (int j = 0; j < 4; j++)
//		{
//			edid[2 * j] = 2 * tmface[i].edge[j]; edid[2 * j + 1] = 2 * tmface[i].edge[j] + 1;
//			if (tmedge[tmface[i].edge[j]].pt[0] != tmface[i].cnct[j])
//			{
//				edid[2 * j] = 2 * tmface[i].edge[j] + 1; edid[2 * j + 1] = 2 * tmface[i].edge[j];
//			}
//		}
//		//construct 4 new edges
//		for (int j = 0; j < 4; j++)
//		{
//			ednew[edloc].pt[0] = pid_fc[i];
//			ednew[edloc].pt[1] = pid_ed[tmface[i].edge[j]];
//			if (tmface[i].type == 1) ednew[edloc].type = 1;//boundary
//			if (tmface[i].c0flag == 1) ednew[edloc].c0flag = 1;//new
//			edid[8 + j] = edloc;
//			edloc++;
//		}
//		int fedge[4][4] = { { edid[0], edid[8], edid[11], edid[7] },{ edid[1], edid[2], edid[9], edid[8] },
//		{ edid[9], edid[3], edid[4], edid[10] },{ edid[11], edid[10], edid[5], edid[6] } };
//		for (int j = 0; j < 4; j++)
//		{
//			fcnew[fcloc].type = tmface[i].type;//
//			fcnew[fcloc].c0flag = tmface[i].c0flag;//new
//			for (int k = 0; k < 4; k++)
//			{
//				fcnew[fcloc].cnct[k] = fcnct[j][k];
//				fcnew[fcloc].edge[k] = fedge[j][k];
//			}
//			fcloc++;
//		}
//	}
//	//update hex
//	vector<Element3D> hxnew(8 * tmesh.size());
//	int hxloc(0);
//	for (int i = 0; i < tmesh.size(); i++)
//	{
//		//construct new edges
//		for (int j = 0; j < 6; j++)
//		{
//			ednew[edloc].pt[0] = pid_bd[i];
//			ednew[edloc].pt[1] = pid_fc[tmesh[i].face[j]];
//			edloc++;
//		}
//		//construct new faces
//		int fcnct[12][4] = { { pid_ed[tmesh[i].edge[0]], pid_fc[tmesh[i].face[0]], pid_bd[i], pid_fc[tmesh[i].face[1]] },
//		{ pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[2]], pid_fc[tmesh[i].face[3]], pid_bd[i] },
//		{ pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[10]], pid_fc[tmesh[i].face[5]] },
//		{ pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[8]] },
//		{ pid_ed[tmesh[i].edge[3]], pid_fc[tmesh[i].face[0]], pid_bd[i], pid_fc[tmesh[i].face[4]] },
//		{ pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[1]], pid_fc[tmesh[i].face[2]], pid_bd[i] },
//		{ pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[9]], pid_fc[tmesh[i].face[5]] },
//		{ pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[11]] },
//		{ pid_ed[tmesh[i].edge[4]], pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[4]] },
//		{ pid_fc[tmesh[i].face[1]], pid_ed[tmesh[i].edge[5]], pid_fc[tmesh[i].face[2]], pid_bd[i] },
//		{ pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[6]], pid_fc[tmesh[i].face[3]] },
//		{ pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[7]] } };
//		//collect all edges and faces in this element
//		int edids[12 * 2 + 6 * 4 + 6], fcids[6 * 4 + 12];
//		for (int j = 0; j < 12; j++)
//		{
//			edids[2 * j] = 2 * tmesh[i].edge[j];
//			edids[2 * j + 1] = 2 * tmesh[i].edge[j] + 1;
//			fcids[24 + j] = 4 * tmface.size() + 12 * i + j;
//		}
//		for (int j = 0; j < 6; j++)
//		{
//			edids[24 + 4 * j] = 2 * tmedge.size() + 4 * tmesh[i].face[j];
//			edids[24 + 4 * j + 1] = 2 * tmedge.size() + 4 * tmesh[i].face[j] + 1;
//			edids[24 + 4 * j + 2] = 2 * tmedge.size() + 4 * tmesh[i].face[j] + 2;
//			edids[24 + 4 * j + 3] = 2 * tmedge.size() + 4 * tmesh[i].face[j] + 3;
//			edids[48 + j] = 2 * tmedge.size() + 4 * tmface.size() + 6 * i + j;
//			fcids[4 * j] = 4 * tmesh[i].face[j];
//			fcids[4 * j + 1] = 4 * tmesh[i].face[j] + 1;
//			fcids[4 * j + 2] = 4 * tmesh[i].face[j] + 2;
//			fcids[4 * j + 3] = 4 * tmesh[i].face[j] + 3;
//		}
//		for (int j = 0; j < 12; j++)
//		{
//			for (int k = 0; k < 4; k++)
//			{
//				fcnew[fcloc].cnct[k] = fcnct[j][k];
//				for (int k0 = 24; k0 < 54; k0++)
//				{
//					if ((fcnct[j][k] == ednew[edids[k0]].pt[0] && fcnct[j][(k + 1) % 4] == ednew[edids[k0]].pt[1]) ||
//						(fcnct[j][k] == ednew[edids[k0]].pt[1] && fcnct[j][(k + 1) % 4] == ednew[edids[k0]].pt[0]))
//					{
//						fcnew[fcloc].edge[k] = edids[k0]; break;
//					}
//				}
//			}
//			fcloc++;
//		}
//		//construct new hex
//		int ecnct[8][8] = { { tmesh[i].cnct[0], pid_ed[tmesh[i].edge[0]], pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[3]], pid_ed[tmesh[i].edge[4]], pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[4]] },
//		{ pid_ed[tmesh[i].edge[0]], tmesh[i].cnct[1], pid_ed[tmesh[i].edge[1]], pid_fc[tmesh[i].face[0]], pid_fc[tmesh[i].face[1]], pid_ed[tmesh[i].edge[5]], pid_fc[tmesh[i].face[2]], pid_bd[i] },
//		{ pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[1]], tmesh[i].cnct[2], pid_ed[tmesh[i].edge[2]], pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[6]], pid_fc[tmesh[i].face[3]] },
//		{ pid_ed[tmesh[i].edge[3]], pid_fc[tmesh[i].face[0]], pid_ed[tmesh[i].edge[2]], tmesh[i].cnct[3], pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[7]] },
//		{ pid_ed[tmesh[i].edge[4]], pid_fc[tmesh[i].face[1]], pid_bd[i], pid_fc[tmesh[i].face[4]], tmesh[i].cnct[4], pid_ed[tmesh[i].edge[8]], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[11]] },
//		{ pid_fc[tmesh[i].face[1]], pid_ed[tmesh[i].edge[5]], pid_fc[tmesh[i].face[2]], pid_bd[i], pid_ed[tmesh[i].edge[8]], tmesh[i].cnct[5], pid_ed[tmesh[i].edge[9]], pid_fc[tmesh[i].face[5]] },
//		{ pid_bd[i], pid_fc[tmesh[i].face[2]], pid_ed[tmesh[i].edge[6]], pid_fc[tmesh[i].face[3]], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[9]], tmesh[i].cnct[6], pid_ed[tmesh[i].edge[10]] },
//		{ pid_fc[tmesh[i].face[4]], pid_bd[i], pid_fc[tmesh[i].face[3]], pid_ed[tmesh[i].edge[7]], pid_ed[tmesh[i].edge[11]], pid_fc[tmesh[i].face[5]], pid_ed[tmesh[i].edge[10]], tmesh[i].cnct[7] } };
//		for (int j = 0; j < 8; j++)
//		{
//			for (int k = 0; k < 8; k++)
//			{
//				hxnew[hxloc].cnct[k] = ecnct[j][k];
//			}
//			//find face connectivity
//			for (int k = 0; k < 6; k++)
//			{
//				array<int, 4> tmp1 = { ecnct[j][solid_fc[k][0]], ecnct[j][solid_fc[k][1]], ecnct[j][solid_fc[k][2]], ecnct[j][solid_fc[k][3]] };
//				sort(tmp1.begin(), tmp1.end());
//				for (int k0 = 0; k0 < 36; k0++)
//				{
//					array<int, 4> tmp2 = { fcnew[fcids[k0]].cnct[0], fcnew[fcids[k0]].cnct[1], fcnew[fcids[k0]].cnct[2], fcnew[fcids[k0]].cnct[3] };
//					sort(tmp2.begin(), tmp2.end());
//					if (tmp1 == tmp2)
//					{
//						hxnew[hxloc].face[k] = fcids[k0]; break;
//					}
//				}
//			}
//			//find edge connectivity
//			for (int k = 0; k < 12; k++)
//			{
//				array<int, 2> tmp1 = { ecnct[j][solid_ed[k][0]], ecnct[j][solid_ed[k][1]] };
//				for (int k0 = 0; k0 < 54; k0++)
//				{
//					if ((tmp1[0] == ednew[edids[k0]].pt[0] && tmp1[1] == ednew[edids[k0]].pt[1]) ||
//						(tmp1[0] == ednew[edids[k0]].pt[1] && tmp1[1] == ednew[edids[k0]].pt[0]))
//					{
//						hxnew[hxloc].edge[k] = edids[k0]; break;
//					}
//				}
//			}
//			hxloc++;
//		}
//	}//type of hex not assigned yet
//
//	 //refinement of Bezier patch
//	BezierPatch_Refine(hxnew);
//
//	//update connectivity
//	tmedge.resize(ednew.size());
//	tmface.resize(fcnew.size());
//	tmesh.resize(hxnew.size());
//	for (int i = 0; i < cp.size(); i++)
//	{
//		cp[i].edge.clear();
//		cp[i].face.clear();
//		cp[i].hex.clear();
//	}
//	for (int i = 0; i < ednew.size(); i++)
//	{
//		tmedge[i].act = 1;
//		tmedge[i].type = ednew[i].type;
//		tmedge[i].sharp = ednew[i].sharp;
//		tmedge[i].c0flag = ednew[i].c0flag;
//		tmedge[i].c0flag_b = ednew[i].c0flag_b;
//		tmedge[i].pt[0] = ednew[i].pt[0]; tmedge[i].pt[1] = ednew[i].pt[1];
//		tmedge[i].face.clear();
//		tmedge[i].hex.clear();
//	}
//	for (int i = 0; i < fcnew.size(); i++)
//	{
//		tmface[i].act = 1;
//		tmface[i].type = fcnew[i].type;
//		tmface[i].c0flag = fcnew[i].c0flag;
//		for (int j = 0; j < 4; j++)
//		{
//			tmface[i].cnct[j] = fcnew[i].cnct[j];
//			tmface[i].edge[j] = fcnew[i].edge[j];
//		}
//		tmface[i].hex.clear();
//	}
//	for (int i = 0; i < hxnew.size(); i++)
//	{
//		tmesh[i].act = 1;
//		//tmesh[i].type = hxnew[i].type;//problem
//		tmesh[i].type = 0;
//		for (int j = 0; j < 8; j++)
//		{
//			tmesh[i].cnct[j] = hxnew[i].cnct[j];
//		}
//		for (int j = 0; j < 12; j++)
//		{
//			tmesh[i].edge[j] = hxnew[i].edge[j];
//		}
//		for (int j = 0; j < 6; j++)
//		{
//			tmesh[i].face[j] = hxnew[i].face[j];
//		}
//	}
//
//	//further treatment of Bezier patches
//	FindBezierIEN(hxnew);
//
//	//deconstruct hxnew, fcnew, ednew
//	ClearRefineMemory(hxnew, fcnew, ednew);
//
//	//vertex-to-hex, edge-to-hex, face-to-hex
//	for (int i = 0; i<tmesh.size(); i++)
//	{
//		for (int j = 0; j<8; j++)
//		{
//			cp[tmesh[i].cnct[j]].hex.push_back(i);
//		}
//		for (int j = 0; j<12; j++)
//		{
//			tmedge[tmesh[i].edge[j]].hex.push_back(i);
//		}
//		for (int j = 0; j<6; j++)
//		{
//			tmface[tmesh[i].face[j]].hex.push_back(i);
//		}
//	}
//	//vertex-to-face, edge-to-face
//	for (int i = 0; i<tmface.size(); i++)
//	{
//		for (int j = 0; j<4; j++)
//		{
//			cp[tmface[i].cnct[j]].face.push_back(i);
//			tmedge[tmface[i].edge[j]].face.push_back(i);
//		}
//	}
//	//vertex-to-edge
//	for (int i = 0; i<tmedge.size(); i++)
//	{
//		for (int j = 0; j<2; j++)
//		{
//			cp[tmedge[i].pt[j]].edge.push_back(i);
//		}
//	}
//	//find extraordinary edges and vertices
//	for (int i = 0; i<tmedge.size(); i++)
//	{
//		if (tmedge[i].type != 1 && tmedge[i].hex.size() != 4)
//		{
//			tmedge[i].type = 2;
//			if (cp[tmedge[i].pt[0]].type != 1)
//				cp[tmedge[i].pt[0]].type = 3;
//			if (cp[tmedge[i].pt[1]].type != 1)
//				cp[tmedge[i].pt[1]].type = 3;
//		}
//	}
//	//find boundary and irregular elements
//	for (int i = 0; i<tmesh.size(); i++)
//	{
//		tmesh[i].type = 0;
//		for (int j = 0; j < 8; j++)
//		{
//			if (cp[tmesh[i].cnct[j]].type == 1)
//			{
//				tmesh[i].type = 1; break;
//			}
//		}
//		if (tmesh[i].type != 1)
//		{
//			for (int j = 0; j<12; j++)
//			{
//				if (tmedge[tmesh[i].edge[j]].type == 2)
//				{
//					tmesh[i].type = 2;
//					break;
//				}
//			}
//			//additional
//			for (int j = 0; j<8; j++)
//			{
//				if (cp[tmesh[i].cnct[j]].type == 3)
//				{
//					tmesh[i].type = 2;
//					break;
//				}
//			}
//		}
//	}
//
//	//boundry extraordinary points
//	//for (int i = 0; i<cp.size(); i++)
//	//{
//	//	if (cp[i].type == 1)
//	//	{
//	//		int count(0);
//	//		for (j = 0; j < cp[i].edge.size(); j++)
//	//		{
//	//			if (tmedge[cp[i].edge[j]].type == 2) count++;
//	//		}
//	//		if (count == 1) cp[i].bcxp = 1;
//	//		else if (count>1) cp[i].bcxp = 2;
//	//	}
//	//}
//}
//
//void TruncatedTspline_3D::BezierExtract_C0C1Bezier(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
//{
//	vector<int> aloc(cp.size(), -1);
//	int count(0);
//	for (uint i = 0; i < cp.size(); i++)
//	{
//		if (cp[i].act == 1)
//		{
//			aloc[i] = count++;
//		}
//	}
//	vector<int> bz_aflag(bzcp.size(), 0);
//	vector<int> bz_aloc(bzcp.size(), -1);
//	for (uint eid = 0; eid < tmesh.size(); eid++)
//	{
//		if (tmesh[eid].bzflag == 1)
//		{
//			for (uint i = 0; i < tmesh[eid].IENc01.size(); i++)
//			{
//				bz_aflag[tmesh[eid].IENc01[i]] = 1;
//			}
//		}
//	}
//	for (uint i = 0; i < bz_aflag.size(); i++)
//	{
//		if (bz_aflag[i] == 1)
//		{
//			bz_aloc[i] = count++;
//		}
//	}
//	cpa.clear();
//	cpa.resize(count);
//	int loc(0);
//	for (uint i = 0; i < cp.size(); i++)
//	{
//		if (cp[i].act == 1)
//		{
//			cpa[loc][0] = cp[i].coor[0];
//			cpa[loc][1] = cp[i].coor[1];
//			cpa[loc][2] = cp[i].coor[2];
//			loc++;
//		}
//	}
//	for (uint i = 0; i < bzcp.size(); i++)
//	{
//		if (bz_aflag[i] == 1)
//		{
//			cpa[loc][0] = bzcp[i][0];
//			cpa[loc][1] = bzcp[i][1];
//			cpa[loc][2] = bzcp[i][2];
//			loc++;
//		}
//	}
//
//	IDBC.clear();
//	IDBC.resize(count);
//	for (uint i = 0; i < IDBC.size(); i++)
//	{
//		IDBC[i] = i;//boundary weakly imposed
//	}
//	gh.clear();
//	gh.resize(IDBC.size(), 0.);//initial guess for iterative solvers
//							   //count = 0;
//							   //double xcoor[3];
//							   //array<double, 3> xcoor;
//							   //for (uint i = 0; i < cp.size(); i++)
//							   //{
//							   //	if (aflag[i] == 1)
//							   //	{
//							   //		xcoor[0] = cp[i].coor[0];
//							   //		xcoor[1] = cp[i].coor[1];
//							   //		xcoor[2] = cp[i].coor[2];
//							   //		//gh[count] = SpecifyDirichBC(xcoor);
//							   //		gh[count] = exact_sol(xcoor);
//							   //		count++;
//							   //	}
//							   //}
//							   //for (uint i = 0; i < bzcp.size(); i++)
//							   //{
//							   //	gh[count + i] = SpecifyDirichBC(bzcp[i].data());
//							   //}
//
//	cout << "Bezier extracting...\n";
//	cout << "# Bezier: " << tmesh.size() << "\n";
//	bzmesh.resize(tmesh.size());
//#pragma omp parallel for
//	for (int eid = 0; eid < tmesh.size(); eid++)
//	{
//		if (eid != 0 && eid % 500 == 0)
//		{
//			cout << eid << " ";
//		}
//		//find types of interfaces
//		if (tmesh[eid].type == 1)
//		{
//			for (int k = 0; k < 6; k++)
//			{
//				if (tmface[tmesh[eid].face[k]].hex.size() == 1)//must be a boundary element
//				{
//					bzmesh[eid].bc[k] = 1;//boundary face for boundary condition
//										  //bzmesh[eid].bcflag = 1;
//				}
//				//else if (tmface[tmesh[eid].face[k]].hex.size() == 2)
//				//{
//				//	int hxnb(tmface[tmesh[eid].face[k]].hex[0]);
//				//	if (hxnb == eid) hxnb = tmface[tmesh[eid].face[k]].hex[1];
//				//	if (tmesh[hxnb].bzflag == 0)
//				//	{
//				//		bzmesh[eid].bc[k] = 2;//coupling interface
//				//		bzmesh[eid].bzcouple = 1;
//				//	}
//				//}
//			}
//		}
//
//		double tmp;
//		bzmesh[eid].type = tmesh[eid].type;//used for visualization
//										   //bzmesh[eid].bzflag = tmesh[eid].bzflag;//not used
//										   //if (bzmesh[eid].bzcouple == 0)
//		{
//			if (tmesh[eid].bzflag == 0)
//			{
//				int count1 = 0;
//				for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
//				{
//					if (aloc[tmesh[eid].IEN[k]] != -1)
//					{
//						count1++;
//					}
//				}
//				bzmesh[eid].IEN.resize(count1);
//				bzmesh[eid].cmat.resize(count1, vector<double>(64, 0.));
//				//if (bzmesh[eid].IEN.size() > 64)
//				//{
//				//	cerr << "bzflag 0 eid: " << eid << "\n";
//				//	getchar();
//				//}
//				count1 = 0;
//				for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
//				{
//					if (aloc[tmesh[eid].IEN[k]] != -1)
//					{
//						bzmesh[eid].IEN[count1] = aloc[tmesh[eid].IEN[k]];
//						for (int k1 = 0; k1 < 64; k1++)
//						{
//							if (tmesh[eid].bemat[k][k1] != 0.)
//							{
//								tmp = tmesh[eid].bemat[k][k1];
//								bzmesh[eid].cmat[count1][k1] = tmp;
//								bzmesh[eid].pts[k1][0] += tmp * cp[tmesh[eid].IEN[k]].coor[0];
//								bzmesh[eid].pts[k1][1] += tmp * cp[tmesh[eid].IEN[k]].coor[1];
//								bzmesh[eid].pts[k1][2] += tmp * cp[tmesh[eid].IEN[k]].coor[2];
//							}
//						}
//						count1++;
//					}
//				}
//			}
//			else if (tmesh[eid].bzflag == 1 || tmesh[eid].bzflag == 2)
//			{
//				int count2 = 0;
//				for (uint k = 0; k < tmesh[eid].IENc2.size(); k++)
//				{
//					if (aloc[tmesh[eid].IENc2[k]] != -1)
//					{
//						count2++;
//					}
//				}
//				//bzmesh[eid].IEN.resize(tmesh[eid].IENc01.size() + tmesh[eid].IENc2.size());
//				bzmesh[eid].IEN.resize(tmesh[eid].IENc01.size() + count2);
//				bzmesh[eid].cmat.resize(bzmesh[eid].IEN.size(), vector<double>(64, 0.));
//				//if (bzmesh[eid].IEN.size() > 64)
//				//{
//				//	cerr << "bzflag 1 or 2 eid: " << eid << "\n";
//				//	cout << tmesh[eid].IENc01.size() << " " << count2 << "\n";
//				//	getchar();
//				//}
//				for (uint k = 0; k < tmesh[eid].IENc01.size(); k++)
//				{
//					bzmesh[eid].IEN[k] = bz_aloc[tmesh[eid].IENc01[k]];
//					for (int k1 = 0; k1 < 64; k1++)
//					{
//						if (tmesh[eid].cmat[k][k1] != 0.)
//						{
//							tmp = tmesh[eid].cmat[k][k1];
//							bzmesh[eid].cmat[k][k1] = tmp;
//							bzmesh[eid].pts[k1][0] += tmp * bzcp[tmesh[eid].IENc01[k]][0];
//							bzmesh[eid].pts[k1][1] += tmp * bzcp[tmesh[eid].IENc01[k]][1];
//							bzmesh[eid].pts[k1][2] += tmp * bzcp[tmesh[eid].IENc01[k]][2];
//						}
//					}
//				}
//				int ist(tmesh[eid].IENc01.size());
//				count2 = 0;
//				for (uint k = 0; k < tmesh[eid].IENc2.size(); k++)
//				{
//					if (aloc[tmesh[eid].IENc2[k]] != -1)
//					{
//						int k0(ist + count2);
//						bzmesh[eid].IEN[k0] = aloc[tmesh[eid].IENc2[k]];
//						for (int k1 = 0; k1 < 64; k1++)
//						{
//							//if (tmesh[eid].cmat[k0][k1] != 0.)
//							if (tmesh[eid].cmat[ist + k][k1] != 0.)
//							{
//								tmp = tmesh[eid].cmat[ist + k][k1];
//								bzmesh[eid].cmat[k0][k1] = tmp;
//								bzmesh[eid].pts[k1][0] += tmp * cp[tmesh[eid].IENc2[k]].coor[0];
//								bzmesh[eid].pts[k1][1] += tmp * cp[tmesh[eid].IENc2[k]].coor[1];
//								bzmesh[eid].pts[k1][2] += tmp * cp[tmesh[eid].IENc2[k]].coor[2];
//							}
//						}
//						count2++;
//					}
//
//				}
//				//for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
//				//{
//				//	bzmesh[eid].IENb[k] = tmesh[eid].IENb[k] + count;
//				//	bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
//				//	bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
//				//	bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
//				//}
//			}
//			//else if (tmesh[eid].bzflag == 2)
//			//{
//			//}
//		}
//		//else//bzflag must be 1
//		//{
//		//	bzmesh[eid].IEN.resize(tmesh[eid].IEN.size());
//		//	bzmesh[eid].cmat.resize(tmesh[eid].IEN.size(), vector<double>(64));
//		//	for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
//		//	{
//		//		bzmesh[eid].IEN[k] = aloc[tmesh[eid].IEN[k]];
//		//		for (int k1 = 0; k1 < 64; k1++)
//		//		{
//		//			bzmesh[eid].cmat[k][k1] = tmesh[eid].bemat[k][k1];
//		//		}
//		//	}
//		//	bzmesh[eid].IENb.resize(tmesh[eid].IENb.size());
//		//	for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
//		//	{
//		//		bzmesh[eid].IENb[k] = tmesh[eid].IENb[k] + count;
//		//		bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
//		//		bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
//		//		bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
//		//	}
//		//}
//	}
//
//	//for (uint i = 0; i < bzmesh.size(); i++)
//	//{
//	//	for (uint j = 0; j < 64; j++)
//	//	{
//	//		double sum(0.);
//	//		for (uint k = 0; k < bzmesh[i].cmat.size(); k++)
//	//		{
//	//			sum += bzmesh[i].cmat[k][j];
//	//		}
//	//		if (fabs(sum - 1.)>1.e-6)
//	//		{
//	//			cout << sum << "\n";
//	//		}
//	//	}
//	//}
//	//cout << "oo\n"; getchar();
//}












//strongly impose Dirichlet BC with fitting
void TruncatedTspline_3D::StrongDirichletBC(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	int bzfc[6][16] = { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }, { 0, 1, 2, 3, 16, 17, 18, 19, 32, 33, 34, 35, 48, 49, 50, 51 }, 
	{ 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63 }, { 12, 13, 14, 15, 28, 29, 30, 31, 44, 45, 46, 47, 60, 61, 62, 63 },
	{ 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60 }, { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63 } };

	vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			aloc[i] = count++;
		}
	}
	vector<int> bz_aflag(bzcp.size(), 0);
	vector<int> bz_aloc(bzcp.size(), -1);
	vector<int> bz_bcflag(bzcp.size(), 0);
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].bzflag == 1)
		{
			for (uint i = 0; i < tmesh[eid].IENc01.size(); i++)
			{
				bz_aflag[tmesh[eid].IENc01[i]] = 1;
			}
			if (tmesh[eid].type == 1)
			{
				for (int i = 0; i < 6; i++)
				{
					if (tmface[tmesh[eid].face[i]].type == 1)
					{
						for (int j = 0; j < 16; j++)
						{
							bz_bcflag[tmesh[eid].IENb[bzfc[i][j]]] = 1;
						}
					}
				}
			}
		}
	}
	for (uint i = 0; i < bz_aflag.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			bz_aloc[i] = count++;
		}
	}

	IDBC.clear();
	IDBC.resize(count, -1);
	gh.clear();
	gh.resize(IDBC.size(), 0.);
	int loc(0), count1(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			if (cp[i].type == 1)
			{
				//array<double, 3> xcoor = { cp[i].coor[0], cp[i].coor[1], cp[i].coor[2] };
				//gh[loc] = exact_sol(xcoor);//directly impose without fitting
				gh[loc] = 0.;
			}
			else
			{
				IDBC[loc] = count1++;
			}
			//if (fabs(cp[i].coor[0] - 0.) < 1.e-8)
			//{
			//	array<double, 3> xcoor = { cp[i].coor[0], cp[i].coor[1], cp[i].coor[2] };
			//	gh[loc] = exact_sol(xcoor);
			//}
			//else if (fabs(cp[i].coor[0] - 1.) < 1.e-8)
			//{
			//	array<double, 3> xcoor = { cp[i].coor[0], cp[i].coor[1], cp[i].coor[2] };
			//	gh[loc] = exact_sol(xcoor);
			//}
			//else
			//{
			//	IDBC[loc] = count1++;
			//}
			loc++;
		}
	}
	for (uint i = 0; i < bzcp.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			if (bz_bcflag[i] == 1)
			{
				//gh[loc] = exact_sol(bzcp[i]);//directly impose without fitting
				gh[loc] = 0.;
			}
			else
			{
				IDBC[loc] = count1++;
			}
			//if (fabs(bzcp[i][0] - 0.) < 1.e-8)
			//{
			//	gh[loc] = exact_sol(bzcp[i]);
			//}
			//else if (fabs(bzcp[i][0] - 1.) < 1.e-8)
			//{
			//	gh[loc] = exact_sol(bzcp[i]);
			//}
			//else
			//{
			//	IDBC[loc] = count1++;
			//}
			loc++;
		}
	}

	//fitting data
	vector<int> IDBC1(IDBC.size(), -1);
	vector<double> gh1(gh.size(), 0.);
	count1 = 0;
	for (uint i = 0; i < IDBC.size(); i++)
	{
		if (IDBC[i] == -1)
		{
			IDBC1[i] = count1++;
		}
	}
	LeastSquare ls;
	vector<double> sol;
	ls.SetProblem(IDBC1, gh1);
	//ls.GetEqParameter(dmrg, nmpl, acoef);
	//ls.VisualizeBoundarySurface(bzmesh, cpts, "../io/complex2/rod2");
	//cout << "done output boundary surface!\n";
	//getchar();
	ls.Run_Fitting(bzmesh, "", sol);
	for (uint i = 0; i < IDBC.size(); i++)
	{
		if (IDBC[i] == -1)
		{
			gh[i] = sol[i];
		}
	}
}

void TruncatedTspline_3D::StrongDirichletBC_C0(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	int bzfc[6][16] = { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }, { 0, 1, 2, 3, 16, 17, 18, 19, 32, 33, 34, 35, 48, 49, 50, 51 },
	{ 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63 }, { 12, 13, 14, 15, 28, 29, 30, 31, 44, 45, 46, 47, 60, 61, 62, 63 },
	{ 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60 }, { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63 } };

	vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			aloc[i] = count++;
		}
	}
	vector<int> bz_aflag(bzcp.size(), 0);
	vector<int> bz_aloc(bzcp.size(), -1);
	vector<int> bz_bcflag(bzcp.size(), 0);
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].bzflag == 1)
		{
			for (uint i = 0; i < tmesh[eid].IENb.size(); i++)
			{
				bz_aflag[tmesh[eid].IENb[i]] = 1;
			}
			if (tmesh[eid].type == 1)
			{
				for (int i = 0; i < 6; i++)
				{
					if (tmface[tmesh[eid].face[i]].type == 1)
					{
						for (int j = 0; j < 16; j++)
						{
							bz_bcflag[tmesh[eid].IENb[bzfc[i][j]]] = 1;
						}
					}
				}
			}
		}
	}
	for (uint i = 0; i < bz_aflag.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			bz_aloc[i] = count++;
		}
	}

	IDBC.clear();
	IDBC.resize(count, -1);
	gh.clear();
	gh.resize(IDBC.size(), 0.);
	int loc(0), count1(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			if (cp[i].type == 1)
			{
				//array<double, 3> xcoor = { cp[i].coor[0], cp[i].coor[1], cp[i].coor[2] };
				//gh[loc] = exact_sol(xcoor);//directly impose without fitting
				gh[loc] = 0.;
			}
			else
			{
				IDBC[loc] = count1++;
			}
			//if (fabs(cp[i].coor[0] - 0.) < 1.e-8)
			//{
			//	array<double, 3> xcoor = { cp[i].coor[0], cp[i].coor[1], cp[i].coor[2] };
			//	gh[loc] = exact_sol(xcoor);
			//}
			//else if (fabs(cp[i].coor[0] - 1.) < 1.e-8)
			//{
			//	array<double, 3> xcoor = { cp[i].coor[0], cp[i].coor[1], cp[i].coor[2] };
			//	gh[loc] = exact_sol(xcoor);
			//}
			//else
			//{
			//	IDBC[loc] = count1++;
			//}
			loc++;
		}
	}
	for (uint i = 0; i < bzcp.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			if (bz_bcflag[i] == 1)
			{
				//gh[loc] = exact_sol(bzcp[i]);//directly impose without fitting
				gh[loc] = 0.;
			}
			else
			{
				IDBC[loc] = count1++;
			}
			//if (fabs(bzcp[i][0] - 0.) < 1.e-8)
			//{
			//	gh[loc] = exact_sol(bzcp[i]);
			//}
			//else if (fabs(bzcp[i][0] - 1.) < 1.e-8)
			//{
			//	gh[loc] = exact_sol(bzcp[i]);
			//}
			//else
			//{
			//	IDBC[loc] = count1++;
			//}
			loc++;
		}
	}

	//fitting data
	vector<int> IDBC1(IDBC.size(), -1);
	vector<double> gh1(gh.size(), 0.);
	count1 = 0;
	for (uint i = 0; i < IDBC.size(); i++)
	{
		if (IDBC[i] == -1)
		{
			IDBC1[i] = count1++;
		}
	}
	LeastSquare ls;
	vector<double> sol;
	ls.SetProblem(IDBC1, gh1);
	//ls.GetEqParameter(dmrg, nmpl, acoef);
	//ls.VisualizeBoundarySurface(bzmesh, cpts, "../io/complex2/rod2");
	//cout << "done output boundary surface!\n";
	//getchar();
	ls.Run_Fitting(bzmesh, "", sol);
	for (uint i = 0; i < IDBC.size(); i++)
	{
		if (IDBC[i] == -1)
		{
			gh[i] = sol[i];
		}
	}
}

void TruncatedTspline_3D::StrongDirichletBC_Elasticity(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	//string fn("../io/letest/cube_bc");
	//int nbc()
	//ReadBC(fn,)

	int bzfc[6][16] = { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
	{ 0, 1, 2, 3, 16, 17, 18, 19, 32, 33, 34, 35, 48, 49, 50, 51 },
	{ 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63 },
	{ 12, 13, 14, 15, 28, 29, 30, 31, 44, 45, 46, 47, 60, 61, 62, 63 },
	{ 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60 },
	{ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63 } };

	vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			aloc[i] = count++;
		}
	}
	vector<int> bz_aflag(bzcp.size(), 0);
	vector<int> bz_aloc(bzcp.size(), -1);
	vector<int> bz_bcflag(bzcp.size(), 0);
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].bzflag == 1)
		{
			for (uint i = 0; i < tmesh[eid].IENc01.size(); i++)
			{
				bz_aflag[tmesh[eid].IENc01[i]] = 1;
			}
			if (tmesh[eid].type == 1)
			{
				for (int i = 0; i < 6; i++)
				{
					if (tmface[tmesh[eid].face[i]].type == 1)
					{
						for (int j = 0; j < 16; j++)
						{
							bz_bcflag[tmesh[eid].IENb[bzfc[i][j]]] = 1;
						}
					}
				}
			}
		}
	}
	for (uint i = 0; i < bz_aflag.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			bz_aloc[i] = count++;
		}
	}

	int uy0(1290), ux0(4891), ux1(1973);//heli
	IDBC.clear();
	IDBC.resize(3 * count, -1);
	gh.clear();
	gh.resize(IDBC.size(), 0.);
	int loc(0), count1(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			if (cp[i].type == 1)
			{
				for (int idof = 0; idof < 3; idof++)
				{
					//if (idof == 0 && fabs(cp[i].coor[idof] - 0.) < 1.e-8)
					//{
					//	gh[3 * loc + idof] = 0.;
					//}
					//else if (idof == 1 && fabs(cp[i].coor[idof] - 0.) < 1.e-8)
					//{
					//	gh[3 * loc + idof] = 0.;
					//}
					//else if (idof == 2 && fabs(cp[i].coor[idof] - 0.) < 1.e-8)
					//{
					//	gh[3 * loc + idof] = 0.;
					//}
					//else if (idof == 0 && fabs(cp[i].coor[idof] - 1.) < 1.e-8)
					//{
					//	gh[3 * loc + idof] = 0.01;
					//}
					//else
					//{
					//	IDBC[3 * loc + idof] = count1++;
					//}
					if (idof == 0 && fabs(cp[i].coor[idof] - cp[ux0].coor[0]) < 1.e-4)
					{
						gh[3 * loc + idof] = 0.;
					}
					else if (idof == 1 && fabs(cp[i].coor[idof] - cp[uy0].coor[1]) < 1.e-4)
					{
						gh[3 * loc + idof] = 0.;
					}
					else if (idof == 2 && (fabs(cp[i].coor[0] - cp[ux0].coor[0]) < 1.e-4 || fabs(cp[i].coor[0] - cp[ux1].coor[0]) < 1.e-4))
					{
						gh[3 * loc + idof] = 0.;
					}
					else if (idof == 0 && fabs(cp[i].coor[idof] - cp[ux1].coor[0]) < 1.e-4)
					{
						gh[3 * loc + idof] = -0.01;
					}
					else
					{
						IDBC[3 * loc + idof] = count1++;
					}
				}
			}
			else
			{
				for (int idof = 0; idof < 3; idof++)
				{
					IDBC[3 * loc + idof] = count1++;
				}
			}
			loc++;
		}
	}
	for (uint i = 0; i < bzcp.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			if (bz_bcflag[i] == 1)
			{
				for (int idof = 0; idof < 3; idof++)
				{
					//if (idof == 0 && fabs(bzcp[i][idof] - 0.) < 1.e-8)
					//{
					//	gh[3 * loc + idof] = 0.;
					//}
					//else if (idof == 1 && fabs(bzcp[i][idof] - 0.) < 1.e-8)
					//{
					//	gh[3 * loc + idof] = 0.;
					//}
					//else if (idof == 2 && fabs(bzcp[i][idof] - 0.) < 1.e-8)
					//{
					//	gh[3 * loc + idof] = 0.;
					//}
					//else if (idof == 0 && fabs(bzcp[i][idof] - 1.) < 1.e-8)
					//{
					//	gh[3 * loc + idof] = .01;
					//}
					//else
					//{
					//	IDBC[3 * loc + idof] = count1++;
					//}
					if (idof == 0 && fabs(bzcp[i][idof] - cp[ux0].coor[0]) < 1.e-4)
					{
						gh[3 * loc + idof] = 0.;
					}
					else if (idof == 1 && fabs(bzcp[i][idof] - cp[uy0].coor[1]) < 1.e-4)
					{
						gh[3 * loc + idof] = 0.;
					}
					else if (idof == 2 && (fabs(bzcp[i][0] - cp[ux0].coor[0]) < 1.e-4 || fabs(bzcp[i][0] - cp[ux1].coor[0]) < 1.e-4))
					{
						gh[3 * loc + idof] = 0.;
					}
					else if (idof == 0 && fabs(bzcp[i][idof] - cp[ux1].coor[0]) < 1.e-4)
					{
						gh[3 * loc + idof] = -0.01;
					}
					else
					{
						IDBC[3 * loc + idof] = count1++;
					}
				}
			}
			else
			{
				for (int idof = 0; idof < 3; idof++)
				{
					IDBC[3 * loc + idof] = count1++;
				}
			}
			loc++;
		}
	}

	//int ux0(34769), ux1(30694);
	//IDBC.clear();
	//IDBC.resize(3 * count, -1);
	//gh.clear();
	//gh.resize(IDBC.size(), 0.);
	//int loc(0), count1(0);
	//for (uint i = 0; i < cp.size(); i++)
	//{
	//	if (cp[i].act == 1)
	//	{
	//		//if (cp[i].type == 1)
	//		//{
	//		//	for (int idof = 0; idof < 3; idof++)
	//		//	{
	//		//		if (fabs(cp[i].coor[idof] - cp[ux0].coor[0]) < 1.e-4)
	//		//		{
	//		//			gh[3 * loc + idof] = 0.;
	//		//		}
	//		//		else if (idof == 2 && fabs(cp[i].coor[idof] - cp[uz1].coor[2]) < 1.e-4)
	//		//		{
	//		//			gh[3 * loc + idof] = 0.1;
	//		//		}
	//		//		else
	//		//		{
	//		//			IDBC[3 * loc + idof] = count1++;
	//		//		}
	//		//	}
	//		//}
	//		//else
	//		{
	//			for (int idof = 0; idof < 3; idof++)
	//			{
	//				IDBC[3 * loc + idof] = count1++;
	//			}
	//		}
	//		loc++;
	//	}
	//}
	//for (uint i = 0; i < bzcp.size(); i++)
	//{
	//	if (bz_aflag[i] == 1)
	//	{
	//		if (bz_bcflag[i] == 1)
	//		{
	//			for (int idof = 0; idof < 3; idof++)
	//			{
	//				if (fabs(bzcp[i][idof] - cp[ux0].coor[0]) < 1.e-4)
	//				{
	//					gh[3 * loc + idof] = 0.;
	//				}
	//				else if (idof == 0 && fabs(bzcp[i][idof] - cp[ux1].coor[0]) < 1.e-2)
	//				{
	//					//cout << "here!\n"; getchar();
	//					gh[3 * loc + idof] = 0.1;
	//				}
	//				else
	//				{
	//					IDBC[3 * loc + idof] = count1++;
	//				}
	//			}
	//		}
	//		else
	//		{
	//			for (int idof = 0; idof < 3; idof++)
	//			{
	//				IDBC[3 * loc + idof] = count1++;
	//			}
	//		}
	//		loc++;
	//	}
	//}
	//cout << "Done BC!\n"; getchar();

	//fitting data
	//vector<int> IDBC1(IDBC.size(), -1);
	//vector<double> gh1(gh.size(), 0.);
	//count1 = 0;
	//for (uint i = 0; i < IDBC.size(); i++)
	//{
	//	if (IDBC[i] == -1)
	//	{
	//		IDBC1[i] = count1++;
	//	}
	//}
	//LeastSquare ls;
	//vector<double> sol;
	//ls.SetProblem(IDBC1, gh1);
	////ls.GetEqParameter(dmrg, nmpl, acoef);
	////ls.VisualizeBoundarySurface(bzmesh, cpts, "../io/complex2/rod2");
	////cout << "done output boundary surface!\n";
	////getchar();
	//ls.Run_Fitting(bzmesh, "", sol);
	//for (uint i = 0; i < IDBC.size(); i++)
	//{
	//	if (IDBC[i] == -1)
	//	{
	//		gh[i] = sol[i];
	//	}
	//}
}

void TruncatedTspline_3D::StrongDirichletBC_Elasticity_Manual(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	//heli
	int bottom[] = { 456, 457, 458, 459, 464, 465, 472, 473, 474, 475, 478, 479, 482, 483, 486, 487,
		501, 502, 503, 504, 505, 506, 511, 512, 513, 514, 515, 517, 530, 531, 532, 533,
		538, 539, 544, 545, 548, 549, 552, 554, 1504, 1505, 1506, 1507, 1512, 1513, 1514, 1515,
		1518, 1519, 1522, 1523, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1550, 1551, 1552,
		1553, 1558, 1559, 1562, 1563, 1566, 2022, 2023, 2024, 2025, 2030, 2031, 2032, 2033, 2036, 2037,
		2040, 2041, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2068, 2069, 2070, 2071, 2076,
		2077, 2080, 2081, 2084, 2540, 2541, 2542, 2543, 2548, 2549, 2550, 2551, 2554, 2555, 2558, 2559,
		2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2586, 2587, 2588, 2589, 2594, 2595, 2598,
		2599, 2602, 3058, 3059, 3060, 3061, 3066, 3067, 3068, 3069, 3072, 3073, 3076, 3077, 3087, 3088,
		3089, 3090, 3091, 3092, 3093, 3094, 3095, 3104, 3105, 3106, 3107, 3120, 3121, 3124, 3125, 3130,
		3716, 3717, 3718, 3719, 3724, 3725, 3726, 3727, 3730, 3731, 3734, 3735, 3745, 3746, 3747, 3748,
		3749, 3750, 3751, 3752, 3753, 3762, 3763, 3764, 3765, 3774, 3775, 3778, 3779, 3780, 4248, 4249,
		4250, 4251, 4256, 4257, 4258, 4259, 4262, 4263, 4266, 4267, 4277, 4278, 4279, 4280, 4281, 4282,
		4283, 4284, 4285, 4294, 4295, 4296, 4297, 4310, 4311, 4314, 4315, 4320, 4906, 4907, 4908, 4909,
		4914, 4915, 4916, 4917, 4920, 4921, 4924, 4925, 4935, 4936, 4937, 4938, 4939, 4940, 4941, 4942,
		4943, 4952, 4953, 4954, 4955, 4964, 4965, 4968, 4969, 4972, 5480, 5481, 5482, 5483, 5488, 5489,
		5490, 5491, 5494, 5495, 5498, 5499, 5509, 5510, 5511, 5512, 5513, 5514, 5515, 5516, 5517, 5526,
		5527, 5528, 5529, 5534, 5535, 5538, 5539, 5542, 5998, 5999, 6000, 6001, 6006, 6007, 6008, 6009,
		6012, 6013, 6016, 6017, 6027, 6028, 6029, 6030, 6031, 6032, 6033, 6034, 6035, 6044, 6045, 6046,
		6047, 6052, 6053, 6056, 6057, 6060, 6516, 6517, 6518, 6519, 6524, 6525, 6526, 6527, 6530, 6531,
		6534, 6535, 6545, 6546, 6547, 6548, 6549, 6550, 6551, 6552, 6553, 6562, 6563, 6564, 6565, 6570,
		6571, 6574, 6575, 6578, 7034, 7035, 7036, 7037, 7046, 7047, 7048, 7049, 7052, 7053, 7060, 7061,
		7072, 7073, 7074, 7075, 7080, 7081, 7082, 7083, 7088, 7098, 7099, 7100, 7101, 7110, 7111, 7114,
		7115, 7120, 27239, 27240, 27241, 27242, 27247, 27248, 27249, 27250, 27251, 27252, 27253, 27254, 27255, 27256,
		27257, 27258, 27271, 27272, 27273, 27274, 27279, 27280, 27281, 27282, 27283, 27284, 27285, 27286, 27299, 27300,
		27301, 27302, 27305, 27306, 27307, 27308, 27309, 27310, 27311, 27312, 27325, 27326, 27327, 27328, 27331, 27332,
		27333, 27334, 27335, 27348, 27349, 27350, 27351, 27354, 27355, 27356, 27357, 27358, 27359, 27360, 27361, 27374,
		27375, 27376, 27377, 27380, 27381, 27382, 27383, 27384, 27397, 27398, 27399, 27400, 27403, 27404, 27405, 27406,
		27407, 27408, 27409, 27410, 27423, 27424, 27425, 27426, 27429, 27430, 27431, 27432, 27433, 27446, 27447, 27448,
		27449, 27452, 27453, 27454, 27455, 27456, 27457, 27458, 27459, 27472, 27473, 27474, 27475, 27478, 27479, 27480,
		27481, 27482, 27495, 27496, 27497, 27498, 27501, 27502, 27503, 27504, 27505, 27506, 27507, 27508, 27521, 27522,
		27523, 27524, 27527, 27528, 27529, 27530, 27531, 27544, 27545, 27546, 27547, 27548, 27549, 27550, 27551, 27564,
		27565, 27566, 27567, 27568, 27569, 32312, 32313, 32314, 32315, 32316, 32317, 32320, 32321, 32322, 32323, 32324,
		32325, 32503, 32504, 32505, 32506, 32507, 32508, 32511, 32512, 32513, 32514, 32515, 32516, 32694, 32695, 32696,
		32697, 32698, 32699, 32702, 32703, 32704, 32705, 32706, 32707, 32966, 32967, 32968, 32969, 32974, 32975, 32978,
		32979, 32980, 32981, 32984, 32985, 33160, 33161, 33162, 33163, 33168, 33169, 33170, 33171, 33174, 33345, 33346,
		33347, 33348, 33353, 33354, 33355, 33356, 33359, 33530, 33531, 33532, 33533, 33538, 33539, 33540, 33541, 33544,
		33769, 33770, 33771, 33772, 33781, 33782, 33783, 33784, 33787 };
	int top[] = { 9296, 9297, 9300, 9301, 9422, 9423, 9426, 10812, 10813, 10814, 10815, 10824, 10825, 10826, 10827, 10828,
		10829, 10830, 10831, 10842, 10843, 10844, 10845, 10857, 10858, 10859, 10860, 10869, 10870, 10871, 10872, 10873,
		10874, 10883, 10884, 10895, 10896, 10897, 10898, 10903, 10904, 10905, 10906, 10907, 10908, 10913, 10914, 10924,
		10925, 10926, 10927, 10932, 10933, 10934, 10935, 10940, 10950, 10951, 10952, 10953, 10958, 10959, 10960, 10961,
		10962, 10963, 10968, 10969, 10979, 10980, 10981, 10982, 10987, 10988, 10989, 10990, 10995, 11005, 11006, 11007,
		11008, 11013, 11014, 11015, 11016, 11017, 11018, 11023, 11024, 11034, 11035, 11036, 11037, 11042, 11043, 11044,
		11045, 11050, 11060, 11061, 11062, 11063, 11072, 11073, 11074, 11075, 11086, 11087, 11088, 11089, 11094, 11095,
		17242, 17243, 17246, 17247, 17357, 17358, 17359, 17360, 17361, 17362, 17365, 17366, 17367, 17368, 17369, 17370,
		17480, 17481, 17482, 17483, 17484, 17485, 17488, 17489, 17490, 17491, 17492, 17493, 17603, 17604, 17605, 17606,
		17607, 17608, 17611, 17612, 17613, 17614, 17615, 17616, 17726, 17727, 17728, 17729, 17730, 17731, 17734, 17735,
		17736, 17737, 17738, 17739, 17849, 17850, 17851, 17852, 17853, 17854, 17857, 17858, 17859, 17860, 17861, 17862,
		17972, 17973, 17974, 17975, 17976, 17977, 17980, 17981, 17982, 17983, 17984, 17985, 18095, 18096, 18097, 18098,
		18099, 18100, 18103, 18104, 18105, 18106, 18107, 18108, 18218, 18219, 18220, 18221, 18222, 18223, 18226, 18227,
		18228, 18229, 18230, 18231, 18341, 18342, 18343, 18344, 18345, 18346, 18349, 18350, 18351, 18352, 18353, 18354,
		18464, 18465, 18466, 18467, 18468, 18469, 18472, 18473, 18474, 18475, 18476, 18477, 18568, 18569, 18570, 18571,
		18576, 18577, 18578, 18579, 20507, 20508, 20513, 20616, 20617, 20618, 20619, 20624, 20625, 20626, 20627, 20630,
		20733, 20734, 20735, 20736, 20741, 20742, 20743, 20744, 20747, 20850, 20851, 20852, 20853, 20858, 20859, 20860,
		20861, 20864, 20967, 20968, 20969, 20970, 20975, 20976, 20977, 20978, 20981, 21084, 21085, 21086, 21087, 21092,
		21093, 21094, 21095, 21098, 21201, 21202, 21203, 21204, 21209, 21210, 21211, 21212, 21215, 21318, 21319, 21320,
		21321, 21326, 21327, 21328, 21329, 21332, 21435, 21436, 21437, 21438, 21443, 21444, 21445, 21446, 21449, 21552,
		21553, 21554, 21555, 21560, 21561, 21562, 21563, 21566, 21669, 21670, 21671, 21672, 21677, 21678, 21679, 21680,
		21683, 21768, 21769, 21770, 21771, 21776, 21777 };
	int side[] = { 10816, 10817, 10818, 10819, 10824, 10825, 10832, 10833, 10834, 10835, 10838, 10839, 10842, 10843, 10846, 10847,
		10861, 10862, 10863, 10864, 10869, 10870, 10875, 10876, 10879, 10880, 10883, 10885, 11106, 11107, 11108, 11109,
		11114, 11115, 11116, 11117, 11120, 11121, 11124, 11125, 11135, 11136, 11137, 11138, 11143, 11144, 11147, 11148,
		11151, 11291, 11292, 11293, 11294, 11299, 11300, 11301, 11302, 11305, 11306, 11309, 11310, 11320, 11321, 11322,
		11323, 11328, 11329, 11332, 11333, 11336, 11476, 11477, 11478, 11479, 11484, 11485, 11486, 11487, 11490, 11491,
		11494, 11495, 11505, 11506, 11507, 11508, 11513, 11514, 11517, 11518, 11521, 11661, 11662, 11663, 11664, 11669,
		11670, 11671, 11672, 11675, 11676, 11679, 11680, 11690, 11691, 11692, 11693, 11698, 11699, 11702, 11703, 11706,
		11846, 11847, 11848, 11849, 11858, 11859, 11860, 11861, 11864, 11865, 11872, 11873, 11884, 11885, 11886, 11887,
		11896, 11897, 11900, 11901, 11906, 27666, 27667, 27668, 27669, 27672, 27673, 27676, 27677, 27678, 27679, 27680,
		27681, 27682, 27683, 27684, 27685, 27766, 27767, 27768, 27769, 27770, 27771, 27774, 27775, 27776, 27777, 27778,
		27779, 27860, 27861, 27862, 27863, 27864, 27865, 27868, 27869, 27870, 27871, 27872, 27873, 27954, 27955, 27956,
		27957, 27958, 27959, 27962, 27963, 27964, 27965, 27966, 27967, 28048, 28049, 28050, 28051, 28052, 28053, 28056,
		28057, 28058, 28059, 28060, 28061, 28142, 28143, 28144, 28145, 28146, 28147, 28150, 28151, 28152, 28153, 28154,
		28155, 28236, 28237, 28238, 28239, 28240, 28241, 28244, 28245, 28246, 28247, 28248, 28249, 28330, 28331, 28332,
		28333, 28334, 28335, 28338, 28339, 28340, 28341, 28342, 28343, 28424, 28425, 28426, 28427, 28428, 28429, 28432,
		28433, 28434, 28435, 28436, 28437, 28518, 28519, 28520, 28521, 28522, 28523, 28526, 28527, 28528, 28529, 28530,
		28531, 28612, 28613, 28614, 28615, 28616, 28617, 28620, 28621, 28622, 28623, 28624, 28625, 28706, 28707, 28708,
		28709, 28710, 28711, 28714, 28715, 28716, 28717, 28718, 28719, 28800, 28801, 28802, 28803, 28804, 28805, 28808,
		28809, 28810, 28811, 28812, 28813, 28894, 28895, 28896, 28897, 28898, 28899, 28902, 28903, 28904, 28905, 28906,
		28907, 28988, 28989, 28990, 28991, 28992, 28993, 28996, 28997, 28998, 28999, 29000, 29001, 29082, 29083, 29084,
		29085, 29086, 29087, 29090, 29091, 29092, 29093, 29094, 29095, 29176, 29177, 29178, 29179, 29180, 29181, 29184,
		29185, 29186, 29187, 29188, 29189, 29274, 29275, 29276, 29277, 29278, 29279, 29282, 29283, 29284, 29285, 29286,
		29287, 29368, 29369, 29370, 29371, 29372, 29373, 29376, 29377, 29378, 29379, 29380, 29381, 29462, 29463, 29464,
		29465, 29466, 29467, 29470, 29471, 29472, 29473, 29474, 29475, 29556, 29557, 29558, 29559, 29560, 29561, 29564,
		29565, 29566, 29567, 29568, 29569, 29650, 29651, 29652, 29653, 29654, 29655, 29658, 29659, 29660, 29661, 29662,
		29663, 29744, 29745, 29746, 29747, 29748, 29749, 29752, 29753, 29754, 29755, 29756, 29757, 29874, 29875, 29876,
		29877, 29882, 29883, 29886, 29887, 29888, 29889, 29892, 29893, 29986, 29987, 29988, 29989, 29994, 29995, 29996,
		29997, 30000, 30001, 30004, 30005, 30082, 30083, 30084, 30085, 30090, 30091, 30092, 30093, 30096, 30173, 30174,
		30175, 30176, 30181, 30182, 30183, 30184, 30187, 30264, 30265, 30266, 30267, 30272, 30273, 30274, 30275, 30278,
		30355, 30356, 30357, 30358, 30363, 30364, 30365, 30366, 30369, 30446, 30447, 30448, 30449, 30454, 30455, 30456,
		30457, 30460, 30537, 30538, 30539, 30540, 30545, 30546, 30547, 30548, 30551, 30628, 30629, 30630, 30631, 30636,
		30637, 30638, 30639, 30642, 30719, 30720, 30721, 30722, 30727, 30728, 30729, 30730, 30733, 30810, 30811, 30812,
		30813, 30818, 30819, 30820, 30821, 30824, 30901, 30902, 30903, 30904, 30909, 30910, 30911, 30912, 30915, 30992,
		30993, 30994, 30995, 31000, 31001, 31002, 31003, 31006, 31083, 31084, 31085, 31086, 31091, 31092, 31093, 31094,
		31097, 31174, 31175, 31176, 31177, 31182, 31183, 31184, 31185, 31188, 31265, 31266, 31267, 31268, 31273, 31274,
		31275, 31276, 31279, 31356, 31357, 31358, 31359, 31364, 31365, 31366, 31367, 31370, 31447, 31448, 31449, 31450,
		31455, 31456, 31457, 31458, 31461, 31542, 31543, 31544, 31545, 31550, 31551, 31552, 31553, 31556, 31633, 31634,
		31635, 31636, 31641, 31642, 31643, 31644, 31647, 31724, 31725, 31726, 31727, 31732, 31733, 31734, 31735, 31738,
		31815, 31816, 31817, 31818, 31823, 31824, 31825, 31826, 31829, 31906, 31907, 31908, 31909, 31914, 31915, 31916,
		31917, 31920, 31997, 31998, 31999, 32000, 32005, 32006, 32007, 32008, 32011, 32112, 32113, 32114, 32115, 32124,
		32125, 32126, 32127, 32130, 32143, 32144, 32145, 32146, 32151, 32152, 32153, 32154, 32155, 32156, 32158, 32159,
		32338, 32339, 32340, 32341, 32346, 32347, 32348, 32349, 32350, 32351, 32353, 32354, 32529, 32530, 32531, 32532,
		32537, 32538, 32539, 32540, 32541, 32542, 32544, 32545, 32724, 32725, 32726, 32727, 32732, 32733, 32736, 32737,
		32740, 32741, 32743, 32745, 32994, 32995, 32996, 32997, 33002, 33003, 33008, 33009, 33011, 33183, 33184, 33185,
		33186, 33191, 33192, 33197, 33198, 33200, 33368, 33369, 33370, 33371, 33376, 33377, 33382, 33383, 33385, 33557,
		33558, 33559, 33560, 33567, 33568, 33573, 33574, 33576 };

	int nbottom(601);
	int ntop(343);
	int nside(728);

	vector<int> bcflag(3 * cpa.size(), 0);
	for (int i = 0; i < nbottom; i++)
	{
		bcflag[3 * (bottom[i] - 1)] = 1;
	}
	for (int i = 0; i < ntop; i++)
	{
		bcflag[3 * (top[i] - 1)] = 2;
	}
	for (int i = 0; i < nside; i++)
	{
		bcflag[3 * (side[i] - 1) + 1] = 1;
	}

	//int uy0(1290), ux0(4891), ux1(1973);//heli
	IDBC.clear();
	IDBC.resize(3 * cpa.size(), -1);
	gh.clear();
	gh.resize(IDBC.size(), 0.);
	int loc(0), count1(0);
	for (uint i = 0; i < cpa.size(); i++)
	{
		for (int j = 0; j < 3; j++)
		{
			int iloc(3 * i + j);
			if (bcflag[iloc] == 0)
			{
				IDBC[iloc] = count1++;
			}
			else if (bcflag[iloc] == 1)
			{
				gh[iloc] = 0.;

			}
			else if (bcflag[iloc] == 2)
			{
				gh[iloc] = 0.01;
			}
		}
	}
}

void TruncatedTspline_3D::StrongDirichletBC_Elasticity_FromFile(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	int bzfc[6][16] = { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
	{ 0, 1, 2, 3, 16, 17, 18, 19, 32, 33, 34, 35, 48, 49, 50, 51 },
	{ 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63 },
	{ 12, 13, 14, 15, 28, 29, 30, 31, 44, 45, 46, 47, 60, 61, 62, 63 },
	{ 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60 },
	{ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63 } };

	string fn("../io/letest/rockerarm_bc");
	//string fn("../io/letest/fertility_bc");
	//string fn("../io/letest/navair_bc");
	int nbc(2);
	vector<vector<int>> ibc;
	vector<array<double, 3>> bc_disp;
	ReadBC(fn, nbc, ibc, bc_disp);

	//for (uint i = 0; i < ibc.size(); i++)
	//{
	//	for (uint j = 0; j < ibc[i].size(); j++)
	//	{
	//		tmesh[ibc[i][j]].bc = i + 1;
	//	}
	//}
	//VisualizeControlMesh("../io/letest/fertility_BC");
	//cout << "Done output CM!\n";
	//getchar();

	vector<int> bz_bcflag(bzcp.size(), 0);
	for (uint i = 0; i < ibc.size(); i++)
	{
		for (uint j = 0; j < ibc[i].size(); j++)
		{
			int eid(ibc[i][j]);
			if (tmesh[eid].type == 1)
			{
				for (int k = 0; k < 6; k++)
				{
					if (tmface[tmesh[eid].face[k]].type == 1)
					{
						for (int k0 = 0; k0 < 16; k0++)
						{
							bz_bcflag[tmesh[eid].IENb[bzfc[k][k0]]] = i + 1;
						}
					}
				}
			}
		}
	}

	/*string fn1("../io/letest/fertilityBC.vtk");
	ofstream fout;
	fout.open(fn1.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << bzcp.size() << " float\n";
		for (uint i = 0; i < bzcp.size(); i++)
		{
			fout << bzcp[i][0] << "\t" << bzcp[i][1] << "\t" << bzcp[i][2] << "\n";
		}
		fout << "\nCELLS " << bzcp.size() << " " << 2 * bzcp.size() << '\n';
		for (uint i = 0; i < bzcp.size(); i++)
		{
			fout << "1 " << i << "\n";
		}
		fout << "\nCELL_TYPES " << bzcp.size() << '\n';
		for (uint i = 0; i < bzcp.size(); i++)
		{
			fout << "1\n";
		}
		fout << "\nCELL_DATA " << bzcp.size() << "\nSCALARS eact float 1\nLOOKUP_TABLE default\n";
		for (uint i = 0; i < bzcp.size(); i++)
		{
			fout << bz_bcflag[i] << "\n";
		}
		fout.close();
	}
	else
	{
		cerr << "Can't open " << fn1 << "\n";
		getchar();
	}
	cout << "Done output bzcp!\n"; getchar();*/

	vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			aloc[i] = count++;
		}
	}
	vector<int> bz_aflag(bzcp.size(), 0);
	vector<int> bz_aloc(bzcp.size(), -1);
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].bzflag == 1)
		{
			for (uint i = 0; i < tmesh[eid].IENc01.size(); i++)
			{
				bz_aflag[tmesh[eid].IENc01[i]] = 1;
			}
		}
	}
	for (uint i = 0; i < bz_aflag.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			bz_aloc[i] = count++;
		}
	}

	IDBC.clear();
	IDBC.resize(3 * count, -1);
	gh.clear();
	gh.resize(IDBC.size(), 0.);
	int loc(0), count1(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			//if (cp[i].type == 1)//assume all passive
			//{
			//	for (int idof = 0; idof < 3; idof++)
			//	{
			//		IDBC[3 * loc + idof] = count1++;
			//	}
			//}
			//else
			{
				for (int idof = 0; idof < 3; idof++)
				{
					IDBC[3 * loc + idof] = count1++;
				}
			}
			loc++;
		}
	}
	for (uint i = 0; i < bzcp.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			//if (bz_bcflag[i] != 0)
			//{
			//	for (int idof = 0; idof < 3; idof++)
			//	{
			//		gh[3 * loc + idof] = bc_disp[bz_bcflag[i] - 1][idof];
			//	}
			//}
			if (bz_bcflag[i] == 1)
			{
				for (int idof = 0; idof < 3; idof++)
				{
					gh[3 * loc + idof] = bc_disp[0][idof];
				}
			}
			else if (bz_bcflag[i] == 2)
			{
				for (int idof = 0; idof < 3; idof++)
				{
					if (idof == 1)//rockerarm
					{
						gh[3 * loc + idof] = bc_disp[1][idof];
					}
					else
					{
						IDBC[3 * loc + idof] = count1++;
					}
					
				}
			}
			else
			{
				for (int idof = 0; idof < 3; idof++)
				{
					IDBC[3 * loc + idof] = count1++;
				}
			}
			loc++;
		}
	}
}

void TruncatedTspline_3D::StrongDirichletBC_Elasticity_EID(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	int bzfc[6][16] = { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
	{ 0, 1, 2, 3, 16, 17, 18, 19, 32, 33, 34, 35, 48, 49, 50, 51 },
	{ 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63 },
	{ 12, 13, 14, 15, 28, 29, 30, 31, 44, 45, 46, 47, 60, 61, 62, 63 },
	{ 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60 },
	{ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63 } };

	//string fn("../io/letest/rockerarm_bc");
	string fn("../io/letest/fertility_bc");
	//string fn("../io/letest/navair_bc");
	//string fn("../io/letest/cube_bc");
	int nbc(2);
	vector<vector<int>> ibc;
	vector<array<double, 3>> bc_disp;
	ReadBC(fn, nbc, ibc, bc_disp);

	vector<int> cp_bcflag(cp.size(), 0);
	vector<int> bz_bcflag(bzcp.size(), 0);
	for (uint i = 0; i < ibc.size(); i++)
	{
		for (uint j = 0; j < ibc[i].size(); j++)
		{
			int eid(ibc[i][j]);
			if (tmesh[eid].type == 1 && tmesh[eid].bzflag != 0)
			{
				for (int k = 0; k < 6; k++)
				{
					if (tmface[tmesh[eid].face[k]].type == 1)
					{
						for (int k0 = 0; k0 < 16; k0++)
						{
							bz_bcflag[tmesh[eid].IENb[bzfc[k][k0]]] = i + 1;
						}
					}
				}
			}
			else if (tmesh[eid].type == 1 && tmesh[eid].bzflag == 0)
			{
				for (int k = 0; k < 6; k++)
				{
					if (tmface[tmesh[eid].face[k]].type == 1)
					{
						for (int k0 = 0; k0 < 4; k0++)
						{
							cp_bcflag[tmface[tmesh[eid].face[k]].cnct[k0]] = i + 1;
						}
					}
				}
			}
		}
	}

	/*string fn1("../io/letest/fertilityBC.vtk");
	ofstream fout;
	fout.open(fn1.c_str());
	if (fout.is_open())
	{
	fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
	fout << "POINTS " << bzcp.size() << " float\n";
	for (uint i = 0; i < bzcp.size(); i++)
	{
	fout << bzcp[i][0] << "\t" << bzcp[i][1] << "\t" << bzcp[i][2] << "\n";
	}
	fout << "\nCELLS " << bzcp.size() << " " << 2 * bzcp.size() << '\n';
	for (uint i = 0; i < bzcp.size(); i++)
	{
	fout << "1 " << i << "\n";
	}
	fout << "\nCELL_TYPES " << bzcp.size() << '\n';
	for (uint i = 0; i < bzcp.size(); i++)
	{
	fout << "1\n";
	}
	fout << "\nCELL_DATA " << bzcp.size() << "\nSCALARS eact float 1\nLOOKUP_TABLE default\n";
	for (uint i = 0; i < bzcp.size(); i++)
	{
	fout << bz_bcflag[i] << "\n";
	}
	fout.close();
	}
	else
	{
	cerr << "Can't open " << fn1 << "\n";
	getchar();
	}
	cout << "Done output bzcp!\n"; getchar();*/

	vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			aloc[i] = count++;
		}
	}
	vector<int> bz_aflag(bzcp.size(), 0);
	vector<int> bz_aloc(bzcp.size(), -1);
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].bzflag == 1)
		{
			for (uint i = 0; i < tmesh[eid].IENc01.size(); i++)
			{
				bz_aflag[tmesh[eid].IENc01[i]] = 1;
			}
		}
	}
	for (uint i = 0; i < bz_aflag.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			bz_aloc[i] = count++;
		}
	}

	IDBC.clear();
	IDBC.resize(3 * count, -1);
	gh.clear();
	gh.resize(IDBC.size(), 0.);
	int loc(0), count1(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			if (cp[i].type == 1)
			{
				if (cp_bcflag[i] == 1)
				{
					for (int idof = 0; idof < 3; idof++)
					{
						gh[3 * loc + idof] = bc_disp[0][idof];
					}
				}
				else if (cp_bcflag[i] == 2)
				{
					for (int idof = 0; idof < 3; idof++)
					{
						//if (idof == 1)//rockerarm
						if (idof == 0)//fertility
						{
							gh[3 * loc + idof] = bc_disp[1][idof];
						}
						else
						{
							IDBC[3 * loc + idof] = count1++;
						}

					}
				}
				else
				{
					for (int idof = 0; idof < 3; idof++)
					{
						IDBC[3 * loc + idof] = count1++;
					}
				}
			}
			else
			{
				for (int idof = 0; idof < 3; idof++)
				{
					IDBC[3 * loc + idof] = count1++;
				}
			}
			loc++;
		}
	}
	for (uint i = 0; i < bzcp.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			//if (bz_bcflag[i] != 0)
			//{
			//	for (int idof = 0; idof < 3; idof++)
			//	{
			//		gh[3 * loc + idof] = bc_disp[bz_bcflag[i] - 1][idof];
			//	}
			//}
			if (bz_bcflag[i] == 1)
			{
				for (int idof = 0; idof < 3; idof++)
				{
					gh[3 * loc + idof] = bc_disp[0][idof];
				}
			}
			else if (bz_bcflag[i] == 2)
			{
				for (int idof = 0; idof < 3; idof++)
				{
					if (idof == 0)
					{
						gh[3 * loc + idof] = bc_disp[1][idof];
					}
					else
					{
						IDBC[3 * loc + idof] = count1++;
					}

				}
			}
			else
			{
				for (int idof = 0; idof < 3; idof++)
				{
					IDBC[3 * loc + idof] = count1++;
				}
			}
			loc++;
		}
	}
}

void TruncatedTspline_3D::StrongDirichletBC_Elasticity_PID(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	vector<vector<int>> pid;
	vector<array<int, 3>> bc_dof;
	vector<array<double, 3>> bc_disp;
	//ReadBC_PID("../io/letest1/heli_coarse_bc/bc", 3, pid, bc_dof, bc_disp);//heli coarse, spline
	//ReadBC_PID("../io/letest1/navair_coarse_bc/bc", 2, pid, bc_dof, bc_disp);//heli coarse, spline
	//ReadBC_PID("../io/honda/honda1/bc", 2, pid, bc_dof, bc_disp);//heli coarse, spline
	//ReadBC_PID("../io/honda/honda2_2/bc", 2, pid, bc_dof, bc_disp);//heli coarse, spline
	//ReadBC_PID("../io/cube_test/lebc/bc", 2, pid, bc_dof, bc_disp);
	ReadBC_PID("../io/engine/lebc/bc", 2, pid, bc_dof, bc_disp);

	//double xyz[3] = { 0.,0.,0. };
	//double shift[3] = { 0.,0.,0. };
	//int dir[3] = { 0,1,0 };
	//for (int i = 0; i < 3; i++)
	//{
	//	for (uint j = 0; j < pid[i].size(); j++)
	//	{
	//		xyz[i] += cp[pid[i][j]].coor[dir[i]];
	//	}
	//	xyz[i] /= double(pid[i].size());
	//}
	//for (int i = 0; i < 3; i++)
	//{
	//	for (uint j = 0; j < pid[i].size(); j++)
	//	{
	//		double tmp = fabs(xyz[i] - cp[pid[i][j]].coor[dir[i]]);
	//		if (tmp > shift[i]) shift[i] = tmp;
	//	}
	//}
	//cout << "xyz: " << xyz[0] << " " << xyz[1] << " " << xyz[2] << "\n";
	//cout << "shift: " << shift[0] << " " << shift[1] << " " << shift[2] << "\n";
	//getchar();

	IDBC.clear();
	IDBC.resize(3 * cpa.size(), -1);
	gh.clear();
	gh.resize(IDBC.size(), 0.);
	vector<int> bcflag(3 * cpa.size(), 0);
	for (uint i = 0; i < pid.size(); i++)
	{
		for (int idof = 0; idof < 3; idof++)
		{
			if (bc_dof[i][idof] == 1)
			{
				for (uint j = 0; j < pid[i].size(); j++)
				{
					bcflag[3 * pid[i][j] + idof] = 1;
					gh[3 * pid[i][j] + idof] = bc_disp[i][idof];
				}
			}
		}
	}
	int count(0);
	for (uint i = 0; i < cpa.size(); i++)
	{
		for (int j = 0; j < 3; j++)
		{
			int iloc(3 * i + j);
			if (bcflag[iloc] == 0)
			{
				IDBC[iloc] = count++;
			}
		}
	}
}

void TruncatedTspline_3D::StrongDirichletBC_Elasticity_Coor(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	int bzfc[6][16] = { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
	{ 0, 1, 2, 3, 16, 17, 18, 19, 32, 33, 34, 35, 48, 49, 50, 51 },
	{ 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63 },
	{ 12, 13, 14, 15, 28, 29, 30, 31, 44, 45, 46, 47, 60, 61, 62, 63 },
	{ 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60 },
	{ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63 } };

	vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			aloc[i] = count++;
		}
	}
	vector<int> bz_aflag(bzcp.size(), 0);
	vector<int> bz_aloc(bzcp.size(), -1);
	vector<int> bz_bcflag(bzcp.size(), 0);
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].bzflag == 1)
		{
			for (uint i = 0; i < tmesh[eid].IENc01.size(); i++)
			{
				bz_aflag[tmesh[eid].IENc01[i]] = 1;
			}
			if (tmesh[eid].type == 1)
			{
				for (int i = 0; i < 6; i++)
				{
					if (tmface[tmesh[eid].face[i]].type == 1)
					{
						for (int j = 0; j < 16; j++)
						{
							bz_bcflag[tmesh[eid].IENb[bzfc[i][j]]] = 1;
						}
					}
				}
			}
		}
	}
	for (uint i = 0; i < bz_aflag.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			bz_aloc[i] = count++;
		}
	}

	//double ux0(2.6388e-5), uy0(2.7166), ux1(5.90525);//heli
	//double tol[3] = { 0.000619612,0.000578553,0.000188722 };
	//double sfac(2.);
	//tol[0] *= sfac; tol[1] *= sfac; tol[2] *= sfac;

	//////double ux0(0.), uy0(0.), ux1(1.), uz0(0.);//cube
	//////double tol[4] = { 1.e-8,1.e-8,1.e-8,1.e-8 };

	//////double ux0(0.), uy0(0.), ux1(1.), uz0(0.), uz1(1.);//cube
	//////double tol[4] = { 1.e-8,1.e-8,1.e-8,1.e-8 };

	//IDBC.clear();
	//IDBC.resize(3 * count, -1);
	//gh.clear();
	//gh.resize(IDBC.size(), 0.);
	//int loc(0), count1(0);
	//for (uint i = 0; i < cp.size(); i++)
	//{
	//	if (cp[i].act == 1)
	//	{
	//		if (cp[i].type == 1)
	//		{
	//			for (int idof = 0; idof < 3; idof++)
	//			{
	//				if (idof == 0 && fabs(cp[i].coor[idof] - ux0) < tol[0])
	//				{
	//					gh[3 * loc + idof] = 0.;
	//				}
	//				else if (idof == 1 && fabs(cp[i].coor[idof] - uy0) < tol[1])
	//				{
	//					gh[3 * loc + idof] = 0.;
	//				}
	//				//else if (idof == 2 && fabs(cp[i].coor[idof] - uz0) < tol[1])//cube only
	//				//{
	//				//	gh[3 * loc + idof] = 0.;
	//				//}
	//				//else if (idof == 2 && fabs(cp[i].coor[idof] - uz1) < tol[1])//cube only
	//				//{
	//				//	gh[3 * loc + idof] = 0.01;
	//				//}
	//				else if (idof == 0 && fabs(cp[i].coor[idof] - ux1) < tol[2])
	//				{
	//					gh[3 * loc + idof] = 0.01;
	//				}
	//				else
	//				{
	//					IDBC[3 * loc + idof] = count1++;
	//				}
	//			}
	//		}
	//		else
	//		{
	//			for (int idof = 0; idof < 3; idof++)
	//			{
	//				IDBC[3 * loc + idof] = count1++;
	//			}
	//		}
	//		loc++;
	//	}
	//}
	//for (uint i = 0; i < bzcp.size(); i++)
	//{
	//	if (bz_aflag[i] == 1)
	//	{
	//		if (bz_bcflag[i] == 1)
	//		{
	//			for (int idof = 0; idof < 3; idof++)
	//			{
	//				if (idof == 0 && fabs(bzcp[i][idof] - ux0) < tol[0])
	//				{
	//					gh[3 * loc + idof] = 0.;
	//				}
	//				else if (idof == 1 && fabs(bzcp[i][idof] - uy0) < tol[1])
	//				{
	//					gh[3 * loc + idof] = 0.;
	//				}
	//				else if (idof == 0 && fabs(bzcp[i][idof] - ux1) < tol[2])
	//				{
	//					gh[3 * loc + idof] = 0.01;
	//				}
	//				else
	//				{
	//					IDBC[3 * loc + idof] = count1++;
	//				}
	//			}
	//		}
	//		else
	//		{
	//			for (int idof = 0; idof < 3; idof++)
	//			{
	//				IDBC[3 * loc + idof] = count1++;
	//			}
	//		}
	//		loc++;
	//	}
	//}

	double uy0(0.), uy1(-25.4), ux0(0.);//navair coarse
	double tol[2] = { 1.e-6,1.e-6 };
	IDBC.clear();
	IDBC.resize(3 * count, -1);
	gh.clear();
	gh.resize(IDBC.size(), 0.);
	int loc(0), count1(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			if (cp[i].type == 1)
			{
				for (int idof = 0; idof < 3; idof++)
				{
					//if (fabs(cp[i].coor[idof] - uy0) < tol[0])
					//{
					//	gh[3 * loc + idof] = 0.;
					//}
					if (idof == 1 && fabs(cp[i].coor[idof] - uy0) < tol[0])//navair
					{
						gh[3 * loc + idof] = 0.;
					}
					else if (idof == 1 && fabs(cp[i].coor[idof] - uy1) < tol[1])
					{
						gh[3 * loc + idof] = -0.1;
					}
					else if (idof == 0 && fabs(cp[i].coor[idof] - ux0) < tol[0])
					{
						gh[3 * loc + idof] = 0.;
					}
					//else if (idof == 2 && fabs(cp[i].coor[idof] - uz0) < tol[1])//cube only
					//{
					//	gh[3 * loc + idof] = 0.;
					//}
					//else if (idof == 2 && fabs(cp[i].coor[idof] - uz1) < tol[1])//cube only
					//{
					//	gh[3 * loc + idof] = 0.01;
					//}
					//else if (idof == 0 && fabs(cp[i].coor[idof] - ux1) < tol[2])
					//{
					//	gh[3 * loc + idof] = 0.01;
					//}
					else
					{
						IDBC[3 * loc + idof] = count1++;
					}
				}
			}
			else
			{
				for (int idof = 0; idof < 3; idof++)
				{
					IDBC[3 * loc + idof] = count1++;
				}
			}
			loc++;
		}
	}
}


void TruncatedTspline_3D::StrongDirichletBC_Poisson_FromFile(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	int bzfc[6][16] = { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
	{ 0, 1, 2, 3, 16, 17, 18, 19, 32, 33, 34, 35, 48, 49, 50, 51 },
	{ 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63 },
	{ 12, 13, 14, 15, 28, 29, 30, 31, 44, 45, 46, 47, 60, 61, 62, 63 },
	{ 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60 },
	{ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63 } };

	//string fn("../io/letest/rockerarm_bc");
	string fn("../io/letest/fertility_bc");
	//string fn("../io/letest/navair_bc");
	int nbc(2);
	vector<vector<int>> ibc;
	vector<array<double, 3>> bc_disp;
	ReadBC(fn, nbc, ibc, bc_disp);

	//for (uint i = 0; i < ibc.size(); i++)
	//{
	//	for (uint j = 0; j < ibc[i].size(); j++)
	//	{
	//		tmesh[ibc[i][j]].bc = i + 1;
	//	}
	//}
	//VisualizeControlMesh("../io/letest/fertility_BC");
	//cout << "Done output CM!\n";
	//getchar();

	vector<int> bz_bcflag(bzcp.size(), 0);
	for (uint i = 0; i < ibc.size(); i++)
	{
		for (uint j = 0; j < ibc[i].size(); j++)
		{
			int eid(ibc[i][j]);
			if (tmesh[eid].type == 1)
			{
				for (int k = 0; k < 6; k++)
				{
					if (tmface[tmesh[eid].face[k]].type == 1)
					{
						for (int k0 = 0; k0 < 16; k0++)
						{
							bz_bcflag[tmesh[eid].IENb[bzfc[k][k0]]] = i + 1;
						}
					}
				}
			}
		}
	}

	/*string fn1("../io/letest/fertilityBC.vtk");
	ofstream fout;
	fout.open(fn1.c_str());
	if (fout.is_open())
	{
	fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
	fout << "POINTS " << bzcp.size() << " float\n";
	for (uint i = 0; i < bzcp.size(); i++)
	{
	fout << bzcp[i][0] << "\t" << bzcp[i][1] << "\t" << bzcp[i][2] << "\n";
	}
	fout << "\nCELLS " << bzcp.size() << " " << 2 * bzcp.size() << '\n';
	for (uint i = 0; i < bzcp.size(); i++)
	{
	fout << "1 " << i << "\n";
	}
	fout << "\nCELL_TYPES " << bzcp.size() << '\n';
	for (uint i = 0; i < bzcp.size(); i++)
	{
	fout << "1\n";
	}
	fout << "\nCELL_DATA " << bzcp.size() << "\nSCALARS eact float 1\nLOOKUP_TABLE default\n";
	for (uint i = 0; i < bzcp.size(); i++)
	{
	fout << bz_bcflag[i] << "\n";
	}
	fout.close();
	}
	else
	{
	cerr << "Can't open " << fn1 << "\n";
	getchar();
	}
	cout << "Done output bzcp!\n"; getchar();*/

	vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			aloc[i] = count++;
		}
	}
	vector<int> bz_aflag(bzcp.size(), 0);
	vector<int> bz_aloc(bzcp.size(), -1);
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].bzflag == 1)
		{
			for (uint i = 0; i < tmesh[eid].IENc01.size(); i++)
			{
				bz_aflag[tmesh[eid].IENc01[i]] = 1;
			}
		}
	}
	for (uint i = 0; i < bz_aflag.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			bz_aloc[i] = count++;
		}
	}

	IDBC.clear();
	IDBC.resize(count, -1);
	gh.clear();
	gh.resize(IDBC.size(), 0.);
	int loc(0), count1(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			IDBC[loc] = count1++;
			loc++;
		}
	}
	for (uint i = 0; i < bzcp.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			if (bz_bcflag[i] == 1)
			{
				gh[loc] = 0.;
			}
			else if (bz_bcflag[i] == 2)
			{
				gh[loc] = 1.;
			}
			else
			{
				IDBC[loc] = count1++;
			}
			loc++;
		}
	}
}

void TruncatedTspline_3D::WeakDirichletBC_Poisson_FromFile(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	int bzfc[6][16] = { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
	{ 0, 1, 2, 3, 16, 17, 18, 19, 32, 33, 34, 35, 48, 49, 50, 51 },
	{ 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63 },
	{ 12, 13, 14, 15, 28, 29, 30, 31, 44, 45, 46, 47, 60, 61, 62, 63 },
	{ 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60 },
	{ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63 } };

	//string fn("../io/letest/rockerarm_bc");
	string fn("../io/letest/fertility_bc");
	//string fn("../io/letest/navair_bc");
	int nbc(2);
	vector<vector<int>> ibc;
	vector<array<double, 3>> bc_disp;
	ReadBC(fn, nbc, ibc, bc_disp);

	vector<int> bz_bcflag(bzcp.size(), 0);
	for (uint i = 0; i < ibc.size(); i++)
	{
		for (uint j = 0; j < ibc[i].size(); j++)
		{
			int eid(ibc[i][j]);
			if (tmesh[eid].type == 1)
			{
				for (int k = 0; k < 6; k++)
				{
					if (tmface[tmesh[eid].face[k]].type == 1)
					{
						bzmesh[eid].bc[k] = 1;
						bzmesh[eid].bcval[k] = 0.1*double(i);
						//for (int k0 = 0; k0 < 16; k0++)
						//{
						//	bz_bcflag[tmesh[eid].IENb[bzfc[k][k0]]] = i + 1;
						//}
					}
				}
			}
		}
	}

	/*vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			aloc[i] = count++;
		}
	}
	vector<int> bz_aflag(bzcp.size(), 0);
	vector<int> bz_aloc(bzcp.size(), -1);
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].bzflag == 1)
		{
			for (uint i = 0; i < tmesh[eid].IENc01.size(); i++)
			{
				bz_aflag[tmesh[eid].IENc01[i]] = 1;
			}
		}
	}
	for (uint i = 0; i < bz_aflag.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			bz_aloc[i] = count++;
		}
	}

	IDBC.clear();
	IDBC.resize(count, -1);
	gh.clear();
	gh.resize(IDBC.size(), 0.);
	int loc(0), count1(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			IDBC[loc] = count1++;
			loc++;
		}
	}
	for (uint i = 0; i < bzcp.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			if (bz_bcflag[i] == 1)
			{
				gh[loc] = 0.;
			}
			else if (bz_bcflag[i] == 2)
			{
				gh[loc] = 1.;
			}
			else
			{
				IDBC[loc] = count1++;
			}
			loc++;
		}
	}*/
}


void TruncatedTspline_3D::ReadBC(string fn, int nbc, vector<vector<int>>& ibc, vector<array<double, 3>>& bc_disp)
{
	ibc.resize(nbc);
	bc_disp.resize(nbc);
	for (int i = 0; i < nbc; i++)
	{
		string fn_i = fn + to_string(i + 1) + ".csv";
		ifstream fin;
		fin.open(fn_i.c_str());
		if (fin.is_open())
		{
			string tmp;
			int ne_bc;
			fin >> tmp >> ne_bc >> bc_disp[i][0]>> bc_disp[i][1] >> bc_disp[i][2];
			ibc[i].resize(ne_bc);
			for (int j = 0; j < ne_bc; j++)
			{
				fin >> ibc[i][j];
			}
			fin.close();
		}
		else
		{
			cerr << "Can't open " << fn_i << "\n";
			getchar();
		}
	}
}

void TruncatedTspline_3D::ReadBC_PID(string fn, int nbc, vector<vector<int>>& pid, vector<array<int,3>>& bc_dof, vector<array<double, 3>>& bc_disp)
{
	pid.resize(nbc);
	bc_dof.resize(nbc);
	bc_disp.resize(nbc);
	for (int i = 0; i < nbc; i++)
	{
		string fn_i = fn + to_string(i) + ".txt";
		ifstream fin;
		fin.open(fn_i.c_str());
		if (fin.is_open())
		{
			string tmp;
			int np_bc;
			fin >> tmp >> np_bc >> bc_dof[i][0] >> bc_dof[i][1] >> bc_dof[i][2] >> bc_disp[i][0] >> bc_disp[i][1] >> bc_disp[i][2];
			pid[i].resize(np_bc);
			for (int j = 0; j < np_bc; j++)
			{
				fin >> pid[i][j];
			}
			fin.close();
		}
		else
		{
			cerr << "Can't open " << fn_i << "\n";
			getchar();
		}
	}
	cout << "Finish Reading BC." << endl;
}







//prepare for patch test, strongly imposed Dirichlet BC
void TruncatedTspline_3D::PatchTest_BC(vector<int>& IDBC, vector<double>& gh)
{
	vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			aloc[i] = count++;
		}
	}
	vector<int> bz_aflag(bzcp.size(), 0);
	vector<int> bz_aloc(bzcp.size(), -1);
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].bzflag == 1)
		{
			for (uint i = 0; i < tmesh[eid].IENc01.size(); i++)
			{
				bz_aflag[tmesh[eid].IENc01[i]] = 1;
			}
		}
	}
	for (uint i = 0; i < bz_aflag.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			bz_aloc[i] = count++;
		}
	}

	IDBC.clear();
	IDBC.resize(count, -1);
	gh.clear();
	gh.resize(IDBC.size(), 0.);
	int loc(0), count1(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			//if (fabs(cp[i].coor[0] - 0.) < 1.e-8)
			if (fabs(cp[i].coor[1] - 0.) < 1.e-8)
			//if (fabs(cp[i].coor[2] - 0.) < 1.e-8)
			{
				array<double, 3> xcoor = { cp[i].coor[0], cp[i].coor[1], cp[i].coor[2] };
				gh[loc] = exact_sol(xcoor);
			}
			//else if (fabs(cp[i].coor[0] - 1.) < 1.e-8)
			else if (fabs(cp[i].coor[1] - 1.) < 1.e-8)
			//else if (fabs(cp[i].coor[2] - 1.) < 1.e-8)
			{
				array<double, 3> xcoor = { cp[i].coor[0], cp[i].coor[1], cp[i].coor[2] };
				gh[loc] = exact_sol(xcoor);
			}
			else
			{
				IDBC[loc] = count1++;
			}
			loc++;
		}
	}
	for (uint i = 0; i < bzcp.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			//if (fabs(bzcp[i][0] - 0.) < 1.e-8)
			if (fabs(bzcp[i][1] - 0.) < 1.e-8)
			//if (fabs(bzcp[i][2] - 0.) < 1.e-8)
			{
				gh[loc] = exact_sol(bzcp[i]);
			}
			//else if (fabs(bzcp[i][0] - 1.) < 1.e-8)
			else if (fabs(bzcp[i][1] - 1.) < 1.e-8)
			//else if (fabs(bzcp[i][2] - 1.) < 1.e-8)
			{
				gh[loc] = exact_sol(bzcp[i]);
			}
			else
			{
				IDBC[loc] = count1++;
			}
			loc++;
		}
	}

	//for (uint i = 0; i < gh.size(); i++)
	//{
	//	cout << setprecision(16) << gh[i] << " ";
	//}
	//cout << "\n";
	//int bcn(0);
	//for (uint i = 0; i < IDBC.size(); i++)
	//{
	//	cout << IDBC[i] << " ";
	//	if (IDBC[i] == -1) bcn++;
	//}
	//cout << "\n";
	//cout << "IDBC -1: " << bcn << "\n";
	//getchar();
}

void TruncatedTspline_3D::PatchTest_OneElement(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	bzmesh.resize(1);
	int eid(0);
	double spt[4] = { 0., 1. / 3., 2. / 3., 1. };
	bzmesh[eid].IEN.resize(64);
	bzmesh[eid].cmat.resize(64, vector<double>(64, 0.));
	IDBC.resize(64, -1);
	gh.resize(64, 0.);
	int loc(0), count(0);
	for (int k = 0; k < 4; k++)
	{
		for (int j = 0; j < 4; j++)
		{
			for (int i = 0; i < 4; i++)
			{
				bzmesh[eid].IEN[loc] = loc;
				bzmesh[eid].cmat[loc][loc] = 1.;
				bzmesh[eid].pts[loc][0] = spt[i];
				bzmesh[eid].pts[loc][1] = spt[j];
				bzmesh[eid].pts[loc][2] = spt[k];
				if (i == 0 || i==3/* || j==0 || j==3 || k==0 || k==3*/)
				{
					gh[loc] = spt[i];
				}
				else
				{
					gh[loc] = spt[i];
					IDBC[loc] = count++;
				}
				loc++;
			}
		}
	}
}






void TruncatedTspline_3D::ReadBEXT3D(string fn, vector<BezierElement3D>& bzmesh, vector<int> &IDBC, vector<double> &gh)
{
	//note that bzel.cp and bzel.amat is used instead of bzel.pts and bzel.cmat
	ifstream fin;
	fin.open(fn);
	if (fin.is_open())
	{
		string stmp, stmp1;
		int npt, nel, pcount(0), ecount(0);
		double dtmp;
		cp.clear();
		bzmesh.clear();
		while (getline(fin, stmp))
		{
			stringstream ss(stmp);
			if (stmp.compare(0, 5, "nodeN") == 0)
			{
				ss >> stmp1 >> npt;
				cp.resize(npt);
			}
			else if (stmp.compare(0, 5, "elemN") == 0)
			{
				ss >> stmp1 >> nel;
				bzmesh.resize(nel);
			}
			else if (stmp.compare(0, 5, "gnode") == 0)
			{
				ss >> stmp1 >> cp[pcount].coor[0] >> cp[pcount].coor[1] >> cp[pcount].coor[2] >> stmp1;
				pcount++;
			}
			else if (stmp.compare(0, 5, "belem") == 0)
			{
				int nIEN, ord1, ord2, ord3, nbn;
				ss >> stmp1 >> nIEN >> ord1 >> ord2 >> ord3;
				nbn = (ord1 + 1)*(ord2 + 1)*(ord3 + 1);
				//cout << nIEN << " " << nbn << "\n"; getchar();
				bzmesh[ecount].IEN.resize(nIEN);
				bzmesh[ecount].cmat.resize(nIEN, vector<double>(nbn));
				bzmesh[ecount].pts.resize(nbn);
				for (int i = 0; i < nbn; i++)
				{
					bzmesh[ecount].pts[i][0] = 0.;
					bzmesh[ecount].pts[i][1] = 0.;
					bzmesh[ecount].pts[i][2] = 0.;
				}
				for (int i = 0; i < nIEN; i++)
				{
					fin >> bzmesh[ecount].IEN[i];
				}
				for (int i = 0; i < nIEN; i++)
				{
					string mflag;
					fin >> mflag;
					if (mflag.compare("s") == 0)
					{
						int nnz, loc;
						fin >> nnz;
						for (int j = 0; j < nnz; j++)
						{
							fin >> loc;
							fin >> bzmesh[ecount].cmat[i][loc];
						}
					}
					else if (mflag.compare("d") == 0)
					{
						for (int j = 0; j < nbn; j++)
						{
							fin >> bzmesh[ecount].cmat[i][j];
						}
					}
					else
					{
						cerr << "matrix flag read in error: " << mflag << "!\n";
						getchar();
					}
					for (int j = 0; j < nbn; j++)
					{
						if (bzmesh[ecount].cmat[i][j] != 0.)
						{
							//cout << i <<" "<<j<<" "<< bzmesh[ecount].amat(i, j) << " "; getchar();
							bzmesh[ecount].pts[j][0] += bzmesh[ecount].cmat[i][j] * cp[bzmesh[ecount].IEN[i]].coor[0];
							bzmesh[ecount].pts[j][1] += bzmesh[ecount].cmat[i][j] * cp[bzmesh[ecount].IEN[i]].coor[1];
							bzmesh[ecount].pts[j][2] += bzmesh[ecount].cmat[i][j] * cp[bzmesh[ecount].IEN[i]].coor[2];
						}
					}
				}
				ecount++;
			}
		}
		fin.close();
	}
	else
	{
		cerr << "Can't open " << fn << "!\n";
	}
	
	//// Set boundary condition
	//int count = 0;
	//for (int i = 0; i < cp.size(); i++)
	//{
	//	if (cp[i].coor[2] < 0.1)
	//	{
	//		IDBC.push_back(-1);
	//		gh.push_back(-2.0);
	//	}
	//	else if (cp[i].coor[2] > 1.5)
	//	{
	//		IDBC.push_back(-1);
	//		gh.push_back(5.0);
	//	}
	//	else
	//	{
	//		IDBC.push_back(count);
	//		gh.push_back(0.0);
	//		count++;
	//	}
	//}
}



void TruncatedTspline_3D::WriteBezierInfo_Blend_LSDYNA(string fn, vector<BezierElement3D>& bzmesh)
{
	//preprocess
	vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].act == 1)
		{
			aloc[i] = count++;
		}
	}
	vector<int> bz_aflag(bzcp.size(), 0);
	vector<int> bz_aloc(bzcp.size(), -1);
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		if (tmesh[eid].bzflag == 1)
		{
			for (uint i = 0; i < tmesh[eid].IENc01.size(); i++)
			{
				bz_aflag[tmesh[eid].IENc01[i]] = 1;
			}
		}
	}
	for (uint i = 0; i < bz_aflag.size(); i++)
	{
		if (bz_aflag[i] == 1)
		{
			bz_aloc[i] = count++;
		}
	}

	//output
	string fname = fn + ".txt";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "B E X T\ntype hex\n";
		fout << "nodeN " << count << "\n";
		fout << "elemN " << bzmesh.size() << "\n";
		int width(16);
		for (uint i = 0; i < cp.size(); i++)
		{
			if (cp[i].act == 1)
			{
				fout << "gnode " << setw(width) << cp[i].coor[0] << " " << setw(width) << cp[i].coor[1] << " " << setw(width) << cp[i].coor[2] << setw(width) << "1\n";
			}
		}
		for (uint i = 0; i < bzcp.size(); i++)
		{
			if (bz_aflag[i] == 1)
			{
				fout << "gnode " << setw(width) << bzcp[i][0] << " " << setw(width) << bzcp[i][1] << " " << setw(width) << bzcp[i][2] << setw(width) << "1\n";
			}
		}
		for (uint i = 0; i < bzmesh.size(); i++)
		{
			vector<int> loc;
			vector<int> nnzv;
			for (uint j = 0; j < bzmesh[i].IEN.size(); j++)
			{
				if (bzmesh[i].IEN[j] >= 0)
				{
					int nnz(0);
					for (uint k = 0; k < bzmesh[i].cmat[j].size(); k++)
					{
						if (bzmesh[i].cmat[j][k] != 0.) nnz++;
					}
					if (nnz != 0)
					{
						loc.push_back(j);
						nnzv.push_back(nnz);
					}
				}
			}
			fout << "belem " << loc.size() << " 3 3 3\n";
			width = 10;
			for (uint j = 0; j < loc.size(); j++)
			{
				fout << setw(width) << bzmesh[i].IEN[loc[j]] << " ";
			}
			fout << "\n";
			for (uint j = 0; j < loc.size(); j++)
			{
				if (nnzv[j] > 20)//dense
				{
					fout << setw(width) << "d ";
					for (uint k = 0; k < bzmesh[i].cmat[loc[j]].size(); k++) fout << setw(width) << bzmesh[i].cmat[loc[j]][k] << " ";
					fout << "\n";
				}
				else//sparse
				{
					fout << setw(width) << "s " << setw(width) << nnzv[j] << " ";
					for (uint k = 0; k < bzmesh[i].cmat[loc[j]].size(); k++)
					{
						if (bzmesh[i].cmat[loc[j]][k] != 0.) fout << setw(width) << k << " " << setw(width) << bzmesh[i].cmat[loc[j]][k] << " ";
					}
					fout << "\n";
				}
			}
		}

		//for (uint i = 0; i < bzmesh.size(); i++)
		//{
		//	int nien(0);
		//	for (uint j = 0; j < bzmesh[i].IEN.size(); j++)
		//	{
		//		if (bzmesh[i].IEN[j] >= 0) nien++;
		//	}
		//	fout << setw(10) << "belem " << nien << " 3 3 3\n";
		//	for (uint j = 0; j < bzmesh[i].IEN.size(); j++)
		//	{
		//		if (bzmesh[i].IEN[j] >= 0) fout << setw(10) << bzmesh[i].IEN[j] << " ";
		//	}
		//	cout << "\n";
		//	for (uint j = 0; j < bzmesh[i].cmat.size(); j++)
		//	{
		//		if (bzmesh[i].IEN[j] >= 0)
		//		{
		//			int nnz(0);
		//			for (uint k = 0; k < bzmesh[i].cmat[j].size(); k++)
		//			{
		//				if (bzmesh[i].cmat[j][k] != 0.) nnz++;
		//			}
		//			if (nnz > 20)//dense
		//			{
		//				fout << "d ";
		//				for (uint k = 0; k < bzmesh[i].cmat[j].size(); k++) fout << bzmesh[i].cmat[j][k] << " ";
		//				fout << "\n";
		//			}
		//			else//sparse
		//			{
		//				fout << "s " << nnz << " ";
		//				for (uint k = 0; k < bzmesh[i].cmat[j].size(); k++)
		//				{
		//					if (bzmesh[i].cmat[j][k] != 0.) fout << k << " " << bzmesh[i].cmat[j][k] << " ";
		//				}
		//				cout << "\n";
		//			}
		//		}
		//	}
		//}

		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::AngranOutputMesh(const vector<BezierElement3D>& bzmesh, string fn)
{
	int cn[8] = { 0, 3, 15, 12, 48, 51, 63, 60 };
	string fname = fn + "bzmesh.vtk";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nBezier mesh\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << 8 * bzmesh.size() << " float\n";
		for (uint i = 0; i < bzmesh.size(); i++)
		{
			for (int j = 0; j < 8; j++)
			{
				fout << bzmesh[i].pts[cn[j]][0] << " " << bzmesh[i].pts[cn[j]][1] << " " << bzmesh[i].pts[cn[j]][2] << "\n";
			}
		}
		fout << "\nCELLS " << bzmesh.size() << " " << 9 * bzmesh.size() << '\n';
		for (uint i = 0; i < bzmesh.size(); i++)
		{
			fout << "8 " << 8 * i << " " << 8 * i + 1 << " " << 8 * i + 2 << " " << 8 * i + 3
				<< " " << 8 * i + 4 << " " << 8 * i + 5 << " " << 8 * i + 6 << " " << 8 * i + 7 << '\n';
		}
		fout << "\nCELL_TYPES " << bzmesh.size() << '\n';
		for (uint i = 0; i < bzmesh.size(); i++)
		{
			fout << "12\n";
		}
		//fout << "POINT_DATA " << sdisp.size() << "\nSCALARS err float 1\nLOOKUP_TABLE default\n";
		//for (uint i = 0; i<sdisp.size(); i++)
		//{
		//	fout << sdisp[i] << "\n";
		//}
		fout << "\nCELL_DATA " << bzmesh.size() << "\nSCALARS Error float 1\nLOOKUP_TABLE default\n";
		for (uint i = 0; i < bzmesh.size(); i++)
		{
			fout << bzmesh[i].type << "\n";
		}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
	string fname3(fn + "bzmeshinfo.txt");
	//ofstream fout;
	fout.open(fname3.c_str());
	if (fout.is_open())
	{
		fout << bzmesh.size() << "\n";
		for (uint i = 0; i < bzmesh.size(); i++)
		{
			for (uint l = 0; l < bzmesh[i].IEN.size(); l++)
			{
				fout << bzmesh[i].IEN[l] + 1;
				if (l == bzmesh[i].IEN.size() - 1)
				{
					fout << "\n";
				}
				else
				{
					fout << " ";
				}
			}
		}
		fout.close();
	}
	else
	{
		cerr << "Can't open " << fname3 << '\n';
	}

	string fname1(fn + "cmat.txt");
	//ofstream fout;
	fout.open(fname1.c_str());
	if (fout.is_open())
	{
		fout << bzmesh.size() << "\n";
		for (uint i = 0; i < bzmesh.size(); i++)
		{
			fout << i << " " << bzmesh[i].IEN.size() << " " << bzmesh[i].type << "\n";
			for (uint l = 0; l < bzmesh[i].IEN.size(); l++)
			{
				fout << bzmesh[i].IEN[l];
				if (l == bzmesh[i].IEN.size() - 1)
				{
					fout << "\n";
				}
				else
				{
					fout << " ";
				}
			}
			for (uint j = 0; j < bzmesh[i].cmat.size(); j++)
			{
				for (uint k = 0; k < bzmesh[i].cmat[j].size(); k++)
				{
					fout << bzmesh[i].cmat[j][k];
					if (k == bzmesh[i].cmat[j].size() - 1)
					{
						fout << "\n";
					}
					else
					{
						fout << " ";
					}
				}
			}

		}
		fout.close();
	}
	else
	{
		cerr << "Can't open " << fname1 << '\n';
	}

	string fname2(fn + "bzpt.txt");
	//ofstream fout;
	fout.open(fname2.c_str());
	if (fout.is_open())
	{
		fout << bzmesh.size() * 64 << "\n";
		for (uint i = 0; i < bzmesh.size(); i++)
		{
			for (int j = 0; j < 64; j++)
			{
				fout << bzmesh[i].pts[j][0] << " " << bzmesh[i].pts[j][1] << " " << bzmesh[i].pts[j][2] << "\n";
			}
		}
		fout.close();
	}
	else
	{
		cerr << "Can't open " << fname2 << '\n';
	}
}

void TruncatedTspline_3D::WriteBezierInfo_AllSpline_LSDYNA(string fn, vector<BezierElement3D>& bzmesh)
{
	cout << "Writing file...\n";
	string fname = fn + ".txt";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "B E X T\ntype hex\n";
		fout << "nodeN " << cp.size() << "\n";
		fout << "elemN " << bzmesh.size() << "\n";
		int width(16);
		for (uint i = 0; i < cp.size(); i++)
		{
			fout << "gnode " << setw(width) << cp[i].coor[0] << " " << setw(width) << cp[i].coor[1] << " " << setw(width) << cp[i].coor[2] << setw(width) << " 1\n";
		}
		for (uint i = 0; i < bzmesh.size(); i++)
		{
			if (i != 0 && i % 500 == 0)
			{
				cout << i << " ";
			}
			vector<int> loc;
			vector<int> nnzv;
			for (uint j = 0; j < bzmesh[i].IEN.size(); j++)
			{
				if (bzmesh[i].IEN[j] >= 0)
				{
					int nnz(0);
					for (uint k = 0; k < bzmesh[i].cmat[j].size(); k++)
					{
						if (bzmesh[i].cmat[j][k] != 0.) nnz++;
					}
					if (nnz != 0)
					{
						loc.push_back(j);
						nnzv.push_back(nnz);
					}
				}
			}
			fout << "belem " << loc.size() << " 3 3 3\n";
			width = 10;
			for (uint j = 0; j < loc.size(); j++)
			{
				fout << setw(width) << bzmesh[i].IEN[loc[j]] << " ";
			}
			fout << "\n";
			for (uint j = 0; j < loc.size(); j++)
			{
				if (nnzv[j] > 20)//dense
				{
					fout << setw(width) << "d ";
					for (uint k = 0; k < bzmesh[i].cmat[loc[j]].size(); k++) fout << setw(width) << bzmesh[i].cmat[loc[j]][k] << " ";
					fout << "\n";
				}
				else//sparse
				{
					fout << setw(width) << "s " << setw(width) << nnzv[j] << " ";
					for (uint k = 0; k < bzmesh[i].cmat[loc[j]].size(); k++)
					{
						if (bzmesh[i].cmat[loc[j]][k] != 0.) fout << setw(width) << k << " " << setw(width) << bzmesh[i].cmat[loc[j]][k] << " ";
					}
					fout << "\n";
				}
			}
		}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
	cout << "End of writing!\n";
}

void TruncatedTspline_3D::WriteBezierInfo_AllSpline_LSDYNA_LocalRefine(string fn, vector<BezierElement3D>& bzmesh)
{
	
	int count(0); 
	vector<int> pid;
	for (uint i = 0; i < hcp.size(); i++)
	{
		for (uint j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				pid.push_back(count);				
			}
		}
	}
	
	cout << "Writing file...\n";
	string fname = fn + ".txt";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "B E X T\ntype hex\n";
		fout << "nodeN " << pid.size() << "\n";
		fout << "elemN " << bzmesh.size() << "\n";
		int width(16);
		for (uint i = 0; i < hcp.size(); i++)
			for (uint j = 0; j < hcp[i].size(); j++)
				if (hcp[i][j].act == 1)
					//fout << "gnode " << i << setw(width) << hcp[i][j].coor[0] << " " << setw(width) << hcp[i][j].coor[1] << " " << setw(width) << hcp[i][j].coor[2] << setw(width) << " 1\n";
					fout << "gnode " << setw(width) << hcp[i][j].coor[0] << " " << setw(width) << hcp[i][j].coor[1] << " " << setw(width) << hcp[i][j].coor[2] << setw(width) << " 1\n";

		for (uint i = 0; i < bzmesh.size(); i++)
		{
			if (i != 0 && i % 500 == 0)
			{
				cout << i << " ";
			}
			vector<int> loc;
			vector<int> nnzv;
			for (uint j = 0; j < bzmesh[i].IEN.size(); j++)
			{
				if (bzmesh[i].IEN[j] >= 0)
				{
					int nnz(0);
					for (uint k = 0; k < bzmesh[i].cmat[j].size(); k++)
					{
						if (bzmesh[i].cmat[j][k] != 0.) nnz++;
					}
					if (nnz != 0)
					{
						loc.push_back(j);
						nnzv.push_back(nnz);
					}
				}
			}
			fout << "belem " << loc.size() << " 3 3 3\n";
			width = 10;
			for (uint j = 0; j < loc.size(); j++)
			{
				fout << setw(width) << bzmesh[i].IEN[loc[j]] << " ";
			}
			fout << "\n";
			for (uint j = 0; j < loc.size(); j++)
			{
				if (nnzv[j] > 20)//dense
				{
					fout << setw(width) << "d ";
					for (uint k = 0; k < bzmesh[i].cmat[loc[j]].size(); k++) fout << setw(width) << bzmesh[i].cmat[loc[j]][k] << " ";
					fout << "\n";
				}
				else//sparse
				{
					fout << setw(width) << "s " << setw(width) << nnzv[j] << " ";
					for (uint k = 0; k < bzmesh[i].cmat[loc[j]].size(); k++)
					{
						if (bzmesh[i].cmat[loc[j]][k] != 0.) fout << setw(width) << k << " " << setw(width) << bzmesh[i].cmat[loc[j]][k] << " ";
					}
					fout << "\n";
				}
			}
		}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
	cout << "End of writing!\n";
}


void TruncatedTspline_3D::WriteBezier(const vector<BezierElement3D>& bzmesh, string fn)
{
	vector<vector<int>> bzabq;
	ReorderBezier(bzmesh, bzabq);

	string fn1(fn + "_bezier.txt");
	ofstream foutinp;
	foutinp.open(fn1.c_str());
	foutinp << "dim 3 \n";
	foutinp << "deg 3 3 \n";
	foutinp << "funcs " << cpa.size() << " \n";
	foutinp << "elems " << bzmesh.size() << " \n";
	for (uint i = 0; i < cpa.size(); i++)
	{
		foutinp << "P" << i << setprecision(15) << "\t" <<
			cpa[i][0] << "\t" << cpa[i][1] << "\t" << cpa[i][2] << "\t" << "1" << '\n';
	}

	foutinp << "elems " << bzmesh.size() << " \n";
	int maxIEN(0);
	int count(0);
	for (uint i = 0; i < bzabq.size(); i++)
	{
		for (uint j = 0; j < bzabq[i].size(); j++)
		{
			if (bzmesh[bzabq[i][j]].IEN.size() > maxIEN)
				maxIEN = bzmesh[bzabq[i][j]].IEN.size();
			foutinp << count << "\t" << bzmesh[bzabq[i][j]].IEN.size() << " \n";
			for (uint k = 0; k < bzmesh[bzabq[i][j]].IEN.size(); k++)
			{
				foutinp << bzmesh[bzabq[i][j]].IEN[k] << "\t";
			}
			foutinp << "\n";
			for (uint k = 0; k < bzmesh[bzabq[i][j]].IEN.size(); k++)
			{
				for (int k0 = 0; k0 < 64; k0++)
				{
					foutinp << bzmesh[bzabq[i][j]].cmat[k][k0] << "\t";
				}
				foutinp << "\n";
			}
			count++;
		}
	}
	foutinp.close();
	cout << "max IEN: " << maxIEN << "\n";
}








//ABAQUS with GEM

void TruncatedTspline_3D::GeneratePlateHole3D(string fn)
{
	vector<double> ku, kv, wu, wv;
	vector<array<double, 3>> pts0, pts1, pts2, pts3, pts;
	vector<array<int, 4>> cnct0, cnct;
	//vector<int> intfc1, intfc2, intfc3;

	ReadInputQuadVTK(fn, pts0, cnct0);
	//Rescale(pts0);//not working as expected
	Mirror2D(0, pts0, pts1);//x mirror
	Mirror2D(1, pts0, pts2);//y mirror
	Mirror2D(0, pts2, pts3);//x mirror

	ReorderPoints(1, pts1);
	ReorderPoints(2, pts2);

	vector<int> pid0(pts0.size()), pid1(pts1.size()), pid2(pts2.size()), pid3(pts3.size());
	int count(0);
	for (uint i = 0; i < pts0.size(); i++)
	{
		pts.push_back(pts0[i]);
		pid0[i] = count++;
	}
	double tol(1.e-10);
	for (uint i = 0; i < pts1.size(); i++)
	{
		//if (intfc1[i] == 0)
		if (fabs(pts1[i][1]) > tol)
		{
			pts.push_back(pts1[i]);
			pid1[i] = count++;
		}
		else
		{
			int loc(-1);
			for (uint j = 0; j < pts0.size(); j++)
			{
				if (fabs(pts1[i][0] - pts0[j][0]) < tol && fabs(pts1[i][1] - pts0[j][1]) < tol)
				{
					loc = j; break;
				}
			}
			if (loc != -1)
			{
				pid1[i] = pid0[loc];
			}
			else
			{
				cerr << "Can't find pts1 and pts0!\n"; getchar();
			}
		}
	}
	for (uint i = 0; i < pts2.size(); i++)
	{
		//if (intfc2[i] == 0)
		if (fabs(pts2[i][0]) > tol)
		{
			pts.push_back(pts2[i]);
			pid2[i] = count++;
		}
		else
		{
			int loc(-1);
			for (uint j = 0; j < pts0.size(); j++)
			{
				if (fabs(pts2[i][0] - pts0[j][0]) < tol && fabs(pts2[i][1] - pts0[j][1]) < tol)
				{
					loc = j; break;
				}
			}
			if (loc != -1)
			{
				pid2[i] = pid0[loc];
			}
			else
			{
				cerr << "Can't find pts2 and pts0!\n"; getchar();
			}
		}
	}
	for (uint i = 0; i < pts3.size(); i++)
	{
		//if (intfc3[i] == 0)
		if (fabs(pts3[i][0]) > tol && fabs(pts3[i][1]) > tol)
		{
			pts.push_back(pts3[i]);
			pid3[i] = count++;
		}
		else if (fabs(pts3[i][1]) < tol)
		{
			int loc(-1);
			for (uint j = 0; j < pts2.size(); j++)
			{
				if (fabs(pts3[i][0] - pts2[j][0]) < tol && fabs(pts3[i][1] - pts2[j][1]) < tol)
				{
					loc = j; break;
				}
			}
			if (loc != -1)
			{
				pid3[i] = pid2[loc];
			}
			else
			{
				cerr << "Can't find pts3 and pts2!\n"; getchar();
			}
		}
		else if (fabs(pts3[i][0]) < tol)
		{
			int loc(-1);
			for (uint j = 0; j < pts1.size(); j++)
			{
				if (fabs(pts3[i][0] - pts1[j][0]) < tol && fabs(pts3[i][1] - pts1[j][1]) < tol)
				{
					loc = j; break;
				}
			}
			if (loc != -1)
			{
				pid3[i] = pid1[loc];
			}
			else
			{
				cerr << "Can't find pts3 and pts1!\n"; getchar();
			}
		}
	}

	cnct.resize(4 * cnct0.size());
	for (uint i = 0; i < cnct0.size(); i++)
	{
		for (int j = 0; j < 4; j++)
		{
			cnct[i][j] = cnct0[i][j];
		}
	}
	int ist = cnct0.size();
	for (uint i = 0; i < cnct0.size(); i++)
	{
		int i1(i + ist);
		//int tmp[4] = { cnct0[i][2], cnct0[i][1], cnct0[i][0], cnct0[i][3] };
		for (int j = 0; j < 4; j++)
		{
			cnct[i1][j] = pid1[cnct[i][j]];
		}
	}
	ist = 2 * cnct0.size();
	for (uint i = 0; i < cnct0.size(); i++)
	{
		int i1(i + ist);
		//int tmp[4] = { cnct0[i][2], cnct0[i][1], cnct0[i][0], cnct0[i][3] };
		for (int j = 0; j < 4; j++)
		{
			cnct[i1][j] = pid2[cnct[i][j]];
		}
	}
	ist = 3 * cnct0.size();
	for (uint i = 0; i < cnct0.size(); i++)
	{
		int i1(i + ist);
		//int tmp[4] = { cnct0[i][1], cnct0[i][2], cnct0[i][3], cnct0[i][0] };
		for (int j = 0; j < 4; j++)
		{
			cnct[i1][j] = pid3[cnct[i][j]];
		}
	}

	//string fn1(fn + "_all");
	//OutputQuadVTK(fn1, pts, cnct);

	Sweep(2, pts, cnct);
	//OutputCM("../io/PlateHole/hex1");

	vector<vector<int>> pid2d, pid3d;
	pid2d.push_back(pid0); pid2d.push_back(pid1); pid2d.push_back(pid2); pid2d.push_back(pid3);
	GetPatchConnect(pid2d, pid3d);

	SetBSplinePatch(pid3d);
	int nrf(6);
	cout << "refining...\n";
	for (int i = 0; i < nrf; i++)
	{
		for (int ip = 0; ip < bsp.size(); ip++)
		{
			bsp[ip].GlobalRefine(0);
			bsp[ip].GlobalRefine(1);
		}
	}
	cout << "done refining!\n";
	SetBSPatchPointID();

	vector<BezierElement3D> bzmesh;
	vector<int> IDBC;
	vector<double> gh;
	//NURBS_BezierExtraction(pid3d, bzmesh, IDBC, gh);
	BSPatch_BezierExtraction(bzmesh, IDBC, gh);

	//VisualizeBezier(bzmesh,"../io/PlateHole1/plate_6");
	string fn1("../io/PlateHole1/PlateHole_6");
	WriteBezier_Abaqus(bzmesh, fn1);
}

void TruncatedTspline_3D::ReadInputQuadVTK(string fn, vector<array<double, 3>>& pts, vector<array<int, 4>>& cnct)
{
	pts.clear();
	cnct.clear();
	string fname(fn + ".vtk"), stmp;
	int npts, neles, itmp;
	ifstream fin;
	fin.open(fname);
	if (fin.is_open())
	{
		for (int i = 0; i<4; i++) getline(fin, stmp);//skip lines
		fin >> stmp >> npts >> stmp;
		pts.resize(npts);
		for (int i = 0; i<npts; i++)
		{
			fin >> pts[i][0] >> pts[i][1] >> pts[i][2];
		}
		getline(fin, stmp);
		fin >> stmp >> neles >> itmp;
		cnct.resize(neles);
		for (int i = 0; i<neles; i++)
		{
			fin >> itmp >> cnct[i][0] >> cnct[i][1] >> cnct[i][2] >> cnct[i][3];
		}
		fin.close();
	}
	else
	{
		cerr << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::OutputQuadVTK(string fn, vector<array<double, 3>>& pts, vector<array<int, 4>>& cnct)
{
	string fname = fn + ".vtk";
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << pts.size() << " float\n";
		for (uint i = 0; i < pts.size(); i++)
		{
			fout << pts[i][0] << " " << pts[i][1] << " " << pts[i][2] << "\n";
		}
		fout << "\nCELLS " << cnct.size() << " " << 5 * cnct.size() << '\n';
		for (uint i = 0; i < cnct.size(); i++)
		{
			fout << "4 " << cnct[i][0] << " " << cnct[i][1] << " " << cnct[i][2] << " " << cnct[i][3] << '\n';
		}
		fout << "\nCELL_TYPES " << cnct.size() << '\n';
		for (uint i = 0; i < cnct.size(); i++)
		{
			fout << "9\n";
		}
		//fout<<"\nPOINT_DATA "<<sval.size()<<"\nSCALARS sum FLOAT\nLOOKUP_TABLE default\n";
		//for(uint i=0;i<sval.size();i++)
		//{
		//	fout<<sval[i]<<"\n";
		//}
		//fout << "\nPOINT_DATA " << sval.size() << "\nNORMALS Normal FLOAT\n";
		//for (uint i = 0; i<sval.size(); i++)
		//{
		//	fout << sval[i][0] << " " << sval[i][1] << " " << sval[i][2] << "\n";
		//}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::Rescale(vector<array<double, 3>>& pts)
{
	double xscl[2] = { -5., 0. };
	double yscl[2] = { 0., 2.5 };
	int scl_not[7] = { 0, 1, 2, 3, 4, 5, 6 };
	int nnscl(7);
	vector<int> scl_flag(pts.size(), 1);
	for (int i = 0; i < nnscl; i++)
	{
		scl_flag[scl_not[i]] = 0;
	}
	double xrg[2] = { 1.e6, -1.e6 };
	double yrg[2] = { 1.e6, -1.e6 };
	for (uint i = 0; i < pts.size(); i++)
	{
		xrg[0] = pts[i][0] < xrg[0] ? pts[i][0] : xrg[0];
		xrg[1] = pts[i][0] > xrg[1] ? pts[i][0] : xrg[1];
		yrg[0] = pts[i][1] < yrg[0] ? pts[i][1] : yrg[0];
		yrg[1] = pts[i][1] > yrg[1] ? pts[i][1] : yrg[1];
	}
	cout << xrg[0] << " " << xrg[1] << "\n";
	cout << yrg[0] << " " << yrg[1] << "\n";

	double tmp[3], ratiox((xscl[1] - xscl[0]) / (xrg[1] - xrg[0])), ratioy((yscl[1] - yscl[0]) / (yrg[1] - yrg[0]));
	cout << ratiox << " " << ratioy << "\n"; getchar();
	for (uint i = 0; i < pts.size(); i++)
	{
		if (scl_flag[i] == 1)
		{
			tmp[0] = (pts[i][0] - xrg[0])*ratiox + xscl[0];
			tmp[1] = (pts[i][1] - yrg[0])*ratioy + yscl[0];
			pts[i][0] = tmp[0];
			pts[i][1] = tmp[1];
		}
	}
}

void TruncatedTspline_3D::KnotVectorWeights(vector<vector<double>>& kv, vector<vector<double>>& wt)
{
	kv.resize(3);
	wt.resize(3);
	double ku0[11] = { 0., 0., 0., 0., .5, .5, .5, 1., 1., 1., 1. };
	double kv0[8] = { 0., 0., 0., 0., 1., 1., 1., 1. };
	double kw0[8] = { 0., 0., 0., 0., 1., 1., 1., 1. };
	double wu0[7] = { 1., 0.9023689271, 0.8535533906, 0.8535533906, 0.8535533906, 0.9023689271, 1. };
	double wv0[4] = { 1., 1., 1., 1. };
	double ww0[4] = { 1., 1., 1., 1. };
	int nku(11), nkv(8), nkw(8);
	int nu(nku - 4), nv(nkv - 4), nw(nkw - 4);
	kv[0].assign(ku0, ku0 + nku);
	kv[1].assign(kv0, kv0 + nkv);
	kv[2].assign(kw0, kw0 + nkw);
	wt[0].assign(wu0, wu0 + nu);
	wt[1].assign(wv0, wv0 + nv);
	wt[2].assign(ww0, ww0 + nw);
}

void TruncatedTspline_3D::Mirror2D(int mr_flag, const vector<array<double, 3>>& pts0, vector<array<double, 3>>& pts)
{
	pts.clear();
	pts.resize(pts0.size());
	//intfc.resize(pts0.size(), 0);

	const double tol(1.e-15);
	if (mr_flag == 0)//w.r.t. x axis
	{
		for (uint i = 0; i < pts0.size(); i++)
		{
			pts[i][0] = pts0[i][0];
			pts[i][1] = -pts0[i][1];
			pts[i][2] = pts0[i][2];
		}
	}
	else if (mr_flag == 1)//w.r.t. y axis
	{
		for (uint i = 0; i < pts0.size(); i++)
		{
			pts[i][0] = -pts0[i][0];
			pts[i][1] = pts0[i][1];
			pts[i][2] = pts0[i][2];
		}
	}
	else
	{
		pts.clear();
		cerr << "Wrong mirror direction!\n";
	}
}

void TruncatedTspline_3D::ReorderPoints(int flag, vector<array<double, 3>>& pts)
{
	int nu(7), nv(4);
	vector<array<double, 3>> pts0(pts.size());
	for (uint i = 0; i < pts.size(); i++)
	{
		pts0[i][0] = pts[i][0];
		pts0[i][1] = pts[i][1];
		pts0[i][2] = pts[i][2];
	}
	if (flag == 1)
	{
		int loc(0);
		int loc1;
		for (int j = 0; j < nv; j++)
		{
			for (int i = 0; i < nu; i++)
			{
				loc1 = j*nu + (nu - 1 - i);
				pts[loc][0] = pts0[loc1][0];
				pts[loc][1] = pts0[loc1][1];
				pts[loc][2] = pts0[loc1][2];
				loc++;
			}
		}
	}
	else if (flag == 2)
	{
		int loc(0);
		int loc1;
		for (int j = 0; j < nv; j++)
		{
			for (int i = 0; i < nu; i++)
			{
				loc1 = j*nu + (nu - 1 - i);
				pts[loc][0] = pts0[loc1][0];
				pts[loc][1] = pts0[loc1][1];
				pts[loc][2] = pts0[loc1][2];
				loc++;
			}
		}
	}
	else if (flag == 3)
	{
	}
}

void TruncatedTspline_3D::Sweep(int s_flag, const vector<array<double, 3>>& pts2d, const vector<array<int, 4>>& cnct2d)
{
	if (s_flag == 2)//along z axis
	{
		double zlen(1.);
		int nez(3);
		int npz(nez + 1);
		vector<double> zcoor(npz);
		for (int i = 0; i < npz; i++)
		{
			zcoor[i] = double(i)*zlen / double(nez);
		}
		cp.resize(pts2d.size() * (nez + 1));
		tmesh.resize(cnct2d.size() * nez);
		for (int i = 0; i < npz; i++)
		{
			int ist(i*pts2d.size());
			for (uint j = 0; j < pts2d.size(); j++)
			{
				cp[ist + j].coor[0] = pts2d[j][0];
				cp[ist + j].coor[1] = pts2d[j][1];
				cp[ist + j].coor[2] = zcoor[i];
			}
		}
		for (int i = 0; i < nez; i++)
		{
			int ist_p[2] = { i*pts2d.size(), (i + 1)*pts2d.size() };
			int ist_e(i*cnct2d.size());
			for (uint j = 0; j < cnct2d.size(); j++)
			{
				for (int k = 0; k < 4; k++)
				{
					tmesh[ist_e + j].cnct[k] = ist_p[0] + cnct2d[j][k];
				}
				for (int k = 0; k < 4; k++)
				{
					tmesh[ist_e + j].cnct[k + 4] = ist_p[1] + cnct2d[j][k];
				}
			}
		}
	}
	else
	{
		cerr << "Sweeping along other axes not available yet!\n";
	}
}

void TruncatedTspline_3D::GetPatchConnect(const vector<vector<int>>& pid2d, vector<vector<int>>& pid3d)
{
	int npz(4);//sweeping direction
	pid3d.resize(pid2d.size());
	for (uint i = 0; i < pid2d.size(); i++)
	{
		//cout << "patch id: " << i << "\n";
		pid3d[i].resize(npz*pid2d[i].size());
		int loc(0);
		for (int j = 0; j < npz; j++)
		{
			//cout << "layer id: " << j << "\n";
			for (uint k = 0; k < pid2d[i].size(); k++)
			{
				pid3d[i][loc] = j*96 + pid2d[i][k];
				//cout << pid3d[i][loc] << " "; getchar();
				loc++;
			}
		}
	}
}

void TruncatedTspline_3D::NURBS_BezierExtraction(const vector<vector<int>>& pid, vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	vector<vector<double>> ku(3);
	vector<vector<double>> wt(3);
	KnotVectorWeights(ku, wt);
	int npx[3] = { ku[0].size() - 4, ku[1].size() - 4, ku[2].size() - 4 };
	int nex[3] = { npx[0] - 1, npx[1] - 1, npx[2] - 1 };//manually given
	//int ncp(npx[0] * npx[1] * npx[2]), nel(nex[0] * nex[1] * nex[2]);//one patch
	int npatch(4);

	//IDBC.resize(npatch*ncp, -1);
	//gh.resize(npatch*ncp, 0.);
	//bzmesh.resize(npatch*nel);
	uint i, j, k, i0, j0, k0, itmp;

	//int count(0);
	//for (k = 0; k < npx[2]; k++)
	//{
	//	for (j = 0; j < npx[1]; j++)
	//	{
	//		for (i = 0; i < npx[0]; i++)
	//		{
	//			//cp[loc].act = 1;
	//			//cp[loc].coor[0] = dmx[0][0] + double(i) * lenx[0];
	//			//cp[loc].coor[1] = dmx[1][0] + double(j) * lenx[1];
	//			//cp[loc].coor[2] = dmx[2][0] + double(k) * lenx[2];
	//			if (i == 0 || i == npx[0] - 1 || j == 0 || j == npx[1] - 1 || k == 0 || k == npx[2] - 1)
	//			{
	//				IDBC[loc] = -1;
	//				gh[loc] = SpecifyDirichBC(cp[loc].coor);
	//			}
	//			else
	//			{
	//				IDBC[loc] = count++;
	//			}
	//			loc++;
	//		}
	//	}
	//}
	//loc = 0;

	for (uint ip = 0; ip < pid.size(); ip++)//assign weights
	{
		int loc = 0;
		for (k = 0; k < npx[2]; k++)
		{
			for (j = 0; j < npx[1]; j++)
			{
				for (i = 0; i < npx[0]; i++)
				{
					if (j == 0)
					{
						cp[pid[ip][loc]].wght = wt[0][i] * wt[1][j] * wt[2][k];
					}
					loc++;
				}
			}
		}
	}

	for (int ip = 0; ip < npatch; ip++)//each patch has the same knot vector
	{
		for (k = 0; k < ku[2].size() - 1; k++)//w direction
		{
			for (j = 0; j < ku[1].size() - 1; j++)//v direction
			{
				for (i = 0; i < ku[0].size() - 1; i++)//u direction
				{
					if (ku[2][k] < ku[2][k + 1] && ku[1][j] < ku[1][j + 1] && ku[0][i] < ku[0][i + 1])
					{
						BezierElement3D bzel;
						bzel.IEN.resize(64);
						int loc0(0);
						for (k0 = 0; k0 < 4; k0++)
						{
							for (j0 = 0; j0 < 4; j0++)
							{
								for (i0 = 0; i0 < 4; i0++)
								{
									itmp = (k - 3 + k0)*npx[1] * npx[0] + (j - 3 + j0)*npx[0] + i - 3 + i0;
									bzel.IEN[loc0] = pid[ip][itmp];
									//cout << bzel.IEN[loc0] << "\n"; getchar();
									loc0++;
								}
							}
						}
						bzel.cmat.resize(64, vector<double>(64, 0.));
						vector<double> ku0(ku[0].begin() + i-3, ku[0].begin() + i + 5);
						vector<double> kv0(ku[1].begin() + j-3, ku[1].begin() + j + 5);
						vector<double> kw0(ku[2].begin() + k-3, ku[2].begin() + k + 5);
						vector<double> ku1, kv1, kw1;
						array<double, 2> ktu = { ku[0][i], ku[0][i + 1] };
						array<double, 2> ktv = { ku[1][j], ku[1][j + 1] };
						array<double, 2> ktw = { ku[2][k], ku[2][k + 1] };
						vector<vector<double>> Tu, Tv, Tw;
						int iloc[3];
						BezierInsertKnots(ku0, ktu, ku1);
						BezierInsertKnots(kv0, ktv, kv1);
						BezierInsertKnots(kw0, ktw, kw1);
						TMatrix(ku0, ku1, 3, Tu);
						TMatrix(kv0, kv1, 3, Tv);
						TMatrix(kw0, kw1, 3, Tw);
						for (i0 = 0; i0 < ku1.size() - 1; i0++)
						{
							if (ku1[i0] == ku[0][i] && ku1[i0 + 1] == ku[0][i + 1])
							{
								iloc[0] = i0 - 3; break;
							}
						}
						for (i0 = 0; i0 < kv1.size() - 1; i0++)
						{
							if (kv1[i0] == ku[1][j] && kv1[i0 + 1] == ku[1][j + 1])
							{
								iloc[1] = i0 - 3; break;
							}
						}
						for (i0 = 0; i0 < kw1.size() - 1; i0++)
						{
							if (kw1[i0] == ku[2][k] && kw1[i0 + 1] == ku[2][k + 1])
							{
								iloc[2] = i0 - 3; break;
							}
						}
						loc0 = 0;//Bspline
						for (k0 = 0; k0 < 4; k0++)
						{
							for (j0 = 0; j0 < 4; j0++)
							{
								for (i0 = 0; i0 < 4; i0++)
								{
									int loc1(0);//Bezier
									for (int k1 = 0; k1 < 4; k1++)
									{
										for (int j1 = 0; j1 < 4; j1++)
										{
											for (int i1 = 0; i1 < 4; i1++)
											{
												bzel.cmat[loc0][loc1] = Tu[iloc[0] + i1][i0] * Tv[iloc[1] + j1][j0] * Tw[iloc[2] + k1][k0];
												bzel.pts[loc1][0] += bzel.cmat[loc0][loc1] * cp[bzel.IEN[loc0]].coor[0];
												bzel.pts[loc1][1] += bzel.cmat[loc0][loc1] * cp[bzel.IEN[loc0]].coor[1];
												bzel.pts[loc1][2] += bzel.cmat[loc0][loc1] * cp[bzel.IEN[loc0]].coor[2];
												loc1++;
											}
										}
									}
									loc0++;
								}
							}
						}
						bzmesh.push_back(bzel);
						//loc++;
					}
				}
			}
		}
	}
}

void TruncatedTspline_3D::ReorderBezier(const vector<BezierElement3D>& bzmesh, vector<vector<int>>& bzabq)
{
	int ntype_max(200);
	vector<int> type_flag(ntype_max, -1);
	int nIEN;
	for (uint i = 0; i < bzmesh.size(); i++)
	{
		nIEN = bzmesh[i].IEN.size();
		if (nIEN < ntype_max)
		{
			if (type_flag[nIEN] == -1)
			{
				vector<int> tmp(1,i);
				bzabq.push_back(tmp);
				type_flag[nIEN] = bzabq.size() - 1;
			}
			else
			{
				bzabq[type_flag[nIEN]].push_back(i);
			}
		}
		else
		{
			cerr << "More element types than expected!\n";
			getchar();
		}
	}
}

void TruncatedTspline_3D::WriteBezier_Abaqus(const vector<BezierElement3D>& bzmesh, string fn)
{
	vector<vector<int>> bzabq;
	ReorderBezier(bzmesh, bzabq);

	int nElem(bzmesh.size());
	int mcrd = 3;
	int degree = 3;
	//int nodes = pow((degree + 1), 3.0);//number of integration points

	//string fn1(fn + "_bezier.inp");
	string fn1(fn + ".inp");
	ofstream foutinp;
	foutinp.open(fn1.c_str());
	foutinp << "*HEADING\n";
	foutinp << "*Part, name=TSpline\n";
	for (int i = 0; i < bzabq.size(); i++)
	{
		foutinp << "*USER ELEMENT, ";
		foutinp << "NODES=" << bzmesh[bzabq[i][0]].IEN.size() << ", ";
		foutinp << "TYPE=U" << i + 1 << ", ";
		foutinp << "COORDINATES=" << mcrd << ", ";
		foutinp << "PROPERTIES=" << 2 << ", "; 
		foutinp << "variables=" << 3000 <<"\n";

		//foutinp << "variables=" << bzmesh[bzabq[i][0]].IEN.size() * 39 << ", ";
		//foutinp << "I PROPERTIES=" << 8 << ", ";
		//foutinp << "PROPERTIES=" << 28 << "\n";

		//foutinp << "INTEGRATION=" << 64 << ", ";
		//foutinp << "TENSOR=THREED\n";
		foutinp << "1,2,3\n";
	}

	foutinp << "*Node,nset=AllNodes\n";
	for (uint i = 0; i < cpa.size(); i++)
	{
		foutinp << i + 1 << setprecision(15) << ",\t" << cpa[i][0] << ",\t" << cpa[i][1] << ",\t" << cpa[i][2] << '\n';
	}
	int count = 1;//element ID
	for (uint i = 0; i < bzabq.size(); i++)
	{
		//foutinp << "*Element, type=U" << i + 1 << ",elset=AllEls" << endl;
		for (uint j = 0; j<bzabq[i].size(); j++)
		{
			foutinp << "*Element, type=U" << i + 1 << endl;
			foutinp << count << ", ";
			for (int k = 0; k < bzmesh[bzabq[i][j]].IEN.size(); k++)
			{
				if (k < bzmesh[bzabq[i][j]].IEN.size() - 1)
					foutinp << bzmesh[bzabq[i][j]].IEN[k] + 1 << ", ";
				else
					foutinp << bzmesh[bzabq[i][j]].IEN[k] + 1;
				if ((k + 1) % 13 == 0 && (k + 1)< bzmesh[bzabq[i][j]].IEN.size())
					foutinp << '\n';
			}
			foutinp << '\n';
			count++;
		}
	}

	foutinp << "*ELSET,ELSET=AllPatches,generate\n";
	foutinp << "1, " << nElem << ", " << "1\n";

	/*int cc(1);
	foutinp << "*NSET,NSET=SetCPFaceLeft\n";
	for (uint i = 0; i < cpa.size(); i++)
	{
		if (fabs(cpa[i][0] - 0.) < 1.e-6)
		{
			if (cc % 14 != 0)
			{
				foutinp << i + 1 << ", ";
			}
			else
			{
				foutinp << i + 1 << ",\n";
			}
			cc++;
		}
	}
	foutinp << '\n';
	cc = 1;
	foutinp << "*NSET,NSET=SetCPFaceRight\n";
	for (int i = 0; i < cpa.size(); i++)
	{
		if (fabs(cpa[i][0] - 1.) < 1.e-6)
		{
			if (cc % 14 != 0)
			{
				foutinp << i + 1 << ", ";
			}
			else
			{
				foutinp << i + 1 << ",\n";
			}
			cc++;
		}
	}
	foutinp << '\n';
	cc = 1;
	foutinp << "*NSET,NSET=SetCPFaceNear\n";
	for (int i = 0; i<cpa.size(); i++)
	{
		if (fabs(cpa[i][1] - 0.) < 1.e-6)
		{
			if (cc % 14 != 0)
			{
				foutinp << i + 1 << ", ";
			}
			else
			{
				foutinp << i + 1 << ",\n";
			}
			cc++;
		}
	}
	foutinp << '\n';
	cc = 1;
	foutinp << "*NSET,NSET=SetCPFaceBottom\n";
	for (int i = 0; i<cpa.size(); i++)
	{
		if (fabs(cpa[i][2] - 0.) < 1.e-6)
		{
			if (cc % 14 != 0)
			{
				foutinp << i + 1 << ", ";
			}
			else
			{
				foutinp << i + 1 << ",\n";
			}
			cc++;
		}
	}
	foutinp << "\n";*/

	foutinp << "*End Part\n";
	//foutinp << "*UEL PROPERTY, ELSET=EltPAtch1, MATERIAL=MAT\n" << "1\n" << "*End Part\n";
	//foutinp << "*UEL PROPERTY, ELSET=EltPAtch1\n";
	//foutinp << "**---E11---|---v12---|----c1---|---c2----|---c3----|----c4---|----c5---|---c6----|\n";
	//foutinp << "    100000,     0.3,     1.0e6,    6.0e1,   80.000,   0.2500,   0.9000,    2.239,\n";
	//foutinp << "**\n**---Y0----|----ep0--|---Y1----|----ep1--|---Y2----|----ep2--|---Y3----|----ep3--|\n";
	//foutinp << "  1157.000,    0.000,   0.0000,   0.0100,1207.5147,  0.00000,1224.9017,   0.0500,\n";
	//foutinp << "**\n**---Y4----|----ep4--|---Y5----|----ep5--|---Y6----|----ep6--|---Y7----|----ep7--|\n";
	//foutinp << "1252.362103,   0.0800,1270.5188,   0.1000,  1426.00,   0.3000,   1538.0,   0.6000,\n";
	//foutinp << "**-------------------------> PROPS(28) | JPROPS(1)\n";
	//foutinp << "**---fGT---|---fxC---|---Gxc---|---fGc---|-CohType-|--FtgMnt-|-psudo3D-|-VirtualE|\n";
	//foutinp << "     0.4,      0.5,     65.0,      0.5,        2,        1,        0,        4, \n";
	//foutinp << "**-----------------------------> JPROPS(8)\n";
	//foutinp << "** --NPLY--|--FaiCrt-|CDDC_NE_D|---------|\n";
	//foutinp << "       1,        3,        0,        0\n*End Part\n";

	foutinp << "*Assembly, name=Assembly\n" << "*Instance, name=I1, part=TSpline\n" << "*End Instance\n" << "*End Assembly\n";

	//foutinp << "*MATERIAL,NAME=MAT\n" << "*Elastic\n";
	//foutinp << "100000, 0.3\n";
	//foutinp << "**\n** Modification (3): Add an amplitude definition\n**\n";
	//foutinp << "*amplitude, name=AMP1\n";
	//foutinp << "0.0, 1.0, 1.0e6, 1.0\n";

	foutinp << "*STEP,NLGEOM=NO\n";
	foutinp << "* Static\n";
	//foutinp << "*Static\n" << "*Boundary\n";
	//foutinp << "I1.SetCPFaceLeft, " << 1 << ", " << 1 << ", " << 0 << endl;
	//foutinp << "I1.SetCPFaceRight, " << 1 << ", " << 1 << ", " << 0.1 << endl;
	//foutinp << "I1.SetCPFaceNear, " << 2 << ", " << 2 << ", " << 0 << endl;
	//foutinp << "I1.SetCPFaceBottom, " << 3 << ", " << 3 << ", " << 0 << endl;

	//foutinp << "**\n** Modification (4): Add a *Temperature line\n**\n";
	//foutinp << "*Temperature, amplitude=AMP1\n";
	//foutinp << "I1.AllNode, 0.0\n";

	foutinp << "*node file, frequency=1\n" << "U,RF,CF\n" << "*el file, frequency=1\n"<< "SDV\n" << "*End Step\n";
	foutinp.close();


	//string fn2(fn + "_bezier.NB");
	string fn2(fn + ".NB");
	ofstream foutnb;
	foutnb.open(fn2.c_str());
	foutnb << "*Dimension" << endl;
	foutnb << 3 << endl;
	foutnb << "*Number of CP by element" << endl;
	foutnb << 64 << endl;
	foutnb << "*Number of patch" << endl;
	foutnb << nElem << endl;
	foutnb << "*Total number of element" << endl;
	foutnb << nElem << endl;
	foutnb << "*Number of element by patch" << endl;
	for (int i = 0; i<nElem - 1; i++)
	{
		foutnb << "1,";
	}
	foutnb << "1";
	foutnb << endl;
 
	for (int i = 0; i<nElem; i++)
	{
		foutnb << "*Patch(" << i + 1 << ")" << endl;
		foutnb << "8" << endl;
		foutnb << "0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 1.000000000000000, 1.000000000000000,1.000000000000000" << endl;
		foutnb << "8" << endl;
		foutnb << "0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 1.000000000000000, 1.000000000000000,1.000000000000000" << endl;
		foutnb << "8" << endl;
		foutnb << "0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 1.000000000000000, 1.000000000000000,1.000000000000000" << endl;
	}
	foutnb << "*Jpqr\n";
	foutnb << 3 << ", " << 3 << ", " << 3 << endl;
	foutnb << "*Nijk\n";
	for (int i = 0; i<nElem; i++)
	{
		foutnb << i + 1 << ",4,4,4\n";
	}

	foutnb << "*Weight\n";
	count = 1;
	for (uint i = 0; i < bzabq.size(); i++)
	{
		for (uint j = 0; j < bzabq[i].size(); j++)
		{
			foutnb << count << ", " << bzmesh[bzabq[i][j]].IEN.size() << '\n';
			for (uint k = 0; k < bzmesh[bzabq[i][j]].IEN.size() - 1; k++)
			{
				foutnb << "1, ";
			}
			foutnb << "1\n";
			count++;
		}
	}

	foutnb << "*Bezier Operator\n";
	count = 1;
	cout << "# elements: " << bzmesh.size() << "\n";
	for (uint i = 0; i < bzabq.size(); i++)
	{
		for (uint j = 0; j < bzabq[i].size(); j++)
		{
			if (count % 1000 == 0)
			{
				cout << floor(double(count * 100) / double(bzmesh.size())) << "% ";
			}
			foutnb << count << ", " << bzmesh[bzabq[i][j]].IEN.size() << '\n';
			for (uint k = 0; k < bzmesh[bzabq[i][j]].IEN.size(); k++)
			{
				foutnb << k + 1 << ", ";
				for (int l = 0; l<64; l++)
				{
					if (l == 63)
						foutnb << setprecision(15) << bzmesh[bzabq[i][j]].cmat[k][l];
					else
						foutnb << setprecision(15) << bzmesh[bzabq[i][j]].cmat[k][l] << ", ";
				}
				foutnb << '\n';
			}
			count++;
		}
	}
	foutnb.close();
}

void TruncatedTspline_3D::WriteBezier_Abaqus_LocalRefine(const vector<BezierElement3D>& bzmesh, string fn)
{
	vector<vector<int>> bzabq;
	ReorderBezier(bzmesh, bzabq);

	int nElem(bzmesh.size());
	int mcrd = 3;
	int degree = 3;
	//int nodes = pow((degree + 1), 3.0);//number of integration points

	string fn1(fn + "_bezier.inp");
	ofstream foutinp;
	foutinp.open(fn1.c_str());
	foutinp << "*HEADING\n";
	foutinp << "*Part, name=Piece\n";
	for (int i = 0; i < bzabq.size(); i++)
	{
		foutinp << "*USER ELEMENT, ";
		foutinp << "NODES=" << bzmesh[bzabq[i][0]].IEN.size() << ", ";
		foutinp << "TYPE=U" << i + 1 << ", ";
		foutinp << "COORDINATES=" << mcrd << ", ";
		foutinp << "variables=" << bzmesh[bzabq[i][0]].IEN.size() * 39 << ", ";
		foutinp << "I PROPERTIES=" << 8 << ", ";
		foutinp << "PROPERTIES=" << 28 << "\n";
		//foutinp << "INTEGRATION=" << 64 << ", ";
		//foutinp << "TENSOR=THREED\n";
		foutinp << "1,2,3\n";
	}

	foutinp << "*Node,nset=AllNode\n";
	int count = 1;
	for (uint i = 0; i < hcp.size(); i++)
	{
		for (uint j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				foutinp << count << setprecision(15) << ",\t" << hcp[i][j].coor[0] << ",\t" << hcp[i][j].coor[1] << ",\t" << hcp[i][j].coor[2] << '\n';
				count++;
			}

		}
	}
		
			
	/*for (uint i = 0; i < cpa.size(); i++)
	{
		foutinp << i + 1 << setprecision(15) << ",\t" << cpa[i][0] << ",\t" << cpa[i][1] << ",\t" << cpa[i][2] << '\n';
	}*/
	count = 1;//element ID
	for (uint i = 0; i < bzabq.size(); i++)
	{
		foutinp << "*Element, type=U" << i + 1 << ",elset=AllEls" << endl;
		for (uint j = 0; j < bzabq[i].size(); j++)
		{
			foutinp << count << ", ";
			for (int k = 0; k < bzmesh[bzabq[i][j]].IEN.size(); k++)
			{
				if (k < bzmesh[bzabq[i][j]].IEN.size() - 1)
					foutinp << bzmesh[bzabq[i][j]].IEN[k] + 1 << ", ";
				else
					foutinp << bzmesh[bzabq[i][j]].IEN[k] + 1;
				if ((k + 1) % 13 == 0)
					foutinp << '\n';
			}
			foutinp << '\n';
			count++;
		}
	}

	foutinp << "*ELSET,ELSET=EltPAtch1,generate\n";
	foutinp << "1, " << nElem << ", " << "1\n";

	/*int cc(1);
	foutinp << "*NSET,NSET=SetCPFaceLeft\n";
	for (uint i = 0; i < cpa.size(); i++)
	{
		if (fabs(cpa[i][0] - 0.) < 1.e-6)
		{
			if (cc % 14 != 0)
			{
				foutinp << i + 1 << ", ";
			}
			else
			{
				foutinp << i + 1 << ",\n";
			}
			cc++;
		}
	}
	foutinp << '\n';
	cc = 1;
	foutinp << "*NSET,NSET=SetCPFaceRight\n";
	for (int i = 0; i < cpa.size(); i++)
	{
		if (fabs(cpa[i][0] - 1.) < 1.e-6)
		{
			if (cc % 14 != 0)
			{
				foutinp << i + 1 << ", ";
			}
			else
			{
				foutinp << i + 1 << ",\n";
			}
			cc++;
		}
	}
	foutinp << '\n';
	cc = 1;
	foutinp << "*NSET,NSET=SetCPFaceNear\n";
	for (int i = 0; i<cpa.size(); i++)
	{
		if (fabs(cpa[i][1] - 0.) < 1.e-6)
		{
			if (cc % 14 != 0)
			{
				foutinp << i + 1 << ", ";
			}
			else
			{
				foutinp << i + 1 << ",\n";
			}
			cc++;
		}
	}
	foutinp << '\n';
	cc = 1;
	foutinp << "*NSET,NSET=SetCPFaceBottom\n";
	for (int i = 0; i<cpa.size(); i++)
	{
		if (fabs(cpa[i][2] - 0.) < 1.e-6)
		{
			if (cc % 14 != 0)
			{
				foutinp << i + 1 << ", ";
			}
			else
			{
				foutinp << i + 1 << ",\n";
			}
			cc++;
		}
	}
	foutinp << "\n";*/

	//foutinp << "*UEL PROPERTY, ELSET=EltPAtch1, MATERIAL=MAT\n" << "1\n" << "*End Part\n";
	foutinp << "*UEL PROPERTY, ELSET=EltPAtch1\n";
	foutinp << "**---E11---|---v12---|----c1---|---c2----|---c3----|----c4---|----c5---|---c6----|\n";
	foutinp << "    100000,     0.3,     1.0e6,    6.0e1,   80.000,   0.2500,   0.9000,    2.239,\n";
	foutinp << "**\n**---Y0----|----ep0--|---Y1----|----ep1--|---Y2----|----ep2--|---Y3----|----ep3--|\n";
	foutinp << "  1157.000,    0.000,   0.0000,   0.0100,1207.5147,  0.00000,1224.9017,   0.0500,\n";
	foutinp << "**\n**---Y4----|----ep4--|---Y5----|----ep5--|---Y6----|----ep6--|---Y7----|----ep7--|\n";
	foutinp << "1252.362103,   0.0800,1270.5188,   0.1000,  1426.00,   0.3000,   1538.0,   0.6000,\n";
	foutinp << "**-------------------------> PROPS(28) | JPROPS(1)\n";
	foutinp << "**---fGT---|---fxC---|---Gxc---|---fGc---|-CohType-|--FtgMnt-|-psudo3D-|-VirtualE|\n";
	foutinp << "     0.4,      0.5,     65.0,      0.5,        2,        1,        0,        4, \n";
	foutinp << "**-----------------------------> JPROPS(8)\n";
	foutinp << "** --NPLY--|--FaiCrt-|CDDC_NE_D|---------|\n";
	foutinp << "       1,        3,        0,        0\n*End Part\n";

	foutinp << "*Assembly, name=Assembly\n" << "*Instance, name=I1, part=Piece\n" << "*End Instance\n" << "*End Assembly\n";
	foutinp << "*MATERIAL,NAME=MAT\n" << "*Elastic\n";
	foutinp << "100000, 0.3\n";
	foutinp << "**\n** Modification (3): Add an amplitude definition\n**\n";
	foutinp << "*amplitude, name=AMP1\n";
	foutinp << "0.0, 1.0, 1.0e6, 1.0\n";

	//foutinp << "*STEP,extrapolation=NO,NLGEOM=NO\n";
	//foutinp << "*Static\n" << "*Boundary\n";
	//foutinp << "I1.SetCPFaceLeft, " << 1 << ", " << 1 << ", " << 0 << endl;
	//foutinp << "I1.SetCPFaceRight, " << 1 << ", " << 1 << ", " << 0.1 << endl;
	//foutinp << "I1.SetCPFaceNear, " << 2 << ", " << 2 << ", " << 0 << endl;
	//foutinp << "I1.SetCPFaceBottom, " << 3 << ", " << 3 << ", " << 0 << endl;

	foutinp << "**\n** Modification (4): Add a *Temperature line\n**\n";
	foutinp << "*Temperature, amplitude=AMP1\n";
	foutinp << "I1.AllNode, 0.0\n";

	foutinp << "*node file, frequency=1\n" << "U,RF,CF\n" << "*el file, frequency=1\n" << "SDV\n" << "*End Step\n";
	foutinp.close();


	string fn2(fn + "_bezier.NB");
	ofstream foutnb;
	foutnb.open(fn2.c_str());
	foutnb << "*Dimension" << endl;
	foutnb << 3 << endl;
	foutnb << "*Number of CP by element" << endl;
	foutnb << 64 << endl;
	foutnb << "*Number of patch" << endl;
	foutnb << nElem << endl;
	foutnb << "*Total number of element" << endl;
	foutnb << nElem << endl;
	foutnb << "*Number of element by patch" << endl;
	for (int i = 0; i < nElem - 1; i++)
	{
		foutnb << "1,";
	}
	foutnb << "1";
	foutnb << endl;

	for (int i = 0; i < nElem; i++)
	{
		foutnb << "*Patch(" << i + 1 << ")" << endl;
		foutnb << "8" << endl;
		foutnb << "0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 1.000000000000000, 1.000000000000000,1.000000000000000" << endl;
		foutnb << "8" << endl;
		foutnb << "0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 1.000000000000000, 1.000000000000000,1.000000000000000" << endl;
		foutnb << "8" << endl;
		foutnb << "0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 1.000000000000000, 1.000000000000000,1.000000000000000" << endl;
	}
	foutnb << "*Jpqr\n";
	foutnb << 3 << ", " << 3 << ", " << 3 << endl;
	foutnb << "*Nijk\n";
	for (int i = 0; i < nElem; i++)
	{
		foutnb << i + 1 << ",4,4,4\n";
	}

	foutnb << "*Weight\n";
	count = 1;
	for (uint i = 0; i < bzabq.size(); i++)
	{
		for (uint j = 0; j < bzabq[i].size(); j++)
		{
			foutnb << count << ", " << bzmesh[bzabq[i][j]].IEN.size() << '\n';
			for (uint k = 0; k < bzmesh[bzabq[i][j]].IEN.size() - 1; k++)
			{
				foutnb << "1, ";
			}
			foutnb << "1\n";
			count++;
		}
	}

	foutnb << "*Bezier Operator\n";
	count = 1;
	cout << "# elements: " << bzmesh.size() << "\n";
	for (uint i = 0; i < bzabq.size(); i++)
	{
		for (uint j = 0; j < bzabq[i].size(); j++)
		{
			if (count % 1000 == 0)
			{
				cout << floor(double(count * 100) / double(bzmesh.size())) << "% ";
			}
			foutnb << count << ", " << bzmesh[bzabq[i][j]].IEN.size() << '\n';
			for (uint k = 0; k < bzmesh[bzabq[i][j]].IEN.size(); k++)
			{
				foutnb << k + 1 << ", ";
				for (int l = 0; l < 64; l++)
				{
					if (l == 63)
						foutnb << setprecision(15) << bzmesh[bzabq[i][j]].cmat[k][l];
					else
						foutnb << setprecision(15) << bzmesh[bzabq[i][j]].cmat[k][l] << ", ";
				}
				foutnb << '\n';
			}
			count++;
		}
	}
	foutnb.close();
}

void TruncatedTspline_3D::WriteBezier_h(const vector<BezierElement3D>& bzmesh, string fn)
{
	vector<array<int, 2>> pact;
	array<int, 2> itmp;
	vector<vector<int>> aloc(hcp.size());
	int count(0);
	for (uint i = 0; i < hcp.size(); i++)
	{
		aloc[i].resize(hcp[i].size(), -1);
		for (uint j = 0; j < hcp[i].size(); j++)
		{
			if (hcp[i][j].act == 1)
			{
				itmp[0] = i;
				itmp[1] = j;
				pact.push_back(itmp);
				aloc[i][j] = count++;
			}
		}
	}

	ofstream fout;
	string fn1(fn + "_bezier.txt");
	fout.open(fn1.c_str());
	if (fout.is_open())
	{
		fout << "dim 3\ndeg 3 3\n";
		fout << "funcs " << pact.size() << "\n";
		fout << "elems " << bzmesh.size() << "\n";
		for (uint i = 0; i < pact.size(); i++)
		{
			fout << "P" << i << "\t" << hcp[pact[i][0]][pact[i][1]].coor[0] << "\t" <<
				hcp[pact[i][0]][pact[i][1]].coor[1] << "\t" << hcp[pact[i][0]][pact[i][1]].coor[2] << "\t1\n";
		}
		fout << "elems " << bzmesh.size() << "\n";
		for (uint i = 0; i < bzmesh.size(); i++)
		{
			count = 0;
			for (uint j = 0; j < bzmesh[i].IEN.size(); j++)
			{
				if (bzmesh[i].IEN[j] != -1)
				{
					count++;
				}
			}
			fout << i << " " << count << "\n";
			count = 0;
			for (uint j = 0; j < bzmesh[i].IEN.size(); j++)
			{
				if (bzmesh[i].IEN[j] != -1)
				{
					fout << bzmesh[i].IEN[j] << " ";
					count++;
					if (count % 16 == 0)
					{
						fout << "\n";
					}
				}
			}
			if (count % 16 != 0)
			{
				fout << "\n";
			}
			for (uint j = 0; j < bzmesh[i].IEN.size(); j++)
			{
				if (bzmesh[i].IEN[j] != -1)
				{
					count = 0;
					for (uint k = 0; k < bzmesh[i].cmat[j].size(); k++)
					{
						fout << bzmesh[i].cmat[j][k] << " ";
						count++;
						if (count % 8 == 0)
						{
							fout << "\n";
						}
					}
					if (count % 8 != 0)
					{
						fout << "\n";
					}
				}
			}
		}
		fout.close();
	}
	else
	{
		cerr << "Can't open " << fn1 << "\n";
	}

	string fn2(fn + "_bc.txt");
	ofstream fbout;
	fbout.open(fn2.c_str());
	if (fbout.is_open())
	{
		fbout << "Indexing of input mesh\n";
		fbout << "nCP " << hcp[0].size() << "\n";
		for (uint i = 0; i < hcp[0].size(); i++)
		{
			fbout << i << " " << aloc[0][i] << "\n";
		}
		fbout.close();
	}
	else
	{
		cerr << "Can't open " << fn2 << "\n";
	}
}

void TruncatedTspline_3D::SetBSplinePatch(const vector<vector<int>>& pid)
{
	vector<vector<double>> ku(3);
	vector<vector<double>> wt(3);
	KnotVectorWeights(ku, wt);
	int npatch(4);
	//int npx[3] = { ku[0].size() - 4, ku[1].size() - 4, ku[2].size() - 4 };
	//int nex[3] = { npx[0] - 1, npx[1] - 1, npx[2] - 1 };//manually given
	////int ncp(npx[0] * npx[1] * npx[2]), nel(nex[0] * nex[1] * nex[2]);//one patch
	
	bsp.resize(npatch);
	for (int ip = 0; ip < npatch; ip++)
	{
		bsp[ip].Initialize(ku);
		int loc(0);
		for (int k = 0; k < bsp[ip].npt[2]; k++)
		{
			for (int j = 0; j < bsp[ip].npt[1]; j++)
			{
				for (int i = 0; i < bsp[ip].npt[0]; i++)
				{
					bsp[ip].cp[loc][0] = cp[pid[ip][loc]].coor[0];
					bsp[ip].cp[loc][1] = cp[pid[ip][loc]].coor[1];
					bsp[ip].cp[loc][2] = cp[pid[ip][loc]].coor[2];
					bsp[ip].wght[loc] = wt[0][i] * wt[1][j] * wt[2][k];
					cp[pid[ip][loc]].wght = bsp[ip].wght[loc];
					bsp[ip].pid[loc] = pid[ip][loc];
					loc++;
				}
			}
		}
	}
}

void TruncatedTspline_3D::SetBSPatchPointID()//currently only for plate with a hole
{
	int count(0);
	int ip(0);
	for (uint i = 0; i < bsp[ip].pid.size(); i++)
	{
		bsp[ip].pid[i] = count++;
	}
	ip = 1;
	int loc(0);
	for (int k = 0; k < bsp[ip].npt[2]; k++)
	{
		for (int j = 0; j < bsp[ip].npt[1]; j++)
		{
			for (int i = 0; i < bsp[ip].npt[0]; i++)
			{
				if (i < bsp[ip].npt[0] - 1)
				{
					bsp[ip].pid[loc] = count++;
				}
				else
				{
					int locnb = k*bsp[ip].npt[1] * bsp[ip].npt[0] + j*bsp[ip].npt[0];
					bsp[ip].pid[loc] = bsp[0].pid[locnb];
				}
				loc++;
			}
		}
	}
	ip = 2;
	loc = 0;
	for (int k = 0; k < bsp[ip].npt[2]; k++)
	{
		for (int j = 0; j < bsp[ip].npt[1]; j++)
		{
			for (int i = 0; i < bsp[ip].npt[0]; i++)
			{
				if (i > 0)
				{
					bsp[ip].pid[loc] = count++;
				}
				else
				{
					int locnb = k*bsp[ip].npt[1] * bsp[ip].npt[0] + j*bsp[ip].npt[0] + bsp[ip].npt[0] - 1;
					bsp[ip].pid[loc] = bsp[0].pid[locnb];
				}
				loc++;
			}
		}
	}
	ip = 3;
	loc = 0;
	for (int k = 0; k < bsp[ip].npt[2]; k++)
	{
		for (int j = 0; j < bsp[ip].npt[1]; j++)
		{
			for (int i = 0; i < bsp[ip].npt[0]; i++)
			{
				if (i > 0 && i < bsp[ip].npt[0] - 1)
				{
					bsp[ip].pid[loc] = count++;
				}
				else if (i == 0)
				{
					int locnb = k*bsp[ip].npt[1] * bsp[ip].npt[0] + j*bsp[ip].npt[0] + bsp[ip].npt[0] - 1;
					bsp[ip].pid[loc] = bsp[2].pid[locnb];
				}
				else if (i == bsp[ip].npt[0] - 1)
				{
					int locnb = k*bsp[ip].npt[1] * bsp[ip].npt[0] + j*bsp[ip].npt[0];
					bsp[ip].pid[loc] = bsp[1].pid[locnb];
				}
				loc++;
			}
		}
	}

	//only for test
	cp.clear();
	cp.resize(count);
	for (uint i = 0; i < cp.size(); i++)
	{
		cp[i].coor[0] = 0.; cp[i].coor[1] = 0.; cp[i].coor[2] = 0.;
		cp[i].wght = 1.;
		cp[i].update = 0;
	}
	for (uint ip = 0; ip < bsp.size(); ip++)
	{
		for (uint i = 0; i < bsp[ip].pid.size(); i++)
		{
			if (cp[bsp[ip].pid[i]].update == 0)
			{
				cp[bsp[ip].pid[i]].coor[0] = bsp[ip].cp[i][0];
				cp[bsp[ip].pid[i]].coor[1] = bsp[ip].cp[i][1];
				cp[bsp[ip].pid[i]].coor[2] = bsp[ip].cp[i][2];
				cp[bsp[ip].pid[i]].wght = bsp[ip].wght[i];
			}
		}
	}
}

void TruncatedTspline_3D::BSPatch_BezierExtraction(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	for (uint ip = 0; ip < bsp.size(); ip++)
	{
		bsp[ip].BuildElement();
		for (uint i = 0; i < bsp[ip].ele.size(); i++)
		{
			BezierElement3D bzel;
			bsp[ip].BezierExtract(i, bzel.cmat, bzel.IEN);
			//only for test
			for (uint j = 0; j < 64; j++)
			{
				for (uint k = 0; k < bzel.IEN.size(); k++)
				{
					//cout << bzel.cmat[k][j] << " ";
					bzel.pts[j][0] += bzel.cmat[k][j] * cp[bzel.IEN[k]].coor[0];
					bzel.pts[j][1] += bzel.cmat[k][j] * cp[bzel.IEN[k]].coor[1];
					bzel.pts[j][2] += bzel.cmat[k][j] * cp[bzel.IEN[k]].coor[2];
				}
				//cout << "\n"; getchar();
			}
			bzmesh.push_back(bzel);
		}
	}
}





/////////////////////////////////////////////

void TruncatedTspline_3D::ProjectBoundary()
{
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].type == 1)
		{
			if (cp[i].sharp == 0)
			{

			}
			else if (cp[i].sharp == 1)
			{

			}
		}
	}
}

void TruncatedTspline_3D::ProjectBoundary_NonSharp()
{

}

void TruncatedTspline_3D::ProjectBoundary_Sharp()
{

}



















///////////////////////////////////////////////////////////////////////

void TruncatedTspline_3D::InitializeMesh_UB(string fn)
{
	ReadVtk_Hex(fn);

	//RescaleDomain();//to [0,1]^3

	InitialConnect_UB();
	SetSharpFeature_1(0.6);

	//string fn1("../io/yuxuan/navair/navair");
	//OutputEdge(fn1);
	//OutputCM(fn1);
	//cout << "done setting sharp feature\n";
	//getchar();
}

void TruncatedTspline_3D::ReadVtk_Hex(string fn)
{
	//read hex vtk
	string fname(fn + ".vtk"), stmp;
	int npts, neles, itmp;
	ifstream fin;
	fin.open(fname);
	if (fin.is_open())
	{
		for (int i = 0; i<4; i++) getline(fin, stmp);//skip lines
		fin >> stmp >> npts >> stmp;
		cp.resize(npts);
		for (int i = 0; i<npts; i++)
		{
			cp[i].act = 1;
			fin >> cp[i].coor[0] >> cp[i].coor[1] >> cp[i].coor[2];
		}
		getline(fin, stmp);
		fin >> stmp >> neles >> itmp;
		tmesh.resize(neles);
		for (int i = 0; i<neles; i++)
		{
			tmesh[i].act = 1;
			fin >> itmp >> tmesh[i].cnct[0] >> tmesh[i].cnct[1] >> tmesh[i].cnct[2] >> tmesh[i].cnct[3] >>
				tmesh[i].cnct[4] >> tmesh[i].cnct[5] >> tmesh[i].cnct[6] >> tmesh[i].cnct[7];
		}
		fin.close();
	}
	else
	{
		cerr << "Cannot open " << fname << "!\n";
	}
}

void TruncatedTspline_3D::InitialConnect_UB()
{
	BuildInitialEdges();
	//SetType_UB();
}

int TruncatedTspline_3D::IsPillowNeeded()
{
	int pillow_flag(0);
	uint i, j;
	for (i = 0; i<tmface.size(); i++)
	{
		if (tmface[i].hex.size() == 1)
		{
			tmface[i].type = 1;
			tmesh[tmface[i].hex[0]].type = 1;
			for (j = 0; j<4; j++)
			{
				cp[tmface[i].cnct[j]].type = 1;
				tmedge[tmface[i].edge[j]].type = 1;
			}
		}
	}
	for (i = 0; i < tmesh.size(); i++)//boundary elements
	{
		if (tmesh[i].type == 0)
		{
			for (j = 0; j < 8; j++)
			{
				if (cp[tmesh[i].cnct[j]].type == 1)
				{
					pillow_flag = 2;
					tmesh[i].type = 1;
					break;
				}
			}
		}
		if (pillow_flag == 2) break;
	}
	//find extraordinary edges and vertices
	for (i = 0; i<tmedge.size(); i++)
	{
		if (tmedge[i].type == 1 && (tmedge[i].hex.size() == 1 || tmedge[i].hex.size() > 2))
		{
			pillow_flag = 2; break;
		}
	}
	if (pillow_flag == 0)
	{
		for (i = 0; i < cp.size(); i++)
		{
			if (cp[i].type == 0)
			{
				int nb[2] = { 0,0 };
				for (j = 0; j < cp[i].hex.size(); j++)
				{
					if (tmesh[cp[i].hex[j]].type == 0)
					{
						nb[0]++;
					}
					else
					{
						nb[1]++;
					}
				}
				if (nb[0] == nb[1])
				{
					pillow_flag = 1; break;
				}
			}
		}
	}
	return pillow_flag;
}

void TruncatedTspline_3D::Pillow(int nlayer)
{
	
	cout << "Pillowing" << endl;
	//input is a hex mesh
	int fcloc[6][4] = { {0,3,2,1},{0,1,5,4},{1,2,6,5},{2,3,7,6},{0,4,7,3},{4,5,6,7} };
	//initial layer
	vector<int> pts0;
	vector<int> pid(cp.size(), -1);
	vector<array<int, 4>> layer0;
	array<int, 4> fctmp;
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].type == 1)//boundary point
		{
			pts0.push_back(i);
			pid[i] = pts0.size() - 1;
		}
	}
	for (uint i = 0; i < tmesh.size(); i++)
	{
		if (tmesh[i].type == 1)//boundary element
		{
			for (int j = 0; j < 6; j++)
			{
				if (tmface[tmesh[i].face[j]].type == 1)//boundary face
				{
					for (int k = 0; k < 4; k++)
					{
						fctmp[k] = pid[tmesh[i].cnct[fcloc[j][k]]];
					}
					layer0.push_back(fctmp);
				}
			}
		}
	}

	vector<vector<int>> p2f(pts0.size());
	vector<double> dist;
	vector<array<double, 3>> dir;
	for (uint i = 0; i < layer0.size(); i++)
	{
		for (int j = 0; j < 4; j++)
		{
			p2f[layer0[i][j]].push_back(i);
		}
	}
	for (uint i = 0; i < pts0.size(); i++)
	{
		double dtmp, dmin(1.e5);
		array<double, 3> vtmp;
		for (uint j = 0; j < cp[pts0[i]].edge.size(); j++)
		{
			if (tmedge[cp[pts0[i]].edge[j]].type == 1)
			{
				int edpt[2] = { tmedge[cp[pts0[i]].edge[j]].pt[0],tmedge[cp[pts0[i]].edge[j]].pt[1] };
				vtmp[0] = cp[edpt[1]].coor[0] - cp[edpt[0]].coor[0];
				vtmp[1] = cp[edpt[1]].coor[1] - cp[edpt[0]].coor[1];
				vtmp[2] = cp[edpt[1]].coor[2] - cp[edpt[0]].coor[2];
				dtmp = sqrt(vtmp[0] * vtmp[0] + vtmp[1] * vtmp[1] + vtmp[2] * vtmp[2]);
				if (dtmp < dmin) dmin = dtmp;
				//if (dtmp < 1.e-10)
				//{
				//	cout << "zero edge length!\n"; getchar();
				//}
			}
		}
		dist.push_back(dmin);
		array<double, 3> nm = { 0.,0.,0. };
		for (uint j = 0; j < p2f[i].size(); j++)
		{
			int fcid(p2f[i][j]);
			array<int,4>::iterator it = find(layer0[fcid].begin(),layer0[fcid].end(),i);
			int loc(it - layer0[fcid].begin());
			if (loc == 4)
			{
				cerr << "can't find!\n"; getchar();
			}
			int edpt[3] = { pts0[layer0[fcid][loc]],pts0[layer0[fcid][(loc + 1) % 4]],pts0[layer0[fcid][(loc + 3) % 4]] };
			double v1[3] = { cp[edpt[1]].coor[0] - cp[edpt[0]].coor[0],cp[edpt[1]].coor[1] - cp[edpt[0]].coor[1],cp[edpt[1]].coor[2] - cp[edpt[0]].coor[2] };
			double v2[3] = { cp[edpt[2]].coor[0] - cp[edpt[0]].coor[0],cp[edpt[2]].coor[1] - cp[edpt[0]].coor[1],cp[edpt[2]].coor[2] - cp[edpt[0]].coor[2] };
			double v3[3] = { v1[1] * v2[2] - v1[2] * v2[1],v1[2] * v2[0] - v1[0] * v2[2], v1[0] * v2[1] - v1[1] * v2[0] };
			dtmp = sqrt(v3[0] * v3[0] + v3[1] * v3[1] + v3[2] * v3[2]);
			v3[0] /= dtmp; v3[1] /= dtmp; v3[2] /= dtmp;
			nm[0] += v3[0];
			nm[1] += v3[1];
			nm[2] += v3[2];
		}
		nm[0] /= double(p2f[i].size());
		nm[1] /= double(p2f[i].size());
		nm[2] /= double(p2f[i].size());
		dir.push_back(nm);
	}
	
	for (int il = 0; il < nlayer; il++)//now only consider nlayer==1
	{
		vector<int> pts1(pts0.size());
		for (uint i = 0; i < pts0.size(); i++)
		{
			Vertex3D ptmp;
			ptmp.act = 1;
			ptmp.coor[0] = cp[pts0[i]].coor[0];
			ptmp.coor[1] = cp[pts0[i]].coor[1];
			ptmp.coor[2] = cp[pts0[i]].coor[2];
			cp.push_back(ptmp);
			pts1[i] = cp.size() - 1;
		}
		for (uint i = 0; i < layer0.size(); i++)
		{
			Element3D etmp;
			etmp.act = 1;
			for (int j = 0; j < 4; j++)
			{
				etmp.cnct[j] = pts0[layer0[i][j]];
				etmp.cnct[j + 4] = pts1[layer0[i][j]];
			}
			tmesh.push_back(etmp);
		}
		//for (uint i = 0; i < pts0.size(); i++)
		//{
		//	pts0[i] = pts1[i];
		//}
	}

	double eta(0.2);
	double smin(1.e5);
	for (uint i = 0; i < pts0.size(); i++)
	{
		double step(eta*dist[i]);
		cp[pts0[i]].coor[0] -= step*dir[i][0];
		cp[pts0[i]].coor[1] -= step*dir[i][1];
		cp[pts0[i]].coor[2] -= step*dir[i][2];
		if (dist[i] < smin) smin = dist[i];
	}
	cout << "min edge len: " << smin << "\n";

	cout << "Done pillowing!\n";
	//OutputCM("../io/hex_input/pillow/cube_coarse");
	//OutputCM("../io/hex_input/pillow/fertility1");
	//OutputCM("../io/hex_input/pillow/rockerarm1");
	//OutputCM("../io/hex_input/pillow/honda1m");
	//OutputCM("../io/hex_input/pillow/honda2");
	//OutputCM("../io/hex_input/pillow/honda2_1");
	//OutputCM("../io/hex_input/pillow/rod");
	//OutputCM("../io/hex_input/pillow/navair_coarse");
}

void TruncatedTspline_3D::Smoothing(int nSize, double stepSize)
{
	cout << "\nSmoothing...\n";

	//int nLapStep(50);
	//for (int it = 0; it < nLapStep; it++)
	//{
	//	for (uint i = 0; i < cp.size(); i++)
	//	{
	//		if (cp[i].type != 1)//interior points only
	//		{
	//			int tmp = LaplaceSmoothingPoint(i, stepSize);
	//		}
	//	}
	//	double minJacob_glb;
	//	int min_pos;
	//	vector<int> BadEle;
	//	GlobalMinJacob(minJacob_glb, min_pos, BadEle);
	//}
	////OutputCM("../io/NAVAIR_GEM/output/smooth1/navair3_0");
	////getchar();

	for (int it = 0; it < nSize; it++)
	{
		cout << "it: " << it << "\n";
		int flag(0);

		double minJacob_glb0;
		int min_pos0(0);
		vector<int> BadEle0;
		GlobalMinJacob(minJacob_glb0, min_pos0, BadEle0);

		//for (uint i0 = 0; i0 < BadEle0.size(); i0++)
		//{
		//	//cout << BadEle0[i0] << " ";
		//	tmesh[BadEle0[i0]].trun = 1;
		//	//int eid(BadEle[i0]);
		//	//for (int i = 0; i < 8; i++)
		//	//{
		//	//	if (cp[tmesh[eid].cnct[i]].type != 1)
		//	//	{
		//	//		int tmp = SmoothingPoint(tmesh[eid].cnct[i], stepSize);
		//	//		if (tmp == 1) flag = 1;
		//	//	}
		//	//}
		//}
		//break;

		for (uint i = 0; i < cp.size(); i++)
		{
			if (cp[i].type != 1)//interior points
			{
				int tmp = SmoothingPoint(i, stepSize);
				if (tmp == 1) flag = 1;
			}
			else if (cp[i].sharp == 0)
			{
				int tmp = SmoothingPointBoundary(i, stepSize);
				if (tmp == 1) flag = 1;
			}
			else if (cp[i].sharp == 1)
			{
				int tmp = SmoothingPointBoundarySharp(i, stepSize);
				if (tmp == 1) flag = 1;
			}
		}
		double minJacob_glb;
		int min_pos;
		vector<int> BadEle;
		GlobalMinJacob(minJacob_glb, min_pos, BadEle);

		for (uint i = 0; i < tmesh.size(); i++) tmesh[i].trun = 0;
		for (uint i = 0; i < BadEle.size(); i++) tmesh[BadEle[i]].trun = 1;

		//if (flag == 0 || minJacob_glb0 > minJacob_glb)
		//{
		//	cout << "After " << it << "steps, no interior point moved!\n";
		//	break;
		//}
		
	}
	cout << "Done smoothing!\n";
	//OutputCM("../io/hex_input/smooth/fertility2");
	//OutputCM("../io/hex_input/smooth/cube_coarse");
	//OutputCM("../io/hex_input/smooth/rockerarm2");
	//OutputCM("../io/hex_input/smooth/navair_coarse");
	//OutputCM("../io/hex_input/smooth/honda1");
	//OutputCM("../io/hex_input/smooth/honda2");
	//OutputCM("../io/hex_input/smooth/honda1_dense");
	//OutputCM("../io/hex_input/smooth/honda1m");
	//OutputCM("../io/hex_input/smooth/honda2_2");
	//OutputCM("../io/hex_input/smooth/heli_dense_loc1");
	//OutputCM("../io/NAVAIR_GEM/output/smooth1/navair3_1");
}

int TruncatedTspline_3D::LaplaceSmoothingPoint(int pid, double stepSize)
{
	double ptmp[3] = { 0.,0.,0., };
	for (uint i = 0; i < cp[pid].edge.size(); i++)
	{
		int edid(cp[pid].edge[i]);
		int pnb(tmedge[edid].pt[0]);
		if (pnb == pid) pnb = tmedge[edid].pt[1];
		ptmp[0] += cp[pnb].coor[0];
		ptmp[1] += cp[pnb].coor[1];
		ptmp[2] += cp[pnb].coor[2];
	}
	cp[pid].coor[0] = ptmp[0] / cp[pid].edge.size();
	cp[pid].coor[1] = ptmp[1] / cp[pid].edge.size();
	cp[pid].coor[2] = ptmp[2] / cp[pid].edge.size();
	
	return 1;
}

int TruncatedTspline_3D::SmoothingPoint(int pid, double stepSize)
{
	const double eps(1.e-6);
	double vol_all(0.), center[3] = { 0.,0.,0. }, avg[3] = { 0.,0.,0. }, dir[3];
	double pold[3] = { cp[pid].coor[0],cp[pid].coor[1],cp[pid].coor[2] };

	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		double e_vol, e_center[3];
		GetHexVolAndCenter(cp[pid].hex[i], e_vol, e_center);
		vol_all += e_vol;
		center[0] += e_center[0] * e_vol;
		center[1] += e_center[1] * e_vol;
		center[2] += e_center[2] * e_vol;
		avg[0] += e_center[0];
		avg[1] += e_center[1];
		avg[2] += e_center[2];
	}
	avg[0] /= double(cp[pid].hex.size());
	avg[1] /= double(cp[pid].hex.size());
	avg[2] /= double(cp[pid].hex.size());

	if (vol_all < eps)
	{
		dir[0] = avg[0] - cp[pid].coor[0];
		dir[1] = avg[1] - cp[pid].coor[1];
		dir[2] = avg[2] - cp[pid].coor[2];
	}
	else
	{
		center[0] /= vol_all;
		center[1] /= vol_all;
		center[2] /= vol_all;
		dir[0] = center[0] - cp[pid].coor[0];
		dir[1] = center[1] - cp[pid].coor[1];
		dir[2] = center[2] - cp[pid].coor[2];
	}

	//before smoothing
	double minJacob_0(1.e5), minJacob_1(1.e5), tmpJacob, GaussPos[3];
	int nBad0(0), nBad1(0);
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_0) minJacob_0 = tmpJacob;
		if (tmpJacob < 0.) nBad0++;
	}
	//double edlen = AverageEdgeLength(pid);
	//double stepSize_scale(stepSize*edlen);
	double stepSize_scale(stepSize);
	//after smoothing
	cp[pid].coor[0] = cp[pid].coor[0] + stepSize_scale*dir[0];
	cp[pid].coor[1] = cp[pid].coor[1] + stepSize_scale*dir[1];
	cp[pid].coor[2] = cp[pid].coor[2] + stepSize_scale*dir[2];
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_1) minJacob_1 = tmpJacob;
		if (tmpJacob < 0.) nBad1++;
	}
	if ((minJacob_0 < 0. && minJacob_1 < minJacob_0) || (nBad1 > nBad0))
	{
		cp[pid].coor[0] = pold[0];
		cp[pid].coor[1] = pold[1];
		cp[pid].coor[2] = pold[2];
		return 0;
	}
	return 1;
}

int TruncatedTspline_3D::SmoothingPointBoundary(int pid, double stepSize)
{
	const double eps(1.e-6);
	double area_all(0.), center[3] = { 0.,0.,0. }, nm[3] = { 0., 0., 0. };
	int nbf(0);
	for (uint i = 0; i < cp[pid].face.size(); i++)
	{
		if (tmface[cp[pid].face[i]].type == 1)
		{
			double e_area, e_center[3], e_nm[3];
			int* it = find(tmface[cp[pid].face[i]].cnct, tmface[cp[pid].face[i]].cnct + 4, pid);
			int loc(it - tmface[cp[pid].face[i]].cnct);
			GetQuadInfo(cp[pid].face[i], loc, e_area, e_center, e_nm);
			area_all += e_area;
			center[0] += e_center[0] * e_area;
			center[1] += e_center[1] * e_area;
			center[2] += e_center[2] * e_area;
			nm[0] += e_nm[0] * e_area;
			nm[1] += e_nm[1] * e_area;
			nm[2] += e_nm[2] * e_area;
			//nm[0] += e_nm[0];
			//nm[1] += e_nm[1];
			//nm[2] += e_nm[2];
			nbf++;
		}
	}
	if (area_all < eps)
	{
		cerr << "Element with almost zero area!\n";
		return 0;
	}
	center[0] /= area_all;	center[1] /= area_all;	center[2] /= area_all;
	nm[0] /= area_all;	nm[1] /= area_all;	nm[2] /= area_all;
	//nm[0] /= double(nbf);	nm[1] /= double(nbf);	nm[2] /= double(nbf);
	double dst = sqrt(nm[0] * nm[0] + nm[1] * nm[1] + nm[2] * nm[2]);
	nm[0] /= dst; nm[1] /= dst; nm[2] /= dst;
	double dir[3] = { center[0] - cp[pid].coor[0],center[1] - cp[pid].coor[1], center[2] - cp[pid].coor[2] };
	dst = dir[0] * nm[0] + dir[1] * nm[1] + dir[2] * nm[2];
	dir[0] = dir[0] - dst*nm[0];
	dir[1] = dir[1] - dst*nm[1];
	dir[2] = dir[2] - dst*nm[2];

	//dst = dir[0] * nm[0] + dir[1] * nm[1] + dir[2] * nm[2];
	//cout << "inner product: " << dst << "\n";
	//getchar();

	double pold[3] = { cp[pid].coor[0],cp[pid].coor[1],cp[pid].coor[2] };

	//before smoothing
	double minJacob_0(1.e5), minJacob_1(1.e5), tmpJacob, GaussPos[3];
	int nBad0(0), nBad1(0);
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_0) minJacob_0 = tmpJacob;
		if (tmpJacob < 0.) nBad0++;
	}
	//double edlen = AverageEdgeLength(pid);
	//double stepSize_scale(stepSize*edlen);
	double stepSize_scale(stepSize);
	//after smoothing
	cp[pid].coor[0] = cp[pid].coor[0] + stepSize_scale*dir[0];
	cp[pid].coor[1] = cp[pid].coor[1] + stepSize_scale*dir[1];
	cp[pid].coor[2] = cp[pid].coor[2] + stepSize_scale*dir[2];
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_1) minJacob_1 = tmpJacob;
		if (tmpJacob < 0.) nBad1++;
	}
	if ((minJacob_0 < 0. && minJacob_1 < minJacob_0) || nBad1 > nBad0)
	{
		cp[pid].coor[0] = pold[0];
		cp[pid].coor[1] = pold[1];
		cp[pid].coor[2] = pold[2];
		return 0;
	}
	return 1;
}

/// Implement geometric flow smoothing -- Angran

double TruncatedTspline_3D::InnerProduct(vector<double> a, vector<double>b)
{
	return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

void TruncatedTspline_3D::GetQuadInfo_Angran(int fcid, int ploc, double& area, double center[3], double nm[3], double alpha, double beta, double gama, double da[3])
{
	//face is counter-clock-wise oriented
	area = 0.;
	center[0] = 0.; center[1] = 0.; center[2] = 0.;
	nm[0] = 0.; nm[1] = 0.; nm[2] = 0.;
	for (int i = 0; i < 4; i++)
	{
		center[0] += cp[tmface[fcid].cnct[i]].coor[0];
		center[1] += cp[tmface[fcid].cnct[i]].coor[1];
		center[2] += cp[tmface[fcid].cnct[i]].coor[2];
	}
	center[0] /= 4.; center[1] /= 4.; center[2] /= 4.;

	int tp[2][3] = { { tmface[fcid].cnct[ploc],tmface[fcid].cnct[(ploc + 1) % 4],tmface[fcid].cnct[(ploc + 3) % 4] },
	{ tmface[fcid].cnct[(ploc + 2) % 4],tmface[fcid].cnct[(ploc + 3) % 4],tmface[fcid].cnct[(ploc + 1) % 4] } };
	double v0[2][3] = { {cp[tp[0][1]].coor[0] - cp[tp[0][0]].coor[0],cp[tp[0][1]].coor[1] - cp[tp[0][0]].coor[1],cp[tp[0][1]].coor[2] - cp[tp[0][0]].coor[2] },
	{ cp[tp[0][2]].coor[0] - cp[tp[0][0]].coor[0],cp[tp[0][2]].coor[1] - cp[tp[0][0]].coor[1],cp[tp[0][2]].coor[2] - cp[tp[0][0]].coor[2] } };
	double v1[2][3] = { { cp[tp[1][1]].coor[0] - cp[tp[1][0]].coor[0],cp[tp[1][1]].coor[1] - cp[tp[1][0]].coor[1],cp[tp[1][1]].coor[2] - cp[tp[1][0]].coor[2] },
	{ cp[tp[1][2]].coor[0] - cp[tp[1][0]].coor[0],cp[tp[1][2]].coor[1] - cp[tp[1][0]].coor[1],cp[tp[1][2]].coor[2] - cp[tp[1][0]].coor[2] } };
	double vc0[3] = { v0[0][1] * v0[1][2] - v0[0][2] * v0[1][1],v0[0][2] * v0[1][0] - v0[0][0] * v0[1][2],v0[0][0] * v0[1][1] - v0[0][1] * v0[1][0] };
	double vc1[3] = { v1[0][1] * v1[1][2] - v1[0][2] * v1[1][1],v1[0][2] * v1[1][0] - v1[0][0] * v1[1][2],v1[0][0] * v1[1][1] - v1[0][1] * v1[1][0] };
	double dst0 = sqrt(vc0[0] * vc0[0] + vc0[1] * vc0[1] + vc0[2] * vc0[2]);
	double dst1 = sqrt(vc1[0] * vc1[0] + vc1[1] * vc1[1] + vc1[2] * vc1[2]);

	//area = (dst0 + dst1) / 2.;
	nm[0] = vc0[0] / dst0; nm[1] = vc0[1] / dst0; nm[2] = vc0[2] / dst0;


	double Area = 0.0;
	double dA[3] = { 0.0 ,0.0, 0.0 };
	double alpha21(0.0), alpha43(0.0), alpha31(0.0), alpha42(0.0);
	double tmpArea;
	vector<double> tmpSuv1 = { 0.0,0.0,0.0 };
	vector<double> tmpSuv2 = { 0.0,0.0,0.0 };

	double u, v;
	vector<double> Su, Sv;
	vector<double> Gpt, wght;
	vector<vector<double>> pt;
	pt.resize(4);
	Su.resize(3); Sv.resize(3);
	for (int i = 0; i < 4; i++)
	{
		pt[i].resize(3, 0.0);
		for (int j = 0; j < 3; j++)
		{
			pt[i][j] = cp[tmface[fcid].cnct[i]].coor[j];
		}
	}

	GetGaussPoint(2, Gpt, wght);

	// Compute Area
	for (int i = 0; i < Gpt.size(); i++)
	{
		for (int j = 0; j < Gpt.size(); j++)
		{
			u = Gpt[i];
			v = Gpt[j];
			for (int k = 0; k < 3; k++)
			{
				Su[k] = (1 - v) * (pt[(ploc + 1) % 4][k] - pt[ploc][k]) + v * (pt[(ploc + 3) % 4][k] - pt[(ploc + 2) % 4][k]);
				Sv[k] = (1 - u) * (pt[(ploc + 2) % 4][k] - pt[ploc][k]) + u * (pt[(ploc + 3) % 4][k] - pt[(ploc + 1) % 4][k]);
				tmpSuv1[k] = (v - 1)*Sv[k] - (u - 1)*Su[k];
				tmpSuv2[k] = -(v - 1)*Sv[k] + (u - 1)*Su[k];

			}
			tmpArea = sqrt(InnerProduct(Su, Su)*InnerProduct(Sv, Sv) - InnerProduct(Su, Sv)*InnerProduct(Su, Sv));
			alpha21 += 0.25 * wght[i] * wght[j] * (1 - v)*InnerProduct(Sv, tmpSuv1) / tmpArea;
			alpha43 += 0.25 * wght[i] * wght[j] * v*InnerProduct(Sv, tmpSuv1) / tmpArea;
			alpha31 += 0.25 * wght[i] * wght[j] * (1 - u)*InnerProduct(Su, tmpSuv2) / tmpArea;
			alpha42 += 0.25 * wght[i] * wght[j] * u*InnerProduct(Su, tmpSuv2) / tmpArea;
			Area += 0.25 * wght[i] * wght[j] * tmpArea;
		}
	}
	area = Area;
	alpha = -alpha21 - alpha42;
	gama = -alpha31 - alpha43;
	beta = -alpha43 - alpha42;

	for (int i = 0; i < 3; i++)
	{
		dA[i] = alpha * (pt[(ploc + 1) % 4][i] - pt[ploc][i]) + gama * (pt[(ploc + 2) % 4][i] - pt[ploc][i]) + beta * (pt[(ploc + 3) % 4][i] - pt[ploc][i]);
	}
	da = dA;

}

void TruncatedTspline_3D::ComputeMeanCurvature(int pid, double H[3])
{
	
	const double eps(1.e-6);
	double area_all(0.), center[3] = { 0.,0.,0. }, nm[3] = { 0., 0., 0. };
	int nbf(0);

	for (uint i = 0; i < 3; i++)
		H[i] = 0.0;

	for (uint i = 0; i < cp[pid].face.size(); i++)
	{
		if (tmface[cp[pid].face[i]].type == 1)
		{
			double e_area, e_center[3], e_nm[3];
			double alpha, beta, gama, dA[3];
			int* it = find(tmface[cp[pid].face[i]].cnct, tmface[cp[pid].face[i]].cnct + 4, pid);
			int loc(it - tmface[cp[pid].face[i]].cnct);

			GetQuadInfo_Angran(cp[pid].face[i], loc, e_area, e_center, e_nm, alpha, beta, gama, dA);
			area_all += e_area;

			for (uint j = 0; j < 3; j++)
				H[j] += dA[j];			
		}
	}

	for (uint j = 0; j < 3; j++)
		H[j] /= area_all;
}

void TruncatedTspline_3D::ComputeCurvatureSharp(int pid, double k[3])
{
	int ned = 0;
	double len_all = 0.0;
	double t[3] = { 0.0,0.0,0.0 };

	if (cp[pid].sharp == 1)
	{
		for (uint i = 0; i < cp[pid].edge.size(); i++)
		{
			if (tmedge[cp[pid].edge[i]].sharp == 1)
			{
				int edid(cp[pid].edge[i]);
				int edpt[2] = { tmedge[edid].pt[0],tmedge[edid].pt[1] };
				if (edpt[1] == pid)
				{
					edpt[0] = tmedge[edid].pt[1];
					edpt[1] = tmedge[edid].pt[0];
				}
				if (ned == 1)
				{
					int itmp(edpt[0]);
					edpt[0] = edpt[1];
					edpt[1] = itmp;
				}
				double vec[3] = { cp[edpt[1]].coor[0] - cp[edpt[0]].coor[0],cp[edpt[1]].coor[1] - cp[edpt[0]].coor[1],
					cp[edpt[1]].coor[2] - cp[edpt[0]].coor[2] };
				double edlen = sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);

				t[0] += vec[0] / edlen;
				t[1] += vec[1] / edlen;
				t[2] += vec[2] / edlen;

				len_all += edlen;

				ned++;
			}
		}

		k[0] = t[0] / (len_all / 2.0);
		k[1] = t[1] / (len_all / 2.0);
		k[2] = t[2] / (len_all / 2.0);
	}
	else if(cp[pid].sharp == 2)
	{
		k[0] = 0.0; k[1] = 0.0; k[2] = 0.0;
	}
}

void TruncatedTspline_3D::ComputePointNormal(int pid, double nm[3])
{
	double area_all(0.);

	for (uint i = 0; i < 3; i++)
		nm[i] = 0.0;

	for (uint i = 0; i < cp[pid].face.size(); i++)
	{
		if (tmface[cp[pid].face[i]].type == 1)
		{
			double e_area, e_center[3], e_nm[3];
			double alpha, beta, gama, dA[3];
			int* it = find(tmface[cp[pid].face[i]].cnct, tmface[cp[pid].face[i]].cnct + 4, pid);
			int loc(it - tmface[cp[pid].face[i]].cnct);

			GetQuadInfo_Angran(cp[pid].face[i], loc, e_area, e_center, e_nm, alpha, beta, gama, dA);
			area_all += e_area;

			nm[0] += e_nm[0] * e_area;
			nm[1] += e_nm[1] * e_area;
			nm[2] += e_nm[2] * e_area;
		}
	}
	for (uint j = 0; j < 3; j++)
		nm[j] /= area_all;
}

int TruncatedTspline_3D::SmoothingPoint_Angran(int pid, double stepSize)
{
	const double eps(1.e-6);
	double vol_all(0.), center[3] = { 0.,0.,0. }, avg[3] = { 0.,0.,0. }, dir[3];
	double pold[3] = { cp[pid].coor[0],cp[pid].coor[1],cp[pid].coor[2] };

	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		double e_vol, e_center[3];
		GetHexVolAndCenter(cp[pid].hex[i], e_vol, e_center);
		vol_all += e_vol;
		center[0] += e_center[0] * e_vol;
		center[1] += e_center[1] * e_vol;
		center[2] += e_center[2] * e_vol;
		avg[0] += e_center[0];
		avg[1] += e_center[1];
		avg[2] += e_center[2];
	}
	avg[0] /= double(cp[pid].hex.size());
	avg[1] /= double(cp[pid].hex.size());
	avg[2] /= double(cp[pid].hex.size());

	if (vol_all < eps)
	{
		dir[0] = avg[0] - cp[pid].coor[0];
		dir[1] = avg[1] - cp[pid].coor[1];
		dir[2] = avg[2] - cp[pid].coor[2];
	}
	else
	{
		center[0] /= vol_all;
		center[1] /= vol_all;
		center[2] /= vol_all;
		dir[0] = center[0] - cp[pid].coor[0];
		dir[1] = center[1] - cp[pid].coor[1];
		dir[2] = center[2] - cp[pid].coor[2];
	}

	//before smoothing
	double minJacob_0(1.e5), minJacob_1(1.e5), tmpJacob, GaussPos[3];
	int nBad0(0), nBad1(0);
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_0) minJacob_0 = tmpJacob;
		if (tmpJacob < 0.) nBad0++;
	}
	//double edlen = AverageEdgeLength(pid);
	//double stepSize_scale(stepSize*edlen);
	double stepSize_scale(stepSize);
	//after smoothing
	//cp[pid].coor[0] = cp[pid].coor[0] + stepSize_scale * dir[0];
	//cp[pid].coor[1] = cp[pid].coor[1] + stepSize_scale * dir[1];
	//cp[pid].coor[2] = cp[pid].coor[2] + stepSize_scale * dir[2];

	cp_smooth[pid].coor[0] = cp[pid].coor[0] + stepSize_scale * dir[0];
	cp_smooth[pid].coor[1] = cp[pid].coor[1] + stepSize_scale * dir[1];
	cp_smooth[pid].coor[2] = cp[pid].coor[2] + stepSize_scale * dir[2];

	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp_smooth[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_1) minJacob_1 = tmpJacob;
		if (tmpJacob < 0.) nBad1++;
	}
	if ((minJacob_0 < 0. && minJacob_1 < minJacob_0) || (nBad1 > nBad0))
	{
		cp[pid].coor[0] = pold[0];
		cp[pid].coor[1] = pold[1];
		cp[pid].coor[2] = pold[2];
		return 0;
	}
	return 1;
}

int TruncatedTspline_3D::SmoothingPointBoundary_Angran(int pid, double stepSize)
{
	const double eps(1.e-6);
	double area_all(0.), center[3] = { 0.,0.,0. }, nm[3] = { 0., 0., 0. }, H[3] = { 0., 0., 0. };
	int nbf(0);
	vector<int> pt_neighbor;
	vector<int> face_neighbor;
	
	// Get neighbor information
	for (uint i = 0; i < cp[pid].face.size(); i++)
	{
		if (tmface[cp[pid].face[i]].type == 1)
		{
			face_neighbor.push_back(cp[pid].face[i]);
			int* it = find(tmface[cp[pid].face[i]].cnct, tmface[cp[pid].face[i]].cnct + 4, pid);
			int loc(it - tmface[cp[pid].face[i]].cnct);

			for (uint j = 1; j < 4; j++) {
				//cout << "Neighbour:" << j << " " << tmface[cp[pid].face[i]].cnct[(loc + j) % 4] << endl;
				if (find(pt_neighbor.begin(), pt_neighbor.end(), tmface[cp[pid].face[i]].cnct[(loc + j) % 4]) == pt_neighbor.end())
					pt_neighbor.push_back(tmface[cp[pid].face[i]].cnct[(loc + j) % 4]);
			}
				
		}
	}

	//cout << "Neighbour num:" <<pt_neighbor.size() << endl;
	//for (int i = 0; i < pt_neighbor.size(); i++)
	//	if (i != pt_neighbor.size() - 1)
	//		cout << pt_neighbor[i] << " ";
	//	else
	//		cout << pt_neighbor[i] << "\n";

	// Compute weight wij, normal dir for pid
	vector<double> w;
	w.resize(pt_neighbor.size(), 0.0);
	for (uint i = 0; i < face_neighbor.size(); i++)
	{
		int fcid = face_neighbor[i];
		double e_area, e_center[3], e_nm[3];
		double alpha(0.0), beta(0.0), gama(0.0), dA[3];
		int* it = find(tmface[fcid].cnct, tmface[fcid].cnct + 4, pid);
		int loc(it - tmface[fcid].cnct);

		GetQuadInfo_Angran(fcid, loc, e_area, e_center, e_nm, alpha, beta, gama, dA);
		area_all += e_area;

		vector<int>::iterator it1;
		int index;
		it1 = find(pt_neighbor.begin(), pt_neighbor.end(), tmface[fcid].cnct[(loc + 1) % 4]);
		index = distance(pt_neighbor.begin(), it1);
		w[index] += alpha;

		it1 = find(pt_neighbor.begin(), pt_neighbor.end(), tmface[fcid].cnct[(loc + 2) % 4]);
		index = distance(pt_neighbor.begin(), it1);
		w[index] += gama;

		it1 = find(pt_neighbor.begin(), pt_neighbor.end(), tmface[fcid].cnct[(loc + 3) % 4]);
		index = distance(pt_neighbor.begin(), it1);
		w[index] += beta;

		H[0] += dA[0];
		H[1] += dA[1];
		H[2] += dA[2];
		center[0] += e_center[0] * e_area;
		center[1] += e_center[1] * e_area;
		center[2] += e_center[2] * e_area;
		nm[0] += e_nm[0] * e_area;
		nm[1] += e_nm[1] * e_area;
		nm[2] += e_nm[2] * e_area;
		//nm[0] += e_nm[0];
		//nm[1] += e_nm[1];
		//nm[2] += e_nm[2];
		nbf++;
	}

	for (uint i = 0; i < w.size(); i++)
	{
		w[i] /= area_all;
		center[i] /= area_all;
		nm[i] /= area_all;
		H[i] /= area_all;
	}
		
	//if (pid == 77)
	//{
	//	cout << "w size: " << w.size() << endl;
	//	for (int i = 0; i < w.size(); i++)
	//		if(i!=w.size()-1)
	//			cout << w[i] << " ";
	//		else
	//			cout << w[i] << "\n";
	//}

	//center[0] /= area_all;	center[1] /= area_all;	center[2] /= area_all;
	//nm[0] /= area_all;	nm[1] /= area_all;	nm[2] /= area_all;
	//nm[0] /= double(nbf);	nm[1] /= double(nbf);	nm[2] /= double(nbf);
	double dst = sqrt(nm[0] * nm[0] + nm[1] * nm[1] + nm[2] * nm[2]);
	nm[0] /= dst; nm[1] /= dst; nm[2] /= dst;
	double dir[3] = { center[0] - cp[pid].coor[0],center[1] - cp[pid].coor[1], center[2] - cp[pid].coor[2] };
	dst = dir[0] * nm[0] + dir[1] * nm[1] + dir[2] * nm[2];
	dir[0] = dir[0] - dst * nm[0];
	dir[1] = dir[1] - dst * nm[1];
	dir[2] = dir[2] - dst * nm[2];

	//// Compute dxdt
	//double dxdt[3] = { 0.0, 0.0, 0.0 };

	for (uint i = 0; i < pt_neighbor.size(); i++)
	{
		double nm_tmp[3], H_tmp[3], nm_H;
		ComputeMeanCurvature(pt_neighbor[i], H_tmp);
		ComputePointNormal(pt_neighbor[i], nm_tmp);
		nm_H = nm_tmp[0] * H_tmp[0] + nm_tmp[1] * H_tmp[1] + nm_tmp[2] * H_tmp[2];

		dir[0] -= 2 * w[i] * (nm_H*nm[0] - H[0]);
		dir[1] -= 2 * w[i] * (nm_H*nm[1] - H[1]);
		dir[2] -= 2 * w[i] * (nm_H*nm[2] - H[2]);

	}
	
	//cout << "Direction: "<<dir[0] << " " << dir[1] << " " << dir[2] << endl;

	double pold[3] = { cp[pid].coor[0],cp[pid].coor[1],cp[pid].coor[2] };

	//before smoothing
	/*double minJacob_0(1.e5), minJacob_1(1.e5), tmpJacob, GaussPos[3];
	int nBad0(0), nBad1(0);
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_0) minJacob_0 = tmpJacob;
		if (tmpJacob < 0.) nBad0++;
	}*/
	//double edlen = AverageEdgeLength(pid);
	//double stepSize_scale(stepSize*edlen);

	double stepSize_scale(stepSize);
	//after smoothing
	//cp[pid].coor[0] = cp[pid].coor[0] + stepSize_scale * dir[0];
	//cp[pid].coor[1] = cp[pid].coor[1] + stepSize_scale * dir[1];
	//cp[pid].coor[2] = cp[pid].coor[2] + stepSize_scale * dir[2];

	cp_smooth[pid].coor[0] = cp[pid].coor[0] + stepSize_scale * dir[0];
	cp_smooth[pid].coor[1] = cp[pid].coor[1] + stepSize_scale * dir[1];
	cp_smooth[pid].coor[2] = cp[pid].coor[2] + stepSize_scale * dir[2];

	//cout << "Old Point Coor: " << cp[pid].coor[0] << " " << cp[pid].coor[1] << " " << cp[pid].coor[2] << endl;
	//cout << "New Point Coor: " << cp_smooth[pid].coor[0] << " " << cp_smooth[pid].coor[1] << " " << cp_smooth[pid].coor[2] << endl;
	/*cout << "Hex size: " << cp_smooth[pid].hex.size() << endl;
	for (uint i = 0; i < cp_smooth[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp_smooth[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_1) minJacob_1 = tmpJacob;
		if (tmpJacob < 0.) nBad1++;
		cout << "TmpJacob " << tmpJacob << endl;
	}*/
	//if ((minJacob_0 < 0. && minJacob_1 < minJacob_0) || nBad1 > nBad0)
	//{
	//	cp[pid].coor[0] = pold[0];
	//	cp[pid].coor[1] = pold[1];
	//	cp[pid].coor[2] = pold[2];
	//	return 0;
	//}
	return 1;
}

int TruncatedTspline_3D::SmoothingPointBoundarySharp_Angran(int pid, double stepSize)
{
	const double eps(1.e-6);
	double len_all(0.), center[3] = { 0.,0.,0. }, ldir[3] = { 0., 0., 0. };
	int ned(0);
	double k1[3] = { 0.0,0.0,0.0 }, ki[3] = { 0.0,0.0,0.0 }, kdelta[3] = {0.0,0.0,0.0};
	double nm[3] = { 0.0,0.0,0.0 };
	double dir[3] = { 0.0,0.0,0.0 };
	double s;

	ComputeCurvatureSharp(pid, ki);
	nm[0] = ki[0] / sqrt(ki[0] * ki[0] + ki[1] * ki[1] + ki[2] * ki[2]);
	nm[1] = ki[1] / sqrt(ki[0] * ki[0] + ki[1] * ki[1] + ki[2] * ki[2]);
	nm[2] = ki[2] / sqrt(ki[0] * ki[0] + ki[1] * ki[1] + ki[2] * ki[2]);

	for (uint i = 0; i < cp[pid].edge.size(); i++)
	{
		if (tmedge[cp[pid].edge[i]].sharp == 1)
		{
			int edid(cp[pid].edge[i]);
			int edpt[2] = { tmedge[edid].pt[0],tmedge[edid].pt[1] };
			if (edpt[1] == pid)
			{
				edpt[0] = tmedge[edid].pt[1];
				edpt[1] = tmedge[edid].pt[0];
			}
			if (ned == 1)
			{
				int itmp(edpt[0]);
				edpt[0] = edpt[1];
				edpt[1] = itmp;
			}
			double vec[3] = { cp[edpt[1]].coor[0] - cp[edpt[0]].coor[0],cp[edpt[1]].coor[1] - cp[edpt[0]].coor[1],
				cp[edpt[1]].coor[2] - cp[edpt[0]].coor[2] };
			double edlen = sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);
			ComputeCurvatureSharp(edpt[1], k1);
			kdelta[0] += (k1[0] - ki[0]) / edlen;
			kdelta[1] += (k1[1] - ki[1]) / edlen;
			kdelta[2] += (k1[2] - ki[2]) / edlen;
			len_all += edlen;
			
			ned++;
		}
	}
	if (len_all < eps)
	{
		cerr << "Edge with almost zero length!\n";
		return 0;
	}

	kdelta[0] = kdelta[0]/(len_all/2.0);
	kdelta[1] = kdelta[1]/(len_all/2.0);
	kdelta[2] = kdelta[2]/(len_all/2.0);

	dir[0] = -(kdelta[0] * nm[0] + kdelta[1] * nm[1] + kdelta[2] * nm[2])*nm[0];
	dir[1] = -(kdelta[0] * nm[0] + kdelta[1] * nm[1] + kdelta[2] * nm[2])*nm[1];
	dir[2] = -(kdelta[0] * nm[0] + kdelta[1] * nm[1] + kdelta[2] * nm[2])*nm[2];

	
	cout << "Index: " << pid << " " << dir[0] << " " << dir[1] << " " << dir[2] <<" length: "<< sqrt(dir[0]*dir[0]+ dir[1] * dir[1]+ dir[2] * dir[2])<< endl;

	double pold[3] = { cp[pid].coor[0],cp[pid].coor[1],cp[pid].coor[2] };

	//before smoothing
	double minJacob_0(1.e5), minJacob_1(1.e5), tmpJacob, GaussPos[3];
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_0) minJacob_0 = tmpJacob;
	}
	//double edlen = AverageEdgeLength(pid);
	//double stepSize_scale(stepSize*edlen);
	double stepSize_scale(stepSize);
	//after smoothing
	//cp[pid].coor[0] = cp[pid].coor[0] + stepSize_scale * dir[0];
	//cp[pid].coor[1] = cp[pid].coor[1] + stepSize_scale * dir[1];
	//cp[pid].coor[2] = cp[pid].coor[2] + stepSize_scale * dir[2];
	cp_smooth[pid].coor[0] = cp[pid].coor[0] + stepSize_scale * dir[0];
	cp_smooth[pid].coor[1] = cp[pid].coor[1] + stepSize_scale * dir[1];
	cp_smooth[pid].coor[2] = cp[pid].coor[2] + stepSize_scale * dir[2];
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp_smooth[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_1) minJacob_1 = tmpJacob;
	}
	if (minJacob_1 < minJacob_0)
	{
		cp[pid].coor[0] = pold[0];
		cp[pid].coor[1] = pold[1];
		cp[pid].coor[2] = pold[2];
		return 0;
	}
	return 1;
}

void TruncatedTspline_3D::Smoothing_Angran(int nSize, double stepSize)
{
	cout << "\nSmoothing...\n";
	const double eps(1.e-6);

	for (int it = 0; it < nSize; it++)
	{
		cout << "it: " << it << "\n";
		int flag(0);

		double minJacob_glb0;
		int min_pos0(0);
		vector<int> BadEle0;
		GlobalMinJacob(minJacob_glb0, min_pos0, BadEle0);

		cp_smooth = cp;

		//cout << "Initialize cp_smooth" << endl;
		
		for (uint i = 0; i < cp.size(); i++)
		{
			if (cp[i].type != 1)//interior points
			{
				int tmp = SmoothingPoint_Angran(i, stepSize);
				if (tmp == 1) flag = 1;
			}
		}
		cp = cp_smooth;

		for (uint i = 0; i < cp.size(); i++)
		{
			//cout << i << " "<< cp[i].type << " Sharp: "<< cp[i].sharp<<endl;
			if (cp[i].type == 1 && cp[i].sharp == 0)
			{
				int tmp = SmoothingPointBoundary_Angran(i, stepSize);
				if (tmp == 1) flag = 1;
			}
			else if (cp[i].type == 1 && cp[i].sharp == 1)
			{
				int tmp = SmoothingPointBoundarySharp_Angran(i, stepSize);
				if (tmp == 1) flag = 1;
			}
		}

		cp = cp_smooth;
		double minJacob_glb;
		int min_pos;
		vector<int> BadEle;
		GlobalMinJacob(minJacob_glb, min_pos, BadEle);

		for (uint i = 0; i < tmesh.size(); i++) tmesh[i].trun = 0;
		for (uint i = 0; i < BadEle.size(); i++) tmesh[BadEle[i]].trun = 1;

		//if (flag == 0 || minJacob_glb0 > minJacob_glb)
		//{
		//	cout << "After " << it << "steps, no interior point moved!\n";
		//	break;
		//}

	}
	cout << "Done smoothing!\n";
	//OutputCM("../io/hex_input/smooth/fertility2");
	//OutputCM("../io/hex_input/smooth/cube_coarse");
	//OutputCM("../io/hex_input/smooth/rockerarm2");
	//OutputCM("../io/hex_input/smooth/navair_coarse");
	//OutputCM("../io/hex_input/smooth/honda1");
	//OutputCM("../io/hex_input/smooth/honda2");
	//OutputCM("../io/hex_input/smooth/honda1_dense");
	//OutputCM("../io/hex_input/smooth/honda1m");
	//OutputCM("../io/hex_input/smooth/honda2_2");
	//OutputCM("../io/hex_input/smooth/heli_dense_loc1");
	//OutputCM("../io/NAVAIR_GEM/output/smooth1/navair3_1");
}

///End of Angran's implementation

int TruncatedTspline_3D::SmoothingPointBoundarySharp(int pid, double stepSize)
{
	const double eps(1.e-6);
	double len_all(0.), center[3] = { 0.,0.,0. }, ldir[3] = { 0., 0., 0. };
	int ned(0);
	for (uint i = 0; i < cp[pid].edge.size(); i++)
	{
		if (tmedge[cp[pid].edge[i]].sharp == 1)
		{
			int edid(cp[pid].edge[i]);
			int edpt[2] = { tmedge[edid].pt[0],tmedge[edid].pt[1] };
			if (edpt[1] == pid)
			{
				edpt[0] = tmedge[edid].pt[1];
				edpt[1] = tmedge[edid].pt[0];
			}
			if (ned == 1)
			{
				int itmp(edpt[0]);
				edpt[0] = edpt[1];
				edpt[1] = itmp;
			}
			double vec[3] = { cp[edpt[1]].coor[0] - cp[edpt[0]].coor[0],cp[edpt[1]].coor[1] - cp[edpt[0]].coor[1],
				cp[edpt[1]].coor[2] - cp[edpt[0]].coor[2] };
			double edlen = sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);
			double midpt[3] = { (cp[edpt[1]].coor[0] + cp[edpt[0]].coor[0]) / 2.,(cp[edpt[1]].coor[1] + cp[edpt[0]].coor[1]) / 2.,
				(cp[edpt[1]].coor[2] + cp[edpt[0]].coor[2]) / 2. };
			len_all += edlen;
			center[0] += midpt[0] * edlen;
			center[1] += midpt[1] * edlen;
			center[2] += midpt[2] * edlen;
			ldir[0] += vec[0] * edlen;
			ldir[1] += vec[1] * edlen;
			ldir[2] += vec[2] * edlen;
			ned++;
		}
	}
	if (len_all < eps)
	{
		cerr << "Edge with almost zero length!\n";
		return 0;
	}
	center[0] /= len_all;	center[1] /= len_all;	center[2] /= len_all;
	ldir[0] /= len_all;	ldir[1] /= len_all;	ldir[2] /= len_all;
	//nm[0] /= double(nbf);	nm[1] /= double(nbf);	nm[2] /= double(nbf);
	double dst = sqrt(ldir[0] * ldir[0] + ldir[1] * ldir[1] + ldir[2] * ldir[2]);
	ldir[0] /= dst; ldir[1] /= dst; ldir[2] /= dst;
	double dir[3] = { center[0] - cp[pid].coor[0],center[1] - cp[pid].coor[1], center[2] - cp[pid].coor[2] };
	dst = dir[0] * ldir[0] + dir[1] * ldir[1] + dir[2] * ldir[2];
	dir[0] = dst*ldir[0];
	dir[1] = dst*ldir[1];
	dir[2] = dst*ldir[2];

	//dst = dir[0] * nm[0] + dir[1] * nm[1] + dir[2] * nm[2];
	//cout << "inner product: " << dst << "\n";
	//getchar();

	double pold[3] = { cp[pid].coor[0],cp[pid].coor[1],cp[pid].coor[2] };

	//before smoothing
	double minJacob_0(1.e5), minJacob_1(1.e5), tmpJacob, GaussPos[3];
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_0) minJacob_0 = tmpJacob;
	}
	//double edlen = AverageEdgeLength(pid);
	//double stepSize_scale(stepSize*edlen);
	double stepSize_scale(stepSize);
	//after smoothing
	cp[pid].coor[0] = cp[pid].coor[0] + stepSize_scale*dir[0];
	cp[pid].coor[1] = cp[pid].coor[1] + stepSize_scale*dir[1];
	cp[pid].coor[2] = cp[pid].coor[2] + stepSize_scale*dir[2];
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_1) minJacob_1 = tmpJacob;
	}
	if (minJacob_1 < minJacob_0)
	{
		cp[pid].coor[0] = pold[0];
		cp[pid].coor[1] = pold[1];
		cp[pid].coor[2] = pold[2];
		return 0;
	}
	return 1;
}

void TruncatedTspline_3D::GetHexMinJacob(int eid, double& minJacob_ele, double GaussPos[3])
{
	vector<double> Gpt, wght;
	GetGaussPoint(2, Gpt, wght);
	Gpt[0] = 0.; Gpt[1] = 1.;
	double detJ;
	minJacob_ele = 1.e5;
	GaussPos[0] = 0.; GaussPos[1] = 0.; GaussPos[2] = 0.;
	for (uint i = 0; i < Gpt.size(); i++)
	{
		for (uint j = 0; j < Gpt.size(); j++)
		{
			for (uint k = 0; k < Gpt.size(); k++)
			{
				//JacobEval(eid, Gpt[i], Gpt[j], Gpt[k], detJ);
				JacobEval_Scale(eid, Gpt[i], Gpt[j], Gpt[k], detJ);
				if (detJ < minJacob_ele)
				{
					minJacob_ele = detJ;
					GaussPos[0] = Gpt[i];
					GaussPos[1] = Gpt[j];
					GaussPos[2] = Gpt[k];
				}
			}
		}
	}
}

void TruncatedTspline_3D::GetHexVolAndCenter(int eid, double& vol, double center[3])
{
	vol = 0.;
	center[0] = 0.; center[1] = 0.; center[2] = 0.;
	for (int i = 0; i < 8; i++)
	{
		center[0] += cp[tmesh[eid].cnct[i]].coor[0];
		center[1] += cp[tmesh[eid].cnct[i]].coor[1];
		center[2] += cp[tmesh[eid].cnct[i]].coor[2];
	}
	center[0] /= 8.; center[1] /= 8.; center[2] /= 8.;

	vector<double> Gpt, wght;
	GetGaussPoint(2, Gpt, wght);
	double detJ;
	for (uint i = 0; i < Gpt.size(); i++)
	{
		for (uint j = 0; j < Gpt.size(); j++)
		{
			for (uint k = 0; k < Gpt.size(); k++)
			{
				JacobEval(eid, Gpt[i], Gpt[j], Gpt[k], detJ);
				vol += wght[i] * wght[j] * wght[k] * detJ;
			}
		}
	}
}

void TruncatedTspline_3D::GetQuadInfo(int fcid, int ploc, double& area, double center[3], double nm[3])
{
	//face is counter-clock-wise oriented
	area = 0.;
	center[0] = 0.; center[1] = 0.; center[2] = 0.;
	nm[0] = 0.; nm[1] = 0.; nm[2] = 0.;
	for (int i = 0; i < 4; i++)
	{
		center[0] += cp[tmface[fcid].cnct[i]].coor[0];
		center[1] += cp[tmface[fcid].cnct[i]].coor[1];
		center[2] += cp[tmface[fcid].cnct[i]].coor[2];
	}
	center[0] /= 4.; center[1] /= 4.; center[2] /= 4.;

	int tp[2][3] = { { tmface[fcid].cnct[ploc],tmface[fcid].cnct[(ploc + 1) % 4],tmface[fcid].cnct[(ploc + 3) % 4] },
	{ tmface[fcid].cnct[(ploc + 2) % 4],tmface[fcid].cnct[(ploc + 3) % 4],tmface[fcid].cnct[(ploc + 1) % 4] } };
	double v0[2][3] = { {cp[tp[0][1]].coor[0] - cp[tp[0][0]].coor[0],cp[tp[0][1]].coor[1] - cp[tp[0][0]].coor[1],cp[tp[0][1]].coor[2] - cp[tp[0][0]].coor[2] },
	{ cp[tp[0][2]].coor[0] - cp[tp[0][0]].coor[0],cp[tp[0][2]].coor[1] - cp[tp[0][0]].coor[1],cp[tp[0][2]].coor[2] - cp[tp[0][0]].coor[2] } };
	double v1[2][3] = { { cp[tp[1][1]].coor[0] - cp[tp[1][0]].coor[0],cp[tp[1][1]].coor[1] - cp[tp[1][0]].coor[1],cp[tp[1][1]].coor[2] - cp[tp[1][0]].coor[2] },
	{ cp[tp[1][2]].coor[0] - cp[tp[1][0]].coor[0],cp[tp[1][2]].coor[1] - cp[tp[1][0]].coor[1],cp[tp[1][2]].coor[2] - cp[tp[1][0]].coor[2] } };
	double vc0[3] = { v0[0][1] * v0[1][2] - v0[0][2] * v0[1][1],v0[0][2] * v0[1][0] - v0[0][0] * v0[1][2],v0[0][0] * v0[1][1] - v0[0][1] * v0[1][0] };
	double vc1[3] = { v1[0][1] * v1[1][2] - v1[0][2] * v1[1][1],v1[0][2] * v1[1][0] - v1[0][0] * v1[1][2],v1[0][0] * v1[1][1] - v1[0][1] * v1[1][0] };
	double dst0 = sqrt(vc0[0] * vc0[0] + vc0[1] * vc0[1] + vc0[2] * vc0[2]);
	double dst1 = sqrt(vc1[0] * vc1[0] + vc1[1] * vc1[1] + vc1[2] * vc1[2]);

	area = (dst0 + dst1) / 2.;
	nm[0] = vc0[0] / dst0; nm[1] = vc0[1] / dst0; nm[2] = vc0[2] / dst0;
}

void TruncatedTspline_3D::GetGaussPoint(int ng, vector<double>& Gpt, vector<double>& wght)
{
	//already map [-1,1] to [0,1]
	Gpt.clear();
	wght.clear();
	switch (ng)
	{
	case 2:
	{
		Gpt.resize(ng);
		wght.resize(ng);
		Gpt[0] = 0.2113248654051871;			Gpt[1] = 0.7886751345948129;
		wght[0] = 1.;			wght[1] = 1.;
		break;
	}
	case 3:
	{
		Gpt.resize(ng);
		wght.resize(ng);
		Gpt[0] = 0.1127016653792583;			Gpt[1] = 0.5;			Gpt[2] = 0.8872983346207417;
		wght[0] = 0.5555555555555556;			wght[1] = 0.8888888888888889;			wght[2] = 0.5555555555555556;
		break;
	}
	case 4:
	{
		Gpt.resize(ng);
		wght.resize(ng);
		Gpt[0] = 0.06943184420297371;			Gpt[1] = 0.33000947820757187;			Gpt[2] = 0.6699905217924281;			Gpt[3] = 0.9305681557970262;
		wght[0] = 0.3478548451374539;			wght[1] = 0.6521451548625461;			wght[2] = 0.6521451548625461;			wght[3] = 0.3478548451374539;
		break;
	}
	case 5:
	{
		Gpt.resize(ng);
		wght.resize(ng);
		Gpt[0] = 0.046910077030668;			Gpt[1] = 0.2307653449471585;			Gpt[2] = 0.5;			Gpt[3] = 0.7692346550528415;  Gpt[4] = 0.953089922969332;
		wght[0] = 0.2369268850561891;			wght[1] = 0.4786286704993665;			wght[2] = 0.5688888888888889;			wght[3] = 0.4786286704993665; wght[4] = 0.2369268850561891;
		break;
	}
	default:
	{
		Gpt.resize(2);
		wght.resize(2);
		Gpt[0] = 0.2113248654051871;			Gpt[1] = 0.7886751345948129;
		wght[0] = 1.;			wght[1] = 1.;
		break;
	}
	}
}

void TruncatedTspline_3D::JacobEval(int eid, double u, double v, double w, double& detJ)
{
	double Nu[2] = { 1. - u,u };
	double Nv[2] = { 1. - v,v };
	double Nw[2] = { 1. - w,w };
	double dNdu[2] = { -1.,1. };
	double dNdv[2] = { -1.,1. };
	double dNdw[2] = { -1.,1. };
	double dNdt[8][3];
	int ploc[8] = { 0,1,3,2,4,5,7,6 };
	int loc(0);
	for (int i = 0; i < 2; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			for (int k = 0; k < 2; k++)
			{
				dNdt[ploc[loc]][0] = dNdu[k] * Nv[j] * Nw[i];
				dNdt[ploc[loc]][1] = Nu[k] * dNdv[j] * Nw[i];
				dNdt[ploc[loc]][2] = Nu[k] * Nv[j] * dNdw[i];
				loc++;
			}
		}
	}
	double dxdt[3][3] = { {0.,0.,0.},{ 0.,0.,0. },{ 0.,0.,0. } };
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			for (int k = 0; k < 8; k++)
			{
				dxdt[i][j] += cp[tmesh[eid].cnct[k]].coor[i] * dNdt[k][j];
			}
		}
	}
	detJ = dxdt[0][0] * (dxdt[1][1] * dxdt[2][2] - dxdt[1][2] * dxdt[2][1]) -
		dxdt[0][1] * (dxdt[1][0] * dxdt[2][2] - dxdt[1][2] * dxdt[2][0]) +
		dxdt[0][2] * (dxdt[1][0] * dxdt[2][1] - dxdt[1][1] * dxdt[2][0]);
	detJ *= 0.125;
}

void TruncatedTspline_3D::JacobEval_Scale(int eid, double u, double v, double w, double& detJ)
{
	double Nu[2] = { 1. - u,u };
	double Nv[2] = { 1. - v,v };
	double Nw[2] = { 1. - w,w };
	double dNdu[2] = { -1.,1. };
	double dNdv[2] = { -1.,1. };
	double dNdw[2] = { -1.,1. };
	double dNdt[8][3];
	int ploc[8] = { 0,1,3,2,4,5,7,6 };
	int loc(0);
	for (int i = 0; i < 2; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			for (int k = 0; k < 2; k++)
			{
				dNdt[ploc[loc]][0] = dNdu[k] * Nv[j] * Nw[i];
				dNdt[ploc[loc]][1] = Nu[k] * dNdv[j] * Nw[i];
				dNdt[ploc[loc]][2] = Nu[k] * Nv[j] * dNdw[i];
				loc++;
			}
		}
	}
	double dxdt[3][3] = { { 0.,0.,0. },{ 0.,0.,0. },{ 0.,0.,0. } };
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			for (int k = 0; k < 8; k++)
			{
				dxdt[i][j] += cp[tmesh[eid].cnct[k]].coor[i] * dNdt[k][j];
			}
		}
	}
	detJ = dxdt[0][0] * (dxdt[1][1] * dxdt[2][2] - dxdt[1][2] * dxdt[2][1]) -
		dxdt[0][1] * (dxdt[1][0] * dxdt[2][2] - dxdt[1][2] * dxdt[2][0]) +
		dxdt[0][2] * (dxdt[1][0] * dxdt[2][1] - dxdt[1][1] * dxdt[2][0]);
	double nm[3] = { sqrt(dxdt[0][0] * dxdt[0][0] + dxdt[1][0] * dxdt[1][0] + dxdt[2][0] * dxdt[2][0]),
		sqrt(dxdt[0][1] * dxdt[0][1] + dxdt[1][1] * dxdt[1][1] + dxdt[2][1] * dxdt[2][1]), 
		sqrt(dxdt[0][2] * dxdt[0][2] + dxdt[1][2] * dxdt[1][2] + dxdt[2][2] * dxdt[2][2]) };
	double tmp(nm[0] * nm[1] * nm[2]);
	if (tmp > 1.e-12)
	{
		detJ /= tmp;
	}
	//double eps(1.e-12);
	//if (detJ < eps)
	//{
	//	double sumtmp(0.);
	//	for (int i = 0; i < 3; i++)
	//	{
	//		for (int j = 0; j < 3; j++)
	//		{
	//			sumtmp += dxdt[i][j] * dxdt[i][j];
	//		}
	//	}
	//	detJ = sqrt(sumtmp);
	//}
}

void TruncatedTspline_3D::GlobalMinJacob(double& minJacob_glb, int& min_pos, vector<int>& BadEle)
{
	minJacob_glb = 1.e5;
	min_pos = -1;
	BadEle.clear();
	const double eps(1.e-10);
	//const double eps(1.e-2);
	for (uint eid = 0; eid < tmesh.size(); eid++)
	{
		double minJacob_ele, GaussPos[3];
		GetHexMinJacob(eid, minJacob_ele, GaussPos);
		if (minJacob_ele < eps)
		{
			BadEle.push_back(eid);
		}
		if (minJacob_ele < minJacob_glb)
		{
			minJacob_glb = minJacob_ele;
			min_pos = eid;
		}
	}
	cout << "minJacob eid nBad: " << minJacob_glb << " " << min_pos << " " << BadEle.size() << "\n";
}

double TruncatedTspline_3D::DeterminantOfThreePoint(double *p1, double *p2, double *p3)
{
   double jacobian;
   jacobian = p1[0] * (p2[1] * p3[2] - p2[2] * p3[1]) + p1[1] * (p2[2] * p3[0] - p2[0] * p3[2]) + p1[2] * (p2[0] * p3[1] - p2[1] * p3[0]);
   return jacobian;
}

void TruncatedTspline_3D::SetHexQuality(int hexindex)
{
   int i, j, v[8], v1, v2, v3;
   double point[24], Jmatrix[9], JmatrixInv[9], det, FnormJ, FnormJInv, leng1, leng2, leng3, vec1[3], vec2[3], vec3[3];
   for (i = 0; i < 8; i++)
   {
      v[i] = tmesh[hexindex].cnct[i];
      for (j = 0; j < 3; j++)
      {
         point[3 * i + j] = cp[v[i]].coor[j];
      }
   }

   for (i = 0; i < 4; i++)
   {
      v1 = (i + 1) % 4;
      v2 = (i + 3) % 4;
      v3 = i + 4;
      FnormJ = 0.0;
      FnormJInv = 0.0;
      for (j = 0; j < 3; j++)
      {
         Jmatrix[j] = point[3 * v1 + j] - point[3 * i + j];
         Jmatrix[3 + j] = point[3 * v2 + j] - point[3 * i + j];
         Jmatrix[6 + j] = point[3 * v3 + j] - point[3 * i + j];
         FnormJ = FnormJ + Jmatrix[j] * Jmatrix[j] + Jmatrix[3 + j] * Jmatrix[3 + j] + Jmatrix[6 + j] * Jmatrix[6 + j];
      }
      leng1 = sqrt(Jmatrix[0] * Jmatrix[0] + Jmatrix[1] * Jmatrix[1] + Jmatrix[2] * Jmatrix[2]);
      leng2 = sqrt(Jmatrix[3] * Jmatrix[3] + Jmatrix[4] * Jmatrix[4] + Jmatrix[5] * Jmatrix[5]);
      leng3 = sqrt(Jmatrix[6] * Jmatrix[6] + Jmatrix[7] * Jmatrix[7] + Jmatrix[8] * Jmatrix[8]);
      if (leng1 < 1.0e-8 || leng2 < 1.0e-8 || leng3 < 1.0e-8)
      {
         printf("%d %d %d %d %d %d %d %d %d %d %d %d %d\n", hexindex, i, v1, v2, v3, v[i], cp[v[i]].type, v[v1], cp[v[v1]].type, v[v2], cp[v[v2]].type, v[v3], cp[v[v3]].type);
         for (j = 0; j < 24; j++)
            printf("%f ", point[j]);
         printf("\n");
      }
      for (j = 0; j < 3; j++)
      {
         vec1[j] = Jmatrix[j] / leng1;
         vec2[j] = Jmatrix[j + 3] / leng2;
         vec3[j] = Jmatrix[j + 6] / leng3;
      }
      det = DeterminantOfThreePoint(vec1, vec2, vec3);
      tmesh[hexindex].Jacobian[i] = det;
      det = DeterminantOfThreePoint(Jmatrix, Jmatrix + 3, Jmatrix + 6);

      JmatrixInv[0] = Jmatrix[4] * Jmatrix[8] - Jmatrix[5] * Jmatrix[7];
      JmatrixInv[1] = Jmatrix[2] * Jmatrix[7] - Jmatrix[1] * Jmatrix[8];
      JmatrixInv[2] = Jmatrix[1] * Jmatrix[5] - Jmatrix[2] * Jmatrix[4];
      JmatrixInv[3] = Jmatrix[5] * Jmatrix[6] - Jmatrix[3] * Jmatrix[8];
      JmatrixInv[4] = Jmatrix[0] * Jmatrix[8] - Jmatrix[2] * Jmatrix[6];
      JmatrixInv[5] = Jmatrix[2] * Jmatrix[3] - Jmatrix[0] * Jmatrix[5];
      JmatrixInv[6] = Jmatrix[3] * Jmatrix[7] - Jmatrix[4] * Jmatrix[6];
      JmatrixInv[7] = Jmatrix[1] * Jmatrix[6] - Jmatrix[0] * Jmatrix[7];
      JmatrixInv[8] = Jmatrix[0] * Jmatrix[4] - Jmatrix[1] * Jmatrix[3];
      FnormJInv = JmatrixInv[0] * JmatrixInv[0] + JmatrixInv[1] * JmatrixInv[1] + JmatrixInv[2] * JmatrixInv[2] + JmatrixInv[3] * JmatrixInv[3] + JmatrixInv[4] * JmatrixInv[4] + JmatrixInv[5] * JmatrixInv[5] + JmatrixInv[6] * JmatrixInv[6] + JmatrixInv[7] * JmatrixInv[7] + JmatrixInv[8] * JmatrixInv[8];
      tmesh[hexindex].ConditionNumb[i] = 1.0 / 3.0 * sqrt(FnormJ * FnormJInv) / fabs(det);
   }
   for (i = 0; i < 4; i++)
   {
      v1 = 4 + (i + 3) % 4;
      v2 = 4 + (i + 1) % 4;
      v3 = i;
      FnormJ = 0.0;
      FnormJInv = 0.0;
      for (j = 0; j < 3; j++)
      {
         Jmatrix[j] = point[3 * v1 + j] - point[3 * (i + 4) + j];
         Jmatrix[3 + j] = point[3 * v2 + j] - point[3 * (i + 4) + j];
         Jmatrix[6 + j] = point[3 * v3 + j] - point[3 * (i + 4) + j];
         FnormJ = FnormJ + Jmatrix[j] * Jmatrix[j] + Jmatrix[3 + j] * Jmatrix[3 + j] + Jmatrix[6 + j] * Jmatrix[6 + j];
      }
      leng1 = sqrt(Jmatrix[0] * Jmatrix[0] + Jmatrix[1] * Jmatrix[1] + Jmatrix[2] * Jmatrix[2]);
      leng2 = sqrt(Jmatrix[3] * Jmatrix[3] + Jmatrix[4] * Jmatrix[4] + Jmatrix[5] * Jmatrix[5]);
      leng3 = sqrt(Jmatrix[6] * Jmatrix[6] + Jmatrix[7] * Jmatrix[7] + Jmatrix[8] * Jmatrix[8]);
      if (leng1 < 1.0e-8 || leng2 < 1.0e-8 || leng3 < 1.0e-8)
      {
         printf("%d %d %d %d %d %d %d %d %d %d %d %d %d\n", hexindex, i + 4, v1, v2, v3, v[i + 4], cp[v[i + 4]].type, v[v1], cp[v[v1]].type, v[v2], cp[v[v2]].type, v[v3], cp[v[v3]].type);
         for (j = 0; j < 24; j++)
            printf("%f ", point[j]);
         printf("\n");
      }
      for (j = 0; j < 3; j++)
      {
         vec1[j] = Jmatrix[j] / leng1;
         vec2[j] = Jmatrix[j + 3] / leng2;
         vec3[j] = Jmatrix[j + 6] / leng3;
      }
      det = DeterminantOfThreePoint(vec1, vec2, vec3);
      tmesh[hexindex].Jacobian[i + 4] = det;
      det = DeterminantOfThreePoint(Jmatrix, Jmatrix + 3, Jmatrix + 6);

      JmatrixInv[0] = Jmatrix[4] * Jmatrix[8] - Jmatrix[5] * Jmatrix[7];
      JmatrixInv[1] = Jmatrix[2] * Jmatrix[7] - Jmatrix[1] * Jmatrix[8];
      JmatrixInv[2] = Jmatrix[1] * Jmatrix[5] - Jmatrix[2] * Jmatrix[4];
      JmatrixInv[3] = Jmatrix[5] * Jmatrix[6] - Jmatrix[3] * Jmatrix[8];
      JmatrixInv[4] = Jmatrix[0] * Jmatrix[8] - Jmatrix[2] * Jmatrix[6];
      JmatrixInv[5] = Jmatrix[2] * Jmatrix[3] - Jmatrix[0] * Jmatrix[5];
      JmatrixInv[6] = Jmatrix[3] * Jmatrix[7] - Jmatrix[4] * Jmatrix[6];
      JmatrixInv[7] = Jmatrix[1] * Jmatrix[6] - Jmatrix[0] * Jmatrix[7];
      JmatrixInv[8] = Jmatrix[0] * Jmatrix[4] - Jmatrix[1] * Jmatrix[3];
      FnormJInv = JmatrixInv[0] * JmatrixInv[0] + JmatrixInv[1] * JmatrixInv[1] + JmatrixInv[2] * JmatrixInv[2] + JmatrixInv[3] * JmatrixInv[3] + JmatrixInv[4] * JmatrixInv[4] + JmatrixInv[5] * JmatrixInv[5] + JmatrixInv[6] * JmatrixInv[6] + JmatrixInv[7] * JmatrixInv[7] + JmatrixInv[8] * JmatrixInv[8];
      tmesh[hexindex].ConditionNumb[i + 4] = 1.0 / 3.0 * sqrt(FnormJ * FnormJInv) / fabs(det);
   }
}

void TruncatedTspline_3D::HexMeshQuality()
{
   int i, j, negativenumb;
   double minjacobian, maxjacobian, mincondition, maxcondition;
   int numb2[21];
   for (i = 0; i < 21; i++)
      numb2[i] = 0;

   minjacobian = 10000000.0;
   maxjacobian = -10000000.0;
   mincondition = 1000000000.0;
   maxcondition = -1000000000.0;
   negativenumb = 0;

   int ii, jj, kk, k, l;

   for (i = 0; i < tmesh.size(); i++)
   {
      SetHexQuality(i);
      for (j = 0; j < 8; j++)
      {
         if (tmesh[i].Jacobian[j] < minjacobian)
            minjacobian = tmesh[i].Jacobian[j];
         if (tmesh[i].Jacobian[j] > maxjacobian)
            maxjacobian = tmesh[i].Jacobian[j];
         if (tmesh[i].ConditionNumb[j] < mincondition)
            mincondition = tmesh[i].ConditionNumb[j];
         if (tmesh[i].ConditionNumb[j] > maxcondition)
            maxcondition = tmesh[i].ConditionNumb[j];
         if (tmesh[i].Jacobian[j] < 0)
            negativenumb++;
         if (tmesh[i].Jacobian[j] < 0.1)
            printf("%f %d %d %d\n", tmesh[i].Jacobian[j], tmesh[i].cnct[j], cp[tmesh[i].cnct[j]].type, cp[tmesh[i].cnct[j]].hex.size());
         numb2[int((tmesh[i].Jacobian[j] + 1) / 0.1)]++;
      }
   }
   printf("Negative jacobian number is: %d\n", negativenumb);
   printf("The maximum jacobian is: %f\n", maxjacobian);
   printf("The minimum jacobian is: %f\n", minjacobian);
   printf("The maximum condition number is: %f\n", maxcondition);
   printf("The minimum condition number is: %f\n", mincondition);

   for (i = 0; i < 20; i++)
   {
      printf("jacobian %f ~ %f numb is %d\n", 0.1 * i - 1.0, 0.1 * (i + 1) - 1.0, numb2[i]);
   }
   printf("jacobian = 1.0 numb is %d\n", numb2[20]);
}

double TruncatedTspline_3D::Distance(double *A, double *B)
{
   return sqrt((A[0] - B[0]) * (A[0] - B[0]) + (A[1] - B[1]) * (A[1] - B[1]) + (A[2] - B[2]) * (A[2] - B[2]));
}

double TruncatedTspline_3D::DotProduct(double p1[], double p2[])
{
   double result;

   result = p1[0] * p2[0] + p1[1] * p2[1] + p1[2] * p2[2];

   return (result);
}

void TruncatedTspline_3D::CrossProduct1(double *U, double *V, double *W)
{
   double Normal;
   /* cross product               */
   W[0] = U[1] * V[2] - U[2] * V[1];
   W[1] = U[2] * V[0] - U[0] * V[2];
   W[2] = U[0] * V[1] - U[1] * V[0];
   /* normal                      */
   Normal = W[0] * W[0] + W[1] * W[1] + W[2] * W[2];
   Normal = sqrt(Normal);
   if (Normal >= 1.0e-8)
   {
      W[0] = W[0] / Normal;
      W[1] = W[1] / Normal;
      W[2] = W[2] / Normal;
   }
}

/* ---------------------------------------------------------------------------*/
void TruncatedTspline_3D::CrossProduct2(double *u, double *v, double *w)
{
   w[0] = u[1] * v[2] - u[2] * v[1];
   w[1] = u[2] * v[0] - v[2] * u[0];
   w[2] = u[0] * v[1] - v[0] * u[1];
}

void TruncatedTspline_3D::Jordan(double *A, double *f, double *b, int ir, int k, int m, int n)
{
	int i, j;
	double temp;

	temp = A[ir * n + k];
	b[ir] = b[ir] / temp;
	for (i = 0; i < n; i++)
	{
		A[ir * n + i] = A[ir * n + i] / temp;
	}

	temp = f[k];
	for (i = 0; i < n; i++)
	{
		f[i] = f[i] - A[ir * n + i] * temp;
	}

	for (i = 0; i < ir; i++)
	{
		temp = A[i * n + k];
		b[i] = b[i] - b[ir] * temp;
		for (j = 0; j < n; j++)
		{
			A[i * n + j] = A[i * n + j] - A[ir * n + j] * temp;
		}
	}

	for (i = ir + 1; i < m; i++)
	{
		temp = A[i * n + k];
		b[i] = b[i] - b[ir] * temp;
		for (j = 0; j < n; j++)
		{
			A[i * n + j] = A[i * n + j] - A[ir * n + j] * temp;
		}
	}
}

void TruncatedTspline_3D::SimplexMethod(double *A, double *b, double *c, int m, int n, double *sol)
{
   int i, j, k, l, ir;
   double minf;

   int *Index;
   Index = (int *)malloc(m * sizeof(int));
   for (i = 0; i < m; i++)
      Index[i] = n - m + i;
   double *x, *f;
   x = (double *)malloc(n * sizeof(double));
   f = (double *)malloc(n * sizeof(double));
   for (i = 0; i < n; i++)
   {
      x[i] = 0.0;
      f[i] = 0.0;
   }
   for (i = 0; i < m; i++)
   {
      x[n - m + i] = b[i];
   }

   for (i = 0; i < n - m; i++)
   {
      f[i] = c[i];
      for (j = 0; j < m; j++)
      {
         f[i] = f[i] - c[n - m + j] * A[j * n + i];
      }
   }

   l = 0;
   for (i = 0; i < n; i++)
   {
      if (f[i] < 0.0)
      {
         l = 1;
         break;
      }
   }

   while (l)
   {
      minf = f[0];
      k = 0;
      for (i = 1; i < n; i++)
      {
         if (f[i] < minf)
         {
            minf = f[i];
            k = i;
         }
      }

      for (i = 0; i < m; i++)
      {
         if (A[i * n + k] > 0)
            break;
      }
      if (i == m)
      {
         printf("Wrong!\n");
         for (j = 0; j < m; j++)
            b[i] = 0.0;
         break;
      }
      minf = b[i] / A[i * n + k];
      ir = i;
      for (i = 0; i < m; i++)
      {
         if ((A[i * n + k] > 0) && b[i] / A[i * n + k] < minf)
         {
            ir = i;
            minf = b[i] / A[i * n + k];
         }
      }
      Index[ir] = k;
      Jordan(A, f, b, ir, k, m, n);

      l = 0;
      for (i = 0; i < n; i++)
      {
         if (f[i] < 0.0)
         {
            l = 1;
            break;
         }
      }
   }

   for (i = 0; i < n; i++)
      sol[i] = 0.0;
   for (i = 0; i < m; i++)
   {
      sol[Index[i]] = b[i];
   }
}

void TruncatedTspline_3D::MaxMinHexJacobian(int vert, double *displacement)
{
	int i, j, k, ii, v[8], v1, v2, v3;
   double p1p2[3], p1p3[3], p1p4[3], vec1[3];
   vec1[0] = 1.0;
   vec1[1] = 1.0;
   vec1[2] = 1.0;
   int size_m, size_n, *signb, negnumb;
   double *A, *b, *c, *sol;
   size_m = cp[vert].hex.size();
   b = (double *)malloc(size_m * sizeof(double));
   signb = (int *)malloc(size_m * sizeof(int));
   size_n = size_m + 8;
   for (i = 0; i < size_m; i++)
   {
      ii = cp[vert].hex[i];
      k = -1;
      for (j = 0; j < 8; j++)
      {
         v[j] = tmesh[ii].cnct[j];
         if (v[j] == vert)
            k = j;
      }
      if (k >= 0 && k < 4)
      {
         v1 = v[(k + 1) % 4];
         v2 = v[(k + 3) % 4];
         v3 = v[k + 4];
      }
      else if (k >= 4 && k < 8)
      {
         v1 = v[4 + (k - 4 + 3) % 4];
         v2 = v[4 + (k - 4 + 1) % 4];
         v3 = v[k - 4];
      }
      else
      {
         printf("Error!\n");
      }

      p1p2[0] = cp[v1].coor[0] - cp[vert].coor[0];
      p1p2[1] = cp[v2].coor[0] - cp[vert].coor[0];
      p1p2[2] = cp[v3].coor[0] - cp[vert].coor[0];
      p1p3[0] = cp[v1].coor[1] - cp[vert].coor[1];
      p1p3[1] = cp[v2].coor[1] - cp[vert].coor[1];
      p1p3[2] = cp[v3].coor[1] - cp[vert].coor[1];
      p1p4[0] = cp[v1].coor[2] - cp[vert].coor[2];
      p1p4[1] = cp[v2].coor[2] - cp[vert].coor[2];
      p1p4[2] = cp[v3].coor[2] - cp[vert].coor[2];
      b[i] = DeterminantOfThreePoint(p1p2, p1p3, p1p4);

      if (b[i] >= 0)
      {
         signb[i] = 1;
      }
      else
      {
         signb[i] = -1;
         b[i] = -1.0 * b[i];
         size_n++;
      }
   }

   A = (double *)malloc(size_m * size_n * sizeof(double));
   c = (double *)malloc(size_n * sizeof(double));
   sol = (double *)malloc(size_n * sizeof(double));
   for (i = 0; i < size_m * size_n; i++)
      A[i] = 0.0;
   for (i = 0; i < size_n; i++)
   {
      c[i] = 0.0;
      sol[i] = 0.0;
   }
   c[6] = -1.0;
   c[7] = 1.0;

   negnumb = 0;
   for (i = 0; i < size_m; i++)
   {
      ii = cp[vert].hex[i];
      k = -1;
      for (j = 0; j < 8; j++)
      {
         v[j] = tmesh[ii].cnct[j];
         if (v[j] == vert)
            k = j;
      }
      if (k >= 0 && k < 4)
      {
         v1 = v[(k + 1) % 4];
         v2 = v[(k + 3) % 4];
         v3 = v[k + 4];
      }
      else if (k >= 4 && k < 8)
      {
         v1 = v[4 + (k - 4 + 3) % 4];
         v2 = v[4 + (k - 4 + 1) % 4];
         v3 = v[k - 4];
      }
      else
      {
         printf("Error!\n");
      }

      p1p2[0] = cp[v1].coor[0] - cp[vert].coor[0];
      p1p2[1] = cp[v2].coor[0] - cp[vert].coor[0];
      p1p2[2] = cp[v3].coor[0] - cp[vert].coor[0];
      p1p3[0] = cp[v1].coor[1] - cp[vert].coor[1];
      p1p3[1] = cp[v2].coor[1] - cp[vert].coor[1];
      p1p3[2] = cp[v3].coor[1] - cp[vert].coor[1];
      p1p4[0] = cp[v1].coor[2] - cp[vert].coor[2];
      p1p4[1] = cp[v2].coor[2] - cp[vert].coor[2];
      p1p4[2] = cp[v3].coor[2] - cp[vert].coor[2];

      A[i * size_n] = DeterminantOfThreePoint(vec1, p1p3, p1p4);
      A[i * size_n + 1] = -A[i * size_n];
      A[i * size_n + 2] = DeterminantOfThreePoint(p1p2, vec1, p1p4);
      A[i * size_n + 3] = -A[i * size_n + 2];
      A[i * size_n + 4] = DeterminantOfThreePoint(p1p2, p1p3, vec1);
      A[i * size_n + 5] = -A[i * size_n + 4];
      A[i * size_n + 6] = 1.0;
      A[i * size_n + 7] = -1.0;

      if (signb[i] == -1)
      {
         for (j = 0; j < 8; j++)
         {
            A[i * size_n + j] = -1.0 * A[i * size_n + j];
         }
         A[i * size_n + 8 + negnumb] = -1.0;
         c[size_n - size_m + i] = 1.0e12;
         negnumb++;
      }

      A[i * size_n + size_n - size_m + i] = 1.0;
   }

   SimplexMethod(A, b, c, size_m, size_n, sol);
   ;
   double value = 0.0;
   for (i = 0; i < size_n; i++)
   {
      value = value - c[i] * sol[i];
   }
   for (k = 0; k < 3; k++)
   {
      displacement[k] = 0.0;
   }
   if (fabs(value) > 1.0e-8)
   {
      for (k = 0; k < 3; k++)
      {
         displacement[k] = sol[2 * k] - sol[2 * k + 1];
      }
   }
}

void TruncatedTspline_3D::ImproveHexJacobian(int Iter, double LBound)
{
	int i, j, k, ii, jj, kk, w, l;
	double displacement[3];

	for (i = 0; i < tmesh.size(); i++)
	{
		SetHexQuality(i);
	}

	for (int it = 0; it < Iter; it++)
	{
		for (i = 0; i < cp.size(); i++)
		{
			if (cp[i].type != 1)
			{
				ii = cp[i].hex.size();
				l = -1;
				for (j = 0; j < ii; j++)
				{
					jj = cp[i].hex[j];
					w = -1;
					for (k = 0; k < 8; k++)
					{
						kk = tmesh[jj].cnct[k];
						if (kk == i)
						{
							w = k;
							break;
						}
					}
					if (w == -1)
						printf("Error!\n");
					if (tmesh[jj].Jacobian[w] < LBound)
					{
						l = 1;
						break;
					}
				}
				if (l != -1)
				{
					MaxMinHexJacobian(i, displacement);
					for (k = 0; k < 3; k++)
					{
						cp[i].coor[k] += displacement[k];
						cp[i].coortmp[k] = cp[i].coor[k];
					}

					for (j = 0; j < cp[i].hex.size(); j++)
					{
						jj = cp[i].hex[j];
						SetHexQuality(jj);
					}
				}
			}
		}
	}
}

double TruncatedTspline_3D::VolumeOfHexahedron(double *point)
{
   int i, j, k, d;
   double Su[3], Sv[3], Sw[3], u, v, w;
   double result = 0.0;

   for (i = 0; i < 2; i++)
   {
      u = Knot[i];
      for (j = 0; j < 2; j++)
      {
         v = Knot[j];
         for (k = 0; k < 2; k++)
         {
            w = Knot[k];
            for (d = 0; d < 3; d++)
            {
               Su[d] = (1 - v) * (1 - w) * (point[3 + d] - point[d]) + v * (1 - w) * (point[6 + d] - point[9 + d]) + (1 - v) * w * (point[15 + d] - point[12 + d]) + v * w * (point[18 + d] - point[21 + d]);
               Sv[d] = (1 - u) * (1 - w) * (point[9 + d] - point[d]) + u * (1 - w) * (point[6 + d] - point[3 + d]) + (1 - u) * w * (point[21 + d] - point[12 + d]) + u * w * (point[18 + d] - point[15 + d]);
               Sw[d] = (1 - u) * (1 - v) * (point[12 + d] - point[d]) + u * (1 - v) * (point[15 + d] - point[3 + d]) + (1 - u) * v * (point[21 + d] - point[9 + d]) + u * v * (point[18 + d] - point[6 + d]);
            }
            result = result + DeterminantOfThreePoint(Su, Sv, Sw);
         }
      }
   }

   result = result / 8.0;
   return (result);
}

double TruncatedTspline_3D::VolumeOfHex(int hexindex)
{
   int i, ii, d;
   double vol, p[24];

   for (i = 0; i < 8; i++)
   {
      ii = tmesh[hexindex].cnct[i];
      for (d = 0; d < 3; d++)
      {
         p[3 * i + d] = cp[ii].coortmp[d];
      }
   }

   vol = VolumeOfHexahedron(p);
   return vol;
}

double TruncatedTspline_3D::Compute_hexh()
{
   int i, ii;
   double totalvol, vol, h;

   totalvol = 0.0;
   for (i = 0; i < tmesh.size(); i++)
   {
      vol = VolumeOfHex(i);
      totalvol = totalvol + vol;
   }
   h = pow(totalvol / tmesh.size(), 1.0 / 3.0);
   return h;
}

double TruncatedTspline_3D::Compute_Ji(int vert)
{
   int i, j, ii, jj, v[8], w, d;
   int i1, i2, i3;
   double p1p2[3], p1p3[3], p1p4[3], jac, totaljac;

   totaljac = 0.0;
   ii = cp[vert].hex.size();
   for (i = 0; i < ii; i++)
   {
      jj = cp[vert].hex[i];
      w = -1;
      for (j = 0; j < 8; j++)
      {
         v[j] = tmesh[jj].cnct[j];
         if (v[j] == vert)
            w = j;
      }
      if (w < 0 || w >= 8)
         printf("Error!\n");
      else if (w < 4)
      {
         i1 = v[(w + 1) % 4];
         i2 = v[(w + 3) % 4];
         i3 = v[w + 4];
      }
      else
      {
         w = w - 4;
         i1 = v[(w + 3) % 4 + 4];
         i2 = v[(w + 1) % 4 + 4];
         i3 = v[w];
      }

      for (d = 0; d < 3; d++)
      {
         p1p2[d] = cp[i1].coortmp[d] - cp[vert].coortmp[d];
         p1p3[d] = cp[i2].coortmp[d] - cp[vert].coortmp[d];
         p1p4[d] = cp[i3].coortmp[d] - cp[vert].coortmp[d];
      }
      double leng1, leng2, leng3;
      leng1 = sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1] + p1p2[2] * p1p2[2]);
      leng2 = sqrt(p1p3[0] * p1p3[0] + p1p3[1] * p1p3[1] + p1p3[2] * p1p3[2]);
      leng3 = sqrt(p1p4[0] * p1p4[0] + p1p4[1] * p1p4[1] + p1p4[2] * p1p4[2]);
      for (d = 0; d < 3; d++)
      {
         p1p2[d] /= leng1;
         p1p3[d] /= leng2;
         p1p4[d] /= leng3;
      }
      jac = DeterminantOfThreePoint(p1p2, p1p3, p1p4);
      totaljac += jac;
   }
   totaljac = totaljac / ii;
   if (totaljac < 0.0)
      printf("Error! Average Jacobian < 0\n");
   return totaljac;
}

double TruncatedTspline_3D::VolumeEnergy(double h, double lambda)
{
   int i, j, k, ii, jj, kk, d, w, v[8], v1[7];
   double energy = 0.0;
   double dis, Ji, jac, p1p2[3], p1p3[3], p1p4[3];

   for (ii = 0; ii < cp.size(); ii++)
   {
      if (cp[ii].type!=1)
      {
         Ji = Compute_Ji(ii);
         jj = cp[ii].hex.size();
         for (j = 0; j < jj; j++)
         {
            kk = cp[ii].hex[j];
            w = -1;
            for (k = 0; k < 8; k++)
            {
               v[k] = tmesh[kk].cnct[k];
               if (v[k] == ii)
                  w = k;
            }
            if (w < 0 || w >= 8)
               printf("Error!\n");
            else if (w < 4)
            {
               v1[0] = v[(w + 1) % 4];
               v1[1] = v[(w + 3) % 4];
               v1[2] = v[w + 4];
               v1[3] = v[(w + 2) % 4];
               v1[4] = v[(w + 1) % 4 + 4];
               v1[5] = v[(w + 3) % 4 + 4];
               v1[6] = v[(w + 2) % 4 + 4];
            }
            else
            {
               w = w - 4;
               v1[0] = v[(w + 3) % 4 + 4];
               v1[1] = v[(w + 1) % 4 + 4];
               v1[2] = v[w];
               v1[3] = v[(w + 2) % 4 + 4];
               v1[4] = v[(w + 1) % 4];
               v1[5] = v[(w + 3) % 4];
               v1[6] = v[(w + 2) % 4];
               w = w + 4;
            }
            for (k = 0; k < 3; k++)
            {
               dis = Distance(cp[ii].coortmp, cp[v1[k]].coortmp);
               energy += (dis - h) * (dis - h);
            }
            for (k = 3; k < 6; k++)
            {
               dis = Distance(cp[ii].coortmp, cp[v1[k]].coortmp);
               energy += (dis - sqrt(2.0) * h) * (dis - sqrt(2.0) * h);
            }
            dis = Distance(cp[ii].coortmp, cp[v1[6]].coortmp);
            energy += (dis - sqrt(3.0) * h) * (dis - sqrt(3.0) * h);

            for (d = 0; d < 3; d++)
            {
               p1p2[d] = cp[v1[0]].coortmp[d] - cp[ii].coortmp[d];
               p1p3[d] = cp[v1[1]].coortmp[d] - cp[ii].coortmp[d];
               p1p4[d] = cp[v1[2]].coortmp[d] - cp[ii].coortmp[d];
            }
            double leng1, leng2, leng3;
            leng1 = sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1] + p1p2[2] * p1p2[2]);
            leng2 = sqrt(p1p3[0] * p1p3[0] + p1p3[1] * p1p3[1] + p1p3[2] * p1p3[2]);
            leng3 = sqrt(p1p4[0] * p1p4[0] + p1p4[1] * p1p4[1] + p1p4[2] * p1p4[2]);
            for (d = 0; d < 3; d++)
            {
               p1p2[d] /= leng1;
               p1p3[d] /= leng2;
               p1p4[d] /= leng3;
            }
            jac = DeterminantOfThreePoint(p1p2, p1p3, p1p4);
            energy += lambda * (jac - Ji) * (jac - Ji);
         }
      }
   }
   return energy;
}

void TruncatedTspline_3D::Volume_regularization(double Lambda, double Tau, int Iter)
{
   int gobj, s, i, j, k, ii, jj, kk, l, ll, d, w;
   double Energy_Old, Energy, Energy_diff, Energy_initial, edgelength;
   int v[8], v1[8];
   double tau2, point[3], dis, p1p2[3], p1p3[3], p1p4[3], jac, Ji, temp1[3], temp2[3], temp3[3];

   edgelength = Compute_hexh();
   Energy_Old = VolumeEnergy(edgelength, Lambda);
   Energy_initial = Energy_Old;
   printf("edgelength = %f, Energy = %f\n", edgelength, Energy_Old);

   for (s = 0; s < Iter; s++)
   {
	   for (ii = 0; ii < cp.size(); ii++)
	   {
		   if (cp[ii].type != 1)
		   {
			   jj = cp[ii].hex.size();

			   point[0] = 0.0;
			   point[1] = 0.0;
			   point[2] = 0.0;
			   Ji = Compute_Ji(ii);
			   for (j = 0; j < jj; j++)
			   {
				   kk = cp[ii].hex[j];
				   w = -1;
				   for (k = 0; k < 8; k++)
				   {
					   v[k] = tmesh[kk].cnct[k];
					   if (v[k] == ii)
						   w = k;
				   }
				   if (w < 0 || w >= 8)
					   printf("Error!\n");
				   else if (w < 4)
				   {
					   v1[0] = v[(w + 1) % 4];
					   v1[1] = v[(w + 3) % 4];
					   v1[2] = v[w + 4];
					   v1[3] = v[(w + 2) % 4];
					   v1[4] = v[(w + 1) % 4 + 4];
					   v1[5] = v[(w + 3) % 4 + 4];
					   v1[6] = v[(w + 2) % 4 + 4];
				   }
				   else
				   {
					   w = w - 4;
					   v1[0] = v[(w + 3) % 4 + 4];
					   v1[1] = v[(w + 1) % 4 + 4];
					   v1[2] = v[w];
					   v1[3] = v[(w + 2) % 4 + 4];
					   v1[4] = v[(w + 1) % 4];
					   v1[5] = v[(w + 3) % 4];
					   v1[6] = v[(w + 2) % 4];
					   w = w + 4;
				   }
				   for (k = 0; k < 3; k++)
				   {
					   dis = Distance(cp[ii].coortmp, cp[v1[k]].coortmp);
					   if (dis > 1.0e-8)
					   {
						   for (d = 0; d < 3; d++)
						   {
							   point[d] = point[d] + (dis - edgelength) / dis * cp[v1[k]].coortmp[d];
							   point[d] = point[d] - (dis - edgelength) / dis * cp[ii].coortmp[d];
						   }
					   }
				   }
				   for (k = 3; k < 6; k++)
				   {
					   dis = Distance(cp[ii].coortmp, cp[v1[k]].coortmp);
					   if (dis > 1.0e-8)
					   {
						   for (d = 0; d < 3; d++)
						   {
							   point[d] = point[d] + 0.5 * (dis - sqrt(2.0) * edgelength) / dis * cp[v1[k]].coortmp[d];
							   point[d] = point[d] - 0.5 * (dis - sqrt(2.0) * edgelength) / dis * cp[ii].coortmp[d];
						   }
					   }
				   }
				   dis = Distance(cp[ii].coortmp, cp[v1[6]].coortmp);
				   if (dis > 1.0e-8)
				   {
					   for (d = 0; d < 3; d++)
					   {
						   point[d] = point[d] + 0.5 * (dis - sqrt(3.0) * edgelength) / dis * cp[v1[6]].coortmp[d];
						   point[d] = point[d] - 0.5 * (dis - sqrt(3.0) * edgelength) / dis * cp[ii].coortmp[d];
					   }
				   }

				   for (d = 0; d < 3; d++)
				   {
					   p1p2[d] = cp[v1[0]].coortmp[d] - cp[ii].coortmp[d];
					   p1p3[d] = cp[v1[1]].coortmp[d] - cp[ii].coortmp[d];
					   p1p4[d] = cp[v1[2]].coortmp[d] - cp[ii].coortmp[d];
				   }
				   double leng1, leng2, leng3;
				   leng1 = sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1] + p1p2[2] * p1p2[2]);
				   leng2 = sqrt(p1p3[0] * p1p3[0] + p1p3[1] * p1p3[1] + p1p3[2] * p1p3[2]);
				   leng3 = sqrt(p1p4[0] * p1p4[0] + p1p4[1] * p1p4[1] + p1p4[2] * p1p4[2]);
				   for (d = 0; d < 3; d++)
				   {
					   p1p2[d] /= leng1;
					   p1p3[d] /= leng2;
					   p1p4[d] /= leng3;
				   }
				   jac = DeterminantOfThreePoint(p1p2, p1p3, p1p4);
				   CrossProduct2(p1p3, p1p4, temp1);
				   CrossProduct2(p1p2, p1p4, temp2);
				   CrossProduct2(p1p2, p1p3, temp3);
				   for (d = 0; d < 3; d++)
				   {
					   point[d] = point[d] + Lambda * (jac - Ji) * (temp1[d] - temp2[d] + temp3[d]);
				   }
			   }

			   double norm = DotProduct(point, point);
			   norm = sqrt(norm);
			   point[0] = point[0] / norm;
			   point[1] = point[1] / norm;
			   point[2] = point[2] / norm;
			   tau2 = Tau + Tau;
			   cp[ii].coor[0] = cp[ii].coortmp[0] + tau2 * point[0];
			   cp[ii].coor[1] = cp[ii].coortmp[1] + tau2 * point[1];
			   cp[ii].coor[2] = cp[ii].coortmp[2] + tau2 * point[2];
		   }
	   }
	   for (ii = 0; ii < cp.size(); ii++)
	   {
		   cp[ii].coortmp[0] = cp[ii].coor[0];
		   cp[ii].coortmp[1] = cp[ii].coor[1];
		   cp[ii].coortmp[2] = cp[ii].coor[2];
	   }

	   Energy = VolumeEnergy(edgelength, Lambda);
	   Energy_diff = fabs(Energy_Old - Energy);
	   if (Energy_Old < Energy)
		   printf("Warning! Energy is increasing!");
	   double Epsilon = 0.00001;
	   if (Energy_diff < Epsilon)
		   break;
	   Energy_Old = Energy;
   }

   printf("Iter = %d, Energy_old = %f, Energy = %f, Energy_diff = %f\n", s, Energy_initial, Energy, Energy_initial - Energy);
}

void TruncatedTspline_3D::Optimizing(int nSize, double stepSize)
{
	//OutputCM("../io/hex_input/smooth/fertility_b");
	cout << "\nOptimizing...\n";
	for (int it = 0; it < nSize; it++)
	{
		cout << it << "\n";
		int flag(0);
		double minJacob_glb;
		int min_pos;
		vector<int> BadEle;
		GlobalMinJacob(minJacob_glb, min_pos, BadEle);

		if (BadEle.size() > 0)
		{
			for (uint i = 0; i < BadEle.size(); i++)
			{
				//int tmp = OptimizingElement(BadEle[i], stepSize);
				int tmp = OptimizeElement(BadEle[i], stepSize);
				if (tmp == 1) flag = 1;
			}
		}
		else
		{
			//int tmp = OptimizingElement(min_pos, stepSize);
			int tmp = OptimizeElement(min_pos, stepSize);
			if (tmp == 1) flag = 1;
		}

		double minJacob_glb1;
		int min_pos1;
		vector<int> BadEle1;
		GlobalMinJacob(minJacob_glb1, min_pos1, BadEle1);

		//if (flag == 0 /*|| fabs(minJacob_glb - minJacob_glb1) < 1.e-6*/)
		//{
		//	cout << "After " << it << "steps, no interior point moved!\n";
		//	break;
		//}

		for (uint i = 0; i < tmesh.size(); i++) tmesh[i].trun = 0;
		for (uint i = 0; i < BadEle.size(); i++) tmesh[BadEle[i]].trun = 1;

	}
	cout << "Done optimizing!\n";
	//OutputCM("../io/hex_input/optimize/fertility1");
	//OutputCM("../io/hex_input/optimize/rockerarm1");
	//OutputCM("../io/hex_input/optimize/honda2_2");
	//OutputCM("../io/NAVAIR_GEM/output/optimize/navair3_0");
}

int TruncatedTspline_3D::OptimizeElement(int eid, double stepSize)
{
	double uc[8][3] = { { 0.,0.,0. },{ 1.,0.,0. },{ 1.,1.,0. },{ 0.,1.,0. },
	{ 0.,0.,1. },{ 1.,0.,1. },{ 1.,1.,1. },{ 0.,1.,1. } };
	int cned[8][4] = { { 0,1,3,4 },{ 1,2,0,5 },{ 2,3,1,6 },{ 3,0,2,7 },{ 4,7,5,0 },{ 5,4,6,1 },{ 6,5,7,2 },{ 7,6,4,3 } };

	//find which corner has min Jacob
	double jacob0(1.e5), detJtmp;
	int ploc(-1);
	for (int i = 0; i < 8; i++)
	{
		JacobEval_Scale(eid, uc[i][0], uc[i][1], uc[i][2], detJtmp);
		if (detJtmp < jacob0 && cp[tmesh[eid].cnct[i]].type != 1)
		{
			jacob0 = detJtmp;
			ploc = i;
		}
	}

	int flag(0);
	for (int ic = 0; ic < 4; ic++)
	{
		int i(cned[ploc][ic]);
		if (cp[tmesh[eid].cnct[i]].type != 1)
		{
			//before
			//JacobEval_Scale(eid, uc[i][0], uc[i][1], uc[i][2], jacob0);
			jacob0 = 1.e5;
			int nBad0(0), nBad1(0);
			for (uint j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
			{
				int hxid(cp[tmesh[eid].cnct[i]].hex[j]);
				double utmp[3];
				GetHexMinJacob(hxid, detJtmp, utmp);
				if (detJtmp < jacob0)
				{
					jacob0 = detJtmp;
				}
				if (detJtmp < 0.) nBad0++;
			}
			//cout << "jacob before: " << jacob0 << "\n";
			double pold[3] = { cp[tmesh[eid].cnct[i]].coor[0],cp[tmesh[eid].cnct[i]].coor[1],cp[tmesh[eid].cnct[i]].coor[2] };
			double detJ_grad[3];
			JacobEval_Grad(eid, i, detJ_grad);
			//cout << detJ_grad[0] << " " << detJ_grad[1] << " " << detJ_grad[2] << "\n";
			//getchar();
			double edlen = AverageEdgeLength(tmesh[eid].cnct[i]);
			double stepScale(edlen*stepSize);
			cp[tmesh[eid].cnct[i]].coor[0] += stepScale*detJ_grad[0];
			cp[tmesh[eid].cnct[i]].coor[1] += stepScale*detJ_grad[1];
			cp[tmesh[eid].cnct[i]].coor[2] += stepScale*detJ_grad[2];
			//after
			double jacob1(1.e5);
			for (uint j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
			{
				int hxid(cp[tmesh[eid].cnct[i]].hex[j]);
				double utmp[3];
				GetHexMinJacob(hxid, detJtmp, utmp);
				if (detJtmp < jacob1)
				{
					jacob1 = detJtmp;
				}
				if (detJtmp < 0.)
				{
					nBad1++;
				}
			}
			//JacobEval_Scale(eid, uc[i][0], uc[i][1], uc[i][2], jacob1);
			//cout << "jacob after: " << jacob1 << "\n";
			//getchar();
			//if (tmesh[eid].cnct[i] == 1765)
			//{
			//	cout << "jacob before: " << jacob0 << "\n";
			//	cout << "jacob after: " << jacob1 << "\n";
			//	getchar();
			//}
			if ((jacob0 < 0. && jacob1 < jacob0) || nBad1 > nBad0)
			{
				cp[tmesh[eid].cnct[i]].coor[0] = pold[0];
				cp[tmesh[eid].cnct[i]].coor[1] = pold[1];
				cp[tmesh[eid].cnct[i]].coor[2] = pold[2];
			}
			else
			{
				flag = 1;
			}
		}
	}
	
	return flag;
}

int TruncatedTspline_3D::OptimizingElement(int eid, double stepSize)
{
	//double stepscale[8];
	//for (int i = 0; i < 8; i++)
	//{
	//	double edlen = 0.;
	//	for (uint j = 0; j < cp[tmesh[eid].cnct[i]].edge.size(); j++)
	//	{
	//		int edid(cp[tmesh[eid].cnct[i]].edge[j]);
	//		int edpid[2] = { tmedge[edid].pt[0],tmedge[edid].pt[1] };
	//		edlen += sqrt((cp[edpid[1]].coor[0] - cp[edpid[0]].coor[0])*(cp[edpid[1]].coor[0] - cp[edpid[0]].coor[0]) +
	//			(cp[edpid[1]].coor[1] - cp[edpid[0]].coor[1])*(cp[edpid[1]].coor[1] - cp[edpid[0]].coor[1]) + 
	//			(cp[edpid[1]].coor[2] - cp[edpid[0]].coor[2])*(cp[edpid[1]].coor[2] - cp[edpid[0]].coor[2]));
	//	}
	//	edlen /= double(cp[tmesh[eid].cnct[i]].edge.size());
	//	stepscale[i] = stepSize*edlen;
	//}

	double uc[8][3] = { { 0.,0.,0. },{ 1.,0.,0. },{ 1.,1.,0. },{ 0.,1.,0. },
	{ 0.,0.,1. },{ 1.,0.,1. },{ 1.,1.,1. },{ 0.,1.,1. } };
	int flag(0);
	for (int i = 0; i < 8; i++)
	{
		if (cp[tmesh[eid].cnct[i]].type != 1)
		{
			//before
			double jacob0(1.e5), jacob1(1.e5), detJtmp;
			//JacobEval_Scale(eid, uc[i][0], uc[i][1], uc[i][2], jacob0);
			for (uint j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
			{
				int hxid(cp[tmesh[eid].cnct[i]].hex[j]);
				double utmp[3];
				GetHexMinJacob(hxid, detJtmp, utmp);
				if (detJtmp < jacob0)
				{
					jacob0 = detJtmp;
				}
			}
			//cout << "jacob before: " << jacob0 << "\n";
			double pold[3] = { cp[tmesh[eid].cnct[i]].coor[0],cp[tmesh[eid].cnct[i]].coor[1],cp[tmesh[eid].cnct[i]].coor[2] };
			//after
			double detJ_grad[3];
			JacobEval_Grad(eid, i, detJ_grad);
			//cout << detJ_grad[0] << " " << detJ_grad[1] << " " << detJ_grad[2] << "\n";
			//getchar();
			double edlen = AverageEdgeLength(tmesh[eid].cnct[i]);
			double stepScale(edlen*stepSize);
			cp[tmesh[eid].cnct[i]].coor[0] += stepScale*detJ_grad[0];
			cp[tmesh[eid].cnct[i]].coor[1] += stepScale*detJ_grad[1];
			cp[tmesh[eid].cnct[i]].coor[2] += stepScale*detJ_grad[2];
			for (uint j = 0; j < cp[tmesh[eid].cnct[i]].hex.size(); j++)
			{
				int hxid(cp[tmesh[eid].cnct[i]].hex[j]);
				double utmp[3];
				GetHexMinJacob(hxid, detJtmp, utmp);
				if (detJtmp < jacob1)
				{
					jacob1 = detJtmp;
				}
			}
			//JacobEval_Scale(eid, uc[i][0], uc[i][1], uc[i][2], jacob1);
			//cout << "jacob after: " << jacob1 << "\n";
			//getchar();
			if (jacob1 < jacob0)
			{
				cp[tmesh[eid].cnct[i]].coor[0] = pold[0];
				cp[tmesh[eid].cnct[i]].coor[1] = pold[1];
				cp[tmesh[eid].cnct[i]].coor[2] = pold[2];
			}
			else
			{
				flag = 1;
			}
		}
	}
	return flag;
}

double TruncatedTspline_3D::AverageEdgeLength(int pid)
{
	//int edpt[12][2] = { {0,1},{1,2},{2,3},{3,0},{0,4},{1,5},{2,6},{3,7},{4,5},{5,6},{6,7},{7,4} };
	double len(0.), dtmp;
	for (int i = 0; i < cp[pid].edge.size(); i++)
	{
		int edid(cp[pid].edge[i]);
		int edpt[2] = { tmedge[edid].pt[0],tmedge[edid].pt[1] };
		double vtmp[3] = { cp[edpt[1]].coor[0] - cp[edpt[0]].coor[0],cp[edpt[1]].coor[1] - cp[edpt[0]].coor[1],
			cp[edpt[1]].coor[2] - cp[edpt[0]].coor[2] };
		dtmp = sqrt(vtmp[0] * vtmp[0] + vtmp[1] * vtmp[1] + vtmp[2] * vtmp[2]);
		len += dtmp;
	}
	len /= double(cp[pid].edge.size());
	return len;
}

void TruncatedTspline_3D::JacobEval_Grad(int eid, int ploc, double grad[3])
{
	int cned[8][3] = { {1,3,4},{2,0,5},{3,1,6},{0,2,7},{7,5,0},{4,6,1},{5,7,2},{6,4,3} };
	//double a[3][3] = { {cp[tmesh[eid].cnct[cned[ploc][0]]].coor[0]-cp[tmesh[eid].cnct[ploc]].coor[0],
	//	cp[tmesh[eid].cnct[cned[ploc][1]]].coor[0] - cp[tmesh[eid].cnct[ploc]].coor[0], 
	//	cp[tmesh[eid].cnct[cned[ploc][2]]].coor[0] - cp[tmesh[eid].cnct[ploc]].coor[0]},
	//	{ cp[tmesh[eid].cnct[cned[ploc][0]]].coor[1] - cp[tmesh[eid].cnct[ploc]].coor[1],
	//	cp[tmesh[eid].cnct[cned[ploc][1]]].coor[1] - cp[tmesh[eid].cnct[ploc]].coor[1],
	//	cp[tmesh[eid].cnct[cned[ploc][2]]].coor[1] - cp[tmesh[eid].cnct[ploc]].coor[1] },
	//	{ cp[tmesh[eid].cnct[cned[ploc][0]]].coor[2] - cp[tmesh[eid].cnct[ploc]].coor[2],
	//	cp[tmesh[eid].cnct[cned[ploc][1]]].coor[2] - cp[tmesh[eid].cnct[ploc]].coor[2],
	//	cp[tmesh[eid].cnct[cned[ploc][2]]].coor[2] - cp[tmesh[eid].cnct[ploc]].coor[2] } };
	////double a[3][3] = { {-3,2,-5},{-1,0,-2},{3,-4,1} };
	//double adj[3][3] = { {a[1][1] * a[2][2] - a[1][2] * a[2][1],a[0][2] * a[2][1] - a[0][1] * a[2][2], a[0][1] * a[1][2] - a[0][2] * a[1][1] },
	//{ a[1][2] * a[2][0] - a[1][0] * a[2][2],a[0][0] * a[2][2] - a[0][2] * a[2][0], a[0][2] * a[1][0] - a[0][0] * a[1][2] }, 
	//{ a[1][0] * a[2][1] - a[1][1] * a[2][0],a[0][1] * a[2][0] - a[0][0] * a[2][1], a[0][0] * a[1][1] - a[0][1] * a[1][0] } };
	//Jacob_Grad[0] = -adj[0][0] - adj[1][0] - adj[2][0];
	//Jacob_Grad[1] = -adj[0][1] - adj[1][1] - adj[2][1];
	//Jacob_Grad[2] = -adj[0][2] - adj[1][2] - adj[2][2];
	//double nm = sqrt(Jacob_Grad[0] * Jacob_Grad[0] + Jacob_Grad[1] * Jacob_Grad[1] + Jacob_Grad[2] * Jacob_Grad[2]);
	//if (nm > 1.e-8)
	//{
	//	Jacob_Grad[0] /= nm;
	//	Jacob_Grad[1] /= nm;
	//	Jacob_Grad[2] /= nm;
	//}
	////cout << adj[0][0] << "\t" << adj[0][1] << "\t" << adj[0][2] << "\n";
	////cout << adj[1][0] << "\t" << adj[1][1] << "\t" << adj[1][2] << "\n";
	////cout << adj[2][0] << "\t" << adj[2][1] << "\t" << adj[2][2] << "\n";
	////getchar();

	double XSIETA[8][3] = { {0.,0.,0.},{ 1.,0.,0. },{ 1.,1.,0. },{ 0.,1.,0. },
	{ 0.,0.,1. },{ 1.,0.,1. },{ 1.,1.,1. },{ 0.,1.,1. }, };
	double jacob;
	double g00, g01, g02, g10, g11, g12, g20, g21, g22;
	double phi[8], phi_xsi[8], phi_eta[8], phi_zeta[8];

	double xsi, eta, zeta;
	//bool flag = true;
	//for (i = 0; i < 8; i++)
	//{
		xsi = XSIETA[ploc][0];
		eta = XSIETA[ploc][1];
		zeta = XSIETA[ploc][2];

		phi[0] = (1 - xsi)*(1 - eta)*(1 - zeta); 	phi[1] = xsi*(1 - eta)*(1 - zeta);
		phi[2] = xsi*eta*(1 - zeta);			phi[3] = (1 - xsi)*eta*(1 - zeta);
		phi[4] = (1 - xsi)*(1 - eta)*zeta;		phi[5] = xsi*(1 - eta)*zeta;
		phi[6] = xsi*eta*zeta;				phi[7] = (1 - xsi)*eta*zeta;

		phi_xsi[0] = -(1 - eta)*(1 - zeta);		phi_xsi[1] = (1 - eta)*(1 - zeta);
		phi_xsi[2] = eta*(1 - zeta);			phi_xsi[3] = -eta*(1 - zeta);
		phi_xsi[4] = -(1 - eta)*zeta;			phi_xsi[5] = (1 - eta)*zeta;
		phi_xsi[6] = eta*zeta;				phi_xsi[7] = -eta*zeta;

		phi_eta[0] = -(1 - xsi)*(1 - zeta);		phi_eta[1] = -xsi*(1 - zeta);
		phi_eta[2] = xsi*(1 - zeta);			phi_eta[3] = (1 - xsi)*(1 - zeta);
		phi_eta[4] = -(1 - xsi)*zeta;			phi_eta[5] = -xsi*zeta;
		phi_eta[6] = xsi*zeta;				phi_eta[7] = (1 - xsi)*zeta;

		phi_zeta[0] = -(1 - xsi)*(1 - eta);		phi_zeta[1] = -xsi*(1 - eta);
		phi_zeta[2] = -xsi*eta;				phi_zeta[3] = -(1 - xsi)*eta;
		phi_zeta[4] = (1 - xsi)*(1 - eta);		phi_zeta[5] = xsi*(1 - eta);
		phi_zeta[6] = xsi*eta;				phi_zeta[7] = (1 - xsi)*eta;

		g00 = 0.0;	g01 = 0.0;	g02 = 0.0;	g10 = 0.0;	g11 = 0.0;	g12 = 0.0;
		g20 = 0.0; g21 = 0.0; g22 = 0.0;
		for (int j = 0; j < 8; j++)
		{
			g00 += cp[tmesh[eid].cnct[j]].coor[0] * phi_xsi[j];
			g01 += cp[tmesh[eid].cnct[j]].coor[0] * phi_eta[j];
			g02 += cp[tmesh[eid].cnct[j]].coor[0] * phi_zeta[j];
			g10 += cp[tmesh[eid].cnct[j]].coor[1] * phi_xsi[j];
			g11 += cp[tmesh[eid].cnct[j]].coor[1] * phi_eta[j];
			g12 += cp[tmesh[eid].cnct[j]].coor[1] * phi_zeta[j];
			g20 += cp[tmesh[eid].cnct[j]].coor[2] * phi_xsi[j];
			g21 += cp[tmesh[eid].cnct[j]].coor[2] * phi_eta[j];
			g22 += cp[tmesh[eid].cnct[j]].coor[2] * phi_zeta[j];
			//cout << phi_zeta[j] << "\n";
			//cout << cp[tmesh[eid].cnct[j]].coor[0] << " " << cp[tmesh[eid].cnct[j]].coor[1] << " " <<
			//	cp[tmesh[eid].cnct[j]].coor[2] << "\n";
		}
		//cout << "\n";
		//cout << g00 << "\t" << g01 << "\t" << g02 << "\n" << g10 << "\t" << g11 << "\t" << g12 << "\n" << g20 << "\t" << g21 << "\t" << g22 << "\n";
		//jacob = g00*g11*g22 + g10*g21*g02 + g20*g01*g12 - g02*g20*g11 - g01*g10*g22 - g00*g12*g21;
		//cout << "jacob: " << jacob << "\n";
		//getchar();

		// normalize
		double dtemp = 0., vtmp[3] = { 0.,0.,0. };
		//for (int j = 0; j < 3; j++)
		//{
		//	vtmp[0] = cp[tmesh[eid].cnct[cned[ploc][j]]].coor[0] - cp[tmesh[eid].cnct[ploc]].coor[0];
		//	vtmp[1] = cp[tmesh[eid].cnct[cned[ploc][j]]].coor[1] - cp[tmesh[eid].cnct[ploc]].coor[1];
		//	vtmp[2] = cp[tmesh[eid].cnct[cned[ploc][j]]].coor[2] - cp[tmesh[eid].cnct[ploc]].coor[2];
		//	dtemp += sqrt(vtmp[0] * vtmp[0] + vtmp[1] * vtmp[1] + vtmp[2] * vtmp[2]);
		//}
		//dtemp /= 3.;
		//if (dtemp > 1.e-6)
		//	jacob /= pow(dtemp, 3);

		double tempgrad[3];
		//if (flag || jacob < minJacob)
		{
			tempgrad[0] = phi_xsi[ploc] * g11*g22 + g10*g21*phi_zeta[ploc] + g20*phi_eta[ploc] * g12
				- g20*phi_zeta[ploc] * g11 - phi_eta[ploc] * g10*g22 - phi_xsi[ploc] * g12*g21;

			tempgrad[1] = g00*phi_eta[ploc] * g22 + phi_xsi[ploc] * g21*g02 + g20*g01*phi_zeta[ploc]
				- g02*g20*phi_eta[ploc] - g01*phi_xsi[ploc] * g22 - g00*phi_zeta[ploc] * g21;

			tempgrad[2] = g00*g11*phi_zeta[ploc] + g10*phi_eta[ploc] * g02 + phi_xsi[ploc] * g01*g12
				- g02*phi_xsi[ploc] * g11 - g01*g10*phi_zeta[ploc] - g00*g12*phi_eta[ploc];

			dtemp = tempgrad[0] * tempgrad[0] + tempgrad[1] * tempgrad[1] + tempgrad[2] * tempgrad[2];
			//if (fabs(dtemp) > 1.e-6)
			{
				//minJacob = jacob[i];
				grad[0] = tempgrad[0];
				grad[1] = tempgrad[1];
				grad[2] = tempgrad[2];
				//flag = false;
			}
		}
	//}

	dtemp = sqrt(grad[0] * grad[0] + grad[1] * grad[1] + grad[2] * grad[2]);
	if (dtemp > 1.e-12)
	{
		for (int i = 0; i < 3; i++)
			grad[i] /= dtemp;
	}
}

//void TruncatedTspline_3D::GlobalMinJacobBEXT(double& minJacob_glb, int& min_pos, vector<int>& BadEle)
//{
//	minJacob_glb = 1.e5;
//	min_pos = -1;
//	BadEle.clear();
//	const double eps(1.e-10);
//	for (uint eid = 0; eid < tmesh.size(); eid++)
//	{
//		double minJacob_ele, GaussPos[3];
//		GetHexMinJacobBEXT(eid, minJacob_ele, GaussPos);
//		if (minJacob_ele < eps)
//		{
//			BadEle.push_back(eid);
//		}
//		if (minJacob_ele < minJacob_glb)
//		{
//			minJacob_glb = minJacob_ele;
//			min_pos = eid;
//		}
//	}
//	cout << "minJacob eid nBad: " << minJacob_glb << " " << min_pos << " " << BadEle.size() << "\n";
//}
//
//void TruncatedTspline_3D::GetHexMinJacobBEXT(int eid, double& minJacob_ele, double GaussPos[3])
//{
//	vector<double> Gpt, wght;
//	GetGaussPoint(2, Gpt, wght);
//	Gpt[0] = 0.; Gpt[1] = 1.;
//	double detJ;
//	minJacob_ele = 1.e5;
//	GaussPos[0] = 0.; GaussPos[1] = 0.; GaussPos[2] = 0.;
//	for (uint i = 0; i < Gpt.size(); i++)
//	{
//		for (uint j = 0; j < Gpt.size(); j++)
//		{
//			for (uint k = 0; k < Gpt.size(); k++)
//			{
//				//JacobEval(eid, Gpt[i], Gpt[j], Gpt[k], detJ);
//				JacobEval_ScaleBEXT(eid, Gpt[i], Gpt[j], Gpt[k], detJ);
//				if (detJ < minJacob_ele)
//				{
//					minJacob_ele = detJ;
//					GaussPos[0] = Gpt[i];
//					GaussPos[1] = Gpt[j];
//					GaussPos[2] = Gpt[k];
//				}
//			}
//		}
//	}
//}

//void TruncatedTspline_3D::JacobEval_ScaleBEXT(int eid, double u, double v, double w, double& detJ)
//{
//	double Nu[4] = { (1. - u)*(1. - u)*(1. - u), 3.*(1. - u)*(1. - u)*u, 3.*(1. - u)*u*u, u*u*u };
//	double Nv[4] = { (1. - v)*(1. - v)*(1. - v), 3.*(1. - v)*(1. - v)*v, 3.*(1. - v)*v*v, v*v*v };
//	double Nw[4] = { (1. - w)*(1. - w)*(1. - w), 3.*(1. - w)*(1. - w)*w, 3.*(1. - w)*w*w, w*w*w };
//
//	double dNdu[4] = { -3.*(1. - u)*(1. - u), 3. - 12.*u + 9.*u*u, 3.*(2. - 3.*u)*u, 3.*u*u };
//	double dNdv[4] = { -3.*(1. - v)*(1. - v), 3. - 12.*v + 9.*v*v, 3.*(2. - 3.*v)*v, 3.*v*v };
//	double dNdw[4] = { -3.*(1. - w)*(1. - w), 3. - 12.*w + 9.*w*w, 3.*(2. - 3.*w)*w, 3.*w*w };
//
//	double dNdt[64][3];
//	double Nx_bz[64];
//	double dNdx_bz[64][3];
//
//	vector<double> Nx;
//	vector<array<double, 3>> dNdx;
//
//	Nx.resize(bzmesh[eid].IEN.size());
//	dNdx.resize(bzmesh[eid].IEN.size());
//
//	int i, j, k, a, b, c, loc;
//	loc = 0;
//	for (i = 0; i<4; i++) {
//		for (j = 0; j<4; j++) {
//			for (k = 0; k < 4; k++) {
//				Nx_bz[loc] = Nu[k] * Nv[j] * Nw[i];
//				dNdt[loc][0] = dNdu[k] * Nv[j] * Nw[i];
//				dNdt[loc][1] = Nu[k] * dNdv[j] * Nw[i];
//				dNdt[loc][2] = Nu[k] * Nv[j] * dNdw[i];
//				loc++;
//			}
//		}
//	}
//
//	for (i = 0; i < bzmesh[eid].IEN.size; i++)
//	{
//		for (j = 0; j < 64; j++)
//		{
//			Nx[i] += bzmesh[eid].cmat[i][j] * Nx_bz[j];
//				for (k = 0; k < 3; k++)
//					dNdx[i] += bzmesh[eid].cmat[i][j] * dNdx_bz[j][k];
//		}
//	}
//
//
//
//	double dxdt[3][3] = { { 0.,0.,0. },{ 0.,0.,0. },{ 0.,0.,0. } };
//	for (i = 0; i < bzmesh[eid].IEN.size; i++)
//		for (a = 0; a<3; a++)
//			for (b = 0; b<3; b++)
//				dxdt[a][b] += cp[bzmesh[eid].IEN[i]].coor[a] * dNdt[i][b];
//
//
//	for (int i = 0; i < 3; i++)
//	{
//		for (int j = 0; j < 3; j++)
//		{
//			for (int k = 0; k < 64; k++)
//			{
//				dxdt[i][j] += cp[tmesh[eid].cnct[k]].coor[i] * dNdt[k][j];
//			}
//		}
//	}
//	detJ = dxdt[0][0] * (dxdt[1][1] * dxdt[2][2] - dxdt[1][2] * dxdt[2][1]) -
//		dxdt[0][1] * (dxdt[1][0] * dxdt[2][2] - dxdt[1][2] * dxdt[2][0]) +
//		dxdt[0][2] * (dxdt[1][0] * dxdt[2][1] - dxdt[1][1] * dxdt[2][0]);
//	double nm[3] = { sqrt(dxdt[0][0] * dxdt[0][0] + dxdt[1][0] * dxdt[1][0] + dxdt[2][0] * dxdt[2][0]),
//		sqrt(dxdt[0][1] * dxdt[0][1] + dxdt[1][1] * dxdt[1][1] + dxdt[2][1] * dxdt[2][1]),
//		sqrt(dxdt[0][2] * dxdt[0][2] + dxdt[1][2] * dxdt[1][2] + dxdt[2][2] * dxdt[2][2]) };
//	double tmp(nm[0] * nm[1] * nm[2]);
//	if (tmp > 1.e-12)
//	{
//		detJ /= tmp;
//	}
//}

//////////////////////////////////////////////////////////////////////////////////////

void TruncatedTspline_3D::Smoothing_Adapt(int nSize, double stepSize)
{
	cout << "\nSmoothing...\n";

	vector<array<int, 2>> psm;
	for (uint i = 0; i < hcp.size(); i++)
	{
		for (uint j = 0; j < hcp[i].size(); j++)
		{
			hcp[i][j].smth = 0;
		}
	}
	//for (uint i = 0; i < hmesh.size(); i++)
	//{
	//	for (uint j = 0; j < hmesh[i].size(); j++)
	//	{
	//		//if (hmesh[i][j].act == 1)
	//		if (hmesh[i][j].act == 1 && i == hmesh.size() - 1)
	//		{
	//			for (int k = 0; k < 8; k++)
	//			{
	//				hcp[i][hmesh[i][j].cnct[k]].smth = 1;
	//			}
	//		}
	//	}
	//}
	//for (uint i = 0; i < hcp.size(); i++)
	//{
	//	for (uint j = 0; j < hcp[i].size(); j++)
	//	{
	//		if (hcp[i][j].smth == 1)
	//		{
	//			array<int, 2> itmp = { i,j };
	//			psm.push_back(itmp);
	//		}
	//	}
	//}

	int il(hcp.size() - 1);
	vector<int> flag(hcp[il].size(), 1);
	for (uint j = 0; j < hface[il].size(); j++)
	{
		if (hface[il][j].hex.size() == 1)
		{
			for (int k = 0; k < 4; k++)
			{
				flag[hface[il][j].cnct[k]] = 0;
			}
		}
	}

	vector<array<int, 2>> psmb;
	for (uint j = 0; j < hcp[il].size(); j++)
	{
		if (flag[j] == 1)
		{
			array<int, 2> itmp = { il,j };
			psm.push_back(itmp);
		}
		else
		{
			array<int, 2> itmp = { il,j };
			psmb.push_back(itmp);
		}
	}
	

	cout << "\n# points to be smoothed: "<<psm.size()<<"\n";

	for (int it = 0; it < nSize; it++)
	{
		cout << "it: " << it << "\n";
		int flag(0);

		//double minJacob_glb0;
		//array<int,2> min_pos0;
		//vector<array<int, 2>> BadEle0;
		//GlobalMinJacob_Adapt(minJacob_glb0, min_pos0, BadEle0);

		//for (uint i0 = 0; i0 < BadEle0.size(); i0++)
		//{
		//	//cout << BadEle0[i0] << " ";
		//	tmesh[BadEle0[i0]].trun = 1;
		//	//int eid(BadEle[i0]);
		//	//for (int i = 0; i < 8; i++)
		//	//{
		//	//	if (cp[tmesh[eid].cnct[i]].type != 1)
		//	//	{
		//	//		int tmp = SmoothingPoint(tmesh[eid].cnct[i], stepSize);
		//	//		if (tmp == 1) flag = 1;
		//	//	}
		//	//}
		//}
		//break;

		for (uint i = 0; i < psm.size(); i++)
		{
			if (hcp[psm[i][0]][psm[i][1]].type != 1)//interior points only
			{
				int tmp = SmoothingPoint_Adapt(psm[i][0], psm[i][1], stepSize);
				if (tmp == 1) flag = 1;
			}
			//else 
			//{
			//	int tmp = SmoothingPointBoundary(i, stepSize);
			//	if (tmp == 1) flag = 1;
			//}
		}
		for (uint i = 0; i < psmb.size(); i++)
		{
			{
				int tmp = SmoothingPointBoundary_Adapt(psmb[i][0], psmb[i][1], stepSize);
			}
			//else 
			//{
			//	int tmp = SmoothingPointBoundary(i, stepSize);
			//	if (tmp == 1) flag = 1;
			//}
		}

		double minJacob_glb;
		array<int,2> min_pos;
		vector<array<int,2>> BadEle;
		GlobalMinJacob_Adapt(minJacob_glb, min_pos, BadEle);

		//if (flag == 0 || minJacob_glb0 > minJacob_glb)
		//{
		//	cout << "After " << it << "steps, no interior point moved!\n";
		//	break;
		//}

	}
	cout << "Done smoothing!\n";

	//OutputCM("../io/hex_input/smooth/fertility2");
	//OutputCM("../io/hex_input/smooth/cube_coarse");
	//OutputCM("../io/hex_input/smooth/rockerarm2");
	//OutputCM("../io/hex_input/smooth/navair_coarse");
	//OutputCM("../io/hex_input/smooth/honda1");
	//OutputCM("../io/hex_input/smooth/honda2");
	//OutputCM("../io/hex_input/smooth/honda1_dense");
	//OutputCM("../io/hex_input/smooth/honda1m");
	//OutputCM("../io/hex_input/smooth/honda2_2");
	//OutputCM("../io/hex_input/smooth/heli_dense_loc1");
}

int TruncatedTspline_3D::SmoothingPoint_Adapt(int lev, int pid, double stepSize)
{
	const double eps(1.e-8);
	double vol_all(0.), center[3] = { 0.,0.,0., };
	for (uint i = 0; i < hcp[lev][pid].hex.size(); i++)
	{
		double e_vol, e_center[3];
		GetHexVolAndCenter_Adapt(lev,hcp[lev][pid].hex[i], e_vol, e_center);
		vol_all += e_vol;
		center[0] += e_center[0] * e_vol;
		center[1] += e_center[1] * e_vol;
		center[2] += e_center[2] * e_vol;
	}
	if (vol_all < eps)
	{
		//cerr << "Element with almost zero volume!\n";
		return 0;
	}
	center[0] /= vol_all;
	center[1] /= vol_all;
	center[2] /= vol_all;
	double dir[3] = { center[0] - hcp[lev][pid].coor[0],center[1] - hcp[lev][pid].coor[1], center[2] - hcp[lev][pid].coor[2] };
	double pold[3] = { hcp[lev][pid].coor[0],hcp[lev][pid].coor[1],hcp[lev][pid].coor[2] };

	//cout << dir[0] << " " << dir[1] << " " << dir[2] << "\n";
	//getchar();

	//before smoothing
	double minJacob_0(1.e5), minJacob_1(1.e5), tmpJacob, GaussPos[3];
	for (uint i = 0; i < hcp[lev][pid].hex.size(); i++)
	{
		GetHexMinJacob_Adapt(lev, hcp[lev][pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_0) minJacob_0 = tmpJacob;
	}
	//double edlen = AverageEdgeLength(pid);
	//double stepSize_scale(stepSize*edlen);
	double stepSize_scale(stepSize);
	//after smoothing
	hcp[lev][pid].coor[0] = hcp[lev][pid].coor[0] + stepSize_scale*dir[0];
	hcp[lev][pid].coor[1] = hcp[lev][pid].coor[1] + stepSize_scale*dir[1];
	hcp[lev][pid].coor[2] = hcp[lev][pid].coor[2] + stepSize_scale*dir[2];
	for (uint i = 0; i < hcp[lev][pid].hex.size(); i++)
	{
		GetHexMinJacob_Adapt(lev, hcp[lev][pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_1) minJacob_1 = tmpJacob;
	}
	if (minJacob_1 < minJacob_0)
	{
		hcp[lev][pid].coor[0] = pold[0];
		hcp[lev][pid].coor[1] = pold[1];
		hcp[lev][pid].coor[2] = pold[2];
		return 0;
	}
	return 1;
}

int TruncatedTspline_3D::SmoothingPointBoundary_Adapt(int lev, int pid, double stepSize)
{
	const double eps(1.e-8);
	double area_all(0.), center[3] = { 0.,0.,0. }, nm[3] = { 0., 0., 0. };
	int nbf(0);
	for (uint i = 0; i < hcp[lev][pid].face.size(); i++)
	{
		if (hface[lev][hcp[lev][pid].face[i]].hex.size() == 1)
		{
			double e_area, e_center[3], e_nm[3];
			int* it = find(hface[lev][hcp[lev][pid].face[i]].cnct, hface[lev][hcp[lev][pid].face[i]].cnct + 4, pid);
			int loc(it - hface[lev][hcp[lev][pid].face[i]].cnct);
			GetQuadInfo_Adapt(lev, hcp[lev][pid].face[i], loc, e_area, e_center, e_nm);
			area_all += e_area;
			center[0] += e_center[0] * e_area;
			center[1] += e_center[1] * e_area;
			center[2] += e_center[2] * e_area;
			nm[0] += e_nm[0] * e_area;
			nm[1] += e_nm[1] * e_area;
			nm[2] += e_nm[2] * e_area;
			//nm[0] += e_nm[0];
			//nm[1] += e_nm[1];
			//nm[2] += e_nm[2];
			nbf++;
		}
	}
	if (area_all < eps)
	{
		cerr << "Element with almost zero area!\n";
		return 0;
	}
	center[0] /= area_all;	center[1] /= area_all;	center[2] /= area_all;
	nm[0] /= area_all;	nm[1] /= area_all;	nm[2] /= area_all;
	//nm[0] /= double(nbf);	nm[1] /= double(nbf);	nm[2] /= double(nbf);
	double dst = sqrt(nm[0] * nm[0] + nm[1] * nm[1] + nm[2] * nm[2]);
	nm[0] /= dst; nm[1] /= dst; nm[2] /= dst;
	double dir[3] = { center[0] - hcp[lev][pid].coor[0],center[1] - hcp[lev][pid].coor[1], center[2] - hcp[lev][pid].coor[2] };
	dst = dir[0] * nm[0] + dir[1] * nm[1] + dir[2] * nm[2];
	dir[0] = dir[0] - dst*nm[0];
	dir[1] = dir[1] - dst*nm[1];
	dir[2] = dir[2] - dst*nm[2];

	//dst = dir[0] * nm[0] + dir[1] * nm[1] + dir[2] * nm[2];
	//cout << "inner product: " << dst << "\n";
	//getchar();

	double pold[3] = { hcp[lev][pid].coor[0],hcp[lev][pid].coor[1],hcp[lev][pid].coor[2] };

	//before smoothing
	double minJacob_0(1.e5), minJacob_1(1.e5), tmpJacob, GaussPos[3];
	for (uint i = 0; i < hcp[lev][pid].hex.size(); i++)
	{
		GetHexMinJacob_Adapt(lev, hcp[lev][pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_0) minJacob_0 = tmpJacob;
	}
	//double edlen = AverageEdgeLength(pid);
	//double stepSize_scale(stepSize*edlen);
	double stepSize_scale(stepSize);
	//after smoothing
	hcp[lev][pid].coor[0] = hcp[lev][pid].coor[0] + stepSize_scale*dir[0];
	hcp[lev][pid].coor[1] = hcp[lev][pid].coor[1] + stepSize_scale*dir[1];
	hcp[lev][pid].coor[2] = hcp[lev][pid].coor[2] + stepSize_scale*dir[2];
	for (uint i = 0; i < hcp[lev][pid].hex.size(); i++)
	{
		GetHexMinJacob_Adapt(lev, hcp[lev][pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_1) minJacob_1 = tmpJacob;
	}
	if (minJacob_1 < minJacob_0)
	{
		hcp[lev][pid].coor[0] = pold[0];
		hcp[lev][pid].coor[1] = pold[1];
		hcp[lev][pid].coor[2] = pold[2];
		return 0;
	}
	return 1;
}

void TruncatedTspline_3D::GetHexMinJacob_Adapt(int lev, int eid, double& minJacob_ele, double GaussPos[3])
{
	vector<double> Gpt(2);
	Gpt[0] = 0.; Gpt[1] = 1.;
	double detJ[2];
	minJacob_ele = 1.e5;
	GaussPos[0] = 0.; GaussPos[1] = 0.; GaussPos[2] = 0.;
	for (uint i = 0; i < Gpt.size(); i++)
	{
		for (uint j = 0; j < Gpt.size(); j++)
		{
			for (uint k = 0; k < Gpt.size(); k++)
			{
				JacobEval_Scale_Adapt(lev, eid, Gpt[i], Gpt[j], Gpt[k], detJ);
				if (detJ[0] < minJacob_ele)
				{
					minJacob_ele = detJ[0];
					GaussPos[0] = Gpt[i];
					GaussPos[1] = Gpt[j];
					GaussPos[2] = Gpt[k];
				}
			}
		}
	}
}

void TruncatedTspline_3D::GetHexVolAndCenter_Adapt(int lev, int eid, double& vol, double center[3])
{
	vol = 0.;
	center[0] = 0.; center[1] = 0.; center[2] = 0.;
	for (int i = 0; i < 8; i++)
	{
		center[0] += hcp[lev][hmesh[lev][eid].cnct[i]].coor[0];
		center[1] += hcp[lev][hmesh[lev][eid].cnct[i]].coor[1];
		center[2] += hcp[lev][hmesh[lev][eid].cnct[i]].coor[2];
	}
	center[0] /= 8.; center[1] /= 8.; center[2] /= 8.;

	vector<double> Gpt, wght;
	GetGaussPoint(2, Gpt, wght);
	double detJ[2];
	for (uint i = 0; i < Gpt.size(); i++)
	{
		for (uint j = 0; j < Gpt.size(); j++)
		{
			for (uint k = 0; k < Gpt.size(); k++)
			{
				JacobEval_Scale_Adapt(lev, eid, Gpt[i], Gpt[j], Gpt[k], detJ);
				vol += wght[i] * wght[j] * wght[k] * detJ[1];
			}
		}
	}
}

void TruncatedTspline_3D::GetQuadInfo_Adapt(int lev, int fcid, int ploc, double& area, double center[3], double nm[3])
{
	//face is counter-clock-wise oriented
	area = 0.;
	center[0] = 0.; center[1] = 0.; center[2] = 0.;
	nm[0] = 0.; nm[1] = 0.; nm[2] = 0.;
	for (int i = 0; i < 4; i++)
	{
		center[0] += hcp[lev][hface[lev][fcid].cnct[i]].coor[0];
		center[1] += hcp[lev][hface[lev][fcid].cnct[i]].coor[1];
		center[2] += hcp[lev][hface[lev][fcid].cnct[i]].coor[2];
	}
	center[0] /= 4.; center[1] /= 4.; center[2] /= 4.;

	int tp[2][3] = { { hface[lev][fcid].cnct[ploc],hface[lev][fcid].cnct[(ploc + 1) % 4],hface[lev][fcid].cnct[(ploc + 3) % 4] },
	{ hface[lev][fcid].cnct[(ploc + 2) % 4],hface[lev][fcid].cnct[(ploc + 3) % 4],hface[lev][fcid].cnct[(ploc + 1) % 4] } };
	double v0[2][3] = { { hcp[lev][tp[0][1]].coor[0] - hcp[lev][tp[0][0]].coor[0],hcp[lev][tp[0][1]].coor[1] - hcp[lev][tp[0][0]].coor[1],hcp[lev][tp[0][1]].coor[2] - hcp[lev][tp[0][0]].coor[2] },
	{ hcp[lev][tp[0][2]].coor[0] - hcp[lev][tp[0][0]].coor[0],hcp[lev][tp[0][2]].coor[1] - hcp[lev][tp[0][0]].coor[1],hcp[lev][tp[0][2]].coor[2] - hcp[lev][tp[0][0]].coor[2] } };
	double v1[2][3] = { { hcp[lev][tp[1][1]].coor[0] - hcp[lev][tp[1][0]].coor[0],hcp[lev][tp[1][1]].coor[1] - hcp[lev][tp[1][0]].coor[1],hcp[lev][tp[1][1]].coor[2] - hcp[lev][tp[1][0]].coor[2] },
	{ hcp[lev][tp[1][2]].coor[0] - hcp[lev][tp[1][0]].coor[0],hcp[lev][tp[1][2]].coor[1] - hcp[lev][tp[1][0]].coor[1],hcp[lev][tp[1][2]].coor[2] - hcp[lev][tp[1][0]].coor[2] } };
	double vc0[3] = { v0[0][1] * v0[1][2] - v0[0][2] * v0[1][1],v0[0][2] * v0[1][0] - v0[0][0] * v0[1][2],v0[0][0] * v0[1][1] - v0[0][1] * v0[1][0] };
	double vc1[3] = { v1[0][1] * v1[1][2] - v1[0][2] * v1[1][1],v1[0][2] * v1[1][0] - v1[0][0] * v1[1][2],v1[0][0] * v1[1][1] - v1[0][1] * v1[1][0] };
	double dst0 = sqrt(vc0[0] * vc0[0] + vc0[1] * vc0[1] + vc0[2] * vc0[2]);
	double dst1 = sqrt(vc1[0] * vc1[0] + vc1[1] * vc1[1] + vc1[2] * vc1[2]);

	area = (dst0 + dst1) / 2.;
	nm[0] = vc0[0] / dst0; nm[1] = vc0[1] / dst0; nm[2] = vc0[2] / dst0;
}

void TruncatedTspline_3D::JacobEval_Scale_Adapt(int lev, int eid, double u, double v, double w, double detJ[2])
{
	double Nu[2] = { 1. - u,u };
	double Nv[2] = { 1. - v,v };
	double Nw[2] = { 1. - w,w };
	double dNdu[2] = { -1.,1. };
	double dNdv[2] = { -1.,1. };
	double dNdw[2] = { -1.,1. };
	double dNdt[8][3];
	int ploc[8] = { 0,1,3,2,4,5,7,6 };
	int loc(0);
	for (int i = 0; i < 2; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			for (int k = 0; k < 2; k++)
			{
				dNdt[ploc[loc]][0] = dNdu[k] * Nv[j] * Nw[i];
				dNdt[ploc[loc]][1] = Nu[k] * dNdv[j] * Nw[i];
				dNdt[ploc[loc]][2] = Nu[k] * Nv[j] * dNdw[i];
				loc++;
			}
		}
	}
	double dxdt[3][3] = { { 0.,0.,0. },{ 0.,0.,0. },{ 0.,0.,0. } };
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			for (int k = 0; k < 8; k++)
			{
				dxdt[i][j] += hcp[lev][hmesh[lev][eid].cnct[k]].coor[i] * dNdt[k][j];
			}
		}
	}
	detJ[0] = dxdt[0][0] * (dxdt[1][1] * dxdt[2][2] - dxdt[1][2] * dxdt[2][1]) -
		dxdt[0][1] * (dxdt[1][0] * dxdt[2][2] - dxdt[1][2] * dxdt[2][0]) +
		dxdt[0][2] * (dxdt[1][0] * dxdt[2][1] - dxdt[1][1] * dxdt[2][0]);
	detJ[1] = detJ[0];
	double nm[3] = { sqrt(dxdt[0][0] * dxdt[0][0] + dxdt[1][0] * dxdt[1][0] + dxdt[2][0] * dxdt[2][0]),
		sqrt(dxdt[0][1] * dxdt[0][1] + dxdt[1][1] * dxdt[1][1] + dxdt[2][1] * dxdt[2][1]),
		sqrt(dxdt[0][2] * dxdt[0][2] + dxdt[1][2] * dxdt[1][2] + dxdt[2][2] * dxdt[2][2]) };
	double tmp(nm[0] * nm[1] * nm[2]);
	if (tmp > 1.e-12)
	{
		detJ[0] /= tmp;
	}
}

void TruncatedTspline_3D::GlobalMinJacob_Adapt(double& minJacob_glb, array<int, 2>& min_pos, vector<array<int,2>>& BadEle)
{
	minJacob_glb = 1.e5;
	min_pos[0] = -1; min_pos[0] = -1;
	BadEle.clear();
	const double eps(1.e-10);
	for (uint i = 0; i < hmesh.size(); i++)
	{
		for (uint j = 0; j < hmesh[i].size(); j++)
		{
			if (hmesh[i][j].act == 1)
			{
				double minJacob_ele, GaussPos[3];
				GetHexMinJacob_Adapt(i, j, minJacob_ele, GaussPos);
				if (minJacob_ele < eps)
				{
					array<int, 2> itmp = { i,j };
					BadEle.push_back(itmp);
				}
				if (minJacob_ele < minJacob_glb)
				{
					minJacob_glb = minJacob_ele;
					min_pos[0] = i; min_pos[1] = j;
				}
			}
		}
	}
	cout << "minJacob eid nBad: " << minJacob_glb << " " << BadEle.size() << "\n";
}

void TruncatedTspline_3D::BadElementFlag_Adapt(const vector<array<int, 2>>& rfid)
{
	for (uint i = 0; i < hmesh.size(); i++)
	{
		for (uint j = 0; j < hmesh[i].size(); j++)
		{
			hmesh[i][j].jacobFlag = 0;
		}
	}
	for (uint i = 0; i < rfid.size(); i++)
	{
		hmesh[rfid[i][0]][rfid[i][1]].jacobFlag = 1;
	}
}







////////////////////////////////////////////////////////////////////////////////


void TruncatedTspline_3D::Optimizing_1(int nSize, int nitrMax, double stepSize)
{
	//double edlen_max = MaxEdgeLength();
	//double eta(1.e-3);
	//double tol(eta*edlen_max);

	double tol(1.e-4);

	cout << "\nOptimizing...\n";
	for (int it = 0; it < nSize; it++)
	{
		int flag(0);
		double minJacob_glb;
		int min_pos;
		vector<int> BadEle;
		GlobalMinJacob(minJacob_glb, min_pos, BadEle);

		vector<int> pbad(cp.size(), 0);
		for (uint i = 0; i < BadEle.size(); i++)
		{
			for (int j = 0; j < 8; j++)
			{
				pbad[tmesh[BadEle[i]].cnct[j]] = 1;
			}
		}

		double dispMax(0.), disp;
		for (uint i = 0; i < cp.size(); i++)
		{
			if (cp[i].type != 1 /*&& pbad[i] == 1 && i==8*/)
			{
				disp = OptimizePoint(i, nitrMax, stepSize);
				if (disp > dispMax) dispMax = disp;
				//if (disp > 1.e14)
				//{
				//	getchar();
				//}
			}
			//else
			//{
			//	SmoothingPointBoundary(i, stepSize);
			//}
		}
		//cout << "Max disp: " << dispMax << "\n";
		//getchar();

		double minJacob_glb1;
		int min_pos1;
		vector<int> BadEle1;
		GlobalMinJacob(minJacob_glb1, min_pos1, BadEle1);

		//if (dispMax < tol)
		//{
		//	cout << "Converged after " << it << " steps!\n";
		//	break;
		//}

		for (uint i = 0; i < tmesh.size(); i++)
		{
			tmesh[i].trun = 0;
		}
		for (uint i = 0; i < BadEle1.size(); i++)
		{
			tmesh[BadEle1[i]].trun = 1;
		}

		//if (BadEle1.size() < 80)
		//{
		//	break;
		//}

		//if (flag == 0 /*|| fabs(minJacob_glb - minJacob_glb1) < 1.e-6*/)
		//{
		//	cout << "After " << it << "steps, no interior point moved!\n";
		//	break;
		//}

	}
	cout << "Done optimizing!\n";
	//OutputCM("../io/hex_input/optimize/cube_coarse4");
	//OutputCM("../io/hex_input/optimize/rockerarm2");
	//OutputCM("../io/hex_input/optimize/fertility2");
	//OutputCM("../io/hex_input/optimize/honda1");
}

double TruncatedTspline_3D::MaxEdgeLength()
{
	double lmax(0.), vtmp[3], dist;
	for (uint i = 0; i < tmedge.size(); i++)
	{
		vtmp[0] = cp[tmedge[i].pt[1]].coor[0] - cp[tmedge[i].pt[0]].coor[0];
		vtmp[1] = cp[tmedge[i].pt[1]].coor[1] - cp[tmedge[i].pt[0]].coor[1];
		vtmp[2] = cp[tmedge[i].pt[1]].coor[2] - cp[tmedge[i].pt[0]].coor[2];
		dist = sqrt(vtmp[0] * vtmp[0] + vtmp[1] * vtmp[1] + vtmp[2] * vtmp[2]);
		if (dist > lmax) lmax = dist;
	}
	return lmax;
}

double TruncatedTspline_3D::OptimizePoint(int pid, int nitrMax, double stepSize)
{
	//first translate and scale
	double trs[3];
	vector<double> scl;
	//TranslateScale(pid, trs, scl);
	double grad[3], dir[3], vdisp[3], stepScale, disp, keta;
	for (int it = 0; it < nitrMax; it++)
	{		
		//cout << "\n\n\npid: " << pid << "\n";
		GetAdvanceDirection(pid, grad, dir, keta);
		//stepScale = GetStepSize(pid, grad, dir, keta);
		stepScale = AverageEdgeLength(pid);
		stepScale *= stepSize;
		//stepScale = stepSize;
		double vdisp[3] = { stepScale*dir[0],stepScale*dir[1], stepScale*dir[2] };
		disp = sqrt(vdisp[0] * vdisp[0] + vdisp[1] * vdisp[1] + vdisp[2] * vdisp[2]);
		cp[pid].coor[0] -= vdisp[0];
		cp[pid].coor[1] -= vdisp[1];
		cp[pid].coor[2] -= vdisp[2];
		//cout << pid << ": " << keta << ", " << dir[0] << " " << dir[1] << " " << dir[2] << "\n";
		//getchar();
		//if (disp > 0.1)
		//{
		//	cout << pid << ": " << keta << ", " << dir[0] << " " << dir[1] << " " << dir[2] << "\n";
		//	getchar();
		//}
		//if (disp < 1.e-4)
		//{
		//	break;
		//}
	}
	//translate and scale back
	//TranslateScale_Reverse(pid, trs, scl);

	return disp;
}

void TruncatedTspline_3D::TranslateScale(int pid, double trs[3], vector<double>& scl)
{
	scl.clear();
	double tol(1.e-8);
	trs[0] = cp[pid].coor[0];
	trs[1] = cp[pid].coor[1];
	trs[2] = cp[pid].coor[2];
	cp[pid].coor[0] = 0.;
	cp[pid].coor[1] = 0.;
	cp[pid].coor[2] = 0.;
	double dmax(0.);
	for (uint i = 0; i < cp[pid].edge.size(); i++)
	{
		int edid(cp[pid].edge[i]);
		int edpt(tmedge[edid].pt[0]);
		if (edpt == pid) edpt = tmedge[edid].pt[1];
		//cp[edpt].coor[0] -= trs[0];
		//cp[edpt].coor[1] -= trs[1];
		//cp[edpt].coor[2] -= trs[2];
		double dst = sqrt(cp[edpt].coor[0]* cp[edpt].coor[0]+ cp[edpt].coor[1] * cp[edpt].coor[1] + cp[edpt].coor[2] * cp[edpt].coor[2]);
		if (dst > dmax)
		{
			dmax = dst;
		}
		//if (dst > tol)
		//{
		//	cp[edpt].coor[0] /= dst;
		//	cp[edpt].coor[1] /= dst;
		//	cp[edpt].coor[2] /= dst;
		//	scl.push_back(dst);
		//}
		//else
		//{
		//	//cout << "repeated points!\n";
		//	scl.push_back(1.);
		//	//cp[edpt].coor[0] /= tol;
		//	//cp[edpt].coor[1] /= tol;
		//	//cp[edpt].coor[2] /= tol;
		//	//scl.push_back(tol);
		//}
	}
	//for (uint i = 0; i < cp[pid].edge.size(); i++)
	//{
	//	int edid(cp[pid].edge[i]);
	//	int edpt(tmedge[edid].pt[0]);
	//	if (edpt == pid) edpt = tmedge[edid].pt[1];
	//	cp[edpt].coor[0] /= dmax;
	//	cp[edpt].coor[1] /= dmax;
	//	cp[edpt].coor[2] /= dmax;
	//	scl.push_back(dmax);
	//}

	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		int hxid(cp[pid].hex[i]);
		for (int j = 0; j < 8; j++)
		{
			cp[tmesh[hxid].cnct[j]].update = 0;
		}
		scl.push_back(dmax);
	}
	cp[pid].update = 1;
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		int hxid(cp[pid].hex[i]);
		for (int j = 0; j < 8; j++)
		{
			if (cp[tmesh[hxid].cnct[j]].update == 0)
			{
				cp[tmesh[hxid].cnct[j]].update = 1;
				cp[tmesh[hxid].cnct[j]].coor[0] = (cp[tmesh[hxid].cnct[j]].coor[0] - trs[0]) / dmax;
				cp[tmesh[hxid].cnct[j]].coor[1] = (cp[tmesh[hxid].cnct[j]].coor[1] - trs[1]) / dmax;
				cp[tmesh[hxid].cnct[j]].coor[2] = (cp[tmesh[hxid].cnct[j]].coor[2] - trs[2]) / dmax;
			}
		}
	}
}

void TruncatedTspline_3D::TranslateScale_Reverse(int pid, double trs[3], const vector<double>& scl)
{
	cp[pid].coor[0] += trs[0];
	cp[pid].coor[1] += trs[1];
	cp[pid].coor[2] += trs[2];

	//for (uint i = 0; i < cp[pid].edge.size(); i++)
	//{
	//	int edid(cp[pid].edge[i]);
	//	int edpt(tmedge[edid].pt[0]);
	//	if (edpt == pid) edpt = tmedge[edid].pt[1];
	//	cp[edpt].coor[0] = scl[i] * cp[edpt].coor[0] + trs[0];
	//	cp[edpt].coor[1] = scl[i] * cp[edpt].coor[1] + trs[1];
	//	cp[edpt].coor[2] = scl[i] * cp[edpt].coor[2] + trs[2];
	//}

	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		int hxid(cp[pid].hex[i]);
		for (int j = 0; j < 8; j++)
		{
			cp[tmesh[hxid].cnct[j]].update = 0;
		}
	}
	cp[pid].update = 1;
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		int hxid(cp[pid].hex[i]);
		for (int j = 0; j < 8; j++)
		{
			if (cp[tmesh[hxid].cnct[j]].update == 0)
			{
				cp[tmesh[hxid].cnct[j]].update = 1;
				cp[tmesh[hxid].cnct[j]].coor[0] = scl[i] * cp[tmesh[hxid].cnct[j]].coor[0] + trs[0];
				cp[tmesh[hxid].cnct[j]].coor[1] = scl[i] * cp[tmesh[hxid].cnct[j]].coor[1] + trs[1];
				cp[tmesh[hxid].cnct[j]].coor[2] = scl[i] * cp[tmesh[hxid].cnct[j]].coor[2] + trs[2];
			}
		}
	}
}

void TruncatedTspline_3D::GetAdvanceDirection(int pid, double dir[3], double dir1[3], double& keta)
{
	double alpha(1.e-3);
	double eps(1.e-4);
	double detJmin(1.e5), detJtmp, postmp[3];
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], detJtmp, postmp);
		if (detJtmp < detJmin)
		{
			detJmin = detJtmp;
		}
	}
	double delta(-1.);
	if (detJmin < eps)
	{
		double beta(1.e-2);
		double to = alpha*(fabs(detJmin));
		delta = sqrt(to*to + to*fabs(detJmin));
	}
	//cout << "delta: " << delta << "\n";

	dir[0] = 0.; dir[1] = 0.; dir[2] = 0.;
	dir1[0] = 0.; dir1[1] = 0.; dir1[2] = 0.;
	keta = 0.;
	//vector<double> eeta(cp[pid].hex.size());
	MatrixXd hsmat = MatrixXd::Zero(3, 3);
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		int eid(cp[pid].hex[i]);
		//cout << "eid: " << eid << "\n";
		int* it = find(tmesh[eid].cnct, tmesh[eid].cnct + 8, pid);
		int loc(it - tmesh[eid].cnct);
		double obj, grad[3], grad2[3][3];
		objGrad(eid, loc, delta, obj, grad, grad2);
		dir[0] += obj*grad[0];
		dir[1] += obj*grad[1];
		dir[2] += obj*grad[2];
		keta += (obj*obj);
		//eeta[i] = obj;
		for (int k1 = 0; k1 < 3; k1++)
		{
			for (int k2 = 0; k2 < 3; k2++)
			{
				hsmat(k1, k2) += (grad[k1] * grad[k2] + obj*grad2[k1][k2]);
			}
		}
	}
	//double tmp(2./double(cp[pid].hex.size()));
	//dir[0] *= tmp;
	//dir[1] *= tmp;
	//dir[2] *= tmp;
	//keta /= double(cp[pid].hex.size());

	//for (int k1 = 0; k1 < 3; k1++)
	//{
	//	for (int k2 = 0; k2 < 3; k2++)
	//	{
	//		hsmat(k1, k2) *= tmp;
	//	}
	//}
	//double hsdet = hsmat.determinant();
	////cout << hsdet << "\n"; getchar();
	//MatrixXd hsinv = hsmat.inverse();
	////cout << hsinv << "\n"; getchar();
	//for (int k1 = 0; k1 < 3; k1++)
	//{
	//	for (int k2 = 0; k2 < 3; k2++)
	//	{
	//		dir1[k1] += (hsinv(k1, k2) * dir[k2]);
	//	}
	//	dir1[k1] = dir[k1];
	//}

	double dst = sqrt(dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]);
	dir[0] /= dst;
	dir[1] /= dst;
	dir[2] /= dst;
	dir1[0] = dir[0];
	dir1[1] = dir[1];
	dir1[2] = dir[2];
	//if (pid == 0)
	//{
	//	cout << "pid obj: " << pid << " " << keta << "\n";
	//	//cout << "element eta: ";
	//	//for (uint i = 0; i < eeta.size(); i++)
	//	//{
	//	//	cout << eeta[i] << " ";
	//	//}
	//	//cout << "\n";
	//	getchar();
	//}
	//cout << dir[0] << " " << dir[1] << " " << dir[2] << "\n";
	//cout << "pid obj: " << pid << " " << keta << "\n";
	//getchar();
}

double TruncatedTspline_3D::GetStepSize(int pid, double grad[3], double dir[3], double keta)
{
	double stepSize(1.);
	double c1(1.e-4);
	double c2(0.9);
	double eps(1.e-16);
	double rho(0.5);
	double coor[3] = { cp[pid].coor[0],cp[pid].coor[1], cp[pid].coor[2] };

	double norm_pk = grad[0] * dir[0] + grad[1] * dir[1] + grad[2] * dir[2];
	double Fleft, Fright;
	double gradtmp[3], dirtmp[3], normtmp;
	while (1)
	{
		Fright = keta - c1*stepSize*norm_pk;
		cp[pid].coor[0] = coor[0] - stepSize*dir[0];
		cp[pid].coor[1] = coor[1] - stepSize*dir[1];
		cp[pid].coor[2] = coor[2] - stepSize*dir[2];
		GetAdvanceDirection(pid, gradtmp, dirtmp, Fleft);
		normtmp = gradtmp[0] * dir[0] + gradtmp[1] * dir[1] + gradtmp[2] * dir[2];
		//cout << Fleft << " " << Fright << "\n";
		//getchar();
		if (Fleft <= Fright && fabs(normtmp) < fabs(c2*norm_pk))
		{
			break;
		}
		stepSize *= rho;
		if (stepSize < eps)
		{
			stepSize = 0.;
			break;
		}
	}
	cp[pid].coor[0] = coor[0];
	cp[pid].coor[1] = coor[1];
	cp[pid].coor[2] = coor[2];

	return stepSize;
}

void TruncatedTspline_3D::objGrad(int eid, int iloc, double delta, double& obj, double grad[3], double grad2[3][3])
{
	//const double eps(1.e-4);
	//double delta(1.e-3);
	double Jmat[3][3], DJmat[3][3][3], detJ, detJgrad[3];
	GetJacobMat(eid, iloc, Jmat, DJmat, detJ, detJgrad);
	double Fnorm2(0.), DFnorm2[3] = {0.,0.,0.};
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			Fnorm2 += Jmat[i][j] * Jmat[i][j];
			DFnorm2[0] += DJmat[0][i][j] * Jmat[i][j];
			DFnorm2[1] += DJmat[1][i][j] * Jmat[i][j];
			DFnorm2[2] += DJmat[2][i][j] * Jmat[i][j];
		}
	}
	double h, coef, tmp;
	//if (detJ < eps)
	//if (delta > 0.)
	//{
	//	tmp = sqrt(detJ*detJ + 4.*delta*delta);
	//	h = .5*(detJ + tmp);
	//	coef = 1. / tmp;
	//}
	//else
	{
		h = detJ;
		coef = 1. / detJ;
	}
	obj = Fnorm2 / (3.*pow(h, 2. / 3.));
	grad[0] = 2.*obj*(DFnorm2[0] / Fnorm2 - detJgrad[0] * coef / 3.);
	grad[1] = 2.*obj*(DFnorm2[1] / Fnorm2 - detJgrad[1] * coef / 3.);
	grad[2] = 2.*obj*(DFnorm2[2] / Fnorm2 - detJgrad[2] * coef / 3.);
	//cout << "DFnorm2: " << DFnorm2[0] << " " << DFnorm2[1] << " " << DFnorm2[2] << "\n";
	//cout << "detGrad: " << detJgrad[0] << " " << detJgrad[1] << " " << detJgrad[2] << "\n";
	//cout << "Fnorm2 h: " << Fnorm2 << " " << h << " " << detJ << " " << tmp << "\n";
	//cout << "obj: " << obj << "\n";
	//cout << "grad: " << grad[0] << " " << grad[1] << " " << grad[2] << "\n";
	//getchar();

	double Fnorm4(Fnorm2*Fnorm2), coef3(pow(coef, 3.));
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			grad2[i][j] = 0;
			double DF2(0.);
			for (int k1 = 0; k1 < 3; k1++)
			{
				for (int k2 = 0; k2 < 3; k2++)
				{
					DF2 += (DJmat[i][k1][k2] * DJmat[j][k1][k2]);
				}
			}
			grad2[i][j] = grad[i] * grad[j] / 3. + 2.*obj*(DF2 / Fnorm2 - 2.*DF2 / Fnorm4 + detJ*detJgrad[i] * detJgrad[j] * coef3 / 3.);
		}
	}
}

void TruncatedTspline_3D::GetJacobMat(int eid, int iloc, double Jmat[3][3], double DJmat[3][3][3], double& detJ, double grad[3])
{
	double u(0.), v(0.), w(0.);
	if (iloc == 1 || iloc == 2 || iloc == 5 || iloc == 6) u = 1.;
	if (iloc == 2 || iloc == 3 || iloc == 6 || iloc == 7) v = 1.;
	if (iloc == 4 || iloc == 5 || iloc == 6 || iloc == 7) w = 1.;
	double Nu[2] = { 1. - u,u };
	double Nv[2] = { 1. - v,v };
	double Nw[2] = { 1. - w,w };
	double dNdu[2] = { -1.,1. };
	double dNdv[2] = { -1.,1. };
	double dNdw[2] = { -1.,1. };
	double dNdt[8][3];
	int ploc[8] = { 0,1,3,2,4,5,7,6 };
	int loc(0);
	for (int i = 0; i < 2; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			for (int k = 0; k < 2; k++)
			{
				dNdt[ploc[loc]][0] = dNdu[k] * Nv[j] * Nw[i];
				dNdt[ploc[loc]][1] = Nu[k] * dNdv[j] * Nw[i];
				dNdt[ploc[loc]][2] = Nu[k] * Nv[j] * dNdw[i];
				loc++;
			}
		}
	}
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			Jmat[i][j] = 0.;
			for (int k = 0; k < 8; k++)
			{
				Jmat[i][j] += cp[tmesh[eid].cnct[k]].coor[i] * dNdt[k][j];
			}
		}
	}
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			DJmat[0][i][j] = 0.;
			DJmat[1][i][j] = 0.;
			DJmat[2][i][j] = 0.;
		}
	}
	DJmat[0][0][0] = dNdt[iloc][0]; DJmat[0][0][1] = dNdt[iloc][1]; DJmat[0][0][2] = dNdt[iloc][2];
	DJmat[1][1][0] = dNdt[iloc][0]; DJmat[1][1][1] = dNdt[iloc][1]; DJmat[1][1][2] = dNdt[iloc][2];
	DJmat[2][2][0] = dNdt[iloc][0]; DJmat[2][2][1] = dNdt[iloc][1]; DJmat[2][2][2] = dNdt[iloc][2];
	double cng[3][3] = { {Jmat[1][1] * Jmat[2][2] - Jmat[1][2] * Jmat[2][1],Jmat[1][0] * Jmat[2][2] - Jmat[1][2] * Jmat[2][0], Jmat[1][0] * Jmat[2][1] - Jmat[1][1] * Jmat[2][0] },
	{ Jmat[0][1] * Jmat[2][2] - Jmat[0][2] * Jmat[2][1],Jmat[0][0] * Jmat[2][2] - Jmat[0][2] * Jmat[2][0], Jmat[0][0] * Jmat[2][1] - Jmat[0][1] * Jmat[2][0] }, 
	{ Jmat[0][1] * Jmat[1][2] - Jmat[0][2] * Jmat[1][1],Jmat[0][0] * Jmat[1][2] - Jmat[0][2] * Jmat[1][0], Jmat[0][0] * Jmat[1][1] - Jmat[0][1] * Jmat[1][0] } };
	
	detJ = Jmat[0][0] * cng[0][0] - Jmat[0][1] * cng[0][1] + Jmat[0][2] * cng[0][2];
	grad[0] = dNdt[iloc][0] * cng[0][0] - dNdt[iloc][1] * cng[0][1] + dNdt[iloc][2] * cng[0][2];
	grad[1] = -(dNdt[iloc][0] * cng[1][0] - dNdt[iloc][1] * cng[1][1] + dNdt[iloc][2] * cng[1][2]);
	grad[2] = dNdt[iloc][0] * cng[2][0] - dNdt[iloc][1] * cng[2][1] + dNdt[iloc][2] * cng[2][2];
}

void TruncatedTspline_3D::Optimizing_glb(int nStep, double stepSize)
{
	double beta(0.2);
}







/////////////////////////////////////////////////////////////////////////////////////////////

void TruncatedTspline_3D::LaplaceSmoothing(int nstep)
{
	cout << "\nLaplace Smoothing...\n";

	double tol(1.e-3);
	for (int it = 0; it < nstep; it++)
	{
		cout << "istep: " << it << "\n";
		double minJacob_glb0;
		int min_pos0(0);
		vector<int> BadEle0;
		GlobalMinJacob(minJacob_glb0, min_pos0, BadEle0);

		for (uint i = 0; i < cp.size(); i++)
		{
			if (cp[i].type != 1)
			{
				LaplaceSmooth_Interior(i);
			}
			//else
			//{
			//	if (cp[i].sharp == 0)
			//	{
			//		LaplaceSmooth_Boundary_NonSharp(i);
			//	}
			//	else if (cp[i].sharp == 1)
			//	{
			//		LaplaceSmooth_Boundary_Sharp(i);
			//	}
			//}
		}

		double minJacob_glb;
		int min_pos;
		vector<int> BadEle;
		GlobalMinJacob(minJacob_glb, min_pos, BadEle);

		//if (fabs(minJacob_glb - minJacob_glb0) < tol && BadEle0.size() == BadEle.size())
		//{
		//	cout << "Converged!\n"; 
		//	break;
		//}
		//else if (minJacob_glb < minJacob_glb0)
		//{

		//}

		for (uint i = 0; i < tmesh.size(); i++) tmesh[i].trun = 0;
		for (uint i = 0; i < BadEle.size(); i++) tmesh[BadEle[i]].trun = 1;
	}

	cout << "Done smoothing!\n";
}

void TruncatedTspline_3D::LaplaceSmooth_Interior(int pid)
{
	//before smoothing
	double minJacob_0(1.e5), minJacob_1(1.e5), tmpJacob, GaussPos[3];
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_0) minJacob_0 = tmpJacob;
	}

	//smoothing
	double ptmp[3] = { 0.,0.,0., };
	double pold[3] = { cp[pid].coor[0],cp[pid].coor[1], cp[pid].coor[2] };
	for (uint i = 0; i < cp[pid].edge.size(); i++)
	{
		int edid(cp[pid].edge[i]);
		int pnb(tmedge[edid].pt[0]);
		if (pnb == pid) pnb = tmedge[edid].pt[1];
		ptmp[0] += cp[pnb].coor[0];
		ptmp[1] += cp[pnb].coor[1];
		ptmp[2] += cp[pnb].coor[2];
	}
	cp[pid].coor[0] = ptmp[0] / cp[pid].edge.size();
	cp[pid].coor[1] = ptmp[1] / cp[pid].edge.size();
	cp[pid].coor[2] = ptmp[2] / cp[pid].edge.size();

	//after smoothing
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_1) minJacob_1 = tmpJacob;
	}

	//if (minJacob_1 < minJacob_0)
	//{
	//	cp[pid].coor[0] = pold[0];
	//	cp[pid].coor[1] = pold[1];
	//	cp[pid].coor[2] = pold[2];
	//}
}

void TruncatedTspline_3D::LaplaceSmooth_Boundary_NonSharp(int pid)
{
	//before smoothing
	double minJacob_0(1.e5), minJacob_1(1.e5), tmpJacob, GaussPos[3];
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_0) minJacob_0 = tmpJacob;
	}

	//smoothing
	double ptmp[3] = { 0.,0.,0., };
	double pold[3] = { cp[pid].coor[0],cp[pid].coor[1], cp[pid].coor[2] };
	int nedb(0);
	for (uint i = 0; i < cp[pid].edge.size(); i++)
	{
		if (tmedge[cp[pid].edge[i]].type == 1)
		{
			int edid(cp[pid].edge[i]);
			int pnb(tmedge[edid].pt[0]);
			if (pnb == pid) pnb = tmedge[edid].pt[1];
			ptmp[0] += cp[pnb].coor[0];
			ptmp[1] += cp[pnb].coor[1];
			ptmp[2] += cp[pnb].coor[2];
			nedb++;
		}
	}
	cp[pid].coor[0] = ptmp[0] / double(nedb);
	cp[pid].coor[1] = ptmp[1] / double(nedb);
	cp[pid].coor[2] = ptmp[2] / double(nedb);

	//after smoothing
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_1) minJacob_1 = tmpJacob;
	}

	//if (minJacob_1 < minJacob_0)
	//{
	//	cp[pid].coor[0] = pold[0];
	//	cp[pid].coor[1] = pold[1];
	//	cp[pid].coor[2] = pold[2];
	//}
}

void TruncatedTspline_3D::LaplaceSmooth_Boundary_Sharp(int pid)
{
	//before smoothing
	double minJacob_0(1.e5), minJacob_1(1.e5), tmpJacob, GaussPos[3];
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_0) minJacob_0 = tmpJacob;
	}

	//smoothing
	double ptmp[3] = { 0.,0.,0., };
	double pold[3] = { cp[pid].coor[0],cp[pid].coor[1], cp[pid].coor[2] };
	int nedb(0);
	for (uint i = 0; i < cp[pid].edge.size(); i++)
	{
		if (tmedge[cp[pid].edge[i]].sharp == 1)
		{
			int edid(cp[pid].edge[i]);
			int pnb(tmedge[edid].pt[0]);
			if (pnb == pid) pnb = tmedge[edid].pt[1];
			ptmp[0] += cp[pnb].coor[0];
			ptmp[1] += cp[pnb].coor[1];
			ptmp[2] += cp[pnb].coor[2];
			nedb++;
		}
	}
	cp[pid].coor[0] = ptmp[0] / double(nedb);
	cp[pid].coor[1] = ptmp[1] / double(nedb);
	cp[pid].coor[2] = ptmp[2] / double(nedb);

	//after smoothing
	for (uint i = 0; i < cp[pid].hex.size(); i++)
	{
		GetHexMinJacob(cp[pid].hex[i], tmpJacob, GaussPos);
		if (tmpJacob < minJacob_1) minJacob_1 = tmpJacob;
	}

	if (minJacob_1 < minJacob_0)
	{
		cp[pid].coor[0] = pold[0];
		cp[pid].coor[1] = pold[1];
		cp[pid].coor[2] = pold[2];
	}
}

void TruncatedTspline_3D::SetSharpFeature_Manual(string fn)
{
	ifstream fin;
	fin.open(fn);
	vector<int> pshp;
	//if (fin.is_open())
	//{
	//	string oneline;
	//	int itmp;
	//	while (getline(fin, oneline))
	//	{
	//		istringstream is(oneline);
	//		is >> itmp;
	//		pshp.push_back(itmp);
	//	}
	//	//int nshp;
	//	//string stmp;
	//	//fin >> stmp >> nshp;
	//	//pshp.resize(nshp);
	//	//for (int i = 0; i < nshp; i++)
	//	//{
	//	//	fin >> pshp[i];
	//	//}
	//	fin.close();
	//}
	//else
	//{
	//	cerr << "Can't open " << fn << "!\n";
	//	return;
	//}

	vector<int> itmp_vec;
	if (fin.is_open())
	{
		string oneline;
		int itmp;
		while (getline(fin, oneline))
		{
			istringstream is(oneline);
			while (is >> itmp)
				itmp_vec.push_back(itmp);
			pshp.push_back(itmp_vec.back());
		}
		//int nshp;
		//string stmp;
		//fin >> stmp >> nshp;
		//pshp.resize(nshp);
		//for (int i = 0; i < nshp; i++)
		//{
		//	fin >> pshp[i];
		//}
		fin.close();
	}
	else
	{
		cerr << "Can't open " << fn << "!\n";
		return;
	}

	for (uint i = 0; i < pshp.size(); i++)
	{
		if (cp[pshp[i]].type == 1)
		{
			cp[pshp[i]].sharp = 1;
		}
	}

	for (uint i = 0; i < tmedge.size(); i++)
	{
		if (tmedge[i].type == 1 && cp[tmedge[i].pt[0]].sharp == 1 && cp[tmedge[i].pt[1]].sharp == 1)
		{
			tmedge[i].sharp = 1;
		}
	}

	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].sharp == 1)
		{
			int nshp(0);
			for (uint j = 0; j < cp[i].edge.size(); j++)
			{
				if (tmedge[cp[i].edge[j]].sharp == 1)
				{
					nshp++;
				}
			}
			if (nshp >= 3 || nshp == 1) cp[i].sharp = 2;//sharp corner
			else if (nshp == 0) cp[i].sharp = 0;
		}
	}
}

bool TruncatedTspline_3D::ComputeElementNormal_Quad(int cnct[4], array<double, 3>& normal_quad)
{

	double vector_1[3], vector_2[3];


	vector_1[0] = hcp[0][cnct[1]].coor[0] - hcp[0][cnct[0]].coor[0];
	vector_1[1] = hcp[0][cnct[1]].coor[1] - hcp[0][cnct[0]].coor[1];
	vector_1[2] = hcp[0][cnct[1]].coor[2] - hcp[0][cnct[0]].coor[2];

	vector_2[0] = hcp[0][cnct[3]].coor[0] - hcp[0][cnct[0]].coor[0];
	vector_2[1] = hcp[0][cnct[3]].coor[1] - hcp[0][cnct[0]].coor[1];
	vector_2[2] = hcp[0][cnct[3]].coor[2] - hcp[0][cnct[0]].coor[2];
	//cout <<"Test"<< vector_1[0] << endl;
	CrossProduct(vector_1, vector_2, normal_quad);
	//cout << "Test" << normal_quad[0] << endl;


	return true;
}

bool TruncatedTspline_3D::CrossProduct(double vector_1[3], double vector_2[3], array<double, 3>& result)
{
	result[0] = vector_1[1] * vector_2[2] - vector_1[2] * vector_2[1];
	result[1] = vector_1[2] * vector_2[0] - vector_1[0] * vector_2[2];
	result[2] = vector_1[0] * vector_2[1] - vector_1[1] * vector_2[0];
	/*cout << "Test_result" << result[0] << endl;*/
	return true;
}

bool TruncatedTspline_3D::DotProduct(vector<array<double, 3>> check_normal_surface_from_edge, double &angle)
{
	double x1 = check_normal_surface_from_edge[0][0];
	double y1 = check_normal_surface_from_edge[0][1];
	double z1 = check_normal_surface_from_edge[0][2];
	double x2 = check_normal_surface_from_edge[1][0];
	double y2 = check_normal_surface_from_edge[1][1];
	double z2 = check_normal_surface_from_edge[1][2];


	/*cout << "test" << endl;
	for (uint k = 0; k < 3; k++)
	{
		cout << check_normal_surface_from_edge[0][k] << "  " ;
	}
	cout << endl;

	cout << "test" << endl;
	for (uint k = 0; k < 3; k++)
	{
		cout << check_normal_surface_from_edge[1][k] << "  ";
	}
	cout << endl;

	getchar();*/

	double dot = x1 * x2 + y1 * y2 + z1 * z2;
	double lenSq1 = x1 * x1 + y1 * y1 + z1 * z1;
	double lenSq2 = x2 * x2 + y2 * y2 + z2 * z2;
	angle = acos(dot / sqrt(lenSq1 * lenSq2));

	/*cout << "test2" << endl;
	cout<<dot<<" "<< lenSq1 <<" "<< lenSq2<<endl;


	cout << angle << endl;

	getchar();*/

	return true;
}

void TruncatedTspline_3D::SetSharpFeature_Manual_Yu(string fn)
{
	ifstream fin;
	fin.open(fn);
	vector<int> pshp;
	/*if (fin.is_open())
	{
		string oneline;
		int itmp;
		while (getline(fin, oneline))
		{
			istringstream is(oneline);
			is >> itmp;
			pshp.push_back(itmp);
		}
		fin.close();
	}
	else
	{
		cerr << "Can't open " << fn << "!\n";
		return;
	}*/

	vector<int> itmp_vec;
	if (fin.is_open())
	{
		string oneline;
		int itmp;
		while (getline(fin, oneline))
		{
			istringstream is(oneline);
			while (is >> itmp)
				itmp_vec.push_back(itmp);
			pshp.push_back(itmp_vec.back());
		}
		//int nshp;
		//string stmp;
		//fin >> stmp >> nshp;
		//pshp.resize(nshp);
		//for (int i = 0; i < nshp; i++)
		//{
		//	fin >> pshp[i];
		//}
		fin.close();
	}
	else
	{
		cerr << "Can't open " << fn << "!\n";
		return;
	}

	for (uint i = 0; i < pshp.size(); i++)
	{
		if (hcp[0][pshp[i]].type == 1)
		{
			hcp[0][pshp[i]].sharp = 1;
		}
	}

	for (uint i = 0; i < hedge[0].size(); i++)
	{
		if (hedge[0][i].type == 1 && hcp[0][hedge[0][i].pt[0]].sharp == 1 && hcp[0][hedge[0][i].pt[1]].sharp == 1)
		{
			hedge[0][i].sharp = 1;
		}
	}

	for (uint i = 0; i < hcp[0].size(); i++)
	{
		if (hcp[0][i].sharp == 1)
		{
			int nshp(0);
			for (uint j = 0; j < hcp[0][i].edge.size(); j++)
			{
				if (hedge[0][hcp[0][i].edge[j]].sharp == 1)
				{
					nshp++;
				}
			}
			if (nshp >= 3 || nshp == 1) hcp[0][i].sharp = 2;//sharp corner
			else if (nshp == 0) hcp[0][i].sharp = 0;
		}
	}
	vector<array<double, 3>> check_normal_surface_from_edge;
	array<double, 3> normal_quad;
	double angle;
	double tol(1.e-2);
	for (uint i = 0; i < hedge[0].size(); i++)
	{
		if (hedge[0][i].sharp == 1)
		{
			if (hcp[0][hedge[0][i].pt[0]].sharp == 0 || hcp[0][hedge[0][i].pt[1]].sharp == 0)
			{
				hedge[0][i].sharp = 0;
			}

		}

		if (hedge[0][i].sharp == 1)
		{
			check_normal_surface_from_edge.clear();
			for (uint j = 0; j < hedge[0][i].face.size(); j++)
			{
				if (hface[0][hedge[0][i].face[j]].type == 1)
				{
					ComputeElementNormal_Quad(hface[0][hedge[0][i].face[j]].cnct, normal_quad);
					check_normal_surface_from_edge.push_back(normal_quad);

					/*for (uint k = 0; k < 4; k++)
					{
						cout << hedge[0][i].face[j] <<": "<< hface[0][hedge[0][i].face[j]].cnct[k] << endl;
					}

					cout << "normal1" << endl;
					for (uint k = 0; k < 3; k++)
					{
						cout << check_normal_surface_from_edge[0][k] << " " ;
					}
					cout << "normal2" << endl;
					for (uint k = 0; k < 3; k++)
					{
						cout << check_normal_surface_from_edge[1][k] << " ";
					}*/

				}
			}
			//cout<<"test angle:"<<acos(1)	<<endl;

			/*if (i==12803)
			{
				DotProduct(check_normal_surface_from_edge, angle);
				cout <<"test34"<< angle << endl;
			}*/

			if (check_normal_surface_from_edge.size() == 2)
			{
				DotProduct(check_normal_surface_from_edge, angle);
				//cout <<"test34"<< angle << endl;
				//if(hedge[0][i].pt[0]==2532)
				if (angle<tol || angle>3.13 - tol)
				{
					//cout << "get normal" << endl;
					//cout << angle << endl;
					hedge[0][i].sharp = 0;
				}

			}


		}

	}
	//getchar();
}







/////////////////////////////////////////////////////////////////////////////////////////////



void TruncatedTspline_3D::QualityImprove()
{

}

void TruncatedTspline_3D::Preprocess()
{
	int pillow_flag = IsPillowNeeded();
	if (pillow_flag != 0)
	{
		Pillow(pillow_flag);
		QualityImprove();
	}
}

void TruncatedTspline_3D::SetType_UB()
{
	//0 - interior regular (default); 1 - boundary regular; 2 - interior irregular; 3 - boundary irregular
	//int ed0[6][4] = { { 4, 5, 6, 7 }, { 1, 3, 9, 11 }, { 0, 2, 8, 10 }, { 1, 3, 9, 11 }, { 0, 2, 8, 10 }, { 4, 5, 6, 7 } };//order could be wrong, but doesn't matter
	uint i, j;
	for (i = 0; i < cp.size(); i++)
	{
		cp[i].type = 0;
	}
	for (i = 0; i < tmedge.size(); i++)
	{
		tmedge[i].type = 0;
	}
	for (i = 0; i < tmesh.size(); i++)
	{
		tmesh[i].type = 0;
	}
	//find BC face, edge, vertex
	for (i = 0; i<tmface.size(); i++)
	{
		if (tmface[i].hex.size() == 1)
		{
			tmface[i].type = 1;
			tmesh[tmface[i].hex[0]].type = 1;
			for (j = 0; j<4; j++)
			{
				cp[tmface[i].cnct[j]].type = 1;
				tmedge[tmface[i].edge[j]].type = 1;
			}
			//set zero length edges
			//int hexid(tmface[i].hex[0]);
			//int* it=find(tmesh[hexid].face,tmesh[hexid].face+6,i);
			//int fc_loc(it-tmesh[hexid].face);
			//for(j=0; j<4; j++)
			//{
			//	tmedge[tmesh[hexid].edge[ed0[fc_loc][j]]].len=0.;
			//}
		}
	}
	for (i = 0; i < tmesh.size(); i++)//boundary elements
	{
		if (tmesh[i].type == 0)
		{
			for (j = 0; j < 8; j++)
			{
				if (cp[tmesh[i].cnct[j]].type == 1)
				{
					tmesh[i].type = 1;
					break;
				}
			}
		}
	}
	//find extraordinary edges and vertices
	for (i = 0; i<tmedge.size(); i++)
	{
		if (tmedge[i].type == 0 && tmedge[i].hex.size() != 4)
		{
			tmedge[i].type = 2;
			//if (cp[tmedge[i].pt[0]].type != 1)
			//	cp[tmedge[i].pt[0]].type = 3;
			//if (cp[tmedge[i].pt[1]].type != 1)
			//	cp[tmedge[i].pt[1]].type = 3;
		}
		else if (tmedge[i].type == 1 && tmedge[i].hex.size() > 2)
		{
			tmedge[i].type = 3;
		}
		//else if (tmedge[i].type == 1 && tmedge[i].hex.size() == 1)//need pillowing
		//{
		//	tmedge[i].type = 4;
		//}
	}
	//boundary
	//for(i=0; i<cp.size(); i++)
	//{
	//	if(cp[i].type==1)//not consider surface extraordinary points yet
	//	{
	//		//int val(0);
	//		//for(j=0; j<cp[i].face.size(); j++)
	//		//{
	//		//	if(tmface[cp[i].face[j]].type==1) val++;
	//		//}
	//		//if(val==3 || val>4) cp[i].type=13;
	//	}
	//}
	//find irregular elements
	for (i = 0; i<tmesh.size(); i++)
	{
		if (tmesh[i].type == 0)
		{
			for (j = 0; j<12; j++)
			{
				if (tmedge[tmesh[i].edge[j]].type == 2)
				{
					tmesh[i].type = 2;
					break;
				}
			}
			//additional
			for (j = 0; j<8; j++)
			{
				if (cp[tmesh[i].cnct[j]].type == 3)
				{
					tmesh[i].type = 2;
					break;
				}
			}
		}
		else if (tmesh[i].type == 1)
		{

		}
	}
	//boundry extraordinary points
	for (i = 0; i<cp.size(); i++)
	{
		if (cp[i].type == 1)
		{
			int count(0);
			for (j = 0; j < cp[i].edge.size(); j++)
			{
				if (tmedge[cp[i].edge[j]].type == 2) count++;
			}
			if (count == 1) cp[i].bcxp = 1;
			else if (count>1) cp[i].bcxp = 2;
		}
	}

	//check 3D EP
	int n3d(0);
	for (i = 0; i < cp.size(); i++)
	{
		if (cp[i].type == 3)
		{
			int ned(0);
			for (j = 0; j < cp[i].edge.size(); j++)
			{
				if (tmedge[cp[i].edge[j]].type == 2)
				{
					ned++;
				}
			}
			if (ned>2)
			{
				n3d++;
			}
		}
	}
	cout << "# 3D EP: " << n3d << "\n";
	//getchar();
}

void TruncatedTspline_3D::Run_UBsplines(string fn, int nrf, vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	InitializeMesh_UB(fn);
	for (int i = 0; i < nrf; i++)
	{
		//Global_Subdivide_wBezier();
		//Global_Subdivide_UB();
	}
	//BuildSplines_UB();
	//BezierExtract_UBsplines(bzmesh, IDBC, gh);

	//PatchTest_BC(IDBC, gh);
	//UserDefineIDBC(IDBC, gh);//fertility

	//StrongDirichletBC_Elasticity(bzmesh, IDBC, gh);
	//StrongDirichletBC_Elasticity_FromFile(bzmesh, IDBC, gh);
}

void TruncatedTspline_3D::BezierExtract_UBsplines(vector<BezierElement3D>& bzmesh, vector<int>& IDBC, vector<double>& gh)
{
	vector<int> aflag(cp.size(), 0);
	vector<int> aloc(cp.size(), -1);
	int count(0);
	for (uint i = 0; i < tmesh.size(); i++)
	{
		if (tmesh[i].bzflag == 0)
		{
			for (uint j = 0; j < tmesh[i].IEN.size(); j++)
			{
				aflag[tmesh[i].IEN[j]] = 1;
			}
		}
		else
		{
			cerr << "Wrong: bzflag is 1 in the comparison case!\n"; getchar();
		}
	}
	for (uint i = 0; i < cp.size(); i++)
	{
		if (aflag[i] == 1)
		{
			aloc[i] = count++;
		}
	}
	cpa.clear();
	cpa.resize(count);
	count = 0;
	for (uint i = 0; i < cp.size(); i++)
	{
		if (aflag[i] == 1)
		{
			cpa[count][0] = cp[i].coor[0];
			cpa[count][1] = cp[i].coor[1];
			cpa[count][2] = cp[i].coor[2];
			count++;
		}
	}

	IDBC.clear();
	IDBC.resize(count + bzcp.size());//bzcp.size()==0
	for (uint i = 0; i < IDBC.size(); i++)
	{
		IDBC[i] = i;//boundary weakly imposed
	}
	gh.clear();
	gh.resize(IDBC.size());//initial guess for iterative solvers
	count = 0;
	//double xcoor[3];
	array<double, 3> xcoor;
	for (uint i = 0; i < cp.size(); i++)
	{
		if (aflag[i] == 1)
		{
			xcoor[0] = cp[i].coor[0];
			xcoor[1] = cp[i].coor[1];
			xcoor[2] = cp[i].coor[2];
			//gh[count] = SpecifyDirichBC(xcoor);
			gh[count] = exact_sol(xcoor);
			count++;
		}
	}
	for (uint i = 0; i < bzcp.size(); i++)
	{
		//gh[count + i] = SpecifyDirichBC(bzcp[i].data());
		gh[count + i] = exact_sol(bzcp[i]);
	}

	cout << "Bezier extracting...\n";
	cout << "# Bezier: " << tmesh.size() << "\n";
	bzmesh.resize(tmesh.size());
#pragma omp parallel for
	for (int eid = 0; eid < tmesh.size(); eid++)
	{
		if (eid != 0 && eid % 500 == 0)
		{
			cout << eid << " ";
		}
		//find types of interfaces
		//if (tmesh[eid].bzflag == 1)
		if (tmesh[eid].bzflag == 0)
		{
			for (int k = 0; k < 6; k++)
			{
				if (tmface[tmesh[eid].face[k]].hex.size() == 1)//must be a boundary element
				{
					bzmesh[eid].bc[k] = 1;//boundary face for boundary condition
										  //bzmesh[eid].bcflag = 1;
				}
				//else if (tmface[tmesh[eid].face[k]].hex.size() == 2)
				//{
				//	int hxnb(tmface[tmesh[eid].face[k]].hex[0]);
				//	if (hxnb == eid) hxnb = tmface[tmesh[eid].face[k]].hex[1];
				//	if (tmesh[hxnb].bzflag == 0)
				//	{
				//		bzmesh[eid].bc[k] = 2;//coupling interface
				//		bzmesh[eid].bzcouple = 1;
				//	}
				//}
			}
		}

		double tmp;
		bzmesh[eid].type = tmesh[eid].type;//used for visualization
		bzmesh[eid].bzflag = tmesh[eid].bzflag;
		if (bzmesh[eid].bzcouple == 0)
		{
			if (tmesh[eid].bzflag == 0)
			{
				bzmesh[eid].IEN.resize(tmesh[eid].IEN.size());
				bzmesh[eid].cmat.resize(tmesh[eid].IEN.size(), vector<double>(64));
				for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
				{
					bzmesh[eid].IEN[k] = aloc[tmesh[eid].IEN[k]];//some IEN may be -1
					for (int k1 = 0; k1 < 64; k1++)
					{
						tmp = tmesh[eid].bemat[k][k1];
						bzmesh[eid].cmat[k][k1] = tmp;
						bzmesh[eid].pts[k1][0] += tmp * cp[tmesh[eid].IEN[k]].coor[0];
						bzmesh[eid].pts[k1][1] += tmp * cp[tmesh[eid].IEN[k]].coor[1];
						bzmesh[eid].pts[k1][2] += tmp * cp[tmesh[eid].IEN[k]].coor[2];
					}
				}
			}
			else
			{
				bzmesh[eid].IENb.resize(tmesh[eid].IENb.size());//64
				for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
				{
					bzmesh[eid].IENb[k] = tmesh[eid].IENb[k] + count;
					bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
					bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
					bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
				}
			}
		}
		else//bzflag must be 1
		{
			bzmesh[eid].IEN.resize(tmesh[eid].IEN.size());
			bzmesh[eid].cmat.resize(tmesh[eid].IEN.size(), vector<double>(64));
			for (uint k = 0; k < tmesh[eid].IEN.size(); k++)
			{
				bzmesh[eid].IEN[k] = aloc[tmesh[eid].IEN[k]];
				for (int k1 = 0; k1 < 64; k1++)
				{
					bzmesh[eid].cmat[k][k1] = tmesh[eid].bemat[k][k1];
				}
			}
			bzmesh[eid].IENb.resize(tmesh[eid].IENb.size());
			for (uint k = 0; k < tmesh[eid].IENb.size(); k++)
			{
				bzmesh[eid].IENb[k] = tmesh[eid].IENb[k] + count;
				bzmesh[eid].pts[k][0] = bzcp[tmesh[eid].IENb[k]][0];
				bzmesh[eid].pts[k][1] = bzcp[tmesh[eid].IENb[k]][1];
				bzmesh[eid].pts[k][2] = bzcp[tmesh[eid].IENb[k]][2];
			}
		}
	}
}







void TruncatedTspline_3D::SplitPolyCube(string fn)
{
	InitializeMesh(fn);
	vector<int> elist;
	vector<array<int, 3>> stype;
	//IdentifyHex_Honda2(elist,stype);
	IdentifyHex_NAVAIR(elist, stype);
	for (uint i = 0; i < stype.size(); i++)
	{
		if (stype[i][0] == 1)
		{
			SplitHexOneDir(elist[i], stype[i][1], stype[i][2]);
		}
		//else if (stype[i][0] == 2)//not in use
		//{
		//	SplitHexTwoDir(elist[i], stype[i][1], stype[i][2]);
		//}
		//else if (stype[i][0] == 3)//not in use
		//{
		//	SplitHexThrDir(elist[i], stype[i][2]);
		//}
	}
	//RemoveRepeatPoint();
	OutputCM(fn);
}

void TruncatedTspline_3D::IdentifyHex_Honda2(vector<int>& elist, vector<array<int, 3>>& stype)
{
	int eddir[12][3] = { {2,8,10},{3,9,11},{0,8,10},{1,9,11},{5,6,7},{4,6,7},{4,5,7},{4,5,6},{0,2,10},{1,3,11},{0,2,8},{1,3,9} };
	int rfdir[12] = { 0,1,0,1,2,2,2,2,0,1,0,1 };

	//int edpt[1][2] = { {125,137} };
	//int edpt[6][2] = { {52,152},{1,138},{110,111},{105,111},{104,105},{104,110} };
	//int edpt[8][2] = { { 154,156 },{ 154,155 },{ 155,160 },{ 80,81 },{ 81,83 },{ 82,83 },{80,82},{96,100} };
	//int edpt[1][2] = { { 99,100 } };
	//int edpt[2][2] = { { 87,96 },{63,73} };
	int edpt[1][2] = { { 88,103 } };
	int ned(1);
	vector<int> flag(tmedge.size(), 0);
	int count(0);
	for (uint i = 0; i < tmedge.size(); i++)
	{
		for (int j = 0; j < ned; j++)
		{
			if ((tmedge[i].pt[0] == edpt[j][0] && tmedge[i].pt[1] == edpt[j][1]) ||
				(tmedge[i].pt[0] == edpt[j][1] && tmedge[i].pt[1] == edpt[j][0]))
			{
				flag[i] = 1;
				count++;
				break;
			}
		}
		
	}
	vector<int> hxdir(tmesh.size(), -1);
	while (count > 0)
	{
		count = 0;
		for (uint i = 0; i < tmedge.size(); i++)
		{
			if (flag[i] == 1)
			{
				for (uint j = 0; j < tmedge[i].hex.size(); j++)
				{
					int hxid(tmedge[i].hex[j]);
					if (hxdir[hxid] == -1)
					{
						int* it = find(tmesh[hxid].edge, tmesh[hxid].edge + 12, i);
						int pos(it - tmesh[hxid].edge);
						if (pos == 12)
						{
							cerr << "Can't find edge in neighboring element!\n";
							break;
						}
						hxdir[hxid] = rfdir[pos];
						for (int k = 0; k < 3; k++)
						{
							if (flag[tmesh[hxid].edge[eddir[pos][k]]] == 0)
							{
								flag[tmesh[hxid].edge[eddir[pos][k]]] = 1;
								count++;
							}
						}
					}
				}
			}
		}
	}
	elist.clear();
	stype.clear();
	int nsp(2-1);//newly inserted points per direction
	for (uint i = 0; i < tmesh.size(); i++)
	{
		if (hxdir[i] != -1)
		{
			elist.push_back(i);
			array<int, 3> tmp = { 1,hxdir[i],nsp };
			stype.push_back(tmp);
		}
	}
}

void TruncatedTspline_3D::IdentifyHex_NAVAIR(vector<int>& elist, vector<array<int, 3>>& stype)
{
	int eddir[12][3] = { { 2,8,10 },{ 3,9,11 },{ 0,8,10 },{ 1,9,11 },{ 5,6,7 },{ 4,6,7 },{ 4,5,7 },{ 4,5,6 },{ 0,2,10 },{ 1,3,11 },{ 0,2,8 },{ 1,3,9 } };
	int rfdir[12] = { 0,1,0,1,2,2,2,2,0,1,0,1 };

	//int edpt[68][2] = { {266,267},{267,268},{268,269},{266,269},{262,263},{264,265},{262,265},{258,259},{260,261},{258,261},
	//{254,255},{256,257},{254,257},{250,251},{252,253},{250,253},{246,247},{248,249},{246,249},{242,243},{244,245},{242,245},
	//{238,239},{240,241},{238,241},{234,235},{236,237},{234,237},{36,37},{37,38},{38,39},{36,39},{32,33},{34,35},{32,35},
	//{28,29},{30,31},{28,31},{24,25},{26,27},{24,27},{20,21},{22,23},{20,23},{16,17},{18,19},{16,19},{12,13},{14,15},{12,15},
	//{8,9},{10,11},{8,11},{4,5},{6,7},{4,7},{405,408},{73,74},{72,75},{68,71},{64,67},{60,63},{56,59},{52,55},{48,51},{44,47},
	//{40,43},{407,408} };
	//int edpt[28][2] = { {4,76},{8,77},{12,78},{16,79},{20,80},{24,81},{28,82},{32,83},{36,84},{40,86},{44,87},{48,88},{52,89},{56,90},
	//{60,91},{64,92},{68,93},{72,94},{234,270},{238,271},{242,272},{246,273},{250,274},{254,275},{258,276},{262,277},{266,278},{404,408} };
	//int edpt[][2] = { {232,292}, };
	//int edpt[][2] = { { 1,117 }, };
	int edpt[][2] = { { 404,417 }, };
	int ned(1);
	vector<int> flag(tmedge.size(), 0);
	int count(0);
	for (uint i = 0; i < tmedge.size(); i++)
	{
		for (int j = 0; j < ned; j++)
		{
			if ((tmedge[i].pt[0] == edpt[j][0] && tmedge[i].pt[1] == edpt[j][1]) ||
				(tmedge[i].pt[0] == edpt[j][1] && tmedge[i].pt[1] == edpt[j][0]))
			{
				flag[i] = 1;
				count++;
				break;
			}
		}

	}
	vector<int> hxdir(tmesh.size(), -1);
	while (count > 0)
	{
		count = 0;
		for (uint i = 0; i < tmedge.size(); i++)
		{
			if (flag[i] == 1)
			{
				for (uint j = 0; j < tmedge[i].hex.size(); j++)
				{
					int hxid(tmedge[i].hex[j]);
					if (hxdir[hxid] == -1)
					{
						int* it = find(tmesh[hxid].edge, tmesh[hxid].edge + 12, i);
						int pos(it - tmesh[hxid].edge);
						if (pos == 12)
						{
							cerr << "Can't find edge in neighboring element!\n";
							break;
						}
						hxdir[hxid] = rfdir[pos];
						for (int k = 0; k < 3; k++)
						{
							if (flag[tmesh[hxid].edge[eddir[pos][k]]] == 0)
							{
								flag[tmesh[hxid].edge[eddir[pos][k]]] = 1;
								count++;
							}
						}
					}
				}
			}
		}
	}
	elist.clear();
	stype.clear();
	int nsp(2 - 1);//newly inserted points per direction
	for (uint i = 0; i < tmesh.size(); i++)
	{
		if (hxdir[i] != -1)
		{
			elist.push_back(i);
			array<int, 3> tmp = { 1,hxdir[i],nsp };
			stype.push_back(tmp);
		}
	}
}

void TruncatedTspline_3D::SplitHexOneDir(int eid, int dir, int np)
{
	int pr[3][4][2] = { {{0,1},{3,2},{4,5},{7,6}},{ { 0,3 },{ 1,2 },{ 4,7 },{ 5,6 } },{ { 0,4 },{ 1,5 },{ 3,7 },{ 2,6 } } };
	int cn1[3][4] = { {0,3,4,7},{0,1,4,5},{0,1,3,2} };
	int cn2[3][4] = { { 1,2,5,6 },{ 3,2,7,6 },{ 4,5,7,6 } };
	vector<int> pid(4 * (np + 2));
	double c[2];
	int loc(0);
	for (int i = 0; i < 4; i++)
	{
		pid[loc] = tmesh[eid].cnct[cn1[dir][i]];
		loc++;
	}
	for (int il = 0; il < np; il++)
	{
		c[1] = double(il + 1) / double(np + 1);
		c[0] = 1. - c[1];
		for (int i = 0; i < 4; i++)
		{
			Vertex3D vtmp;
			vtmp.coor[0] = c[0] * cp[tmesh[eid].cnct[pr[dir][i][0]]].coor[0] + c[1] * cp[tmesh[eid].cnct[pr[dir][i][1]]].coor[0];
			vtmp.coor[1] = c[0] * cp[tmesh[eid].cnct[pr[dir][i][0]]].coor[1] + c[1] * cp[tmesh[eid].cnct[pr[dir][i][1]]].coor[1];
			vtmp.coor[2] = c[0] * cp[tmesh[eid].cnct[pr[dir][i][0]]].coor[2] + c[1] * cp[tmesh[eid].cnct[pr[dir][i][1]]].coor[2];
			cp.push_back(vtmp);
			pid[loc] = cp.size() - 1;
			loc++;
		}
	}
	for (int i = 0; i < 4; i++)
	{
		pid[loc] = tmesh[eid].cnct[cn2[dir][i]];
		loc++;
	}
	int iloc[4] = { 0,1,3,2 };
	for (int i = 0; i < np + 1; i++)
	{
		Element3D etmp;
		etmp.act = 1;
		int ist1(4 * i), ist2(4 * (i + 1));
		if (dir == 1)
		{
			for (int j = 0; j < 4; j++)
			{
				etmp.cnct[j+4] = pid[ist1 + iloc[j]];
				etmp.cnct[j] = pid[ist2 + iloc[j]];
			}
		}
		else
		{
			for (int j = 0; j < 4; j++)
			{
				etmp.cnct[j] = pid[ist1 + iloc[j]];
				etmp.cnct[j + 4] = pid[ist2 + iloc[j]];
			}
		}
		tmesh.push_back(etmp);
	}

	tmesh[eid].act = 0;
}

void TruncatedTspline_3D::OutputCornerPoint(string fn)
{
	double axis[3][3] = { {1.,0.,0.},{0.,1.,0.},{0.,0.,1.} };
	double tol(1.e-8);
	InitializeMesh(fn);
	vector<int> cnlist;
	for (uint i = 0; i < cp.size(); i++)
	{
		if (cp[i].type == 1)
		{
			double vtmp[2][3], tmp[2];
			int flag[3] = { 0,0,0 };
			for (uint j = 0; j < cp[i].face.size(); j++)
			{
				int fcid(cp[i].face[j]);
				if (tmface[fcid].type == 1)
				{
					vtmp[0][0] = cp[tmface[fcid].cnct[1]].coor[0] - cp[tmface[fcid].cnct[0]].coor[0];
					vtmp[0][1] = cp[tmface[fcid].cnct[1]].coor[1] - cp[tmface[fcid].cnct[0]].coor[1];
					vtmp[0][2] = cp[tmface[fcid].cnct[1]].coor[2] - cp[tmface[fcid].cnct[0]].coor[2];
					vtmp[1][0] = cp[tmface[fcid].cnct[3]].coor[0] - cp[tmface[fcid].cnct[0]].coor[0];
					vtmp[1][1] = cp[tmface[fcid].cnct[3]].coor[1] - cp[tmface[fcid].cnct[0]].coor[1];
					vtmp[1][2] = cp[tmface[fcid].cnct[3]].coor[2] - cp[tmface[fcid].cnct[0]].coor[2];
					for (int k = 0; k < 3; k++)
					{
						tmp[0] = vtmp[0][0] * axis[k][0] + vtmp[0][1] * axis[k][1] + vtmp[0][2] * axis[k][2];
						tmp[1] = vtmp[1][0] * axis[k][0] + vtmp[1][1] * axis[k][1] + vtmp[1][2] * axis[k][2];
						if (fabs(tmp[0]) < tol && fabs(tmp[1]) < tol)
						{
							flag[k] = 1;
						}
					}
				}
			}
			if (flag[0] == 1 && flag[1] == 1 && flag[2] == 1)
			{
				cnlist.push_back(i);
			}
		}
	}

	string fname(fn + "_cn.vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << cnlist.size() << " float\n";
		for (uint i = 0; i < cnlist.size(); i++)
		{
			fout << cp[cnlist[i]].coor[0] << " " << cp[cnlist[i]].coor[1] << " " << cp[cnlist[i]].coor[2] << "\n";
		}
		fout << "\nCELLS " << cnlist.size() << " " << 2 * cnlist.size() << '\n';
		for (uint i = 0; i < cnlist.size(); i++)
		{
			fout << "1 " << i << "\n";
		}
		fout << "\nCELL_TYPES " << cnlist.size() << '\n';
		for (uint i = 0; i<cnlist.size(); i++)
		{
			fout << "1\n";
		}
		fout.close();
	}
	else
	{
		cerr << "Can't open " << fname << "!\n";
	}
	string fname1(fn + "_CornerPoints.txt");
	fout.open(fname1.c_str());
	if (fout.is_open())
	{
		for (uint i = 0; i < cnlist.size(); i++)
		{
			fout << cnlist[i] << " " << cp[cnlist[i]].coor[0] << " " << cp[cnlist[i]].coor[1] << " " << cp[cnlist[i]].coor[2] << "\n";
		}
		fout.close();
	}
}







//////////////////////////////////////////////////////////

void ManualPolycube_Honda2(string fn)
{
	vector<array<double, 3>> pts;
	vector<array<int, 8>> cube;
	//cube 1
	double a[3] = {10.,2.,3.};//given
	double pt1[21][3] = { {0.,0.,0.},{a[1],a[1],0.},{a[2],a[2],0.},
	{a[0],0.,0.},{a[0] - a[1],a[1],0.},{ a[0] - a[2],a[2],0. },
	{ a[0],a[0],0. },{ a[0] - a[1],a[0] - a[1],0. },{ a[0] - a[2],a[0] - a[2],0. },
	{ 0.,a[0],0. },{ a[1],a[0] - a[1],0. },{ a[2],a[0] - a[2],0. }};
	int pair1[3][2] = { {9,6},{10,7},{11,8} };
	double alpha1[3] = { 1. / a[0],3. / a[0],9. / a[0] };//given
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			int k(12 + 3 * i + j);
			pt1[k][0] = alpha1[i] * pt1[pair1[j][1]][0] + (1. - alpha1[i])*pt1[pair1[j][0]][0];
			pt1[k][1] = alpha1[i] * pt1[pair1[j][1]][1] + (1. - alpha1[i])*pt1[pair1[j][0]][1];
			pt1[k][2] = alpha1[i] * pt1[pair1[j][1]][2] + (1. - alpha1[i])*pt1[pair1[j][0]][2];
		}
	}
	double z12[2] = { 0.,10. };
	int qd1[14][4] = { {0,3,4,1},{1,4,5,2},{3,6,7,4},{4,7,8,5},{10,13,12,9},{13,16,15,12},{16,19,18,15},{19,7,6,18},
	{11,14,13,10},{14,17,16,13},{17,20,19,16},{20,8,7,19},{0,1,10,9},{1,2,11,10} };

	//cube 2
	double x2[11] = {pt1[9][0],pt1[12][0], pt1[15][0], pt1[18][0], pt1[6][0], 
		pt1[15][0]+1.,pt1[18][0] - 3.,pt1[18][0] - 2.,pt1[6][0] + 2.,pt1[6][0] + 27.,pt1[6][0] + 37. };
	double y2[8] = { 35.,37.,38.,40.,42.,44.,46.,47. };
	double pt2[30][3] = { { x2[0],y2[3],0. },{ x2[1],y2[3],0. },{ x2[2],y2[3],0. },{ x2[3],y2[0],0. },{ x2[4],y2[0],0. },
	{ x2[4],y2[1],0.},{ x2[3],y2[2],0. },{ x2[7],y2[3],0. },{ x2[5],y2[4],0. },{ x2[6],y2[4],0. },{ x2[5],y2[5],0. },{ x2[6],y2[5],0. },
	{ x2[0],y2[6],0. },{ x2[1],y2[6],0. },{ x2[2],y2[6],0. },{ x2[7],y2[6],0. },
	{ x2[0],y2[7],0. },{ x2[1],y2[7],0. },{ x2[2],y2[7],0. },{ x2[7],y2[7],0. },{ x2[8],y2[2],0. },{ x2[8],y2[1],0. },
	{ x2[9],y2[1],0. },{ x2[9],y2[2],0. },{ x2[9],y2[6],0. },{ x2[9],y2[7],0. },
	{ x2[10],y2[1],0. },{ x2[10],y2[2],0. },{ x2[10],y2[6],0. },{ x2[10],y2[7],0. }};
	int qd2[24][4] = { {9,12,22,21},{12,15,23,22},{15,18,24,23},{18,6,25,24},{24,25,26,27},{23,24,27,28},{26,42,41,27},
	{27,41,36,28},{21,22,34,33},{22,23,35,34},{33,34,38,37},{34,35,39,38},{35,36,40,39},{23,28,30,29},{30,28,36,32},
	{31,32,36,35},{23,29,31,35},{42,43,44,41},{41,44,45,36},{36,45,46,40},{43,47,48,44},{44,48,49,45},{45,49,50,46} };

	//cube 3
	double org3[3] = { 0.,47.,0. };
	double y3_0[6] = {5.,7.,8.,12.,13.,15.};
	double y3[6] = { y3_0[0] + org3[1],y3_0[1] + org3[1], y3_0[2] + org3[1], y3_0[3] + org3[1], y3_0[4] + org3[1], y3_0[5] + org3[1] };
	double z3[5] = {2.,3.,7.,8.,10.};
	double pt3[14][3] = { {0.,org3[1], 0. },{ 0.,org3[1], z3[4] },{ 0.,y3[0], 0. },{ 0.,y3[0], z3[4] },
	{ 0.,y3[1], z3[0] },{ 0.,y3[1], z3[3] },{ 0.,y3[2], z3[1] },{ 0.,y3[2], z3[2] },{ 0.,y3[3], z3[1] },{ 0.,y3[3], z3[2] },
	{ 0.,y3[4], z3[0] },{ 0.,y3[4], z3[3] },{ 0.,y3[5], 0. },{ 0.,y3[5], z3[4] } };
	double x3[3] = {0.,1.,3.};
	int qd3[9][4] = { {0,1,3,2},{2,3,5,4},{4,5,7,6},{5,3,13,11},{7,5,11,9},{8,9,11,10},{10,11,13,12},{2,4,10,12},{4,6,8,10} };

	//cube 4
	int pid4[14] = { 1,4,2,5,11,14,17,20,8,10,13,16,19,7 };
	double z4[2][2] = { {-2.5,0.},{10.,12.5} };
	int qd4[7][4] = { {0,1,3,2},{3,1,13,8},{4,5,10,9},{5,6,11,10},{6,7,12,11},{7,8,13,12},{0,2,4,9} };

	/*int npt1(21), nel1(14);
	int npt2(30), nel2(24);
	for (int i = 0; i < npt1; i++)
	{
		array<double, 3> ptmp = { pt1[i][0],pt1[i][1], pt1[i][2] };
		pts.push_back(ptmp);
	}
	for (int i = 0; i < npt2; i++)
	{
		array<double, 3> ptmp = { pt1[i][0],pt1[i][1], pt1[i][2] };
		pts.push_back(ptmp);
	}

	int npt3(21), nel3(14);
	int npt4(21), nel4(14);
	for (int i = 0; i < npt1; i++)
	{
		array<double, 3> ptmp = { pt1[i][0],pt1[i][1], pt1[i][2] };
		pts.push_back(ptmp);
	}
	for (int i = 0; i < npt1; i++)
	{
		array<double, 3> ptmp = { pt1[i][0],pt1[i][1], z1 };
		pts.push_back(ptmp);
	}*/

	string fname(fn + ".vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		int npt1(21), nel1(14);
		int npt2(30), nel2(24), nlayer12(2);
		int npt3(14), nel3(9), nlayer3(3);
		int npt4(14), nel4(7), nblock4(2), nlayer4(2);
		int npt = (npt1 + npt2)*nlayer12 + npt3*nlayer3 + npt4*(nblock4*nlayer4);
		int nel = (nel1 + nel2)*(nlayer12 - 1) + nel3*(nlayer3 - 1) + nel4*(nblock4*(nlayer4 - 1));
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		//fout << "POINTS " << npt << " float\n";
		//for (uint i = 0; i<npt; i++)
		//{
		//	fout << pt1[pid4[i]][0] << " " << pt1[pid4[i]][1] << " " << pt1[pid4[i]][2] << "\n";
		//}
		//fout << "\nCELLS " << nel << " " << 5 * nel << '\n';
		//for (uint i = 0; i<nel; i++)
		//{
		//	fout << "4 ";
		//	for (int j = 0; j<4; j++)
		//	{
		//		fout << qd4[i][j] << ' ';
		//	}
		//	fout << '\n';
		//}
		//fout << "\nCELL_TYPES " << nel << '\n';
		//for (uint i = 0; i<nel; i++)
		//{
		//	fout << "9\n";
		//}

		fout << "POINTS " << npt << " float\n";
		for (int il = 0; il < nlayer12; il++)
		{
			for (int i = 0; i < npt1; i++)
			{
				fout << pt1[i][0] << " " << pt1[i][1] << " " << z12[il] << "\n";
			}
			for (int i = 0; i < npt2; i++)
			{
				fout << pt2[i][0] << " " << pt2[i][1] << " " << z12[il] << "\n";
			}
		}
		for (int il = 0; il < nlayer3; il++)
		{
			for (int i = 0; i < npt3; i++)
			{
				fout << x3[il] << " " << pt3[i][1] << " " << pt3[i][2] << "\n";
			}
		}
		for (int l1 = 0; l1 < nblock4; l1++)
		{
			for (int l2 = 0; l2 < nlayer4; l2++)
			{
				for (int i = 0; i < npt4; i++)
				{
					fout << pt1[pid4[i]][0] << " " << pt1[pid4[i]][1] << " " << z4[l1][l2] << "\n";
				}
			}
		}
		int ist3 = (npt1 + npt2)*nlayer12;
		int ist4 = (npt1 + npt2)*nlayer12 + npt3*nlayer3;
		fout << "\nCELLS " << nel << " " << 9 * nel << '\n';
		for (int il = 0; il < nlayer12 - 1; il++)
		{
			int ip1(il*(npt1 + npt2));
			int ip2((il + 1)*(npt1 + npt2));
			for (int i = 0; i < nel1; i++)
			{
				fout << "8 ";
				for (int j = 0; j < 4; j++) fout << ip1 + qd1[i][j] << ' ';
				for (int j = 0; j < 4; j++) fout << ip2 + qd1[i][j] << ' ';
				fout << '\n';
			}
			for (int i = 0; i < nel2; i++)
			{
				fout << "8 ";
				for (int j = 0; j < 4; j++) fout << ip1 + qd2[i][j] << ' ';
				for (int j = 0; j < 4; j++) fout << ip2 + qd2[i][j] << ' ';
				fout << '\n';
			}
		}
		for (int il = 0; il < nlayer3 - 1; il++)
		{
			int ip1 = ist3 + il*npt3;
			int ip2 = ist3 + (il + 1)*npt3;
			for (int i = 0; i < nel3; i++)
			{
				fout << "8 ";
				for (int j = 0; j < 4; j++) fout << ip1 + qd3[i][j] << ' ';
				for (int j = 0; j < 4; j++) fout << ip2 + qd3[i][j] << ' ';
				fout << '\n';
			}
		}
		for (int l1 = 0; l1 < nblock4; l1++)
		{
			for (int l2 = 0; l2 < nlayer4-1; l2++)
			{
				int ip1 = ist4 + l1*nlayer4*npt4 + l2*npt4;
				int ip2 = ist4 + l1*nlayer4*npt4 + (l2 + 1)*npt4;
				for (int i = 0; i < nel4; i++)
				{
					fout << "8 ";
					for (int j = 0; j < 4; j++) fout << ip1 + qd4[i][j] << ' ';
					for (int j = 0; j < 4; j++) fout << ip2 + qd4[i][j] << ' ';
					fout << '\n';
				}
			}
		}
		fout << "\nCELL_TYPES " << nel << '\n';
		for (uint i = 0; i<nel; i++)
		{
			fout << "12\n";
		}
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void ManualPolycube_NAVAIR(string fn_in, string fn_out)
{
	vector<array<double, 3>> ptri;
	vector<array<int, 3>> etri;//not useful
	ReadVtk_tri(fn_in, ptri, etri);
	
	//first planar face
	int cn1[116] = {890,5793,8338,13207,9162,10339,11049,9140,3712,1497,160,388,9452,9447,1677,10163,4275,4303,4063,4296,6629,4220,14348,6544,
	7576,14451,2087,5997,2862,2903,2908,2779,13766,4886,2642,10141,10884,10853,12813,2636,9205,10367,11890,2569,1596,3477,5360,13730,
	1684,10193,6142,6157,14390,4054,12717,12935,14330,14322,10478,10429,6403,6410,2187,2209,2176,2169,2162,10732,9614,9603,14171,584,
	3323,3311,3314,3320,
	14715,1046,5033,6579,4722,7316,2181,1995,9606,
	11444,11444,11444,11444,11444,11444,11444,11444,11444,11444,11444,
	9002,9002,9002,9002,9002,9002,9002,9002,9002,9002,
	8338,8338,8338,8338,8338,8338,8338,8338};
	int npt1(116);
	double y1(ptri[14682][1]);
	vector<array<double, 3>> pt1(npt1);
	for (int i = 0; i < 76; i++)
	{
		pt1[i] = ptri[cn1[i]];
	}
	for (int i = 76; i < 85; i++)
	{
		pt1[i][0] = ptri[cn1[i]][0];
		pt1[i][1] = ptri[cn1[0]][1];
		pt1[i][2] = ptri[cn1[0]][2];
	}
	for (int i = 85; i < 96; i++)
	{
		pt1[i][1] = ptri[cn1[0]][1];
		pt1[i][2] = ptri[cn1[i]][2];
		if (i == 85)
		{
			pt1[i][0] = ptri[cn1[0]][0];
		}
		else if (i == 95)
		{
			pt1[i][0] = ptri[cn1[1]][0];
		}
		else
		{
			pt1[i][0] = ptri[cn1[i - 10]][0];
		}
	}
	for (int i = 96; i < 106; i++)
	{
		pt1[i][1] = ptri[cn1[0]][1];
		pt1[i][2] = ptri[cn1[i]][2];
		if (i == 105)
		{
			pt1[i][0] = ptri[cn1[1]][0];
		}
		else
		{
			pt1[i][0] = ptri[cn1[i - 20]][0];
		}
	}
	for (int i = 106; i < 114; i++)
	{
		pt1[i][0] = ptri[cn1[i - 29]][0];
		pt1[i][1] = ptri[cn1[0]][1];
		pt1[i][2] = ptri[cn1[i]][2];
	}
	pt1[114][0] = pt1[0][0]; pt1[114][1] = pt1[0][1]; pt1[114][2] = pt1[96][2];
	pt1[115][0] = pt1[96][0]; pt1[115][1] = pt1[0][1]; pt1[115][2] = pt1[3][2];
	int qd1[84][4] = { {76,77,5,4},{5,77,87,6,},{7,6,87,86},{76,4,7,86},{77,78,9,8},{9,78,88,10},{11,10,88,87},{77,8,11,87},
	{78,79,13,12},{13,79,89,14},{15,14,89,88},{78,12,15,88},{79,80,17,16},{17,80,90,18},{19,18,90,89},{79,16,19,89},
	{80,81,21,20},{21,81,91,22},{23,22,91,90},{80,20,23,90},{81,82,25,24},{25,82,92,26},{27,26,92,91},{81,24,27,91},
	{82,83,29,28},{29,83,93,30},{31,30,93,92},{82,28,31,92},{83,84,33,32},{33,84,94,34},{35,34,94,93},{83,32,35,93},
	{84,1,37,36},{37,1,95,38},{39,38,95,94},{84,36,39,94},
	{86,87,41,40},{41,87,97,42},{43,42,97,96},{86,40,43,96},{87,88,45,44},{45,88,98,46},{47,46,98,97},{87,44,47,97},
	{88,89,49,48},{49,89,99,50},{51,50,99,98},{88,48,51,98},{89,90,53,52},{53,90,100,54},{55,54,100,99},{89,52,55,99},
	{90,91,57,56},{57,91,101,58},{59,58,101,100},{90,56,59,100},{91,92,61,60},{61,92,102,62},{63,62,102,101},{91,60,63,101},
	{92,93,65,64},{65,93,103,66},{67,66,103,102},{92,64,67,102},
	{93,94,69,68},{69,94,104,70},{71,70,104,103},{93,68,71,103},{94,95,73,72},{73,95,105,74},{75,74,105,104},{94,72,75,104},
	{0,76,86,85},{85,86,96,114},{114,96,115,3},{96,97,106,115},{97,98,107,106},{98,99,108,107},{99,100,109,108},{100,101,110,109},
	{101,102,111,110},{102,103,112,111},{103,104,113,112},{104,105,2,113} };
	int nqd1(84);

	//second planar piece
	int cn2[69] = { 13207,8338,13998,2362,3936,13554,13528,2330,3892,3958,2252,3863,4546,6890,4639,4653,8437,8476,8418,8277,
		8616,11630,12211,9917,8648,11993,11966,7351,5134,14030,9704,7283,12118,665,672,9689,9876,9891,9868,5217,
		4680,14431,7928,498,7296,11575,5087,5322,
		8969,4680,14431,7928,498,7296,11575,5087,5322,3512,
		8969,4680,14431,7928,498,7296,11575,5087,5322 };
	int npt2(69);
	vector<array<double, 3>> pt2(2*npt2);
	for (int i = 0; i < 40; i++)
	{
		pt2[i] = ptri[cn2[i]];
	}
	for (int i = 40; i < 67; i++)
	{
		pt2[i][0] = ptri[cn2[i]][0];
		pt2[i][2] = ptri[cn2[0]][2];
		if (i < 48)
		{
			pt2[i][1] = ptri[cn2[0]][1];
		}
		else if (i < 58)
		{
			pt2[i][1] = ptri[cn2[48]][1];
		}
		else
		{
			pt2[i][1] = ptri[cn2[2]][1];
		}
	}
	pt2[67][0] = pt2[48][0]; pt2[67][1] = pt2[0][1]; pt2[67][2] = pt2[0][2];
	pt2[68][0] = pt2[0][0]; pt2[68][1] = pt2[48][1]; pt2[68][2] = pt2[0][2];
	int qd2[47][4] = { {48,49,5,4},{5,49,59,6},{7,6,59,58},{48,4,7,58},{49,50,9,8},{9,50,60,10},{11,10,60,59},{49,8,11,59},
	{50,51,13,12},{13,51,61,14},{15,14,61,60},{50,12,15,60},{51,52,17,16},{17,52,62,18},{19,18,62,61},{51,16,19,61},
	{52,53,21,20},{21,53,63,22},{23,22,63,62},{52,20,23,62},{53,54,25,24},{25,54,64,26},{27,26,64,63},{53,24,27,63},
	{54,55,29,28},{29,55,65,30},{31,30,65,64},{54,28,31,64},{55,56,33,32},{33,56,66,34},{35,34,66,65},{55,32,35,65},
	{56,57,37,36},{37,57,2,38},{39,38,2,66},{56,36,39,66},
	{0,67,48,68},{67,40,49,48},{40,41,50,49},{41,42,51,50},{42,43,52,51},{43,44,53,52},{44,45,54,53},{45,46,55,54},{46,47,56,55},
	{47,1,57,56},{68,48,58,3} };
	int nqd2(47);
	double z2(ptri[5913][2]), x2_shf(ptri[6536][0]);
	int pid2_shf[3] = {42,51,61};
	for (int i = 0; i < npt2; i++)
	{
		pt2[npt2 + i][0] = pt2[i][0];
		pt2[npt2 + i][1] = pt2[i][1];
		pt2[npt2 + i][2] = z2;
	}
	for (int i = 0; i < 3; i++)
	{
		pt2[npt2 + pid2_shf[i]][0] = x2_shf;
	}

	int pair12[9][2] = { {115,67}, {106,40},{107,41},{108,42,},{109,43},{110,44},{111,45},{112,46},{113,47} };
	for (int i = 0; i < 9; i++)
	{
		pt1[pair12[i][0]] = pt2[pair12[i][1]];
	}

	//2nd piece additional
	int qd2_id[30];
	int nqd2_1(30);
	for (int i = 0; i < 24; i++)
	{
		qd2_id[i] = i + 12;
	}
	for (int i = 24; i < 30; i++)
	{
		qd2_id[i] = i + 16;
	}
	vector<int> pid2_flag(npt2, 0);
	vector<int> pid2_act(npt2, 0);
	for (int i = 0; i < 30; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			pid2_flag[qd2[qd2_id[i]][j]] = 1;
		}
	}
	int count2(0);
	for (int i = 0; i < npt2; i++)
	{
		if (pid2_flag[i] == 1)
		{
			pid2_act[i] = count2++;
			array<double, 3> tmp = { pt2[npt2+i][0],pt2[npt2 + i][1],ptri[6532][2] };
			pt2.push_back(tmp);
		}
	}

	//3rd piece
	int cn3[16] = {890,13207,2362,1021,301,10582,9313,941,
	85,114,
	0,8,9,1,
	9331,
	9};
	int npt3(16);
	vector<array<double, 3>> pt3(npt3);
	for (int i = 0; i < 8; i++)
	{
		pt3[i] = ptri[cn3[i]];
	}
	pt3[8] = pt1[85];
	pt3[9] = pt1[114];
	for (int i = 10; i < 14; i++)
	{
		pt3[i][0] = pt3[0][0];
		pt3[i][1] = pt2[68][1];
		pt3[i][2] = pt3[cn3[i]][2];
	}
	pt3[14] = ptri[cn3[14]];
	pt3[15][0] = pt3[0][0]; pt3[15][1] = pt3[2][1]; pt3[15][2] = pt3[9][2];
	int qd3[9][4] = { {0,8,11,10},{8,9,12,11},{9,1,13,12},{12,13,2,15},{10,11,14,4},{11,12,5,14},{5,12,15,6},{7,6,15,3},{10,4,7,3} };
	int nqd3(9);
	double x3(ptri[7532][0]);

	//4th piece
	int line4[3][11] = { {0,67,40,41,42,43,44,45,46,47,1},{ 69,136,109,110,111,112,113,114,115,116,70 },
	{-1,-1,-1,-1,164,165,166,167,168,169,138} };
	//int line4_1[11] = {3,115,106,107,108,109,110,111,112,113,2};
	//int line4_2[11] = {119,231,222,223,224,225,226,227,228,229,118};
	//int line4_3[11] = {69,136,109,110,111,112,113,114,115,116,70};
	int npt4(29);
	vector<array<double, 3>> pt4(2*npt4);
	int loc4(0);
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 11; j++)
		{
			if (line4[i][j] != -1)
			{
				pt4[loc4] = pt2[line4[i][j]];
				pt4[npt4 + loc4][0] = pt2[line4[i][j]][0];
				pt4[npt4 + loc4][1] = y1;
				pt4[npt4 + loc4][2] = pt2[line4[i][j]][2];
				loc4++;
			}
			
		}
	}
	int nqd4(16);
	vector<array<int, 8>> cube4(nqd4);
	for (int i = 0; i < 10; i++)
	{
		cube4[i][0] = npt4 + i; cube4[i][1] = npt4 + i + 1; cube4[i][2] = npt4 + i + 12; cube4[i][3] = npt4 + i + 11;
		cube4[i][4] = i; cube4[i][5] = i + 1; cube4[i][6] = i + 12; cube4[i][7] = i + 11;
	}
	for (int i = 0; i < 6; i++)
	{
		int i1(i + 10);
		cube4[i1][0] = npt4 + i + 15; cube4[i1][1] = npt4 + i + 16; cube4[i1][2] = npt4 + i + 23; cube4[i1][3] = npt4 + i + 22;
		cube4[i1][4] = i+15; cube4[i1][5] = i + 16; cube4[i1][6] = i + 23; cube4[i1][7] = i + 22;
	}

	//5th piece
	double x5_1[2] = { x3,pt1[0][0] };
	double y5_1[2] = { y1,pt1[0][1] };
	double z5_1[5] = { pt1[0][2],pt1[85][2],pt1[114][2],pt1[3][2],z2 };
	double x5_2[2] = { x3,pt1[0][0] };
	double y5_2[3] = { pt2[3][1],pt2[68][1],pt2[0][1] };
	double z5_2[2] = { z2,pt2[0][2] };
	int npt5(20+12);
	vector<array<double, 3>> pt5(npt5);
	int loc5(0);
	for (int i = 0; i < 5; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			for (int k = 0; k < 2; k++)
			{
				pt5[loc5][0] = x5_1[k];
				pt5[loc5][1] = y5_1[j];
				pt5[loc5][2] = z5_1[i];
				loc5++;
			}
		}
	}
	loc5 = 0;
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			for (int k = 0; k < 2; k++)
			{
				pt5[20+loc5][0] = x5_2[j];
				pt5[20+loc5][1] = y5_2[i];
				pt5[20+loc5][2] = z5_2[k];
				loc5++;
			}
		}
	}
	int nqd5(6);
	vector<array<int, 8>> cube5(nqd5);
	for (int i = 0; i < 4; i++)
	{
		cube5[i][0] = 4 * (i+1); cube5[i][1] = 4 * (i+1) + 1; cube5[i][2] = 4 * (i+1) + 3; cube5[i][3] = 4 * (i+1) + 2;
		cube5[i][4] = 4*i; cube5[i][5] = 4 * i+1; cube5[i][6] = 4 * i+3; cube5[i][7] = 4 * i + 2;
	}
	for (int i = 0; i < 2; i++)
	{
		cube5[4+i][0] = 20+4 * (i + 1); cube5[4 + i][1] = 20 + 4 * (i + 1) + 1; cube5[4 + i][2] = 20 + 4 * (i + 1) + 3; cube5[4 + i][3] = 20 + 4 * (i + 1) + 2;
		cube5[4 + i][4] = 20 + 4 * i; cube5[4 + i][5] = 20 + 4 * i + 1; cube5[4 + i][6] = 20 + 4 * i + 3; cube5[4 + i][7] = 20 + 4 * i + 2;
	}

	string fname(fn_out + ".vtk");
	ofstream fout;
	fout.open(fname.c_str());
	if (fout.is_open())
	{
		//int npt(npt2);
		//int nel(nqd2);
		//fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		//fout << "POINTS " << npt << " float\n";
		//for (uint i = 0; i<npt; i++)
		//{
		//	fout << pt2[i][0] << " " << pt2[i][1] << " " << pt2[i][2] << "\n";
		//}
		//fout << "\nCELLS " << nel << " " << 5 * nel << '\n';
		//for (uint i = 0; i<nel; i++)
		//{
		//	fout << "4 ";
		//	for (int j = 0; j<4; j++)
		//	{
		//		fout << qd2[i][j] << ' ';
		//	}
		//	fout << '\n';
		//}
		//fout << "\nCELL_TYPES " << nel << '\n';
		//for (uint i = 0; i<nel; i++)
		//{
		//	fout << "9\n";
		//}

		//int npt(2*npt1);
		//int nel(nqd1);
		//int npt(pt2.size());
		//int nel(nqd2+nqd2_1);
		//int npt(2 * npt3);
		//int nel(nqd3);
		int npt = 2 * npt1 + pt2.size() + 2 * npt3 + pt4.size() + pt5.size();
		int nel = nqd1 + nqd2 + nqd2_1 + nqd3 + nqd4 + nqd5;
		fout << "# vtk DataFile Version 2.0\nSquare plate test\nASCII\nDATASET UNSTRUCTURED_GRID\n";
		fout << "POINTS " << npt << " float\n";
		for (uint i = 0; i<npt1; i++)
		{
			fout << pt1[i][0] << " " << pt1[i][1] << " " << pt1[i][2] << "\n";
		}
		for (uint i = 0; i<npt1; i++)
		{
			fout << pt1[i][0] << " " << y1 << " " << pt1[i][2] << "\n";
		}
		for (uint i = 0; i < pt2.size(); i++)
		{
			fout << pt2[i][0] << " " << pt2[i][1] << " " << pt2[i][2] << "\n";
		}
		for (uint i = 0; i<npt3; i++)
		{
			fout << pt3[i][0] << " " << pt3[i][1] << " " << pt3[i][2] << "\n";
		}
		for (uint i = 0; i<npt3; i++)
		{
			fout << x3 << " " << pt3[i][1] << " " << pt3[i][2] << "\n";
		}
		for (uint i = 0; i < pt4.size(); i++)
		{
			fout << pt4[i][0] << " " << pt4[i][1] << " " << pt4[i][2] << "\n";
		}
		for (uint i = 0; i < pt5.size(); i++)
		{
			fout << pt5[i][0] << " " << pt5[i][1] << " " << pt5[i][2] << "\n";
		}
		fout << "\nCELLS " << nel << " " << 9 * nel << '\n';
		for (uint i = 0; i<nqd1; i++)
		{
			fout << "8 ";
			for (int j = 0; j<4; j++)
			{
				fout << npt1 + qd1[i][j] << ' ';
			}
			for (int j = 0; j<4; j++)
			{
				fout << qd1[i][j] << ' ';
			}
			fout << '\n';
		}
		int ist = 2 * npt1;
		for (uint i = 0; i<nqd2; i++)
		{
			fout << "8 ";
			for (int j = 0; j<4; j++)
			{
				fout << ist+npt2 + qd2[i][j] << ' ';
			}
			for (int j = 0; j<4; j++)
			{
				fout << ist + qd2[i][j] << ' ';
			}
			fout << '\n';
		}
		for (uint i = 0; i<nqd2_1; i++)
		{
			fout << "8 ";
			for (int j = 0; j<4; j++)
			{
				fout << ist + 2 * npt2 + pid2_act[qd2[qd2_id[i]][j]] << ' ';
			}
			for (int j = 0; j<4; j++)
			{
				fout << ist + npt2+qd2[qd2_id[i]][j] << ' ';
			}
			fout << '\n';
		}
		ist += pt2.size();
		for (uint i = 0; i<nqd3; i++)
		{
			fout << "8 ";
			for (int j = 0; j<4; j++)
			{
				fout << ist + npt3 + qd3[i][j] << ' ';
			}
			for (int j = 0; j<4; j++)
			{
				fout << ist + qd3[i][j] << ' ';
			}
			fout << '\n';
		}
		ist += (2 * npt3);
		for (uint i = 0; i<nqd4; i++)
		{
			fout << "8 ";
			for (int j = 0; j<8; j++)
			{
				fout << ist + cube4[i][j] << ' ';
			}
			fout << '\n';
		}
		ist += pt4.size();
		for (uint i = 0; i<nqd5; i++)
		{
			fout << "8 ";
			for (int j = 0; j<8; j++)
			{
				fout << ist + cube5[i][j] << ' ';
			}
			fout << '\n';
		}
		fout << "\nCELL_TYPES " << nel << '\n';
		for (uint i = 0; i<nel; i++)
		{
			fout << "12\n";
		}

		/*fout << "POINTS " << npt << " float\n";
		for (int il = 0; il < nlayer12; il++)
		{
			for (int i = 0; i < npt1; i++)
			{
				fout << pt1[i][0] << " " << pt1[i][1] << " " << z12[il] << "\n";
			}
			for (int i = 0; i < npt2; i++)
			{
				fout << pt2[i][0] << " " << pt2[i][1] << " " << z12[il] << "\n";
			}
		}
		for (int il = 0; il < nlayer3; il++)
		{
			for (int i = 0; i < npt3; i++)
			{
				fout << x3[il] << " " << pt3[i][1] << " " << pt3[i][2] << "\n";
			}
		}
		for (int l1 = 0; l1 < nblock4; l1++)
		{
			for (int l2 = 0; l2 < nlayer4; l2++)
			{
				for (int i = 0; i < npt4; i++)
				{
					fout << pt1[pid4[i]][0] << " " << pt1[pid4[i]][1] << " " << z4[l1][l2] << "\n";
				}
			}
		}
		int ist3 = (npt1 + npt2)*nlayer12;
		int ist4 = (npt1 + npt2)*nlayer12 + npt3*nlayer3;
		fout << "\nCELLS " << nel << " " << 9 * nel << '\n';
		for (int il = 0; il < nlayer12 - 1; il++)
		{
			int ip1(il*(npt1 + npt2));
			int ip2((il + 1)*(npt1 + npt2));
			for (int i = 0; i < nel1; i++)
			{
				fout << "8 ";
				for (int j = 0; j < 4; j++) fout << ip1 + qd1[i][j] << ' ';
				for (int j = 0; j < 4; j++) fout << ip2 + qd1[i][j] << ' ';
				fout << '\n';
			}
			for (int i = 0; i < nel2; i++)
			{
				fout << "8 ";
				for (int j = 0; j < 4; j++) fout << ip1 + qd2[i][j] << ' ';
				for (int j = 0; j < 4; j++) fout << ip2 + qd2[i][j] << ' ';
				fout << '\n';
			}
		}
		for (int il = 0; il < nlayer3 - 1; il++)
		{
			int ip1 = ist3 + il*npt3;
			int ip2 = ist3 + (il + 1)*npt3;
			for (int i = 0; i < nel3; i++)
			{
				fout << "8 ";
				for (int j = 0; j < 4; j++) fout << ip1 + qd3[i][j] << ' ';
				for (int j = 0; j < 4; j++) fout << ip2 + qd3[i][j] << ' ';
				fout << '\n';
			}
		}
		for (int l1 = 0; l1 < nblock4; l1++)
		{
			for (int l2 = 0; l2 < nlayer4 - 1; l2++)
			{
				int ip1 = ist4 + l1*nlayer4*npt4 + l2*npt4;
				int ip2 = ist4 + l1*nlayer4*npt4 + (l2 + 1)*npt4;
				for (int i = 0; i < nel4; i++)
				{
					fout << "8 ";
					for (int j = 0; j < 4; j++) fout << ip1 + qd4[i][j] << ' ';
					for (int j = 0; j < 4; j++) fout << ip2 + qd4[i][j] << ' ';
					fout << '\n';
				}
			}
		}
		fout << "\nCELL_TYPES " << nel << '\n';
		for (uint i = 0; i<nel; i++)
		{
			fout << "12\n";
		}*/
		fout.close();
	}
	else
	{
		cout << "Cannot open " << fname << "!\n";
	}
}

void PolycubeDeleteRepeatPoint(string fn)
{
	vector<array<double, 3>> pts0;
	vector<array<int, 8>> cnct0;
	ReadVtk_hex(fn, pts0, cnct0);

	double tol(1.e-4);
	vector<int> flag(pts0.size(), -1);
	double dst, vtmp[3];
	for (uint i = 0; i < pts0.size()-1; i++)
	{
		for (uint j = i + 1; j < pts0.size(); j++)
		{
			if (flag[i] == -1 && flag[j] == -1)
			{
				vtmp[0] = pts0[j][0] - pts0[i][0];
				vtmp[1] = pts0[j][1] - pts0[i][1];
				vtmp[2] = pts0[j][2] - pts0[i][2];
				dst = sqrt(vtmp[0] * vtmp[0] + vtmp[1] * vtmp[1] + vtmp[2] * vtmp[2]);
				if (dst < tol)
				{
					flag[j] = i;
				}
			}			
		}
	}
	vector<int> pid(pts0.size(), -1);
	vector<array<double, 3>> pts;
	vector<array<int, 8>> cnct(cnct0.size());
	for (uint i = 0; i < pts0.size(); i++)
	{
		if (flag[i] == -1)
		{
			pts.push_back(pts0[i]);
			pid[i] = pts.size() - 1;
		}
		else
		{
			pid[i] = pid[flag[i]];
		}
	}
	for (uint i = 0; i < cnct.size(); i++)
	{
		for (int j = 0; j < 8; j++)
		{
			cnct[i][j] = pid[cnct0[i][j]];
			//if (flag[cnct0[i][j]] != -1)
			//{
			//	cnct[i][j] = pid[flag[cnct0[i][j]]];
			//}
		}
	}

	WriteVtk_hex(fn + "_1", pts, cnct);
	WriteRaw_hex(fn, pts, cnct);
}

void ManualAddCube(string fn)
{
	vector<array<double, 3>> pts0;
	vector<array<int, 8>> cnct0;
	ReadVtk_hex(fn, pts0, cnct0);

	int n(pts0.size());
	int padd1[2][3][7] = { {{230,506,241,1195,1197,1199,242},{1540,2223,2280,2413,2432,2451,1729},{1542,2224,2281,2414,2433,2452,1731}},
	{{63,169,66,1201,1203,1205,69},{1578,n,n+1,n+2,n+3,n+4,1767},{1580,n+5,n+6,n+7,n+8,n+9,1769}} };
	int n1 = n + 10;
	int padd2[2][3][7] = { {{234,1187,1183,1179,233,502,222},{1617,2375,2337,2299,2242,2185,1428},{1621,2377,2339,2301,2244,2187,1432}},
	{{18,1185,1181,1177,15,167,12},{1615,n1,n1+1,n1+2,n1+3,n1+4,1426},{1619,n1+5,n1+6,n1+7,n1+8,n1+9,1430}} };
	int nx(7), ny(3), nz(2);
	for (int i = 0; i < nz; i++)
	{
		for (int j = 0; j < ny; j++)
		{
			for (int k = 0; k < nx; k++)
			{
				if (padd1[i][j][k] >= n)
				{
					array<double, 3> ptmp = {pts0[padd1[0][j][k]][0],pts0[padd1[0][j][0]][1], pts0[padd1[1][0][0]][2]};
					pts0.push_back(ptmp);
				}
				else
				{
					pts0[padd1[i][j][k]][1] = pts0[padd1[0][j][0]][1];
				}
			}
		}
	}
	for (int i = 0; i < nz; i++)
	{
		for (int j = 0; j < ny; j++)
		{
			for (int k = 0; k < nx; k++)
			{
				if (padd2[i][j][k] >= n)
				{
					array<double, 3> ptmp = { pts0[padd2[0][j][k]][0],pts0[padd2[0][j][0]][1], pts0[padd2[1][0][0]][2] };
					pts0.push_back(ptmp);
				}
				else
				{
					pts0[padd2[i][j][k]][1] = pts0[padd2[0][j][0]][1];
				}
			}
		}
	}
	for (int i = 0; i < nz-1; i++)
	{
		for (int j = 0; j < ny-1; j++)
		{
			for (int k = 0; k < nx-1; k++)
			{
				array<int, 8> etmp = {padd1[i][j][k],padd1[i][j][k+1],padd1[i][j+1][k + 1],padd1[i][j+1][k],
					padd1[i + 1][j][k],padd1[i + 1][j][k + 1],padd1[i + 1][j + 1][k + 1],padd1[i + 1][j + 1][k] };
				cnct0.push_back(etmp);
			}
		}
	}
	for (int i = 0; i < nz - 1; i++)
	{
		for (int j = 0; j < ny - 1; j++)
		{
			for (int k = 0; k < nx - 1; k++)
			{
				array<int, 8> etmp = { padd2[i][j][k],padd2[i][j][k + 1],padd2[i][j + 1][k + 1],padd2[i][j + 1][k],
					padd2[i + 1][j][k],padd2[i + 1][j][k + 1],padd2[i + 1][j + 1][k + 1],padd2[i + 1][j + 1][k] };
				cnct0.push_back(etmp);
			}
		}
	}

	WriteVtk_hex(fn + "_add", pts0, cnct0);
}

void PolyCubeCorrespond(string fn_poly, string crsp)
{
	vector<array<double, 3>> pts;
	vector<array<int, 8>> cnct;
	ReadVtk_hex(fn_poly, pts, cnct);

	string fn(crsp + ".txt");
	ifstream fin;
	fin.open(fn.c_str());
	vector<array<double, 2>> pr;
	array<double, 2> tmp;
	if (fin.is_open())
	{
		while (!fin.eof())
		{
			fin >> tmp[0] >> tmp[1];
			pr.push_back(tmp);
		}
		fin.close();
	}
	else
	{
		cerr << "Can't open " << fn << "!\n";
	}

	string fn1(crsp + "_out.txt");
	ofstream fout;
	fout.open(fn1.c_str());
	if (fout.is_open())
	{
		for (uint i = 0; i < pr.size(); i++)
		{
			fout << pr[i][0] << " " << pts[pr[i][1]][0] << " " << pts[pr[i][1]][1] << " " << pts[pr[i][1]][2] << "\n";
		}
		fout.close();
	}
	else
	{
		cerr << "Can't open " << fn1 << "\n";
	}
}

void DeleteVoidElement(string fn)
{
	vector<array<double, 3>> pts;
	vector<array<int, 8>> cnct0, cnct;
	ReadVtk_hex(fn, pts, cnct0);

	for (uint i = 0; i < cnct0.size(); i++)
	{
		int flag(0);
		for (int j = 0; j < 7; j++)
		{
			for (int k = j+1; k < 8; k++)
			{
				if (cnct0[i][j] == cnct0[i][k])
				{
					flag = 1; break;
				}
			}
			if (flag == 1) break;
		}
		if (flag == 0)
		{
			cnct.push_back(cnct0[i]);
		}
	}

	WriteVtk_hex(fn + "_1", pts, cnct);
}

void RepairConnectivity(string fn)
{
	vector<array<double, 3>> pts;
	vector<array<int, 8>> cnct;
	ReadVtk_hex(fn, pts, cnct);

	for (uint i = 0; i < cnct.size(); i++)
	{
		double v[3][3] = { {pts[cnct[i][1]][0] - pts[cnct[i][0]][0],pts[cnct[i][1]][1] - pts[cnct[i][0]][1], pts[cnct[i][1]][2] - pts[cnct[i][0]][2]},
		{ pts[cnct[i][3]][0] - pts[cnct[i][0]][0],pts[cnct[i][3]][1] - pts[cnct[i][0]][1], pts[cnct[i][3]][2] - pts[cnct[i][0]][2] },
		{ pts[cnct[i][4]][0] - pts[cnct[i][0]][0],pts[cnct[i][4]][1] - pts[cnct[i][0]][1], pts[cnct[i][4]][2] - pts[cnct[i][0]][2] } };
		MatrixXd mat(3, 3);
		for (int j = 0; j < 3; j++)
		{
			for (int k = 0; k < 3; k++)
			{
				mat(j, k) = v[j][k];
			}
		}
		double detJ = mat.determinant();
		if (detJ < 0.)
		{
			int tmp;
			for (int j = 0; j < 4; j++)
			{
				tmp = cnct[i][j];
				cnct[i][j] = cnct[i][j + 4];
				cnct[i][j + 4] = tmp;
			}
		}
	}

	WriteVtk_hex(fn + "_1", pts, cnct);
}

void PolyCubeSubdiv(string fn_in)
{
	int fc[6][4] = { {0,3,2,1},{0,1,5,4},{1,2,6,5},{2,3,7,6},{0,4,7,3},{4,5,6,7} };
	int ed[12][2] = { {0,1},{1,2},{2,3},{0,3},{0,4},{1,5},{2,6},{3,7},{4,5},{5,6},{6,7},{4,7} };
	vector<array<double, 3>> pts;
	vector<array<int, 8>> cnct0, cnct;
	ReadRaw_hex(fn_in, pts, cnct0);
	//ReadVtk_hex(fn_in, pts, cnct0);
	cnct.resize(8 * cnct0.size());
	for (uint i = 0; i < cnct0.size(); i++)
	{
		array<double, 3> ptmp = { 0.,0.,0. };
		for (int j = 0; j < 8; j++)
		{
			ptmp[0] += 0.125*pts[cnct0[i][j]][0];
			ptmp[1] += 0.125*pts[cnct0[i][j]][1];
			ptmp[2] += 0.125*pts[cnct0[i][j]][2];
		}
		pts.push_back(ptmp);
		int pidb = pts.size() - 1;
		int pidf[6];
		for (int j = 0; j < 6; j++)
		{
			ptmp[0] = 0.; ptmp[1] = 0.; ptmp[2] = 0.;
			for (int k = 0; k < 4; k++)
			{
				ptmp[0] += 0.25*pts[cnct0[i][fc[j][k]]][0];
				ptmp[1] += 0.25*pts[cnct0[i][fc[j][k]]][1];
				ptmp[2] += 0.25*pts[cnct0[i][fc[j][k]]][2];
			}
			pts.push_back(ptmp);
			pidf[j] = pts.size() - 1;
		}
		int pide[12];
		for (int j = 0; j < 12; j++)
		{
			ptmp[0] = 0.; ptmp[1] = 0.; ptmp[2] = 0.;
			for (int k = 0; k < 2; k++)
			{
				ptmp[0] += 0.5*pts[cnct0[i][ed[j][k]]][0];
				ptmp[1] += 0.5*pts[cnct0[i][ed[j][k]]][1];
				ptmp[2] += 0.5*pts[cnct0[i][ed[j][k]]][2];
			}
			pts.push_back(ptmp);
			pide[j] = pts.size() - 1;
		}
		int cube[8][8] = { {cnct0[i][0],pide[0],pidf[0],pide[3],pide[4],pidf[1],pidb,pidf[4]},
		{ pide[0],cnct0[i][1],pide[1],pidf[0],pidf[1],pide[5],pidf[2],pidb },
		{ pidf[0],pide[1],cnct0[i][2],pide[2],pidb,pidf[2],pide[6],pidf[3] },
		{ pide[3],pidf[0],pide[2],cnct0[i][3],pidf[4],pidb,pidf[3],pide[7] },
		{ pide[4],pidf[1],pidb,pidf[4],cnct0[i][4],pide[8],pidf[5],pide[11] },
		{ pidf[1],pide[5],pidf[2],pidb,pide[8],cnct0[i][5],pide[9],pidf[5] },
		{ pidb,pidf[2],pide[6],pidf[3],pidf[5],pide[9],cnct0[i][6],pide[10] },
		{ pidf[4],pidb,pidf[3],pide[7],pide[11],pidf[5],pide[10],cnct0[i][7] } };
		for (int j = 0; j < 8; j++)
		{
			for (int k = 0; k < 8; k++)
			{
				cnct[8 * i + j][k] = cube[j][k];
			}
		}
	}
	WriteVtk_hex(fn_in + "_r", pts, cnct);
	PolycubeDeleteRepeatPoint(fn_in + "_r");
	//WriteRaw_hex(fn, pts, cnct);
}
